<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>分布式事务</title>
    <url>/1999-01-23-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<div class="note default">
            <p>todo</p>
          </div>


<a id="more"></a>

]]></content>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>无锁队列</title>
    <url>/1999-01-24-lockfree%20queue/</url>
    <content><![CDATA[<div class="note default">
            <p>todo</p>
          </div>


<a id="more"></a>

]]></content>
      <tags>
        <tag>mq</tag>
      </tags>
  </entry>
  <entry>
    <title>零拷贝</title>
    <url>/1999-01-25-zero%20copy/</url>
    <content><![CDATA[<div class="note default">
            <p>todo</p>
          </div>


<a id="more"></a>

]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>c++ 反射</title>
    <url>/1999-02-15-c++%20%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<div class="note default">
            <p>todo</p>
          </div>


<a id="more"></a>



]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>从禅者的初心开始</title>
    <url>/2019-04-15-%E6%9C%80%E5%BC%80%E5%A7%8B%E7%9A%84%E5%9C%B0%E6%96%B9/</url>
    <content><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li>
<li><a href="#test">test</a></li>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#%E6%91%98%E6%8A%84">摘抄</a></li>
<li><a href="#%E5%85%B1%E5%8B%89">共勉</a></li>
</ul>
<a id="more"></a>

<h2 id="test"><a href="#test" class="headerlink" title="test"></a>test</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>   &emsp;&emsp;&emsp;许久没有敲字,确是生疏了,心里又暗示要在这个节点写下第一篇文章.<br /><br>   &emsp;&emsp;&emsp;想起近几年来的遭遇,不回头不知凶险，也要庆幸于几个关键时期的幸运.苦于留下的,是扭曲的人格和无我的状态.<br /><br>   &emsp;&emsp;&emsp;好吧,便以引用来开启这一新的阶段<br><br /><br><br /></p>
<h2 id="摘抄"><a href="#摘抄" class="headerlink" title="摘抄"></a>摘抄</h2><blockquote>
<p>&emsp;&emsp;一位禅师就是实现了完全自由的人,而着这种完全自由是所有人类的潜能。他无拘无束的生活在他整个存在的丰盈里。他的意识之流不是我们一般自我中心意识那种固定的重复模式,而是会依实际的当下环境自然地生发出来。结果就是，他的人格表现出来各种不凡的素质：轻快、活力充沛、坦率、简朴、谦卑、真诚、喜气洋洋、无比善悟与深不可测的慈悲。他的整个人见证了所谓“活在当下”的真实之中。<br><br /><br><br /></p>
</blockquote>
<blockquote>
<p>&emsp;&emsp;但到头来，让众弟子感到困惑、入迷和被深化的、并不是老师的不平凡、而是他的无比平凡。因为他只是他自己，所以得以成为众弟子的一面镜子。与他在一起时，我们意识到了自己的优点和缺点，但在此同时又不会感受到他又一丝赞美或责难。在他面前，我们看到了自己的未来面目，也看到了他的各种不平凡只是我们自己的真实本性。当我们学会把本性释放出来，师徒之间的界限就会消失，消失在佛心展开而成的一道存在于欢愉的深流里。</p>
</blockquote>
<br />

<h2 id="共勉"><a href="#共勉" class="headerlink" title="共勉"></a>共勉</h2><ul>
<li>当你想要寻找一个上师，那么你的身边就会出现一位。</li>
<li>自己教育自己</li>
</ul>
<p><img src="https://i.loli.net/2019/04/15/5cb4a568c6959.jpg"></p>
]]></content>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>开源数据库[postgresql]资料汇总</title>
    <url>/2019-04-21-postgresql%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h2 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h2><ul>
<li>pgadmin     自带客户端(windows),最新版本已经可以在浏览器登录了</li>
<li>dbvis        JDBC(咱也不懂,咱也不想查),反正oracle,sqlserver,pgsql都能连.用着也顺手,就是不免费</li>
<li>psql        自带客户端(linux)  /home/postgres/pgsql/bin/psql -U username -H hostaddr -d database</li>
</ul>
<a id="more"></a>

<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><blockquote>
<p>配置文件postgresql.conf,里面的含义网上都有.搜索下很方便查到.<br>这里只记录几个个人常用的配置项:<br /></p>
</blockquote>
<ul>
<li><p>log_statement (string)    开启后数据库日志pg_log会更新,方便定位问题<br /></p>
<blockquote>
<p>ddl包括所有数据定义语句，如CREATE、ALTER和DROP语句<br /><br>mod包括所有ddl语句和更新数据的语句，例如INSERT、UPDATE、DELETE、TRUNCATE、 COPY FROM、PREPARE和 EXECUTE<br /><br>All包括所有的语句。只有超级用户才能修改这个参数<br /><br><img src="https://i.loli.net/2019/04/24/5cc0783bb7b85.png"></p>
</blockquote>
</li>
<li><p>shared_buffers (integer)    设置pgsql共享缓存区大小,吃内存.但可以提高命中率（好像需要和其他参数配合使用,后续补充）</p>
<blockquote>
<p>这个参数只有在启动数据库时，才能被设置。它表示数据缓冲区中的数据块的个数，每个数据块的大小是8KB。数据缓冲区位于数据库的共享内存中，它越大越好，不能小于128KB。默认值是1024<br /></p>
</blockquote>
</li>
</ul>
<h2 id="常用语句"><a href="#常用语句" class="headerlink" title="常用语句"></a>常用语句</h2><ul>
<li><p>查数据库大小<br /></p>
<blockquote>
<p>SELECT d.datname AS Name, pg_catalog.pg_get_userbyid(d.datdba) AS Owner,<br>CASE WHEN pg_catalog.has_database_privilege(d.datname, ‘CONNECT’)<br>THEN pg_catalog.pg_size_pretty(pg_catalog.pg_database_size(d.datname))<br>ELSE ‘No Access’<br>END AS SIZE<br>FROM pg_catalog.pg_database d<br>ORDER BY<br>CASE WHEN pg_catalog.has_database_privilege(d.datname, ‘CONNECT’)<br>THEN pg_catalog.pg_database_size(d.datname)<br>ELSE NULL<br>END DESC – nulls first<br>LIMIT 20</p>
</blockquote>
</li>
<li><p>查占用空间最大的20张表<br /></p>
<blockquote>
<p>SELECT nspname || ‘.’ || relname AS “relation”,<br>pg_size_pretty(pg_total_relation_size(C.oid)) AS “total_size”<br>FROM pg_class C<br>LEFT JOIN pg_namespace N ON (N.oid = C.relnamespace)<br>WHERE nspname NOT IN (‘pg_catalog’, ‘information_schema’)<br>AND C.relkind &lt;&gt; ‘i’<br>AND nspname !~ ‘^pg_toast’<br>ORDER BY pg_total_relation_size(C.oid) DESC<br>LIMIT 20;</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>查所有的表<br /></p>
<blockquote>
<p>select tablename from pg_tables where tablename like ‘%fav%’;</p>
</blockquote>
</li>
<li><p>查所有表的字段<br /></p>
<blockquote>
<p>select count(attname) from pg_attribute;</p>
</blockquote>
</li>
<li><p>查某张表中所有字段<br /></p>
<blockquote>
<p>select * from information_schema.columns where table_schema=’public’ and table_name = ‘tbl_user’;</p>
</blockquote>
</li>
<li><p>查看某个字段存在与哪张表中<br /></p>
<blockquote>
<p>SELECT * from information_schema.columns WHERE COLUMN_NAME = ‘name’ ;<br /><br>SELECT * from information_schema.columns WHERE COLUMN_NAME like ‘%parent%’;</p>
</blockquote>
</li>
<li><p>查看数据库连接<br /></p>
<blockquote>
<p>select * from pg_stat_activity;</p>
</blockquote>
</li>
<li><p>查看各客户端的连接数<br /></p>
<blockquote>
<p>SELECT client_addr,count(<em>) from pg_stat_activity group by client_addr order by count(</em>) desc;</p>
</blockquote>
</li>
<li><p>数据库的oid<br /></p>
<blockquote>
<p>select * from pg_database where oid=16384;</p>
</blockquote>
</li>
<li><p>表的oid<br /></p>
<blockquote>
<p>select relname from pg_class where relfilenode = 25207;</p>
</blockquote>
</li>
<li><p>按占用时间统计,pgadmin中运行<br /></p>
<blockquote>
<p>SELECT query, calls, total_time/calls AS onecall_time, total_time, shared_blks_hit,shared_blks_dirtied,shared_blks_read,shared_blks_written,rows, 100.0 * shared_blks_hit /nullif(shared_blks_hit + shared_blks_read, 0) AS hit_percent FROM pg_stat_statements WHERE query like ‘select%tbl_res%’ ORDER BY total_time DESC LIMIT 1000;</p>
</blockquote>
</li>
<li><p>按调用次数统计,pgadmin中运行<br /></p>
<blockquote>
<p>SELECT query, calls, total_time/calls AS onecall_time, total_time, rows, 100.0 * shared_blks_hit /nullif(shared_blks_hit + shared_blks_read, 0) AS hit_percent FROM pg_stat_statements ORDER BY calls DESC LIMIT 50;</p>
</blockquote>
</li>
<li><p>查看正在执行的sql 每个进程一行,会覆盖<br /></p>
<blockquote>
<p>select * from pg_stat_activity where query_start is not null and query like ‘%tbl_bm_poll_info%’ order by query_start DESC;</p>
</blockquote>
</li>
<li><p>查询闲置连接数<br /></p>
<blockquote>
<p>select count(*) from pg_stat_activity where state=’idle’;<br /><br>select * from pg_stat_activity where state != ‘idle’;</p>
</blockquote>
</li>
<li><p>清空统计结果<br /></p>
<blockquote>
<p>select pg_stat_statements_reset() ;</p>
</blockquote>
</li>
<li><p>修改密码<br /></p>
<blockquote>
<p>ALTER USER postgres PASSWORD ‘admin’;</p>
</blockquote>
</li>
<li><p>创建pg_stat_statements<br /></p>
<blockquote>
<p>create extension pg_stat_statements; </p>
</blockquote>
</li>
</ul>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式基础</title>
    <url>/2019-04-27-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#%E8%AF%B4%E6%98%8E">说明</a></li>
<li><a href="#%E6%AD%A3%E6%96%87">正文</a></li>
</ul>
<a id="more"></a>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  &emsp;&emsp;&emsp;对正则表达式不熟悉,目前用到的地方也不多.但是偶尔学习过程中遇到了会阻碍自己的理解.所以打算把正则表达式的基础用法总结下.</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><blockquote>
<p>1.本文参考了下面的文章: <a href="https://www.jianshu.com/p/ac2596be9606?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation">系统地学习正则表达式</a><br /><br>2.测试正则语法的网站: <a href="https://regex101.com/">regex101</a></p>
</blockquote>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="文本字符匹配"><a href="#文本字符匹配" class="headerlink" title="文本字符匹配"></a><code>文本字符匹配</code></h3><table>
    <thead align="center">
        <tr>
            <th style="text-align:center">Regular expression</th>
            <th style="text-align:center">Input</th>
            <th style="text-align:center">OutPut</th>
        </tr>
    </thead>
    <tbody align="center">
        <tr>
            <td>string</td>
            <td>This is a string.</td>
            <td>string</td>
        </tr>
    </tbody>
</table>

<h3 id="匹配任意单个字符"><a href="#匹配任意单个字符" class="headerlink" title="匹配任意单个字符"></a><code>匹配任意单个字符</code></h3><table>
    <thead>
        <tr>
            <th style="text-align:center">Regular expression</th>
            <th style="text-align:center">Input</th>
            <th style="text-align:center">OutPut</th>
        </tr>
    </thead>
    <tbody align="center">
        <tr>
            <td>a.c</td>
            <td>abc</td>
            <td>abc</td>
        </tr>
        <tr>
            <td>a.c</td>
            <td>abbc</td>
            <td>not match</td>
        </tr>
        <tr>
            <td>a.c</td>
            <td>a5c</td>
            <td>a5c</td>
        </tr>
    </tbody>
</table>

<h3 id="匹配特殊字符-需要转义"><a href="#匹配特殊字符-需要转义" class="headerlink" title="匹配特殊字符(需要转义)"></a><code>匹配特殊字符(需要转义)</code></h3><table>
    <thead>
        <tr>
            <th style="text-align:center">Regular expression</th>
            <th style="text-align:center">Input</th>
            <th style="text-align:center">OutPut</th>
        </tr>
    </thead>
    <tbody align="center">
        <tr>
            <td>a\.c</td>
            <td>a.c</td>
            <td>a.c</td>
        </tr>
        <tr>
            <td>a\.c</td>
            <td>abc</td>
            <td>not match</td>
        </tr>
        <tr>
            <td>a\+c</td>
            <td>a+c</td>
            <td>a+c</td>
        </tr>
        <tr>
            <td>a+c</td>
            <td>aac</td>
            <td>aac</td>
        </tr>
        <tr>
            <td>a\+c</td>
            <td>aac</td>
            <td>not match</td>
        </tr>
        <tr>
            <td>a\[c</td>
            <td>a[c</td>
            <td>a[c</td>
        </tr>
        <tr>
            <td>a[c</td>
            <td>a[c</td>
            <td>error</td>
        </tr>
        <tr>
            <td>a\\c</td>
            <td>a\c</td>
            <td>a\c</td>
        </tr>
        <tr>
            <td>a\c</td>
            <td>a\c</td>
            <td>error</td>
        </tr>
    </tbody>
</table>

<h3 id="字符集合"><a href="#字符集合" class="headerlink" title="字符集合"></a><code>字符集合</code></h3><blockquote>
<p>[abc] 匹配a/b/c其中一个,取反:[^abc] <br><br>[a-z] 匹配一个小写字母,取反:[^a-z] <br><br>[0-9] 匹配一位数，相当于[0123456789],取反:[^0-9] <br><br>[0-9a-zA-Z] 与上面类似,[]中可以存在多种规则 <br></p>
</blockquote>
<h3 id="约定俗成的"><a href="#约定俗成的" class="headerlink" title="约定俗成的"></a><code>约定俗成的</code></h3> <table>
    <thead>
        <tr>
            <th style="text-align:center">元字符</th>
            <th style="text-align:center">描述</th>
        </tr>
    </thead>
    <tbody align="center">
        <tr>
            <td>\d</td>
            <td>[0-9]</td>
        </tr>
        <tr>
            <td>\D</td>
            <td>[^0-9]</td>
        </tr>
        <tr>
            <td>\w</td>
            <td>[0-9a-zA-Z_]</td>
        </tr>
        <tr>
            <td>\W</td>
            <td>[^0-9a-zA-Z_]</td>
        </tr>
        <tr>
            <td>\s</td>
            <td>[\f\n\r\t\v]</td>
        </tr>
        <tr>
            <td>\S</td>
            <td>[^\f\n\r\t\v]</td>
        </tr>
    </tbody>
</table>

<h3 id="匹配次数"><a href="#匹配次数" class="headerlink" title="匹配次数"></a><code>匹配次数</code></h3> <table>
    <thead>
        <tr>
            <th style="text-align:center">正则表达式</th>
            <th style="text-align:center">描述</th>
            <th style="text-align:center">Regular expression</th>
            <th style="text-align:center">Input</th>
            <th style="text-align:center">Output</th>
        </tr>
    </thead>
    <tbody align="center">
        <tr>
            <td>{1,3}</td>
            <td>匹配1个到3个</td>
            <td>a{1,3}d</td>
            <td>aad</td>
            <td>aad</td>
        </tr>
        <tr>
            <td>{2}</td>
            <td>匹配2个</td>
            <td>a{2}d</td>
            <td>aaad</td>
            <td>aad</td>
        </tr>
        <tr>
            <td>*</td>
            <td>0个到多个,同{0,}</td>
            <td>a*d</td>
            <td>addddddddddd</td>
            <td>ad,d,d,d,d,d,d,d,d,d,d 11种结果</td>
        </tr>
        <tr>
            <td>+</td>
            <td>1个到多个,同{1,}</td>
            <td>a+d</td>
            <td>addddddddddd</td>
            <td>ad</td>
        </tr>
    </tbody>
</table>

<h3 id="字符串边界"><a href="#字符串边界" class="headerlink" title="字符串边界"></a><code>字符串边界</code></h3><table>
    <thead>
        <tr>
            <th style="text-align:center">Regular expression</th>
            <th style="text-align:center">Input</th>
            <th style="text-align:center">OutPut</th>
            <th style="text-align:center">Describe</th>
        </tr>
    </thead>
    <tbody align="center">
        <tr>
            <td>^begin</td>
            <td>begin and end</td>
            <td>begin</td>
            <td>表示以begin开头的字符串</td>
        </tr>
        <tr>
            <td>^begin</td>
            <td>from begin to end</td>
            <td>not match</td>
            <td>begin不在字符串的开始就匹配不上</td>
        </tr>
        <tr>
            <td>end$</td>
            <td>begin and end</td>
            <td>end</td>
            <td>表示以end结束的字符串</td>
        </tr>
        <tr>
            <td>end$</td>
            <td>begin and end ...</td>
            <td>not match</td>
            <td>end不在字符串的结束就匹配不上</td>
        </tr>
    </tbody>
</table>

<h3 id="注意-和-的区别"><a href="#注意-和-的区别" class="headerlink" title="注意 ^[] 和 [^] 的区别"></a><code>注意 ^[] 和 [^] 的区别</code></h3><blockquote>
<p>^[0-9] 表示字符串是以数字开始的<br><br>[^0-9] 表示一个不是数字的字符<br></p>
</blockquote>
<table>
    <thead>
        <tr>
            <th style="text-align:center">Regular expression</th>
            <th style="text-align:center">Input</th>
            <th style="text-align:center">OutPut</th>
            <th style="text-align:center">Describe</th>
        </tr>
    </thead>
    <tbody align="center">
        <tr>
            <td>^[0-9a-zA-Z]{4,}$</td>
            <td>12cd5678</td>
            <td>12cd5678</td>
            <td>表示由数字和字母组成的字符串,且字符串的长度>=4</td>
        </tr>
        <tr>
            <td>^[0-9a-zA-Z]{4,}$</td>
            <td>12cd5>678</td>
            <td>not match</td>
            <td>有其他字符></td>
        </tr>
        <tr>
            <td>^[0-9a-zA-Z]{4,}$</td>
            <td>a5c</td>
            <td>not match</td>
            <td>不足4位></td>
        </tr>
    </tbody>
</table>

<h3 id="贪婪词汇"><a href="#贪婪词汇" class="headerlink" title="贪婪词汇"></a><code>贪婪词汇</code></h3><blockquote>
<p>贪婪匹配:正则表达式总是寻找最大的匹配，而不是最小的<br></p>
</blockquote>
<table>
    <thead>
        <tr>
            <th style="text-align:center">贪婪量词</th>
            <th style="text-align:center">非贪婪量词</th>
        </tr>
    </thead>
    <tbody align="center">
        <tr>
            <td>*</td>
            <td>*？</td>
        </tr>
        <tr>
            <td>+</td>
            <td>+？</td>
        </tr>
        <tr>
            <td>{n,}</td>
            <td>{n,}?</td>
        </tr>
    </tbody>
</table>

<table>
    <thead>
        <tr>
            <th style="text-align:center">贪婪版本</th>
            <th style="text-align:center">Input</th>
            <th style="text-align:center">Output</th>
            <th style="text-align:center">Describe</th>
        </tr>
    </thead>
    <tbody align="center">
        <tr>
            <td>s.*g</td>
            <td>xiao song xiao song</td>
            <td>song xiao song</td>
            <td>s和g之间有0到多个任意字符</td>
        </tr>
    </tbody>
</table>

<table>
    <thead>
        <tr>
            <th style="text-align:center">非贪婪版本</th>
            <th style="text-align:center">Input</th>
            <th style="text-align:center">Output</th>
        </tr>
    </thead>
    <tbody align="center">
        <tr>
            <td>s.*?g</td>
            <td>xiao song xiao song</td>
            <td>song,song</td>
        </tr>
    </tbody>
</table>]]></content>
      <tags>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>句柄泄露的定位过程</title>
    <url>/2019-05-05-%E5%8F%A5%E6%9F%84%E6%B3%84%E9%9C%B2%E7%9A%84%E5%AE%9A%E4%BD%8D%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li>
<li><a href="#%E6%B5%81%E7%A8%8B">流程</a></li>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#%E8%AF%B4%E6%98%8E">说明</a></li>
<li><a href="#strace%E4%BB%8B%E7%BB%8D">strace介绍</a></li>
<li><a href="#strace%E5%8F%82%E6%95%B0">strace参数</a></li>
<li><a href="#demo%E5%AE%9E%E8%B7%B5">demo实践</a></li>
</ul>
<a id="more"></a>

<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p><img src="https://i.loli.net/2019/05/05/5cceeaa01c6c6.png"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>定位句柄泄露问题,目前掌握的最好用的就是strace命令.可以监测指定进程的系统调用,来寻找是否存在持续创建socket并且未释放的地方.当前,strace命令还有其他用武之处,但不在本文所描述的范畴内</p>
</blockquote>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><blockquote>
<p>本文主要讲解strace的用法.用尝试写一个简单的句柄泄露的Demo来分析</p>
</blockquote>
<h2 id="strace介绍"><a href="#strace介绍" class="headerlink" title="strace介绍"></a>strace介绍</h2><blockquote>
<p>strace命令是一个集诊断、调试、统计与一体的工具，我们可以使用strace对应用的系统调用和信号传递的跟踪结果来对应用进行分析，以达到解决问题或者是了解应用工作过程的目的。当然strace与专业的调试工具比如说gdb之类的是没法相比的，因为它不是一个专业的调试器。</p>
</blockquote>
<blockquote>
<p>strace的最简单的用法就是执行一个指定的命令，在指定的命令结束之后它也就退出了。在命令执行的过程中，strace会记录和解析命令进程的所有系统调用以及这个进程所接收到的所有的信号值。</p>
</blockquote>
<h2 id="strace参数"><a href="#strace参数" class="headerlink" title="strace参数"></a>strace参数</h2><table>
    <thead align="center">
        <tr>
            <th style="text-align:center">参数名</th>
            <th style="text-align:center">说明</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>-c</td>
            <td>统计每一系统调用的所执行的时间,次数和出错的次数等</td>
        </tr>
        <tr>
            <td>-d</td>
            <td>输出strace关于标准错误的调试信息</td>
        </tr>
        <tr>
            <td>-f</td>
            <td>跟踪由fork调用所产生的子进程</td>
        </tr>
        <tr>
            <td>-F</td>
            <td>尝试跟踪vfork调用.在-f时,vfork不被跟踪</td>
        </tr>
        <tr>
            <td>-ff</td>
            <td>如果提供-o filename,则所有进程的跟踪结果输出到相应的filename.pid中,pid是各进程的进程号</td>
        </tr>
        <tr>
            <td>-h</td>
            <td>输出简要的帮助信息</td>
        </tr>
        <tr>
            <td>-i</td>
            <td>输出系统调用的入口指针</td>
        </tr>
        <tr>
            <td>-q</td>
            <td>禁止输出关于脱离的消息</td>
        </tr>
        <tr>
            <td>-r</td>
            <td>打印出相对时间,关于每一个系统调用</td>
        </tr>
        <tr>
            <td>-t</td>
            <td>在输出中的每一行前加上时间信息</td>
        </tr>
        <tr>
            <td>-tt</td>
            <td>在输出中的每一行前加上时间信息,微秒级</td>
        </tr>
        <tr>
            <td>-T</td>
            <td>显示每一调用所耗的时间</td>
        </tr>
        <tr>
            <td>-v</td>
            <td>输出所有的系统调用.一些调用关于环境变量,状态,输入输出等调用由于使用频繁,默认不输出</td>
        </tr>
        <tr>
            <td>-V</td>
            <td>输出strace的版本信息</td>
        </tr>
        <tr>
            <td>-x</td>
            <td>以十六进制形式输出非标准字符串</td>
        </tr>
        <tr>
            <td>-xx</td>
            <td>所有字符串以十六进制形式输出</td>
        </tr>
        <tr>
            <td>-a column</td>
            <td>设置返回值的输出位置.默认为40</td>
        </tr>
        <tr>
            <td>-e expr</td>
            <td>指定一个表达式,用来控制如何跟踪</td>
        </tr>
        <tr>
            <td>-e trace=set</td>
            <td>跟踪指定的系统 调用.例如:-e trace=open,close,rean,write表示只跟踪这四个系统调用.默认的为set=all.</td>
        </tr>
        <tr>
            <td>-e trace=file</td>
            <td>只跟踪有关文件操作的系统调用</td>
        </tr>
        <tr>
            <td>-e trace=process</td>
            <td>只跟踪有关进程控制的系统调用</td>
        </tr>
        <tr>
            <td>-e trace=network</td>
            <td>跟踪与网络有关的所有系统调用</td>
        </tr>
        <tr>
            <td>-e strace=signal</td>
            <td>跟踪所有与系统信号有关的系统调用</td>
        </tr>
        <tr>
            <td>-e trace=ipc</td>
            <td>跟踪所有与进程间通讯有关的系统调用</td>
        </tr>
        <tr>
            <td>-e abbrev=set</td>
            <td>设定strace输出的系统调用的结果集.-v 等与 abbrev=none.默认为abbrev=all</td>
        </tr>
        <tr>
            <td>-e raw=set</td>
            <td>将指定的系统调用的参数以十六进制显示</td>
        </tr>
        <tr>
            <td>-e signal=set</td>
            <td>指定跟踪的系统信号.默认为all.如 signal=!SIGIO(或者signal=!io),表示不跟踪SIGIO信号</td>
        </tr>
        <tr>
            <td>-e read=set</td>
            <td>输出从指定文件中读出 的数据.例如: -e read=3,5</td>
        </tr>
        <tr>
            <td>-e write=set</td>
            <td>输出写入到指定文件中的数据</td>
        </tr>
        <tr>
            <td>-o filename</td>
            <td>将strace的输出写入文件filename</td>
        </tr>
        <tr>
            <td>-p pid</td>
            <td>跟踪指定的进程pid</td>
        </tr>
        <tr>
            <td>-s strsize</td>
            <td>指定输出的字符串的最大长度.默认为32.文件名一直全部输出</td>
        </tr>
        <tr>
            <td>-u username</td>
            <td>以username的UID和GID执行被跟踪的命令</td>
        </tr>
    </tbody>
</table>

<h2 id="demo实践"><a href="#demo实践" class="headerlink" title="demo实践"></a>demo实践</h2><blockquote>
<p>写了个最简化的句柄泄露的Demo,思路是客户端创建socket后发给本机一个没被监听的端口.connect失败后直接return.当前也可以用open后直接return等方法.这里顺便再熟悉下socket的创建流程.</p>
</blockquote>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include&lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;sys/socket.h&gt;
#include&lt;netinet/in.h&gt;
#include&lt;arpa/inet.h&gt;

int main()
&#123;
    int iConnFd = 0;
    char szAddr[] = &#123;&quot;127.0.0.1&quot;&#125;;
    struct sockaddr_in  stServerAddr = &#123;0&#125;;

    for (int i = 0; i &lt; 10000; ++i)
    &#123;
        if ((iConnFd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)
        &#123;
            perror(&quot;Failed to create socket!&quot;);
            return -1;
        &#125;

        stServerAddr.sin_family = AF_INET;
        stServerAddr.sin_port = htons(7777);

        if (inet_pton(AF_INET, szAddr, (void*)&amp;stServerAddr.sin_addr) &lt;= 0)
        &#123;
            perror(&quot;Failed to swicth ip addr!&quot;);
            close(iConnFd);
            iConnFd = -1;
            return -1;
        &#125;

        if (connect(iConnFd, (struct sockaddr*)&amp;stServerAddr, sizeof(stServerAddr)) &lt; 0)
        &#123;
            perror(&quot;Failed to connect!&quot;);
            //close(iConnFd);
        &#125;

        sleep(1);
    &#125;


    return 0;
&#125;</code></pre>
<ul>
<li><p>如图:</p>
<p>  <img src="https://i.loli.net/2019/05/05/5ccf049ac9f67.png"><br>  <img src="https://i.loli.net/2019/05/05/5ccf049b33760.png"><br>  <img src="https://i.loli.net/2019/05/05/5ccf049b3be32.png"></p>
<p>  可以清晰的看出来,进程一直在创建socket，然后connect，cconnect失败后没有回收socket.当然这是很理想的情况,生产环境下比较复杂了,需要具体问题具体分析.</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>POE相机的安装配置</title>
    <url>/2019-05-17-POE%E7%9B%B8%E6%9C%BA%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章简单记录下自己安装的两个IPC的过程,以后会基于此总结一些onvif和sip的知识.</p>
<a id="more"></a>


<h2 id="什么是POE"><a href="#什么是POE" class="headerlink" title="什么是POE"></a>什么是POE</h2><p><code>引用自</code>: <a href="https://zhuanlan.zhihu.com/p/33654563">关于POE你知道多少？POE知识汇总！</a></p>
<blockquote>
<p>POE（Power Over Ethernet）是有源以太网供电的简称，指的是在现有的以太网Cat.5布线基础架构不作任何改动的情况下，在为一些基于IP的终端（如IP电话机、无线局域网接入点AP、网络摄像机等）传输数据信号的同时，还能为此类设备提供直流供电的技术。POE技术能在确保现有结构化布线安全的同时保证现有网络的正常运作，最大限度地降低成本。</p>
</blockquote>
<p><img src="https://i.loli.net/2019/05/17/5cdebbf3d0ac590260.jpg"></p>
<pre><code>简单来看就是相比普通的网线多了4条线来供电.</code></pre>
<h2 id="尝试部署POE相机"><a href="#尝试部署POE相机" class="headerlink" title="尝试部署POE相机"></a>尝试部署POE相机</h2><p>最近在咸鱼上买了2个二手的IPC,一个大华的IPC-HDW2120C,一个宇视的IPC3331S-IRS-PF80-DT,都挺老的型号了.也不支持H.265.耐不住便宜啊，也支持POE.买来研究下onvif和sip.<br></p>
<p><code>实物图</code>:<br><img src="https://i.loli.net/2019/05/17/5cdec01c9c99081119.jpg"><br><br></p>
<blockquote>
<p>安装过程中还是遇到了一些麻烦,因为对硬件不熟,之前都不知道POE.后来在卖家的指导以及自己查了点资料后才搞定.具体遇到的一些难点说明一下:<br><br>    1:网络摄像机既要传输网络,又要供电.但POE线是可以同时满足这两点的.文章前面也说明了原理.<br><br>    2:这两个摄像头都是支持POE供电的,但我的网线是4芯的,不能供电,并且我的wifi装置也不支持POE.因此我在网上又买了POE网线和POE”交换机”,可以看我拍的实物图.<br><br>    3：都是二手的相机,也没有说明书.不知道摄像头的IP.所以需要工具.宇视相机查IP可以用EzTool工具,大华的用大华快速配置工具.在官网上都能找到.如图:<br></p>
</blockquote>
<p><code>大华快速配置工具</code>:<br><img src="https://i.loli.net/2019/05/17/5cdec3049abcb37039.png"><br><code>EzTool</code>:<br><img src="https://i.loli.net/2019/05/17/5cdec3049064829485.png"></p>
<blockquote>
<p>对了,相机的ip地址要和自己电脑在同一网段才能显示出来.可以先配成一个网段链接相机后再修改相机的ip地址.<br></p>
</blockquote>
<p><code>登陆界面</code>：</p>
<p><img src="https://i.loli.net/2019/05/17/5cdec4780557384275.png"><br><img src="https://i.loli.net/2019/05/17/5cdec4780e66963484.png"></p>
<blockquote>
<p>实况就不截图了,工具配置完成.希望后面能坚持下去,好好利用下.</p>
</blockquote>
]]></content>
      <tags>
        <tag>视频</tag>
      </tags>
  </entry>
  <entry>
    <title>人为什么会悲伤</title>
    <url>/2019-05-30-%E4%BA%BA%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%82%B2%E4%BC%A4/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/05/30/5ceebf66ef61d90634.jpg"></p>
<p>&emsp;&emsp;&emsp;最近好几次不经意间,会去思考悲伤是怎样的一种情绪.人为什么会悲伤?此时此刻,我十分冷静的,来思考悲伤这种情绪.以此,在陷入悲伤时,能够早点超脱出来.得以自已.<br></p>
<a id="more"></a>

<p>&emsp;&emsp;&emsp;如何定义悲伤?维基百科上对悲伤的解释:<br></p>
<blockquote>
<p>悲伤是种情绪反应，多数高等哺乳动物均有此反应，其中，人类对此反应最为显著。<br>人类的悲伤通常来自经历上的挫折失败，如：无法抗拒的住所改变，亲友死亡、离婚、毕业或失业。另外，这类生物反应又会因生活经验与文化特质而异。举例来说，失去亲人往往让人觉得悲伤，但悲伤的表达方式则因当事者年龄，经历而有所不同。悲伤表现在外即为沮丧心情。通常悲伤也会伴与落泪与沉默。<br>悲伤是保罗·艾克曼提出的六种基本情感之一：愤怒、厌恶、恐惧、快乐、悲伤、惊讶。</p>
</blockquote>
<p>&emsp;&emsp;&emsp;最后这句,我觉得很有意思.悲伤是人类的一种基本情感.是人类的，并且是基本的情感.试想,我们总是沉浸在学习中,玩乐中,工作中.总是适应在自己所处的时代,社会中.而一旦悲伤起来,便会变得沉默,并感到痛苦.这时候,我们总是异常冷静而专注的沉浸在让自己感到悲伤的事情之中.总是免不了会去想为什么会发生这种事情,应该如何解决,又会对自己往后的生活产生什么影响.这种时候,我们其实是从俗世的生活中跳脱出来了,疏远了单一独特的个体,来到了人类共性的领域.<br><br>&emsp;&emsp;&emsp;产生悲伤的原因有很多,但其实细细想来,大多数悲伤产生的原因都大同小异.每个人都会在一定的阶段接触,经历一些事情的变化，跃迁.如果准备的不够充分,没有足够的人生经历或至始至终没有解决,解释通一种挫折,便会必然的陷入悲伤.这看来,像是上帝安排的，作为人所必须经历的一道坎.<br><br>悲伤对人的影响因人而异,和宗教,文化,生活经历有关.想了想,我大胆的认为悲伤对人的影响取决于人对于死亡和生存的看法.<br><br>&emsp;&emsp;&emsp;我总是觉得西方人相对于东方人,对于悲伤处理的更好一些.从对死亡的角度来看,西方人也会痛苦,但是在痛苦发生的阶段,他们往往还能冷静的处理俗世,基本生活中的事情,并且会以一种寄予希望的形式来处理，比如会在坟墓，在死亡地点,放置一些鲜花.点蜡烛,与亲朋好友一起祷告.（没去过西方,影视作品带给我的印象）。再来看生存的角度,我们常说西方人少系列,在众多冒险类项目中,西方是遥遥领先于东方的.爬山,攀登,骑行,西方人更有勇气去尝试,并且对糟糕结果的接受程度很多,能够容忍高风险的事情.西方的父母更愿意支持孩子做自己喜欢的事情,即使安全风险很高.<br><br>&emsp;&emsp;&emsp;作为一个传统的东方人,我试图借鉴一些西方的处世之道.希望在不愿意发生的事情发生的时候,能够冷静的对待.避免自身长时间的陷入一种低免疫力的失落状态中.从而在挫折发生阶段做更多有意义的时候,早点为以后的生活做打算,进行弥补.即使跳脱出悲伤的情绪,能够理智的向前看.(我其实很不情愿用理智这个词)<br><br>&emsp;&emsp;&emsp;想一想,你所谓的悲伤,在这个世界,其实很多人都会经历.很少的挫折是罕见的.有那么多人冒着生命危险去尝试新鲜的,有趣的事情.并且已经有很多人为此付出了性命,那么你为什么,不能在挫折发生的时候，激励自己,改变自己，让自己活得更出色,更有趣呢.这何尝不是一个契机,让你做出改变,去尝试更多以前没有接触的活动,眼界放开,才会认识更多的人.明白很多人都一直在做有趣的事情,开心的事情.很多人都为自己的优秀做出了努力.这样在你别人击败时，还会茫然吗？<br><br>&emsp;&emsp;&emsp;悲伤的时候,经常会不知所措.我想这是悲伤的初级阶段吧,正是自己的无能为力,不知所措,才让自己处于一种被动的,无助的状态中.只有自己强大了,才能最好的抵御悲伤带来的负面影响.接受已经发生的,尽力去弥补,同时也不要忘记让自己活得更好.<br><br>&emsp;&emsp;&emsp;悲伤本身,有什么意义呢？当你回头看的时候，里面的自己还是现在的自己吗?活在当下,勇于接受,改变自己,和大家共勉.</p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2019/05/30/5ceebde639c2520375.jpg"></p>
]]></content>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>gsoap的安装过程</title>
    <url>/2019-06-03-gsoap%E7%9A%84%E5%AE%89%E8%A3%85%20-%20%E5%89%AF%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在搞onvif，gsoap是绕不过的坎,安装的过程大大超出了预期,可以说是相当的艰难了,大概记录下过程.</p>
<a id="more"></a>

<h2 id="漫长的安装过程"><a href="#漫长的安装过程" class="headerlink" title="漫长的安装过程"></a>漫长的安装过程</h2><p>1.下载gsoap: <a href="http://sourceforge.net/projects/gsoap2">开源下载链接</a> <br><br>2.下载,解压缩.<br></p>
<blockquote>
<p>$ cd gsoap-2.8<br><br>$ ./configure –with-openssl=/usr/local/ssl<br><br>$ make<br><br>$ make install<br></p>
</blockquote>
<p>3.解决错误.<br></p>
<blockquote>
<p>然后大概会报错：<code>aclocal-1.16: 未找到命令</code> ,网上找到的解决办法:autoreconf -ivf .为此要安装autoconf和automake,参考: <a href="https://jingyan.baidu.com/article/8275fc8691d01a46a03cf6a5.html">在CentOS中安装autoconf和automake</a>.安装autoconf和automake的时候又报错了,真是头大.参考我的操作步骤吧(精简了下),也记不起来了<br></p>
</blockquote>
<pre><code> 06:03:31 autoreconf -ivf
 06:05:51 wget http://ftp.gnu.org/gnu/autoconf/autoconf-2.69.tar.gz
 06:06:10 yum -y install wget
 06:06:18 wget http://ftp.gnu.org/gnu/autoconf/autoconf-2.69.tar.gz
 06:09:47 ls
 06:09:54 tar -xzvf autoconf-2.69.tar.gz 
 06:09:58 cd autoconf-2.69
 06:10:04 ./configure 
 06:10:10 make
 06:10:21 make | grep err
 06:11:18 cd ..
 06:11:22 wget http://www.cpan.org/modules/by-module/Data/Data-Dumper-2.173.tar.gz
 06:12:01 tar -xzvf Data-Dumper-2.173.tar.gz 
 06:12:04 cd Data-Dumper-2.173
 06:12:15 perl Makefile.PL 
 06:13:01 cd ..
 06:13:03 wget http://files.directadmin.com/services/9.0/ExtUtils-MakeMaker-6.31.tar.gz
 06:13:30 tar -xzvf ExtUtils-MakeMaker-6.31.tar.gz 
 06:13:35 cd ExtUtils-MakeMaker-6.31
 06:13:50 perl Makefile.PL 
 06:14:08 yum install perl-ExtUtils-MakeMaker
 06:14:15 perl Makefile.PL 
 06:15:01 cd autoconf-2.69
 06:15:20 ./configure 
 06:15:25 make
 06:16:15 cd Data-Dumper-2.173
 06:16:18 make
 06:16:23 make install    
 06:16:34 cd ExtUtils-MakeMaker-6.31
 06:16:37 make
 06:16:41 make install
 06:16:42 cd ..
 06:16:48 cd autoconf-2.69
 06:16:49 ls
 06:16:50 make
 06:16:57 make install
 06:17:02 cd ..
 06:17:09 cd gsoap-2.8/
 06:17:10 ls
 06:17:12 make
 06:17:18 ./configure
 06:17:44 make
 06:17:50 autoconf --version
 06:18:06 wget http://ftp.gnu.org/gnu/automake/automake-1.14.tar.gz
 06:23:25 tar -xzvf automake-1.14.tar.gz 
 06:23:28 cd automake-1.14
 06:23:55 ./bootstrap.sh 
 06:26:29 yum install perl-Thread-Queue
 06:26:35 ./bootstrap.sh 
 06:26:42 ./configure 
 06:26:51 make
 06:26:57 make install
 06:27:04 automake --version
 06:27:07 cd ..
 06:27:07 ls
 06:27:11 cd gsoap-2.8/
 06:27:12 ls
 06:27:16 ./configure
 06:27:30 ls
 06:27:31 make
 06:27:54 autoreconf -ivf&lt;br&gt;</code></pre>
<blockquote>
<p>aclocal-1.16这个问题大概是解决了.接着执行: ./configure –with-openssl=/usr/local/ssl 又报错.大概是ssl有问题.于是:<br></p>
</blockquote>
<pre><code>yum install openssl
yum install openssl-devel
cd /
find . -name openssl 找到openssl的头文件的地址，我的是 ./usr/include/openssl
然后: ./configure --with-openssl=/usr/include/openssl</code></pre>
<blockquote>
<p>又报错找不到yacc，继续:</p>
</blockquote>
<pre><code>yum install byacc
yum install flex</code></pre>
<blockquote>
<p>安装完,make的时候又报奇怪的错误.重新configure后就好了: </p>
</blockquote>
<pre><code>./configure --with-openssl=/usr/include/openssl
make
make install
which wsdl2h soapcpp2
wsdl2h -h</code></pre>
<blockquote>
<p>大功告成.整个安装过程着实捉急.凭印象和history信息进行了整理.有点混乱,可能记录也不全面.就这样吧.<br></p>
</blockquote>
]]></content>
      <tags>
        <tag>gsoap</tag>
      </tags>
  </entry>
  <entry>
    <title>rtsp_digest加解密</title>
    <url>/2019-06-17-rtsp_digest%E5%8A%A0%E8%A7%A3%E5%AF%86/</url>
    <content><![CDATA[<h2 id="维基百科"><a href="#维基百科" class="headerlink" title="维基百科"></a>维基百科</h2><blockquote>
<p>Digest access authentication is one of the agreed-upon methods a web server can use to negotiate credentials, such as username or password, with a user’s web browser. This can be used to confirm the identity of a user before sending sensitive information, such as online banking transaction history. It applies a hash function to the username and password before sending them over the network.  <br></p>
<p>摘要访问身份验证是Web服务器可以用来与用户的Web浏览器协商凭据（例如用户名或密码）的商定方法之一。这可用于在发送敏感信息（例如在线银行交易历史记录）之前确认用户的身份。它在通过网络发送之前将哈希函数应用于用户名和密码</p>
</blockquote>
<a id="more"></a>

<h2 id="加解密流程"><a href="#加解密流程" class="headerlink" title="加解密流程"></a>加解密流程</h2><p>摘要访问身份验证最初由RFC 2069（HTTP扩展：摘要访问身份验证）指定。RFC 2069大致规定了传统的摘要式身份验证方案，其安全性由服务器生成的nonce值维护。身份验证响应形成如下（其中HA1和HA2是字符串变量的名称）</p>
<h2 id="rtsp-digest加密"><a href="#rtsp-digest加密" class="headerlink" title="rtsp digest加密"></a>rtsp digest加密</h2><p>onvif实况要走rtsp协议(目前还不是很熟悉这块,不确定是否必须).但ODM工具实况是走rtsp的.我也抓了报文：<br><br>    链接：<a href="https://pan.baidu.com/s/1h1hUiPAQDKzugfRLNUmdPg">https://pan.baidu.com/s/1h1hUiPAQDKzugfRLNUmdPg</a><br><br>    提取码：0rp8 </p>
<p><img src="https://i.loli.net/2019/06/18/5d07b98b5ab1a49848.png"></p>
<pre><code>DESCRIBE rtsp://192.168.1.18/media/video1 RTSP/1.0
CSeq: 3
User-Agent: LIVE555 Streaming Media v2012.06.17
Accept: application/sdp

RTSP/1.0 401 ClientUnAuthorized
CSeq: 3
WWW-Authenticate: Digest realm=&quot;48ea630ea6b6&quot;,nonce=&quot;1560111814178281114221112111111170273871&quot;, stale=&quot;FALSE&quot;

DESCRIBE rtsp://192.168.1.18/media/video1 RTSP/1.0
CSeq: 4
Authorization: Digest username=&quot;admin&quot;, realm=&quot;48ea630ea6b6&quot;, nonce=&quot;1560111814178281114221112111111170273871&quot;,
uri=&quot;rtsp://192.168.1.18/media/video1&quot;, response=&quot;100bcc84410727cf46a8b33db7258c01&quot;
User-Agent: LIVE555 Streaming Media v2012.06.17
Accept: application/sdp

RTSP/1.0 200 OK
CSeq: 4
Content-Base: rtsp://192.168.1.18/media/video1
Content-Length: 508
Content-Type: application/sdp

v=0
o=- 1001 1 IN IP4 192.168.1.18
s=VCP IPC Realtime stream
m=video 0 RTP/AVP 105
c=IN IP4 192.168.1.18
a=control:rtsp://192.168.1.18/media/video1/video
a=rtpmap:105 H264/90000
a=fmtp:105 profile-level-id=64001f; packetization-mode=1; sprop-parameter-sets=Z2QAH6wrUCgC3QgAAB9AAAYahCAA,aO4xsg==
a=recvonly
m=application 0 RTP/AVP 107
c=IN IP4 192.168.1.18
a=control:rtsp://192.168.1.18/media/video1/metadata
a=rtpmap:107 vnd.onvif.metadata/90000
a=fmtp:107 DecoderTag=h3c-v3 RTCP=0
a=recvonly</code></pre>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>第一次发rtsp.method == DESCRIBE，没有带用户名密码,服务端返回401鉴权不通过,并在401 response中携带了域名(realm),nonce<br><br>客户端基于realm,nonce进行digest摘要字组串加密,第二次发rtsp.method == DESCRIBE ，并携带鉴权信息.其中response=”100bcc84410727cf46a8b33db7258c01”就是最后的加密信息,服务端也会生成一份response与客户端的进行校验.</p>
<h2 id="response的生成逻辑"><a href="#response的生成逻辑" class="headerlink" title="response的生成逻辑"></a>response的生成逻辑</h2><pre><code>HA1 = MD5（用户名：域名(realm)：密码）
HA2 = MD5（方法：digestURI）
响应= MD5（HA1：nonce：HA2）

HA1 = MD5（admin:48ea630ea6b6:***） = a913b0ee8a4c9d05cf6d34b597b45e1f
HA2 = MD5（DESCRIBE:rtsp://192.168.1.18/media/video1）= 68010645697e5e209583dde1323ca453
响应= MD5（a913b0ee8a4c9d05cf6d34b597b45e1f:1560111814178281114221112111111170273871:68010645697e5e209583dde1323ca453）
    = 100bcc84410727cf46a8b33db7258c01</code></pre>
<h2 id="Md5加密"><a href="#Md5加密" class="headerlink" title="Md5加密"></a>Md5加密</h2><p>这里我用的md5sum命令在服务器上进行加密,比较方便</p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2019/06/18/5d07bca12de6421653.jpg"></p>
]]></content>
      <tags>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title>wireshark切割报文</title>
    <url>/2019-06-24-wireshark%E5%88%87%E5%89%B2%E6%8A%A5%E6%96%87/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有的时候抓的报文太大,打开比较费时间.甚至打开时报错,这个时候就需要分割报文了.当然如果能够在抓包的时候进行必要的过滤,让原始包就没那么大,就最好了.此文只描述将已经抓到的大报文进行切割.</p>
<a id="more"></a>

<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>文章主要参考了: <a href="https://help.aliyun.com/knowledge_detail/40729.html">抓包信息使用Wireshark无法打开查看</a></p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><code>用到的命令</code>:<br>// -C 100                    :按照100个frame来切割，  <br><br>// D:\test.pcapng            :原始包路径<br><br>// D:                        :新生成的报文路径<br><br>//editcap.exe在wireshark的安装路径下 <br><br>editcap.exe -c 100 D:\test.pcapng D:\ </p>
<p><code>敲命令</code><br><img src="https://i.loli.net/2019/06/24/5d10f1c771b1133014.png"></p>
<p><code>生成的文件</code><br><img src="https://i.loli.net/2019/06/24/5d10f1c7b25c675048.png"></p>
<p>每个文件都是100 frame</p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p>哈哈,水了一篇博客,最近真是有点懒惰了<br><img src="https://i.loli.net/2019/06/24/5d10f1c8473db75970.jpg"></p>
]]></content>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>Tcp_keepalive</title>
    <url>/2019-06-30-Tcp_keepalive/</url>
    <content><![CDATA[<h2 id="墨菲定律"><a href="#墨菲定律" class="headerlink" title="墨菲定律"></a>墨菲定律</h2><p>墨菲定律，又译为摩菲定律，具体内容是“凡是可能出错的事就一定会出错”</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一个学徒,在第一次接触一件事物时,不能很全面,很深入的认知.一段时间后,没了新鲜感,容易失去兴趣,流于表面.就像我,简单的tcp握手,挥手流程,一直没有真正的了解过,心存侥幸,等到真正遇到这方面的问题,才方恨少于读书.吃了墨菲定律的亏,所以说,还是要一步一步,踏踏实实的行进啊.心存侥幸的,都是赌徒.做学徒,不做赌徒.</p>
<a id="more"></a>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://tldp.org/HOWTO/html_single/TCP-Keepalive-HOWTO/">TCP Keepalive HOWTO</a> <br><br><a href="http://www.blogjava.net/yongboy/archive/2015/04/14/424413.html">随手记之TCP Keepalive笔记</a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>keepalive概念非常简单：当您设置TCP连接时，您可以关联一组计时器。其中一些计时器处理keepalive程序。当keepalive定时器到达零时，您向对等体发送一个keepalive探测数据包，其中没有数据并且ACK标志已打开。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>一般服务器进程间都会有一定的保活机制,确保对端已经建立的连接是有效的,如果保活失败则可以进行一定的重连操作尝试恢复.或者直接清理掉无效的连接,减少系统的资源.</p>
<p>除此之外,操作系统(姑且这样认为吧)提供了一些参数,可以设置后通过其实现对连接进行检测.我接触到keeplaive也是在这样的情境下.当上层程序因为种种原因,或是其他网络原因,配置原因.一些tcp连接没有成功释放,例如我最近遇到的:CLOSE_WAIT.系统中存在大量的连接处于CLOSE_WAIT状态,使得进程占用的open file很快就达到上限,严重影响其他业务.</p>
<ul>
<li>CLOSE_WAIT状态</li>
</ul>
<p><img src="https://i.loli.net/2019/06/30/5d18d266c898441132.jpg"> <br></p>
<p>tcp四次挥手的过程中,作为被动关闭方,在收到主动关闭方发来的FIN后,回复ACK确认,然后自己便处于CLOSE_WAIT状态,通常这个状态持续的时间比较短,如果发现环境中存在大量的CLOSE_WAIT状态的连接,则一定有问题了.</p>
<h2 id="解决CLOSE-WAIT"><a href="#解决CLOSE-WAIT" class="headerlink" title="解决CLOSE_WAIT"></a>解决CLOSE_WAIT</h2><ul>
<li><p>找到问题的根因，对症下药</p>
<blockquote>
<p>可以抓包结合日志等分析,造成问题的具体原因,再去对应的做修改</p>
</blockquote>
</li>
<li><p>暂时规避</p>
<blockquote>
<p>通过设置tcp的keepalive值,让操作系统代理对tcp连接进行保活,及时释放有问题的连接</p>
</blockquote>
</li>
</ul>
<h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><p>可以这样查看当前配置的值: <br></p>
<pre><code>[root@localhost ~]# sysctl -a | grep keepalive
net.ipv4.tcp_keepalive_intvl = 75
net.ipv4.tcp_keepalive_probes = 9
net.ipv4.tcp_keepalive_time = 7200</code></pre>
<p>修改系统的缺省值: <br></p>
<pre><code>echo &quot;net.ipv4.tcp_keepalive_time=7200&quot; &gt; /etc/sysctl.conf
echo &quot;net.ipv4.tcp_keepalive_intvl=75&quot; &gt;&gt; /etc/sysctl.conf
echo &quot;net.ipv4.tcp_keepalive_probes=9&quot; &gt;&gt; /etc/sysctl.conf

//使其生效
sysctl -p</code></pre>
<p>值的解释: <br></p>
<pre><code>TCP_KEEPDILE 设置连接上如果没有数据发送的话，多久后发送keepalive探测分组，单位是秒
TCP_KEEPINTVL 前后两次探测之间的时间间隔，单位是秒
TCP_KEEPCNT 关闭一个非活跃连接之前的最大重试次数</code></pre>
<p>必要的一步: <br><br>手动修改,或者用下面介绍的LD_PRELOAD加载的libkeepalive.so <br></p>
<pre><code>setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, &amp;optval, sizeof(optval));  //打开keepalive开关
setsockopt(sockfd, SOL_TCP, TCP_KEEPCNT, &amp;optval, sizeof(optval));        //探测的次数
setsockopt(sockfd, SOL_TCP, TCP_KEEPIDLE, &amp;optval, sizeof(optval));        //多少秒没有数据往来开始探测
setsockopt(sockfd, SOL_TCP, TCP_KEEPINTVL, &amp;optval, sizeof(optval));    //探测的间隔时间
//以此来让创建的sockfd被代理进行保活</code></pre>
<h2 id="libkeepalive-so"><a href="#libkeepalive-so" class="headerlink" title="libkeepalive.so"></a>libkeepalive.so</h2><p><a href="http://libkeepalive.sourceforge.net/">下载地址</a> <br><br>源码: <br></p>
<pre><code>#define _GNU_SOURCE
#include &lt;dlfcn.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;strings.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/tcp.h&gt;

int socket(int domain, int type, int protocol);

int socket(int domain, int type, int protocol)
&#123;
  static int (*orig_socket)(int, int, int) = NULL;
  int sockfd = -1, optval = 1;
  char *env;

  do &#123;
    /* if the original function is NULL, try to resolve it or break */
    if(!orig_socket &amp;&amp; !(*(void **)(&amp;orig_socket) = dlsym(RTLD_NEXT, &quot;socket&quot;))) &#123;
      errno = EACCES;
      break;
    &#125;

    /* call original function with parameters */
    if((sockfd = (*orig_socket)(domain, type, protocol)) == -1) break;

    /* socket must be IPv4 or IPv6 */
    if((domain != AF_INET) &amp;&amp; (domain != AF_INET6)) break;

    /* socket must be TCP */
    if(!(type &amp; SOCK_STREAM)) break;

    /* if environment variable KEEPALIVE is set to &quot;off&quot;, break */
    if((env = getenv(&quot;KEEPALIVE&quot;)) &amp;&amp; !strcasecmp(env, &quot;off&quot;)) break;

    /* if setting keepalive fails, break */
    if(setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, &amp;optval, sizeof(optval)) == -1) break;

    #ifdef TCP_KEEPCNT
    /* if environment variable KEEPCNT is set, override the default option value */
    if((env = getenv(&quot;KEEPCNT&quot;))) &#123;
      optval = atoi(env);
      setsockopt(sockfd, SOL_TCP, TCP_KEEPCNT, &amp;optval, sizeof(optval));
    &#125;
    #endif

    #ifdef TCP_KEEPIDLE
    /* if environment variable KEEPIDLE is set, override the default option value */
    if((env = getenv(&quot;KEEPIDLE&quot;))) &#123;
      optval = atoi(env);
      setsockopt(sockfd, SOL_TCP, TCP_KEEPIDLE, &amp;optval, sizeof(optval));
    &#125;
    #endif

    #ifdef TCP_KEEPINTVL
    /* if environment variable KEEPINTVL is set, override the default option value */
    if((env = getenv(&quot;KEEPINTVL&quot;))) &#123;
      optval = atoi(env);
      setsockopt(sockfd, SOL_TCP, TCP_KEEPINTVL, &amp;optval, sizeof(optval));
    &#125;
    #endif
  &#125; while(0);

  return sockfd;
&#125;</code></pre>
<p><a href="https://blog.csdn.net/liangxiaozhang/article/details/7245926">preload更改函数调用</a> <br><br>就这么点代码,使用了PRELOAD修改了原有的socket函数，默认都加了设置保活参数的setsockopt.</p>
<p>下面VMWARE验证:<br>找到了之前的一个简单代码改了下,作为客户端和本地的21端口建立连接,通过preload预加载的方式将libkeepalive.so加载进去: <br></p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include&lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;sys/socket.h&gt;
#include&lt;netinet/in.h&gt;
#include&lt;arpa/inet.h&gt;

int main()
&#123;
    int iConnFd = 0;
    char szAddr[] = &#123;&quot;127.0.0.1&quot;&#125;;
    struct sockaddr_in  stServerAddr = &#123;0&#125;;

    for (int i = 0; i &lt; 10000; ++i)
    &#123;
        if ((iConnFd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)
        &#123;
            perror(&quot;Failed to create socket!&quot;);
            return -1;
        &#125;

        stServerAddr.sin_family = AF_INET;
        stServerAddr.sin_port = htons(21);

        if (inet_pton(AF_INET, szAddr, (void*)&amp;stServerAddr.sin_addr) &lt;= 0)
        &#123;
            perror(&quot;Failed to swicth ip addr!&quot;);
            close(iConnFd);
            iConnFd = -1;
            return -1;
        &#125;

        if (connect(iConnFd, (struct sockaddr*)&amp;stServerAddr, sizeof(stServerAddr)) &lt; 0)
        &#123;
            perror(&quot;Failed to connect!&quot;);
            close(iConnFd);
        &#125;

        while(1)
            ;
    &#125;


    return 0;
&#125;</code></pre>
<p><img src="https://i.loli.net/2019/07/01/5d18de8cab59434076.png"></p>
<p>可以看到客户端和21端口建立三次握手成功5秒后，就开始发keepalive探测消息了.<br>再看看系统调用: <br></p>
<pre><code>socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3
setsockopt(3, SOL_SOCKET, SO_KEEPALIVE, [1], 4) = 0
setsockopt(3, SOL_TCP, TCP_KEEPCNT, [5], 4) = 0
setsockopt(3, SOL_TCP, TCP_KEEPIDLE, [5], 4) = 0
setsockopt(3, SOL_TCP, TCP_KEEPINTVL, [5], 4) = 0
connect(3, &#123;sa_family=AF_INET, sin_port=htons(21), sin_addr=inet_addr(&quot;127.0.0.1&quot;)&#125;, 16) = 0</code></pre>
<p>使用的命令:</p>
<pre><code>env LD_PRELOAD=&quot;/home/wang/libkeepalive-0.3/libkeepalive.so&quot; KEEPCNT=5 KEEPIDLE=5 KEEPINTVL=5 ./a.out</code></pre>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2019/07/01/5d18dff010dcc81790.jpg"></p>
]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Tcp_握手流程</title>
    <url>/2019-07-05-Tcp%E6%8F%A1%E6%89%8B%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://i.loli.net/2019/07/08/5d2366c95b28288446.jpg"> <br></p>
<a id="more"></a>

<h2 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h2><ul>
<li><p>三次握手<br><img src="https://i.loli.net/2019/07/05/5d1e35a158a3652056.png"></p>
</li>
<li><p>四次挥手<br><img src="https://i.loli.net/2019/07/05/5d1e34f5b0efe22731.png"></p>
</li>
<li><p>三次挥手<br><img src="https://i.loli.net/2019/07/05/5d1e34f5a17d151482.png"></p>
</li>
</ul>
<h2 id="TIME-WAIT的作用"><a href="#TIME-WAIT的作用" class="headerlink" title="TIME_WAIT的作用"></a>TIME_WAIT的作用</h2><p>摘自:<br><a href="https://blog.csdn.net/qq_16077957/article/details/80112397">TIME_WAIT状态存在的意义</a> </p>
<p>1 可靠地实现了TCP全双工连接的终止 <br><br>我们知道，TCP是比较可靠的。当TCP向另一端发送数据时，他要求对端返回一个确认（如同我们关闭时候的FIN和ACK）。如果没有收到确认，则会重发。<br>回忆一下我们最终的那个FIN与ACK，被动关闭方发送FIN，并等待主动关闭方返回的ACK。我们假设最终的ACK丢失，被动关闭方将需要重新发送它的最终那个FIN，主动关闭方必须维护状态信息（TIME_WAIT），以允许它重发最终的那个ACK。<br>如果没有了这个状态，当他第二次收到FIN时，会响应一个RST（也是一种类型的TCP分节），会被服务器解释成一个错误。<br>为了TCP打算执行必要的工作以彻底终止某个连接两个方向上的数据流（即全双工关闭），那么他必须要正确处理连接终止四个分节中任何一个分节丢失的情况。</p>
<p>2 允许老的重复分节在网络中的消逝（为什么需要2MSL） <br><br>首先，存在这样的情况，某个路由器崩溃或者两个路由器之间的某个链接断开时，路由协议需要花费数秒到数分钟的时间才能稳定找出另一条通路。在这段时间内，可能发生路由循环（路由器A把分组发送给B，B又发送回给A），这种情况我们称之为迷途。假设迷途的分组是一个TCP分节，在迷途期间，发送端TCP超时并重传该分组，重传分组通过某路径到达目的地，而后不久（最多MSL秒）路由循环修复，早先迷失在这个循环中的分组最终也被送到目的地。这种分组被称之为重复分组或者漫游的重复分组，TCP必须要正确处理这些重复的分组。<br>我们假设ip1:port1和ip2:port2 之间有一个TCP连接。我们关闭了这个链接，过一段时间后在相同IP和端口之间建立了另一个连接。TCP必须防止来自之前那个连接的老的重复分组在新连接上出现。为了做到这一点，TCP将不复用处于TIME_WAIT状态的连接。2MSL的时间足以让某个方向上的分组存活MSL秒后被丢弃，另一个方向上的应答也最多存活MSL秒后被丢弃。</p>
]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>listen的backup参数</title>
    <url>/2019-07-08-listen%E7%9A%84backup%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/yangbodong22011/article/details/60399728">深入探索 Linux listen() 函数 backlog 的含义</a> <br><br><a href="https://www.cnblogs.com/fczjuever/archive/2013/04/17/3026694.html">Linux之TCP IP内核参数优化</a> <br><br><a href="https://fixatom.com/some-doubts-and-misunderstandings-of-tcp/">对 Linux TCP 的若干疑点和误会Share this</a></p>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><img src="https://i.loli.net/2019/07/08/5d2366c919fd754829.png"></p>
<p>对于连接的初始阶段,服务端会维持2个队列.一个SYN队列,一个accept队列.<br><br>限制syn队列的值：</p>
<pre><code>[root@localhost ~]# cat /proc/sys/net/ipv4/tcp_max_syn_backlog
65535
[root@localhost ~]#</code></pre>
<p>限制accept队列的值:</p>
<pre><code>listen(fd, backlog);

[root@localhost wang]# cat /proc/sys/net/core/somaxconn
65535
[root@localhost wang]#

//取这两个的较小值
//直接修改配置文件只能临时生效,永久的方案是修改/etc/sysctl.conf,然后执行sysctl -p.</code></pre>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>1 修改了/proc/sys/net/ipv4/tcp_max_syn_backlog=5，但实测SYN_RECV在6-9之间,没有严格按照配置文件的值来算.后来找到一篇文章,作者做了验证,可参考<a href="https://www.cnblogs.com/zengkefu/p/5606696.html">linux诡异的半连接(SYN_RECV)队列长度</a></p>
<pre><code>tcp        0      0 127.0.0.1:7777          127.0.0.1:58653         SYN_RECV    -
tcp        0      0 127.0.0.1:7777          127.0.0.1:58655         SYN_RECV    -
tcp        0      0 127.0.0.1:7777          127.0.0.1:58650         SYN_RECV    -
tcp        0      0 127.0.0.1:7777          127.0.0.1:58651         SYN_RECV    -
tcp        0      0 127.0.0.1:7777          127.0.0.1:58657         SYN_RECV    -
tcp        0      0 127.0.0.1:7777          127.0.0.1:58656         SYN_RECV    -
tcp        0      0 127.0.0.1:7777          127.0.0.1:58654         SYN_RECV    -
tcp        0      0 127.0.0.1:7777          127.0.0.1:58652         SYN_RECV    -
tcp        0      0 127.0.0.1:7777          127.0.0.1:58649         SYN_RECV    -</code></pre>
<p>2 修改backlog=5,进行测试.ESTABLISHED=6.不增不减.可参考<a href="https://blog.csdn.net/yangbodong22011/article/details/60399728">深入探索 Linux listen() 函数 backlog 的含义</a>，应该就是backlog+1</p>
<pre><code>tcp        0      0 127.0.0.1:7777          127.0.0.1:40454         ESTABLISHED -
tcp        0      0 127.0.0.1:7777          127.0.0.1:40455         ESTABLISHED -
tcp        0      0 127.0.0.1:7777          127.0.0.1:40452         ESTABLISHED -
tcp        0      0 127.0.0.1:7777          127.0.0.1:40450         ESTABLISHED -
tcp        0      0 127.0.0.1:7777          127.0.0.1:40451         ESTABLISHED -
tcp        0      0 127.0.0.1:7777          127.0.0.1:40453         ESTABLISHED -</code></pre>
<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>当SYN队列值很大,backlog很小的时候.在accept队列满了的时候,客户端再发送数据,服务器会怎么处理这些数据?<br>实验证明:accept队列达到backlog+1后,再accept会报错的,如果服务端线程accept是个循环,有可能导致服务端直接退出的:</p>
<pre><code>accept(3, &#123;sa_family=AF_INET, sin_port=htons(57100), sin_addr=inet_addr(&quot;127.0.0.1&quot;)&#125;, [16]) = 4
accept(3, &#123;sa_family=AF_INET, sin_port=htons(57101), sin_addr=inet_addr(&quot;127.0.0.1&quot;)&#125;, [16]) = 5
accept(3, &#123;sa_family=AF_INET, sin_port=htons(57102), sin_addr=inet_addr(&quot;127.0.0.1&quot;)&#125;, [16]) = 6
accept(3, 0x7fff429f1f70, [16])         = -1 EAGAIN (Resource temporarily unavailable)</code></pre>
<p><img src="https://i.loli.net/2019/07/14/5d2b4522d6ad038115.png"></p>
<p>还有一种情况,backup=3,我用nc起了4个客户端.客户端是4个ESTABLISHED，服务端是3个ESTABLISHED，一个SYN_RECV.我在第4个客户端发了一串字符，此时第4个客户端对应服务器的连接还是SYN_RECV,然后服务端close掉第3个客户端(57111),再去accept第4个客户端(57112),此时57112之前发的数据还能收到.证明了处于SYN_RECV状态的连接,是会保留收到的数据的(可能会有其他一些条件的限制)</p>
<pre><code>[root@localhost ~]# netstat -anp | grep 6666
tcp        1      0 0.0.0.0:6666            0.0.0.0:*               LISTEN      22982/./server      
tcp        0      0 127.0.0.1:6666          127.0.0.1:57110         ESTABLISHED 22982/./server      
tcp        0      0 127.0.0.1:57111         127.0.0.1:6666          CLOSE_WAIT  23025/nc            
tcp       27      0 127.0.0.1:6666          127.0.0.1:57112         ESTABLISHED -                   
tcp        0      0 127.0.0.1:6666          127.0.0.1:57111         FIN_WAIT2   -                   
tcp        0      0 127.0.0.1:57112         127.0.0.1:6666          ESTABLISHED 23026/nc            
tcp        0      0 127.0.0.1:6666          127.0.0.1:57109         ESTABLISHED 22982/./server      
tcp        0      0 127.0.0.1:57109         127.0.0.1:6666          ESTABLISHED 23022/nc            
tcp        0      0 127.0.0.1:57110         127.0.0.1:6666          ESTABLISHED 23023/nc


第4个客户端:
[root@localhost ~]# nc 127.0.0.1 6666
99999999999999999999999999

服务端:
i= 0
i= 1
i= 2
close fd
i= 3
read data: 99999999999999999999999999</code></pre>
<h2 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h2><pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include&lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;sys/socket.h&gt;
#include&lt;netinet/in.h&gt;
#include&lt;arpa/inet.h&gt;

int main()
&#123;
    int iConnFd = 0;
    char szAddr[] = &#123;&quot;127.0.0.1&quot;&#125;;
    struct sockaddr_in  stServerAddr = &#123;0&#125;;

    for (int i = 0; i &lt; 10000; ++i)
    &#123;
        if ((iConnFd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)
        &#123;
            perror(&quot;Failed to create socket!&quot;);
            return -1;
        &#125;

        stServerAddr.sin_family = AF_INET;
        stServerAddr.sin_port = htons(7777);

        if (inet_pton(AF_INET, szAddr, (void*)&amp;stServerAddr.sin_addr) &lt;= 0)
        &#123;
            perror(&quot;Failed to swicth ip addr!&quot;);
            close(iConnFd);
            iConnFd = -1;
            return -1;
        &#125;

        if (connect(iConnFd, (struct sockaddr*)&amp;stServerAddr, sizeof(stServerAddr)) &lt; 0)
        &#123;
            perror(&quot;Failed to connect!&quot;);
            close(iConnFd);
        &#125;
        else
        &#123;
            puts(&quot;connect ok!&quot;);
        &#125;

    &#125;


    return 0;
&#125;</code></pre>
<h2 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h2><pre><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;netdb.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;

int main()
&#123;
    struct sockaddr_in serveraAddr , clientAddr;
    socklen_t clientAddrLen;
    int nFd = 0,linkFd = 0;
    int nRet = 0;
    int nReadLen = 0;
    char szBuff[BUFSIZ] = &#123;0&#125;;

    nFd = socket(AF_INET,SOCK_STREAM,0);
    if(-1 == nFd)
    &#123;
        perror(&quot;socket:&quot;);
        return -1;
    &#125;

    memset(&amp;serveraAddr,0,sizeof(struct sockaddr_in));
    serveraAddr.sin_family = AF_INET; 
    serveraAddr.sin_addr.s_addr = htonl(INADDR_ANY);
    serveraAddr.sin_port = htons(7777);

    int isReuse = 1;
    setsockopt(nFd,SOL_SOCKET,SO_REUSEADDR,(const char*)&amp;isReuse,sizeof(isReuse));

    nRet = bind(nFd,(struct sockaddr*)&amp;serveraAddr,sizeof(serveraAddr));
    if(-1 == nRet)
    &#123;
        perror(&quot;bind:&quot;);
        return -1;
    &#125;

    listen(nFd,5);

    #if 0
    clientAddrLen = sizeof(struct sockaddr_in);
    linkFd = accept(nFd,(struct sockaddr*)&amp;clientAddr,&amp;clientAddrLen);
    if(-1 == linkFd)
    &#123;
        perror(&quot;accept:&quot;);
        return -1;
    &#125;

    while(1)
    &#123;
        memset(szBuff,0,BUFSIZ);
        nReadLen = read(linkFd,szBuff,BUFSIZ);
        if(nReadLen &gt; 0)
        &#123;
            printf(&quot;read data: %s\n&quot;,szBuff);
        &#125;
    &#125;
    #endif

    while(1)
      ;

    return 0;
&#125;</code></pre>
]]></content>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>gsoap添加header</title>
    <url>/2019-07-15-gsoap%E6%B7%BB%E5%8A%A0header/</url>
    <content><![CDATA[<h2 id="Foreword"><a href="#Foreword" class="headerlink" title="Foreword"></a>Foreword</h2><p>前端时间碰到个事,axis的相机onvif接入,告警订阅有些问题.折磨了好久,后来自己买了个2手的axis相机,试着改了下gsoap的代码,才搞定,记录下</p>
<a id="more"></a>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>这里有类似的问题:<br><a href="https://stackoverflow.com/questions/28853553/onvif-pullpointsubscriptionclient-pullmessages">ONVIF PullPointSubscriptionClient.PullMessages</a></p>
<pre><code>I&#39;m trying to get event messages from some ONVIF devices. My code is in C#.

On a (Axis camera) device on EventPortTypeClient.CreatePullPointSubscription returns:

Address.Value: http : / /192.168.8.48/onvif/services
ReferenceParameters.Any.First().OuterXml: &lt;dom0:SubscriptionId xmlns:dom0=&quot;http : / /www.axis.com/2009/event&quot;&gt;38&lt;/dom0:SubscriptionId&gt;
So I add the &quot;To&quot; and &quot;SubscriptionId&quot; soap headers and can get event messages with PullPointSubscriptionClient.PullMessages(&quot;PT5M&quot;, 99, Any, out CurrentTime, out NotificationMessages)

&lt;s:Envelope xmlns:a=&quot;http://www.w3.org/2005/08/addressing&quot; xmlns:s=&quot;http://www.w3.org/2003/05/soap-envelope&quot;&gt;
  &lt;s:Header&gt;
    &lt;a:Action s:mustUnderstand=&quot;1&quot;&gt;http://www.onvif.org/ver10/events/wsdl/PullPointSubscription/PullMessagesRequest&lt;/a:Action&gt;
    &lt;a:MessageID&gt;urn:uuid:f243dbe4-b082-4a6c-aa65-8145468fcf3e&lt;/a:MessageID&gt;
    &lt;a:ReplyTo&gt;
      &lt;a:Address&gt;http://www.w3.org/2005/08/addressing/anonymous&lt;/a:Address&gt;
    &lt;/a:ReplyTo&gt;
    &lt;VsDebuggerCausalityData xmlns=&quot;http://schemas.microsoft.com/vstudio/diagnostics/servicemodelsink&quot;&gt;uIDPo0zfnhoyh15KqPZwP/IS9H0AAAAAdCoo8EjbCUScx/bG/DGcdXp8kY6WrAJDp0TTtNAtj0EACQAA&lt;/VsDebuggerCausalityData&gt;
    &lt;Security s:mustUnderstand=&quot;1&quot; xmlns=&quot;http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd&quot;&gt;
      &lt;wsse:UsernameToken xmlns:wsse=&quot;http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd&quot; xmlns:wsu=&quot;http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd&quot; wsu:Id=&quot;SecurityToken-GWt5XP2ogUljZ/fzEJvnX0WhGpx3FV4i/dRnE539OFU=&quot;&gt;
        &lt;wsse:Username xmlns:wsse=&quot;http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd&quot;&gt;root&lt;/wsse:Username&gt;
        &lt;wsse:Password Type=&quot;http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordDigest&quot; xmlns:wsse=&quot;http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd&quot;&gt;pjwOOO0hOXtUZyJb6B6Lb0ctRIU=&lt;/wsse:Password&gt;
        &lt;wsse:Nonce EncodingType=&quot;http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary&quot; xmlns:wsse=&quot;http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd&quot;&gt;DEE/P1c/P1E/eG9XTT87Pz8/&lt;/wsse:Nonce&gt;
        &lt;wsu:Created xmlns:wsu=&quot;http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd&quot;&gt;2015-03-02T19:06:54.269Z&lt;/wsu:Created&gt;
      &lt;/wsse:UsernameToken&gt;
    &lt;/Security&gt;
    &lt;a:To s:mustUnderstand=&quot;1&quot;&gt;http://192.168.8.48/onvif/services&lt;/a:To&gt;
    &lt;SubscriptionId s:mustUnderstand=&quot;1&quot; xmlns=&quot;http://www.axis.com/2009/event&quot;&gt;38&lt;/SubscriptionId&gt;
  &lt;/s:Header&gt;
  &lt;s:Body xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
    &lt;PullMessages xmlns=&quot;http://www.onvif.org/ver10/events/wsdl&quot;&gt;
      &lt;Timeout&gt;PT5M&lt;/Timeout&gt;
      &lt;MessageLimit&gt;99&lt;/MessageLimit&gt;
    &lt;/PullMessages&gt;
  &lt;/s:Body&gt;
&lt;/s:Envelope&gt;</code></pre>
<p>onvif告警订阅的流程:</p>
<ul>
<li><p>订阅 <br><br>client –&gt; subscribe –&gt; server(ipc) <br><br>server –&gt; 200 ok  –&gt; client</p>
</li>
<li><p>续订 <br><br>client –&gt; renew –&gt; server(ipc) <br><br>server –&gt; 200 ok  –&gt; client</p>
</li>
<li><p>取消订阅 <br><br>client –&gt; unsubscribe –&gt; server(ipc) <br><br>server –&gt; 200 ok  –&gt; client</p>
</li>
</ul>
<p>现在的问题是,axis的ipc在subscirbe的200 ok中携带了subscirbeid，他们用这个来区分订阅源的实例.并且要求client在renew和unsubscibe中携带这个subscribeid.这就比较麻烦了<br><br>200 ok携带的subscribeid:</p>
<p><img src="https://i.loli.net/2019/07/16/5d2ca732e811411421.png"></p>
<p>现在需要在renew和unsubscribe的header中添加一个字段 <br><br>参考<a href="https://www.cnblogs.com/SkyMouse/archive/2012/04/25/2469959.html">gSoap: How to add info to SOAP Header using gSOAP</a></p>
<p><code>step 1</code> </p>
<pre><code>//soap-&gt;header中添加一个字段
struct SOAP_ENV__Header
&#123;
    public:
     void *dummy; /* transient */
     char *username;
    ...
     char *subscribeid;
&#125;;</code></pre>
<p><code>step 2</code></p>
<pre><code>//在对应的renew和unsubscribe的gsoap函数下，添加
if (NULL != soap-&gt;header-&gt;subscribeid)
&#123;
    soap_element_begin_out(soap, &quot;SubscriptionId a:IsReferenceParameter=\&quot;true\&quot; xmlns=\&quot;http://www.axis.com/2009/event\&quot;&quot;, -1, &quot;&quot;)
            || soap_string_out(soap, a-&gt;subscribe_id, 0)
            || soap_element_end_out(soap, &quot;SubscriptionId&quot;)
&#125;</code></pre>
<p><code>step 3</code></p>
<pre><code>//我省略了这步
//Add the namespace mapping to namespaces array in .nsmap file.
&#123;&quot;headerNS&quot;, &quot;http://customeheader.test.com&quot;, NULL, NULL&#125;,        </code></pre>
<p><code>step 4</code></p>
<pre><code>//在对应的地方给subscirbeid赋值,即200 ok中返回的值,需要解析EndpointReference
struct soap soap; 
soap_init(&amp;soap);
...
strcpy(soap-&gt;header-&gt;username, username);
strcpy(soap-&gt;header-&gt;password, passwd);
...
poSoap-&gt;header-&gt;subscribe_id = &quot;EndpointReference&quot;</code></pre>
<p>Finally, like this:</p>
<p><img src="https://i.loli.net/2019/07/16/5d2ca39ac54ae30239.png"></p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2019/07/16/5d2ca60b280b669049.jpg"></p>
]]></content>
      <tags>
        <tag>onvif</tag>
      </tags>
  </entry>
  <entry>
    <title>sipp总结</title>
    <url>/2019-07-17-sipp%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本文一些资料从网络获得,出处已经找不到了，就不粘原文了.</p>
<a id="more"></a>

<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>SIPp是一个测试SIP协议性能的开源工具软件</p>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p><code>脚本模拟</code>  </p>
<p>通过Xml格式的自定义脚本文件格式，模拟 真实网元进行UAS和UAC等场景的话务量性 能测试。</p>
<p><code>运行控制</code> </p>
<p>支持外部配置文件的导入、内部及外部命令 处理、过程监控和统计结果的输出。 </p>
<p><code>消息构造</code> </p>
<p>提供标准化的sip协议支持，便捷的消息构造。 支持多种运行参数，应对不同测试场景要求</p>
<p><code>程序设计</code> </p>
<p>支持branch分支、变量处理、正则表达式、 算术运算等功能，便于构建程序化脚本 </p>
<p>除了以上主要功能外，SIPp还提供了包括TLS、鉴权、 密码认证、RTP媒体流收发等其他的特性支持</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>sipp有windows版和linux版本,本人比较习惯用linux下的.</p>
<p><a href="http://sipp.sourceforge.net/">官方下载链接</a></p>
<p><code>3.3 version 百度网盘</code></p>
<pre><code>链接：https://pan.baidu.com/s/145iR5wK_RyZZEVEw9NsD_Q 
提取码：08a3 </code></pre>
<p><code>中文翻译版使用手册</code>  </p>
<pre><code>链接：https://pan.baidu.com/s/1cZVl-_xqRJZh1Dsvk24lJQ 
提取码：ea5n </code></pre>
<p>有如下四个选项来编译 SIPp：</p>
<blockquote>
<p>不包含对 TLS，SCTP 或 PCAP 的支持</p>
</blockquote>
<pre><code>tar -xvzf sipp-xxx.tar
cd sipp
./configure
make</code></pre>
<blockquote>
<p>包含 TLS 支持</p>
</blockquote>
<pre><code>tar -xvzf sipp-xxx.tar
cd sipp
./configure --with-openssl
make</code></pre>
<blockquote>
<p>包含 PCAP play 支持</p>
</blockquote>
<pre><code>tar -xvzf sipp-xxx.tar
cd sipp
./configure --with-pcap
make</code></pre>
<blockquote>
<p>包含 SCTP 支持</p>
</blockquote>
<pre><code>tar -xvzf sipp-xxx.tar
cd sipp
./configure --with-sctp
make</code></pre>
<blockquote>
<p>或者组合支持以上功能</p>
</blockquote>
<pre><code>tar -xvzf sipp-xxx.tar
cd sipp
./configure --with-sctp --with-pcap --with-openssl
make</code></pre>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><blockquote>
<p>我的启动脚本</p>
</blockquote>
<pre><code>#!/bin/sh
./sipp-3.5.1/sipp 192.169.1.111:7100  -sf main.xml -p 7777 -i 192.169.1.108  -m  1 -oocsf message.xml -trace_err 
exit</code></pre>
<blockquote>
<p>简单说明</p>
</blockquote>
<pre><code>-m: 设置最本最大的呼叫个数，当 sipp 达到该指定值会自动退出
-oocsf: 加载 out-of-call 脚本</code></pre>
<blockquote>
<p>OCC（Out-of-call）脚本作为特殊类型的脚本，通常不会单独使用，而是与UAC脚本配合使用（也只能与UAC脚本配合，UAS等类型脚本无法支持-occsn等执行命令）。主要作用为扩展UAC脚本的适用范围，使UAC脚本能够在接收到不同会话内的非预期消息时，不至于直接丢弃。如注册客户端可能会遇到接收到通知NOTIFY的消息，此时就需要在运行register脚本的时候适用-oocsn或-oocsf参数，配合ooc脚本，实现对NOTIFY消息返回200的操作。</p>
</blockquote>
<h2 id="示例脚本"><a href="#示例脚本" class="headerlink" title="示例脚本"></a>示例脚本</h2><h3 id="main-xml"><a href="#main-xml" class="headerlink" title="main.xml"></a>main.xml</h3><pre><code>&lt;![CDATA[
&lt;?xml version=&quot;1.0&quot; encoding=&quot;gb2312&quot;?&gt;&lt;!DOCTYPE scenario SYSTEM &quot;sipp.dtd&quot;&gt;
&lt;scenario name=&quot;Catalog&quot;&gt;

&lt;send&gt;
    &lt;![CDATA[
        REGISTER sip:1234567890@192.169.1.201:7100 SIP/2.0
        Via: SIP/2.0/UDP 192.169.1.107:7100;branch=[call_number]
        Call-ID: [call_id]
        From: &lt;sip:23232323232004567890@192.169.1.107:7100&gt;;tag=[call_number]
        To: &lt;sip:23232323232004567890@192.169.1.107&gt;
        CSeq:65 REGISTER
        Contact: &lt;sip:23232323232004567890@[local_ip]:[local_port]&gt;
        OutUserInfo: DomainId=23232323232004567890u;UserName=1234567890;UserPri=10
        Max-Forwards: 70
        Expires: 3600
        User-Agent: hik
        RegMode: PLAT;Describe=hik-xxxx;Register;DevVer=Plat1.0
        Content-Length: 0
    ]]&gt;
&lt;/send&gt;

&lt;recv response=&quot;200&quot;&gt;
&lt;/recv&gt;

&lt;!--recv response=&quot;400&quot; next=&quot;message&quot;&gt;
&lt;/recv--&gt;

&lt;!--recv response=&quot;487&quot; next=&quot;message&quot;&gt;
&lt;/recv--&gt;

&lt;pause hide=&quot;true&quot; milliseconds=&quot;20000&quot;/&gt;
&lt;/scenario&gt;
]]&gt; </code></pre>
<h3 id="message-xml"><a href="#message-xml" class="headerlink" title="message.xml"></a>message.xml</h3><pre><code>&lt;![CDATA[
&lt;?xml version=&quot;1.0&quot; encoding=&quot;gb2312&quot;?&gt;&lt;!DOCTYPE scenario SYSTEM &quot;sipp.dtd&quot;&gt;
&lt;scenario name=&quot;Catalog&quot;&gt;

&lt;!--recv request=&quot;REGISTER&quot; optional=&quot;true&quot; next=&quot;message&quot;&gt;
&lt;/recv--&gt;

&lt;label id=&quot;message&quot;/&gt;
&lt;recv request=&quot;MESSAGE&quot;&gt;
    &lt;action&gt;
        &lt;ereg regexp=&quot;&lt;CmdType&gt;([[:alnum:]]*)&lt;/CmdType&gt;&quot; 
            search_in=&quot;body&quot; 
            check_it=&quot;false&quot; 
            assign_to=&quot;1,2&quot;
            /&gt;
        &lt;strcmp assign_to=&quot;flag&quot; variable=&quot;2&quot; value=&quot;Catalog&quot; /&gt;
        &lt;test assign_to=&quot;result&quot; variable=&quot;flag&quot; compare=&quot;not_equal&quot; value=&quot;0&quot; /&gt;

        &lt;ereg regexp=&quot;&lt;SN&gt;([[:alnum:]]*)&lt;/SN&gt;&quot;
            search_in=&quot;body&quot;
            check_it=&quot;false&quot;
            assign_to=&quot;3,4&quot;
        /&gt;

        &lt;ereg regexp=&quot;CSeq: ([[:alnum:]]*)&quot;
            search_in=&quot;msg&quot;
            check_it=&quot;false&quot;
            assign_to=&quot;5,6,7&quot;
        /&gt;

        &lt;todouble assign_to=&quot;8&quot; variable=&quot;6&quot; /&gt;
        &lt;add assign_to=&quot;8&quot; value=&quot;1&quot; /&gt;
        &lt;assignstr assign_to=&quot;9&quot; value=&quot;[$8]&quot; /&gt;

        &lt;ereg regexp=&quot;([[:alnum:]]*).0000&quot; 
            variable=&quot;9&quot;
            search_in=&quot;var&quot; 
            check_it=&quot;false&quot; 
            assign_to=&quot;tmp,cseq&quot;
            /&gt;

        &lt;exec command=&quot;echo \&quot;arg2:[$2]\n arg4:[$4]\n arg6:[$6]\n [$8]\n arg9:[$9] \ncseq:[$cseq]\&quot; &gt;log.log &quot;/&gt;


    &lt;/action&gt;
&lt;/recv&gt;
&lt;Reference variables=&quot;1,2,3,4,5,6,7,8,9,flag,result,tmp,cseq&quot; /&gt;

&lt;!--nop hide=&quot;true&quot; next=&quot;message&quot; test=&quot;result&quot; /--&gt;
&lt;pause hide=&quot;true&quot; milliseconds=&quot;20&quot;/&gt;    
&lt;send&gt;
    &lt;![CDATA[

        SIP/2.0 200 OK
        [last_Via:] 
        [last_Call-ID:] 
        [last_From:]
        [last_To:]
        [last_CSeq:]
        Contact: &lt;sip:23232323232004567890@[local_ip]:[local_port]&gt;
        User-Agent: hik
        Content-Length: 0

    ]]&gt;  
&lt;/send&gt;

&lt;pause hide=&quot;true&quot; milliseconds=&quot;20&quot;/&gt;    
&lt;send&gt;
&lt;![CDATA[

    MESSAGE sip:1234567890@192.169.1.201:7100 SIP/2.0
    Via: SIP/2.0/UDP 192.169.1.107:7100;branch=[call_number]
    Call-ID: [call_id]@192.169.1.107
    From: &lt;sip:23232323232004567890@192.169.1.107:7100;transport=udp&gt;;tag=[call_number]
    To: &lt;sip:1234567890@192.169.1.201;transport=udp&gt;
    CSeq: [$cseq] MESSAGE
    Max-Forwards: 70
    Expires: 90
    User-Agent: hik
    Contact: &lt;sip:23232323232004567890@192.169.1.107:7100&gt;
    Content-Length: [len]
    Content-Type: application/MANSCDP+xml

    &lt;?xml version=&quot;1.0&quot; encoding=&quot;GB2312&quot;?&gt;

    &lt;Response&gt;
    &lt;CmdType&gt;Catalog&lt;/CmdType&gt;
    &lt;SN&gt;[$4]&lt;/SN&gt;
    &lt;DeviceID&gt;23232323232004567890&lt;/DeviceID&gt;
    &lt;SumNum&gt;1&lt;/SumNum&gt;
    &lt;DeviceList Num=&quot;1&quot;&gt;
    &lt;Item&gt;
    &lt;DeviceID&gt;61000000001310001000&lt;/DeviceID&gt;
    &lt;Name&gt;22&lt;/Name&gt;
    &lt;Manufacturer&gt;hik&lt;/Manufacturer&gt;
    &lt;Model&gt;hik&lt;/Model&gt;
    &lt;Owner&gt;hik&lt;/Owner&gt;
    &lt;CivilCode&gt;3402&lt;/CivilCode&gt;
    &lt;Block&gt;[$6]&lt;/Block&gt;
    &lt;Address&gt;192.169.1.107&lt;/Address&gt;
    &lt;Parental&gt;0&lt;/Parental&gt;
    &lt;ParentID&gt;23232323232004567890/34020000002150000001&lt;/ParentID&gt;
    &lt;IPAddress&gt;&lt;/IPAddress&gt;
    &lt;Port&gt;7777&lt;/Port&gt;
    &lt;Password&gt;admin&lt;/Password&gt;
    &lt;Status&gt;OFF&lt;/Status&gt;
    &lt;Longitude&gt;&lt;/Longitude&gt;
    &lt;Latitude&gt;&lt;/Latitude&gt;
    &lt;Info&gt;
    &lt;CameraType&gt;3&lt;/CameraType&gt;
    &lt;PTZType&gt;3&lt;/PTZType&gt;
    &lt;BusinessGroupID&gt;34020000002150000001&lt;/BusinessGroupID&gt;
    &lt;/Info&gt;
    &lt;/Item&gt;
    &lt;/DeviceList&gt;
    &lt;/Response&gt;

]]&gt; 
&lt;/send&gt; 

&lt;/scenario&gt;
]]&gt; </code></pre>
<h2 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h2><p>sipp不同于简单的tcp/udp发送工具,sipp可以自动填充计算一些sipp头域的值，支持正则表达式,是会话相关的,有错误日志记录.总之功能很强大,目前我用到的场景还比较局限,常用于模拟复现一些问题,对于解决问题帮助很大.关于sipp的使用其实就是前面提到的中文文档,熟读文档，应有尽有.</p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2019/07/30/5d3fd9ce642d675870.jpg"></p>
]]></content>
      <tags>
        <tag>sip</tag>
      </tags>
  </entry>
  <entry>
    <title>TheRiver的由来</title>
    <url>/2019-07-30-TheRiver%E7%9A%84%E7%94%B1%E6%9D%A5/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从初中开始,因为一款回合制游戏其中的一段渊源,我从那个时候就一直用的这个网名:<code>江上摆渡翁</code> <br><br>几乎后来所有我玩的游戏,还有网站，社交平台,需要ID的我都会沿用这个名称. <br><br>后来,我打算换个简洁的英文的网名,结合了river这个人物和TheShy的名字,又保留了我原先的江上这个词的意境,最终定为:<code>TheRiver</code></p>
<a id="more"></a>

<h2 id="Who-is-river"><a href="#Who-is-river" class="headerlink" title="Who is river"></a>Who is river</h2><p>原文：<a href="https://moment.douban.com/post/124804/?douban_rec=1">上帝宠爱的人都会在年轻时死去</a><br>这里把上面链接的文章复制过来,作者:李荷西  非常喜欢的一篇文章</p>
<p>前几天刷了个电影，斯蒂芬.金的小说《尸体》改编的《伴我同行》（stand by me）。</p>
<p>按罗伯特.麦基在《故事》这本书里的划分，这应该是属于小情节电影里的教育情节电影。</p>
<p>电影故事简介：</p>
<p>这是一部关于成长的电影。著名作家戈迪（理查德•德莱福斯 Richard Dreyfuss 饰）回忆起他12岁时的一次冒险活动：当时，年少的戈迪（威尔•惠顿 Wil Wheaton 饰）与他的三个小伙伴克里斯（瑞凡•菲尼克斯 River Phoenix 饰）、泰迪（科里•费尔德曼 Corey Feldman 饰）和维恩为了当一回“英雄”去河的对岸的森林里寻找一具12岁男孩的尸体。</p>
<p>4个少年家庭各有问题，他们都有自己的心事。在旅程中每个人的性格都被体现得淋漓尽致：四个男孩性格中的软弱和坚强，在闪火车，翻铁门，越森林等一系列的行动中被最大限度的放大；每个人都有自己可望而不可及的梦想……</p>
<p>1987年金球奖最佳电影、最佳导演提名，1987年奥斯卡奖最佳编剧提名。</p>
<p>整体来说，这个电影并无大冲突，是一个作家对于自己12岁那年的一段回忆的讲述。电影表面上是在讲一段少年的冒险以及友情，实际上是在说家庭。每一个12岁的少年，都身穿着家庭所给予的枷锁。</p>
<p>世界上没有完美的父母，没有完美的Family。每个人都在试图挣脱着家的牢笼。12岁的男孩最强烈。</p>
<p>4个小男孩儿，一个承受着父母只偏爱哥哥的冷暴力，一个爸爸酗酒哥哥坐牢，一个的爸爸是曾经登陆过诺曼底的精神病患者，另一个是笨笨的不那么敏感的胖子。</p>
<p>River Phoenix在里面饰演男主作家最好的朋友Chris。</p>
<p>他在电影里长这样：<br><img src="https://i.loli.net/2019/07/30/5d4063666f34635191.jpg"></p>
<p>这部影片给他赢来了会演又长得很帅的声誉。之后的《不设通缉令》更为他赢得了奥斯卡最佳男配的提名。《不羁的天空》又名《我自己的爱荷达》让他坐上了威尼斯电影节影帝的位置。</p>
<p>比起15岁出演《伴我同行》时，这个少年清俊了许多。<br><img src="https://i.loli.net/2019/07/30/5d406366b3f6a60215.jpg"></p>
<p>他是一个特别的孩子。从名字上就可以看出来。</p>
<p>1970年，8月23日，母亲在公路上难产三天后生下他，来到世间便仿佛奇迹。凤凰城，河流，嬉皮士父母给了他这个名字。却恰恰切合了漂流一生在雨季归去的宿命。父母以赫尔曼·黑塞（Hermann Hesse）的小说《席特哈尔塔》中的“生命的河流”为第一个孩子取名River，即河流，中间名裘德（Jude）则取自甲壳虫乐队的著名歌曲《Hey Jude》。</p>
<p>－－－引自豆瓣和百度百科</p>
<p>18岁出演《夺宝奇兵3》，21岁和基努里维斯合作出演《我自己的爱荷达》，成为基努里维斯的密友，在圈内与约翰尼德普交好。曾经有人说，如果River还活着，那么他绝对就可以和约翰尼德普平分“最性感男人”之称。而当时寂寂无名的莱昂纳多迪卡普里奥，把他视为偶像。<br><img src="https://i.loli.net/2019/07/30/5d406366b42d326330.jpg"></p>
<p>River，1993年在准备参加约翰尼德普的万圣节派对前去世，死因是吸毒过量。他体内海洛因与古柯碱的含量是致死量的八倍。</p>
<p>看到这里，可能很多人会说，这是一个被上帝宠坏了的孩子。年纪轻轻便坐拥巨大名利，在好莱坞的镁光灯下，他迷失了，变坏了。</p>
<p>事实并非如此。16岁之后，River便负担父母和4个兄妹的全部家用。他给予很多人人道主义帮助，还是环境保护者，买了800英亩的濒危雨林。并且，他终身素食。</p>
<p>他16岁那年交了个女朋友，他非常喜欢她。共进晚餐时，女朋友点了一盘软壳蟹。他无法忍受地跑出了餐厅。她找到他时，他正在哭：“我这么爱你，为什么？”</p>
<p>他理解不了人们吃任何生命体，哪怕是最喜欢的女朋友也不行。</p>
<p>同时，他还写歌，有自己的乐队，是词曲作者和主音吉他。</p>
<p>这样一个光芒万丈、有才华、内心温柔的人，为什么会吸毒？那么大的剂量，根本就是自杀！</p>
<p>世人都被他忧伤淡淡的表情和独特脆弱的气质所吸引，而这些也许并不是他所刻意营造的“popular”外在，也许是埋在骨子里，与生具来的。</p>
<p>他的眉间总是锁紧。他从未演过阳光热情或者凶悍的角色。</p>
<p>生前接到的最后两个片约一部是《夜访吸血鬼》，一部是《黑血》。当时他准备拍完这两部电影就退出娱乐圈。《夜访吸血鬼》因为他的离世无法参演，但电影出来后，最后出现的字幕上，可以看到这样的文字:”仅以此献给瑞凡·菲尼克斯 (River Phoenix)”.</p>
<p>而《黑血》这部影片，在他去世时，只差11天就杀青。直到2012年才面世。<br><img src="https://i.loli.net/2019/07/30/5d406366b491f51905.jpg"></p>
<p>有网友评论这张《黑血》的剧照说：</p>
<p>从很小开始，眉心就一直紧皱，从未舒展。。。心疼啊~来过这么快的一下子…</p>
<p>可是，到底是什么让这样一个孩子从小就不开心呢？他明明拥有了所有人都羡慕的一切。</p>
<p>然后我找到了这样的一段记录：</p>
<p>当菲尼克斯还在蹒跚学步的时候，他的父母约翰和艾琳就加入了一个名为“上帝之子”（the Children of God）的邪教组织。他们起初在南部一带过着居无定所的生活，最终选择了“上帝之子”的公社所在地、委内瑞拉的加拉加斯生活。该邪教教徒把孩子们送到街头唱歌卖艺，如果不这么做，孩子们就得挨饿。</p>
<p>更有甚者，“上帝之子”被认为是一个和性有关的邪教组织。儿童被鼓励彼此之间、并和成年人发生性关系。他们的宗教仪式包括祈祷，随后彼此间发生性关系以实现“性的探索”，参与该“仪式”的甚至包括年仅三岁的儿童。在接受《Details》杂志专访时，菲尼克斯坦承自己第一次与人发生性关系是在他四岁的时候，对方也是一个孩子。“但是后来我杜绝了这一行为。10至14岁之间我是完全禁欲的。”直到菲尼克斯7岁的时候，父母才脱离了这一邪教组织，原因是上级指令女教徒必须通过色诱招募更多的男教徒，这令菲尼克斯的母亲有所犹豫。直到这时她才发出抗议：“组织的领导者疯了。他想要通过性去吸引富有的门徒。没门！”</p>
<p>尽管脱离邪教，但往后菲尼克斯家庭的行为依然让人觉得颇为怪异。比如菲尼克斯15岁那年，是在自家后院由父母特意为之搭建并装饰得漂漂亮亮的帐篷里再度与他人发生性关系的！据与菲尼克斯合作《伴我同行》的男演员科里·费尔德曼透露，在菲尼克斯看来，那相当于夺走自己的“第二次童贞”。对方是家族的朋友，那次充满仪式感的性行为是双方父母的共同安排。</p>
<p>这段记录来自于River Phoenix的传记。</p>
<p>如果真如传记所说，那么River算是有着极深且不堪的童年阴影。他一生都在努力走出这种阴影。从小被送去学表演，拍广告，成为童星，接拍电影，最终深陷好莱坞的漩涡中心。每一步似乎都身不由己。什么才是他真正想做的呢？大概只有音乐。</p>
<p>什么是他真正想拥有的呢？大概是一个健康美满又平凡的家庭。</p>
<p>他曾经这样形容在世人眼中无限荣光的好莱坞：肮脏、恶心。</p>
<p>如果用那句著名的“眼睛是心理的投射”来解释的话，River也许从来不够自信。</p>
<p>也许对他来说，活着太过绵长。就算功成名就也无法自救。英年早逝，让太多人都记得他最漂亮时候的样子。<br><img src="https://i.loli.net/2019/07/30/5d406366b58e386367.jpg"></p>
<p>西方有一句谚语：”上帝爱的人都会在很年轻的时候就死去，这是上帝爱之子才具有的权利.”</p>
<p>也许死亡，是上帝赋予他的又一个权力。他用死亡和自己也和这个荒诞的世界和解了。</p>
]]></content>
      <tags>
        <tag>River</tag>
      </tags>
  </entry>
  <entry>
    <title>题库</title>
    <url>/2019-07-30-%E9%A2%98%E5%BA%93/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一些零碎的面试知识点，先放这里</p>
<a id="more"></a>

<h2 id="基本知识回顾"><a href="#基本知识回顾" class="headerlink" title="基本知识回顾"></a>基本知识回顾</h2><p>已知strcpy函数的原型是：</p>
<pre><code>char * strcpy(char * strDest,const char * strSrc); </code></pre>
<p>1.不调用库函数，实现strcpy函数。</p>
<p>2.解释为什么要返回char *。</p>
<p>错误示例:</p>
<pre><code>char * strcpy(char * strDest,const char * strSrc)
&#123;
    if（NULL == strDest）
    &#123;
        return NULL:
    &#125;

    if (NULL == strSrc)
    &#123;
        return strDest;
    &#125;

    if (NULL != strSrc)
    &#123;
        strDest++ = strSrc++;
    &#125;

    *strDest = &#39;\0&#39;;

&#125;</code></pre>
<p>参考答案:</p>
<pre><code>char * strcpy(char * strDest,const char * strSrc)  
&#123;  
    if ((strDest==NULL)||(strSrc==NULL)) //[1]  
        throw &quot;Invalid argument(s)&quot;; //[2]  
    char * strDestCopy=strDest; //[3]  
    while ((*strDest++=*strSrc++)!=&#39;\0&#39;); //[4]  
    return strDestCopy;  
&#125; </code></pre>
<p>注意点:</p>
<p>1：检查指针的有效性，注意隐式的类型转换，用NULL来检查比较合理</p>
<p>2：异常的处理,不管是源还是目的指针,为空都抛出异常。或者return NULL</p>
<pre><code>打印异常:terminate called after throwing an instance of &#39;char const*&#39;</code></pre>
<p>3：函数返回值,保存目的字符串的起始位置返回,不是源字符串,这样可以使函数支持链式表达式</p>
<p>链式表达式:</p>
<pre><code>int iLength=strlen(strcpy(strA,strB)); 

char * strA=strcpy(new char[10],strB); </code></pre>
<p>4：最简洁的语句</p>
<pre><code>while (*strDest++=*strSrc++);</code></pre>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a><a href="https://yq.aliyun.com/articles/8360">链接</a></h2><p>1.<code>求下面函数的返回值</code></p>
<pre><code>int countx = 0;  
while(x)  
&#123;  
    countx ++;  
    x = x&amp;(x-1);  
&#125;  
return countx;  </code></pre>
<p>参考答案:</p>
<pre><code>while循环每次把2进制的右边的1消除,返回值是循环的次数,循环的次数是x的二进制位中包含1的个数</code></pre>
<p>2.<code>什么是“引用”?声明和使用“引用”要注意哪些问题?</code></p>
<p>参考答案:</p>
<pre><code>引用就是某个目标变量的“别名”，对引用的操作与对变量直接操作效果完全相同
声明一个引用的时候，切记要对其进行初始化
它本身不是一种数据类型，因此引用本身不占存储单元</code></pre>
<p>网上有的地方说数组不能引用,其实是可以的,参考: <a href="https://blog.csdn.net/kbccs/article/details/80114971">关于数组的引用和引用的数组</a></p>
<pre><code>//数组的引用
int a[10] =&#123;0&#125;;
int (&amp;b)[10] = a;</code></pre>
<p>网上有的地方说引用一经定义,就不可更改,但是我用vs2017是可以的:</p>
<pre><code>int a = 1;
int c = 2;
int &amp; b = a;
b = c;</code></pre>
<p>3.<code>将“引用”作为函数参数有哪些特点?</code></p>
<pre><code>类似指针,不同于传值调用会自动创建临时变量副本,提高效率
不同于指针,传入指针,函数也会申请临时的指针变量存放实际变量的地址,而引用不会.且引用的可读性更好</code></pre>
<p>4.<code>在什么时候需要使用“常引用”?</code></p>
<pre><code>如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。常引用声明方式：const 类型标识符 &amp;引用名=目标变量名;

//有点像是常量指针
int a ;  
const int &amp;ra=a;  
ra=1; //错误  
a=1; //正确 

int main()
&#123;
    string  foo();
    void bar(string &amp; s);

    bar(foo()); //错误,非常量引用的初始值必须是左值 无法从const string 转换为 string &amp; 
    bar(&quot;hello world&quot;); //错误,利用拷贝构造函数会生成const string,但无法转为string &amp;
    //改成bar(const string &amp; s)就好了 
&#125;</code></pre>
<p><a href="https://blog.csdn.net/zxc024000/article/details/56016066">非常量引用的初始值必须是左值</a> <br></p>
<p>5.<code>“引用”与指针的区别是什么?</code></p>
<p>6.<code>线程与进程的区别</code></p>
<pre><code>进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同
线程是共享了进程的上下文环境，的更为细小的CPU时间段</code></pre>
<p><a href="https://www.zhihu.com/question/25532384">线程和进程的区别是什么？</a></p>
]]></content>
      <tags>
        <tag>work</tag>
      </tags>
  </entry>
  <entry>
    <title>排序</title>
    <url>/2019-08-04-%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>参考: </p>
<p><a href="https://blog.csdn.net/MoreWindows/article/details/7961256">白话经典算法系列之八 MoreWindows白话经典算法之七大排序总结篇</a> <br><br><code>&lt;编程珠玑&gt;</code> <br><br><code>&lt;C程序设计语言&gt;</code></p>
<a id="more"></a>

<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><blockquote>
<p>冒泡排序（英语：Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
</blockquote>
<pre><code>#include &quot;pch.h&quot;
#include &lt;iostream&gt;
using namespace std;

void BubbleSort(int a[], int n)
&#123;
    int i, j;
    i = j = 0;
    for (i = 0; i &lt; n; i++)
    &#123;
        for (j = 1; j &lt; n - i; j++)
        &#123;
            if (a[j] &lt; a[j - 1]) //升序
                swap(a[j], a[j - 1]);
        &#125;
    &#125;
&#125;

void BubbleSort2(int a[], int n)
&#123;
    int i,j,f,k;
    i = j = f = k = 0;

    f = n;
    while(f &gt; 0)
    &#123;
        k = f;
        f = 0;
        for (j = 1; j &lt; k; j++)
        &#123;
            if (a[j] &lt; a[j - 1]) //升序
            &#123;
                swap(a[j], a[j - 1]);
                f = j;
            &#125;
        &#125;

    &#125;
&#125;

int main()
&#123;
    int a[] = &#123;4,5,1,2,9,45,4225,11,452,4,254,14,1,454,555,4,26&#125;;
    int n = sizeof(a) / sizeof(int);

    cout &lt;&lt; &quot;Old: &quot; &lt;&lt; endl;
    for (int i = 0; i &lt; n; i++)
        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;
    cout &lt;&lt; endl;

    BubbleSort2(a, n);

    cout &lt;&lt; &quot;New: &quot; &lt;&lt; endl;
    for (int i = 0; i &lt; n; i++)
        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;
    cout &lt;&lt; endl;

&#125;</code></pre>
<p>结果:</p>
<pre><code>Old:
4 5 1 2 9 45 4225 11 452 4 254 14 1 454 555 4 26
New:
1 1 2 4 4 4 5 9 11 14 26 45 254 452 454 555 4225</code></pre>
<p>总结:</p>
<pre><code>冒泡排序比较基本,效率很差,很少有人用.纯是初学者拿来玩.

BubbleSort:
for(记录冒泡最顶端的数n-i)
    for(两两交换,将一趟中最大的数移动到顶端n-i)

BubbleSort2:
while(flag记录当前冒泡顶端的位置,以及判断本趟有没有有效移动,可以提前结束)
    for(一趟比较和移动,终点是上次移动的顶端k/f,跳过右边本来有序的情况)</code></pre>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>大多数纸牌游戏都采用插入排序来让玩家手上的牌有序,当拿到一张新牌时,将其插入到合适的位置</p>
<pre><code>#include &quot;pch.h&quot;
#include &lt;iostream&gt;
using namespace std;

void InsertSort(int a[], int n)
&#123;
    int i, j, t;
    i = j = t = 0;
    for (i = 1; i &lt; n; i++)
    &#123;
        t = a[i];
        for (j = i - 1; j &gt;=0 &amp;&amp; a[j] &gt; t; j-- ) //升序
        &#123;
            a[j + 1] = a[j];
        &#125;
        a[j + 1] = t;
    &#125;
&#125;

void InsertSort2(int a[], int n)
&#123;
    int i = 0;
    int j = 0;

    for (i = 1; i &lt; n; i++)
    &#123;
        for (j = i - 1; j &gt;= 0 &amp;&amp; a[j] &gt; a[j + 1]; j--) //升序
        &#123;
            swap(a[j], a[j + 1]);
        &#125;
    &#125;
&#125;

int main()
&#123;
    int a[] = &#123;4,5,1,2,9,45,4225,11,452,4,254,14,1,454,555,4,26&#125;;
    int n = sizeof(a) / sizeof(int);

    cout &lt;&lt; &quot;Old: &quot; &lt;&lt; endl;
    for (int i = 0; i &lt; n; i++)
        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;
    cout &lt;&lt; endl;

    InsertSort2(a, n);

    cout &lt;&lt; &quot;New: &quot; &lt;&lt; endl;
    for (int i = 0; i &lt; n; i++)
        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;
    cout &lt;&lt; endl;

&#125;</code></pre>
<p>结果:</p>
<pre><code>Old:
4 5 1 2 9 45 4225 11 452 4 254 14 1 454 555 4 26
New:
1 1 2 4 4 4 5 9 11 14 26 45 254 452 454 555 4225

Process returned 0 (0x0)   execution time : 0.024 s
Press any key to continue.</code></pre>
<p>总结：</p>
<pre><code>左边是一个有序数组,从a[0]开始到a[n - 1]
for(将a[1...n-1]插入a[0])
    for(插入a[i]需要进行的交换(挪位)操作)

InsertSort:将左边的依次右移,最后把a[i]放到合适的位置
InsertSort2:从右边开始,把乱序的左右两个数交换,直到整体有序.有点像是冒泡排序其中的一点思路.</code></pre>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>直接选择排序和直接插入排序很相似: <br><br>直接选择排序是把无序区的最小值挪到有序区的最右边(升序)，无序区从j=1开始,有序区初始是a[0] <br><br>直接插入排序是把无序区的第一个值挪到有序区的合适位置,无序区从j=1开始,有序区初始是a[0] <br></p>
<pre><code>#include &quot;pch.h&quot;
#include &lt;iostream&gt;
using namespace std;

void SelectSort(int a[], int n)
&#123;
    int i, j, nMinIndex;
    i = j = nMinIndex = 0;

    for (i = 0; i &lt; n; i++)
    &#123;
        nMinIndex = i;
        for (j = i+1; j &lt; n; j++)
        &#123;
            if (a[j] &lt; a[nMinIndex]) //升序
                nMinIndex = j;
        &#125;
        swap(a[i], a[nMinIndex]);
    &#125;
&#125;

int main()
&#123;
    int a[] = &#123;4,5,1,2,9,45,4225,11,452,4,254,14,1,454,555,4,26&#125;;
    int n = sizeof(a) / sizeof(int);

    cout &lt;&lt; &quot;Old: &quot; &lt;&lt; endl;
    for (int i = 0; i &lt; n; i++)
        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;
    cout &lt;&lt; endl;

    SelectSort(a, n);

    cout &lt;&lt; &quot;New: &quot; &lt;&lt; endl;
    for (int i = 0; i &lt; n; i++)
        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;
    cout &lt;&lt; endl;

&#125;</code></pre>
<p>结果:</p>
<pre><code>Old:
4 5 1 2 9 45 4225 11 452 4 254 14 1 454 555 4 26
New:
1 1 2 4 4 4 5 9 11 14 26 45 254 452 454 555 4225</code></pre>
<h2 id="shell-希尔-排序"><a href="#shell-希尔-排序" class="headerlink" title="shell(希尔)排序"></a>shell(希尔)排序</h2><p>wikipedia: <br><br>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。 <br><br>希尔排序是基于插入排序的以下两点性质而提出改进方法的： <br><br>1 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率 <br><br>2 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位    </p>
<pre><code>#include &quot;pch.h&quot;
#include &lt;iostream&gt;
using namespace std;

void ShellSort(int a[], int n)
&#123;
    int i, j, gap;
    i = j = gap = 0;
    int t = 0; 

    for (gap = n / 2; gap &gt; 0; gap /= 2)
    &#123;
        for (i = gap; i &lt; n; i++)
        &#123;
            for (j = i - gap; j &gt;= 0 &amp;&amp; a[j] &gt; a[j + gap]; j -= gap)
            &#123;
                swap(a[j], a[j + gap]);
            &#125;
        &#125;
    &#125;
&#125;

void ShellSort2(int a[], int n)
&#123;
    int i, j, gap, t;
    i = j = gap = t = 0;

    for (gap = n / 2; gap &gt; 0; gap /= 2)
    &#123;
        for (i = gap; i &lt; n; i++)
        &#123;
            t = a[i];
            for (j = i - gap; j &gt;= 0 &amp;&amp; a[j] &gt; t; j -= gap)
            &#123;
                a[j + gap] = a[j];
            &#125;
            a[j + gap] = t;
        &#125;
    &#125;
&#125;

int main()
&#123;
    int a[] = &#123;4,5,1,2,9,45,4225,11,452,4,254,14,1,454,555,4,26&#125;;
    int n = sizeof(a) / sizeof(int);

    cout &lt;&lt; &quot;Old: &quot; &lt;&lt; endl;
    for (int i = 0; i &lt; n; i++)
        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;
    cout &lt;&lt; endl;

    ShellSort2(a, n);

    cout &lt;&lt; &quot;New: &quot; &lt;&lt; endl;
    for (int i = 0; i &lt; n; i++)
        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;
    cout &lt;&lt; endl;

&#125;</code></pre>
<p>总结:<br>理解插入排序是理解希尔排序的关键.gap = 1的时候就是完全的插入排序,gap != 1的时候,是为了让总体有序,提高插入排序的效率.因为插入排序在总体有序的情况下,效率比较高.步长(gap)一般是取一半,这并不是最优的方案.暂不深入研究.</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为较小和较大的2个子序列，然后递归地排序两个子序列</p>
<pre><code>#include &quot;pch.h&quot;
#include &lt;iostream&gt;
using namespace std;

void QuickSort(int a[], int left, int right)
&#123;
    int i, middle;
    i = middle = 0;

    if (left &gt;= right)
        return;

    middle = left;
    for (i = left + 1; i &lt;= right; i++)
    &#123;
        if (a[i] &lt; a[left])
        &#123;
            swap(a[++middle], a[i]);
        &#125;
    &#125;

    swap(a[left], a[middle]);
    QuickSort(a, left, middle - 1);
    QuickSort(a, middle + 1, right);

&#125;

int main()
&#123;
    int a[] = &#123;4,5,1,2,9,45,4225,11,452,4,254,14,1,454,555,4,26&#125;;
    int n = sizeof(a) / sizeof(int);

    cout &lt;&lt; &quot;Old: &quot; &lt;&lt; endl;
    for (int i = 0; i &lt; n; i++)
        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;
    cout &lt;&lt; endl;

    QuickSort(a, 0, n - 1);

    cout &lt;&lt; &quot;New: &quot; &lt;&lt; endl;
    for (int i = 0; i &lt; n; i++)
        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;
    cout &lt;&lt; endl;

&#125;</code></pre>
<p>总结:</p>
<p>快排有很多的版本,网上很多人实现的代码比较复杂,不利于理解.效率也不好说,更重要的是很难论证是否正确,快排使用递归函数,有的时候很难简单的判断是否有误.上面记录的实现方式,是在两本书中都出现过的,一种简单的快速排序.就记住这一种吧. <br><br>理解这个的难点是middle的变化.</p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2019/08/04/NefDXsGnVPaydWY.jpg" alt="4_2.jpg"></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>人间值得</title>
    <url>/2019-10-09-%E4%BA%BA%E9%97%B4%E5%80%BC%E5%BE%97/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>博客停了2个月了,中间尝试了一些其他的东西,工作这段时间也很忙,耽搁了.今天翻阅邮箱的时候,又回首了一些往日时光,更觉得人真是健忘的，以前的种种形成了现在的自己,现在的自己也在构成以后的那个人,而适当的思考下已经走过的路，遇过的,经历的,也能带来一些思考.重新审视,自己从一开始继承的,好的,错误的东西.以及可以从他人那里参考的.岁月流逝,我越发清晰的认识到人和人的不同,哪怕朝夕相处的两个人,可能看到的是两个完全不同的世界,但却在相同的空间下,彼此知/不知.生活中还是有很多可以重复熟悉的东西,我今天再看3年前上一家公司领导的一封邮件,发现其中部分文字是今天才能领悟，感同身受到的.真的自己走的路,不过是他人的重复罢了.多说无益,邮箱中找到了几张图片,是大概16年村子里有一家的老人去世了,儿子当时葬礼办的很热闹,很用心.之前多少经过好些次这家门前,对其有一些简单的认识,感觉为人忠厚,有种几十年如一日的感觉,稍微传统一些.图片是儿子给去世的母亲写的,我今天看了便也很有感触,贴一部分出来,也激励下我自己,不要荒废生活，人间还是值得的,也多回家看看,与朋友聚聚,偶尔思考下.</p>
<a id="more"></a>


<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2019/10/09/avqF2LzYKVl1jSe.jpg" alt="00_s.jpg"></p>
]]></content>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>lua-闭包</title>
    <url>/2019-10-13-lua-%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><code>programming in lua</code> </p>
<p><a href="https://www.codingnow.com/2000/download/The%20Implementation%20of%20Lua5.0.pdf">The Implementation of Lua5.0.pdf</a></p>
<a id="more"></a>

<h2 id="函数和闭包"><a href="#函数和闭包" class="headerlink" title="函数和闭包"></a>函数和闭包</h2><p>当 Lua 编译一个函数时，会生成一个原型。该原型包含有函数的虚拟机指令 、<br>常数值（数值、字符串等），以及一些调试信息。在运行期，任何时候只要 Lua<br><code>执行一个 function...end 表达式，它就会创建一个新的闭包</code>。每个闭包都有一个对<br>函数原型的引用、一个对环境的引用（环境其实是一个表，函数可在该表中索引<br>全局变量，后面细述），和一个数组，数组中每个元素都是一个对 upvalue 的引<br>用，可通过该数组来存取外层的局部变量。</p>
<h2 id="lua的函数"><a href="#lua的函数" class="headerlink" title="lua的函数"></a>lua的函数</h2><p>lua的函数是带有<code>词法界定</code>的<code>第一类值</code></p>
<blockquote>
<p>词法界定：被嵌套的函数可以访问它外部的局部变量</p>
</blockquote>
<p><code>LUA</code></p>
<pre><code>function newCounter()
local i = 0;
return function()
    i = i + 1;
    return i;
end
end

c1 = newCounter();
print(c1());
print(c1());</code></pre>
<p><code>C/C++</code></p>
<pre><code>int function()
&#123;
    i = i + 1;
    return i;
&#125;

int newCounter()
&#123;
    int i = 0;
    return function();
&#125;

int main()
&#123;
    cout &lt;&lt; newCounter() &lt;&lt; endl;
    return 0;
&#125;

error: &#39;i&#39; was not declared in this scope|</code></pre>
<blockquote>
<p>第一类值:在lua中函数和其他值(数值,字符串)一样,函数可以被存放在变量中，也可以存放在表中,可以作为函数的参数,还可以作为函数的返回值.</p>
</blockquote>
<h2 id="upvalue"><a href="#upvalue" class="headerlink" title="upvalue"></a>upvalue</h2><p>在内部函数变量i既不是全局变量,也不是局部变量,这种称为外部局部变量或者upvalue.</p>
<p><img src="https://i.loli.net/2019/10/13/q7Ntc2dyx1J4V3I.png" alt="upvalue.png"></p>
<p>Lua 用一种称为 upvalue 的结构来实现闭包。对任何外层局部变量的存取间<br>接地通过 upvalue 来进行。upvalue 最初指向栈中变量活跃的地方（图 4 左 边 ）。<br>当离开变量作用域时（超过变量生存期时），变量被复制到 upvalue 中（图 4 右<br>边）。由于对变量的存取是通过 upvalue 里的指针间接进行的，因此复制动作对<br>任何存取此变量的代码来说都是没有影响的。与内层函数不同的是，声明该局部<br>变量的函数直接在堆栈中存取它的局部变量。</p>
<p>通过为每个变量至少创建一个 upvalue 并按所需情况进行重复利用，保证了<br>未决状态（是否超过生存期）的局部变量（pending vars）能够在闭包间正确地<br>共享。为了保证这种唯一性，Lua 为整个运行栈保存了一个链接着所有正打开着<br>的 upvalue（那些当前正指向栈内局部变量的 upvalue）的链表（图 4 中未决状态<br>的局部变量的链表）。当 Lua 创建一个新的闭包时，它开始遍历所有的外层局部<br>变量，对于其中的每一个，若在上述 upvalue 链表中找到它，就重用此 upvalue，<br>否则，Lua 将创建一个新的 upvalue 并加入链表中。注意，一般情况下这种遍历<br>过程在探查了少数几个节点后就结束了，因为对于每个被内层函数用到的外层局<br>部变量来说，该链表至少包含一个与其对应的入口（upvalue）。一旦某个关闭的<br>upvalue 不再被任何闭包所引用，那么它的存储空间就立刻被回收。</p>
<p>一个函数有可能存取其更外层函数而非直接外层函数的局部变量。这种情况<br>下，有可能当闭包创建时，此局部变量尚不存在。Lua 使用 flat 闭包来处理这种<br>情况。有了 flat 闭包，无论何时只要函数存取更外层的局部变量，该变量也会进<br>入其直接外层函数的闭包中。这样，当一个函数被实例化时，所有进入其闭包的<br>变量就在直接外层函数的栈或闭包中了。</p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2019/10/13/zYpaoScur9h1Qlq.jpg" alt="road_small.jpg"></p>
]]></content>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>lua-迭代器</title>
    <url>/2019-10-14-lua-%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E8%8C%83%E6%80%A7for/</url>
    <content><![CDATA[<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><code>programming in lua</code> </p>
<p><a href="https://www.codingnow.com/2000/download/The%20Implementation%20of%20Lua5.0.pdf">The Implementation of Lua5.0.pdf</a></p>
<a id="more"></a>

<h2 id="范性for"><a href="#范性for" class="headerlink" title="范性for"></a>范性for</h2><p>范性for的文法:</p>
<pre><code>for &lt;var-list&gt; in &lt;exp-list&gt; do
    codeblock
end</code></pre>
<p>也即:</p>
<pre><code>for var_1, ..., var_n in explist do block end</code></pre>
<p>等价于:</p>
<pre><code>do
    local _f, _s, _var = explist
    while true do
        local var_1, ..., var_n = _f(_s, _var)
        _var = var_1
        if _var = nil then break end
        block
    end
end</code></pre>
<p>说明：</p>
<pre><code>_f:    迭代函数
_s:    状态常量
_var_n:    控制变量 </code></pre>
<h2 id="无状态的迭代器"><a href="#无状态的迭代器" class="headerlink" title="无状态的迭代器"></a>无状态的迭代器</h2><p>无状态的迭代器是指不保留任何状态的迭代器,因此在循环中我们可以利用无状态迭代器避免创建闭包花费额外的代价.<br>每一次迭代,迭代函数都是用两个变量(状态常量和控制变量)的值作为参数被调用,一个无状态的迭代器利用这两个值可以获取下一个元素.</p>
<p><code>input:</code></p>
<pre><code>function iter(a, i)
    i = i + 1
    if a[i] then
        return i,a[i]
    end
end

function mypairs(a)
    return iter, a, 0
end

a = &#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125;;
for k,v in mypairs(a) do
    print(k, v)
end</code></pre>
<p><code>output:</code></p>
<pre><code>1       one
2       two
3       three</code></pre>
<p>说明:</p>
<p>不同于闭包,迭代的”索引”不是通过upvalue来保存,而是利用范性for自身的_var = var_1来给迭代函数代入新的索引参数.需要注意的是,写无状态的迭代器的时候,函数要返回三个值,分别是迭代函数,状态常量,控制变量.参数个数不足的自动用nil替代,多了的自动抛弃.</p>
<p>闭包的函数定义是写在工厂函数内部的,无状态迭代器则是写在函数外面的.目前还不肯定是否这样就不会创建闭包.这里后续熟悉了再补充.</p>
<h2 id="多状态的迭代器"><a href="#多状态的迭代器" class="headerlink" title="多状态的迭代器"></a>多状态的迭代器</h2><p>无状态迭代器通过传入状态常量和控制变量给范性for循环来控制迭代,而有时需要更多的参数来控制.使用闭包可以完成,还可以通过table作为迭代器的状态常量，把所有需要的值放进table内来实现.</p>
<p><code>input:</code></p>
<pre><code>function iter(tab)
    i = tab.index
    if tab[i] then
        tab.index = i + 1
        return i,tab[i]
    end
end

function mypairs(tab)
    return iter, tab, nil
end

tab = &#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, index = 1&#125;;
for k,v in mypairs(tab) do
    print(k, v)
end</code></pre>
<p><code>output:</code></p>
<pre><code>1       one
2       two
3       three</code></pre>
<p>说明:<br>应该尽可能的使用无状态的迭代器,由for循环来保存状态.这样不需要创建对象花费的代价少<br>次之,可以用闭包<br>最后使用table这种多状态的迭代器,因为创建闭包的代价比table少,并且lua处理闭包的速度比table快.</p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2019/10/13/2N3ZuwmPa1qtdJD.jpg" alt="p2187011954.jpg"></p>
]]></content>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>lua-编译-运行-调试</title>
    <url>/2019-10-22-lua-%E7%BC%96%E8%AF%91-%E8%BF%90%E8%A1%8C-%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><code>programming in lua</code> <br><br><a href="https://www.kancloud.cn/digest/lua-programming/204455">编译、运行、错误处理</a> <br><br><a href="https://gist.github.com/britzl/9937367">britzl/traceback.lua</a> <br><br><a href="https://www.codingnow.com/2000/download/The%20Implementation%20of%20Lua5.0.pdf">The Implementation of Lua5.0.pdf</a></p>
<a id="more"></a>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Lua会预先把代码预编译成中间码然后再执行.在解释型语言中存在编译阶段听起来不太合适.然而,解释型语言的特征不在于是否被编译,而是编译时是否是运行时的一部分.执行编译产生的中间码速度会更快.<br>函数dofile的存在就是说明可以将lua作为解释型语言被调用。</p>
<p>difile其实是个辅助的函数,真正完成功能的是<code>loadfile</code>函数.</p>
<p><code>loadfile ([filename [, mode [, env]]])</code> <br></p>
<blockquote>
<p>Similar to load, but gets the chunk from file filename or from the standard input, if no file name is given.</p>
</blockquote>
<p>与dofile不同的是,loadfile编译代码成中间码并且返回编译后的chunk作为一个函数,而不执行代码.另外,loadfile不会抛出异常,而是返回错误代码.</p>
<p><code>int luaL_loadstring (lua_State *L, const char *s)    </code>            [-0, +1, –]</p>
<blockquote>
<p>Loads a string as a Lua chunk. This function uses lua_load to load the chunk in the zero-terminated string s.</p>
</blockquote>
<p>loadstring与loadfile类似,但它不是读取文件，而是读取串，but,现在这个函数不能用了.老的教程都没有提到这一点.<br><br>参考:<br><br>From <a href="http://www.lua.org/manual/5.2/manual.html#8.2">Lua 5.2 reference manual</a>:</p>
<pre><code>Function loadstring is deprecated. Use load instead; it now accepts string arguments and are exactly equivalent to loadstring.
//不推荐使用函数loadstring。使用load代替；它现在接受字符串参数，并且完全等同于loadstring。

&gt; i=3
&gt; loadstring(&quot;i=i+1&quot;)
stdin:1: attempt to call a nil value (global &#39;loadstring&#39;)
stack traceback:
        stdin:1: in main chunk
        [C]: in ?
&gt;
&gt; f = load(&quot;i = i + 1&quot;)
&gt; f()
&gt; print(i)
4
&gt; f()
&gt; print(i)
5</code></pre>
<p>lua把每一个chunk都当成一个匿名函数处理。例如, chunk “a = 1” 等价于: <br></p>
<pre><code>function
    a = 1
end</code></pre>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>1 load和loadfile都不会抛出错误,如果发生错误他们将返回nil加上错误信息</p>
<pre><code>print(load(&quot;1 + &quot;))
nil     [string &quot;1 + &quot;]:1: unexpected symbol near &#39;1&#39;</code></pre>
<p>2 load和loadfile都不会有边界效应,他们仅仅编译chunk成为他们内部实现的一个匿名函数.通常对他们的误解是他们定义了函数.lua中的函数定义是发生在运行时的赋值而不是发生在编译时.例如:</p>
<pre><code>--file foo.lua    
function foo(x)
    print(x)
end</code></pre>
<p>当我们执行命令f = loadfile(“foo.lua”)时，foo被编译了但还没有被定义.如果要定义,必须运行:</p>
<pre><code>f()        --defines &#39;foo&#39;</code></pre>
<p>3 load编译的时候不关心词法范围：</p>
<pre><code>//仔细看下面的代码,注意哪个是全局变量i,哪个是局部变量i
&gt; function test()
&gt;&gt; print(i)
&gt;&gt; local i = 0
&gt;&gt;
&gt;&gt; f = load(&quot;i = i + 1&quot;)
&gt;&gt; f()
&gt;&gt; print(i)
&gt;&gt;
&gt;&gt; function g()
&gt;&gt; i = i + 1
&gt;&gt; end
&gt;&gt;
&gt;&gt; g()
&gt;&gt; print(i)
&gt;&gt; end
&gt;
&gt; test()
8
0
1
&gt; test()
9
0
1</code></pre>
<p>4 load通常用于运行程序外部的代码,load期望一个chunk，即语句.如果想要加载<code>表达式</code>,需要在表达式前加return,那样将返回表达式的值.</p>
<blockquote>
<p>表达式，是由数字、算符、数字分组符号（括号）、自由变量和约束变量等以能求得数值的有意义排列方法所得的组合。约束变量在表达式中已被指定数值，而自由变量则可以在表达式之外另行指定数值。</p>
</blockquote>
<pre><code>//书上是local sql, 但前面提到的loadstring是用的全局变量,这里sql我就用了全局变量，不然会和实际有出入的

Lua 5.1.4  Copyright (C) 1994-2008 Lua.org, PUC-Rio

&gt; print&quot;enter you r expression:&quot;
enter your expression:
&gt; sql = io.read()
6
&gt; func = assert(loadstring(&quot;return &quot; .. sql))
&gt; print(&quot;the value of your expression is &quot; .. func())
the value of your expression is 6



Lua 5.3.5  Copyright (C) 1994-2018 Lua.org, PUC-Rio

&gt; print&quot;enter you r expression:&quot;
enter you r expression:
&gt; sql = io.read()
5
&gt; func = assert(load(&quot;return &quot; .. sql))
&gt; print(&quot;the value of your expression is &quot; .. func())
the value of your expression is 5</code></pre>
<h2 id="reuire函数"><a href="#reuire函数" class="headerlink" title="reuire函数"></a>reuire函数</h2><p>lua提供更高级的require函数来加载运行库。require和dofile有两点不同：<br>1    require会搜索目录加载文件<br>2    require会判断文件是否已经加载避免重复加载同一文件。</p>
<p>require使用的路径和普通我们看到的路径还有些区别,我们一般看到的路径都是一个目录列表.require的路径是一个模式列表,每一个模式指明一种由虚文件名(require的参数)转成实文件名的方法.匹配的时候lua会首先将问号用虚文件名替换,然后看是否有这样的文件存在.如果不存在继续用同样的方法用第二个模式匹配.</p>
<p>例如,路径如下: <br><br>    ?;?.lua;C:\windows?;/usr/local/lua/?/?.lua</p>
<p>调用 <code>require(&quot;lili&quot;)</code>时会尝试打开这些文件:</p>
<pre><code>lili
lili.lua
c:\windows\lili
/usr/local/lili/lili.lua</code></pre>
<p>require只关心分号和问号,其他的信息在路径中定义.</p>
<p>路径：<br>Lua将require搜索的模式字符串放在变量package.path中。当Lua启动后，便以环境变量<code>LUA_PATH</code>的值来初始化这个变量。如果没有找到该环境变量，则使用一个编译时定义的默认路径来初始化。如果require无法找到与模块名相符的Lua文件，就会找C程序库。C程序库的搜索模式存放在变量package.cpath中。而这个变量则是通过环境变量<code>LUA_CPATH</code>来初始化的。</p>
<pre><code>&gt; print(&quot;LUA MODULES:\n&quot;,(package.path:gsub(&quot;%;&quot;,&quot;\n\t&quot;)),&quot;\n\n C MODULES:\n&quot;,(package.cpath:gsub(&quot;%;&quot;,&quot;\n\t&quot;)))
LUA MODULES:
    ./?.lua
    /usr/share/lua/5.1/?.lua
    /usr/share/lua/5.1/?/init.lua
    /usr/lib64/lua/5.1/?.lua
    /usr/lib64/lua/5.1/?/init.lua    

 C MODULES:
    ./?.so
    /usr/lib64/lua/5.1/?.so
    /usr/lib64/lua/5.1/loadall.so</code></pre>
<p>一个路径中的模式也可以不包含问号而只是一个固定的路径,比如: <br><br>    ?;?.lua;/usr/local/default.lua</p>
<p>这种情况下,require没有匹配的时候就会用这个固定的文件(这个缺省的文件放在模式列表的最后才有意义)</p>
<h2 id="异常和错误处理"><a href="#异常和错误处理" class="headerlink" title="异常和错误处理"></a>异常和错误处理</h2><p>如果在lua中需要处理错误,需要调用pcall函数封装你的代码,从而捕捉异常和错误.<br><code>pcall</code>在保护模式下调用它的第一个参数并运行,因此可以捕获所有的异常和错误.<br>如果没有异常和错误,pcall返回true和调用返回的任何值:</p>
<pre><code>&gt; first,second = pcall( function() print(&quot;code blocks...&quot;) return &quot;success!&quot; end)
code blocks...
&gt; print(first, second)
true    success!</code></pre>
<p>否则,返回nil加错误信息:</p>
<pre><code>&gt; first,second = pcall( function() error(&#123;err1 = &quot;step one&quot;&#125;) end)
&gt; print(first, second)
false    table: 0xbd6690
&gt; print(second.err1)
step one</code></pre>
<p>错误信息不一定非要是字符串,传递给error的任何信息都会被pcall返回.<br>这种机制提供了我么在lua中处理异常和错误的全部内容。我们通过error抛出异常,然后通过pcall来捕获它.</p>
<h2 id="错误信息和回跟踪"><a href="#错误信息和回跟踪" class="headerlink" title="错误信息和回跟踪"></a>错误信息和回跟踪</h2><p><code>error函数</code> <br></p>
<p><code>debug.traceback()</code> <br></p>
<p>当pcall返回错误的时候它已经释放了保存错误发生情况的栈的信息，而我们想获取相关的堆栈信息就必须在pcall返回前获取,lua提供了xpcall来实现这个功能,xpcall接受2个参数,调用函数和错误处理函数.<br>可以手动调用debug或者debug.traceback来查看错误信息.</p>
<pre><code>&gt; function a()
&gt;&gt; print(&quot;a&quot; + 1)
&gt;&gt; end
&gt; 
&gt; function b()
&gt;&gt; a()
&gt;&gt; end
&gt; 
&gt; function c()
&gt;&gt; b()
&gt;&gt; end
&gt; 
&gt; function err()
&gt;&gt; print(&quot;deal err func:&quot;)
&gt;&gt; print(debug.traceback())
&gt;&gt; end
&gt; 
&gt; print(xpcall( c, err))
deal err func:
stack traceback:
    stdin:3: in function &lt;stdin:1&gt;
    stdin:2: in function &#39;a&#39;
    stdin:2: in function &#39;b&#39;
    stdin:2: in function &lt;stdin:1&gt;
    [C]: in function &#39;xpcall&#39;
    stdin:1: in main chunk
    [C]: ?
false    nil</code></pre>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2>]]></content>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>lua-协同程序</title>
    <url>/2019-11-05-lua-%E5%8D%8F%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><code>programming in lua</code> <br><br><a href="https://www.kancloud.cn/digest/lua-programming/204455">编译、运行、错误处理</a> <br><br><a href="https://gist.github.com/britzl/9937367">britzl/traceback.lua</a> <br><br><a href="https://www.codingnow.com/2000/download/The%20Implementation%20of%20Lua5.0.pdf">The Implementation of Lua5.0.pdf</a></p>
<a id="more"></a>

<h2 id="协同基础"><a href="#协同基础" class="headerlink" title="协同基础"></a>协同基础</h2><p>协同程序(coroutine)与多线程情况下的线程比价类似：有自己的堆栈,自己的局部变量,有自己的指令指针，和其他协调程序共享全局变量等信息.</p>
<p><code>线程和协同程序的区别:</code><br>在多处理器情况下,从概念上讲多线程程序同时运行多个和线程;而协同程序是通过协作来完成,在任一指定时刻只有一个协同程序在运行.并且这个正在运行的协同程序只有在明确的被要求挂起的时候才会被挂起.</p>
<p>简单的讲： <br><br>1 任一时刻只有一个协同程序在运行,这个后面总结并发和并行的时候再另行总结 <br><br>2 协同只能主动挂起,无法在外部终止 <br></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><code>coroutine.create (f)</code> <br></p>
<blockquote>
<p>Creates a new coroutine, with body f. f must be a function. Returns this new coroutine, an object with type “thread”.<br><br></p>
</blockquote>
<p>create函数创建一个新的协同程序,create只有一个参数；协同程序将要运行的代码封装而成的函数,返回值为thread类型的值表示创建了一个新的协同程序.</p>
<pre><code>Lua 5.3.5  Copyright (C) 1994-2018 Lua.org, PUC-Rio
&gt; co = coroutine.create(
&gt;&gt; function()
&gt;&gt; print(&quot;hello！&quot;);
&gt;&gt; end
&gt;&gt; )
&gt;
&gt; print(co);
thread: 0115e154</code></pre>
<p>协同程序有三个状态：挂起态，运行态，停止态。当我们创建一个协同程序时它开始的状态是挂起态,也就是说我们创建协同程序的时候不会自动运行,可以使用status函数检查协同的状态.</p>
<p><code>coroutine.status (co)</code> <br></p>
<blockquote>
<p>Returns the status of coroutine co, as a string: “running”, if the coroutine is running (that is, it called status); “suspended”, if the coroutine is suspended in a call to yield, or if it has not started running yet; “normal” if the coroutine is active but not running (that is, it has resumed another coroutine); and “dead” if the coroutine has finished its body function, or if it has stopped with an error.</p>
</blockquote>
<pre><code>&gt; print(coroutine.status(co))
suspended</code></pre>
<p><code>coroutine.resume (co [, val1, ···])</code> <br></p>
<blockquote>
<p>Starts or continues the execution of coroutine co. The first time you resume a coroutine, it starts running its body. The values val1, … are passed as the arguments to the body function. If the coroutine has yielded, resume restarts it; the values val1, … are passed as the results from the yield.</p>
</blockquote>
<blockquote>
<p>If the coroutine runs without any errors, resume returns true plus any values passed to yield (when the coroutine yields) or any values returned by the body function (when the coroutine terminates). If there is any error, resume returns false plus the error message.</p>
</blockquote>
<pre><code>&gt; coroutine.resume(co)
hello！
true
&gt; print(coroutine.status(co))
dead</code></pre>
<p><code>coroutine.yield (···)</code> <br></p>
<blockquote>
<p>Suspends the execution of the calling coroutine. Any arguments to yield are passed as extra results to resume.</p>
</blockquote>
<pre><code>&gt; co = coroutine.create(
&gt;&gt; function()
&gt;&gt; for i=1, 5 do
&gt;&gt; print(&quot;num = &quot; .. i);
&gt;&gt; coroutine.yield();
&gt;&gt; end
&gt;&gt; end
&gt;&gt; )
&gt;
&gt; print(coroutine.resume(co));
num = 1
true
&gt; print(coroutine.resume(co));
num = 2
true
&gt; print(coroutine.resume(co));
num = 3
true
&gt; print(coroutine.resume(co));
num = 4
true
&gt; print(coroutine.resume(co));
num = 5
true
&gt; print(coroutine.resume(co));
true
&gt; print(coroutine.resume(co));
false   cannot resume dead coroutine</code></pre>
<p><code>example 1</code> </p>
<p>The first time you resume a coroutine, it starts running its body. The values val1, … are passed as the arguments to the body function. <br></p>
<pre><code>&gt; co = coroutine.create(
&gt;&gt; function(a, b)
&gt;&gt; print(&quot;co&quot;,a,b);
&gt;&gt; end
&gt;&gt; )
&gt;
&gt; print(coroutine.resume(co, 1, 2));
co      1       2
true</code></pre>
<p><code>example 2</code> </p>
<p>If the coroutine has yielded, resume restarts it; the values val1, … are passed as the results from the yield.</p>
<pre><code>//yield不带其他参数
&gt; co = coroutine.create(
&gt;&gt; function()
&gt;&gt; print(&quot;co&quot;,coroutine.yield());
&gt;&gt; end
&gt;&gt; )
&gt;
&gt; print(coroutine.resume(co));
true
&gt; print(coroutine.resume(co, 1, 2));
co      1       2
true

//yield带参数
&gt; co = coroutine.create(
&gt;&gt; function()
&gt;&gt; print(&quot;co&quot;,coroutine.yield(a,b));
&gt;&gt; print(a,b);
&gt;&gt; end
&gt;&gt; )
&gt;
&gt; print(coroutine.resume(co));
true    nil     nil
&gt; print(coroutine.resume(co, 1, 2));
co      1       2
nil     nil
true

//一定要注意是yield的额外参数作为resume的返回值,resume的额外参数作为yield的返回值.这句话不好理解的.</code></pre>
<p><code>example 3</code> </p>
<p>当协同代码结束时,主函数返回的值都会传给相应的resume</p>
<pre><code>&gt; co = coroutine.create(
&gt;&gt; function()
&gt;&gt; print(&quot;co&quot;);
&gt;&gt; return 1,2,3,4,5;
&gt;&gt; end
&gt;&gt; )
&gt;
&gt; print(coroutine.resume(co));
co
true    1       2       3       4       5

//注意print的返回值顺序,这里和yield传值时候true的顺序不太一样.这一点还比较奇怪</code></pre>
<p><code>coroutine.running ()</code> <br></p>
<blockquote>
<p>Returns the running coroutine plus a boolean, true when the running coroutine is the main one.</p>
</blockquote>
<p><code>coroutine.wrap (f)</code> <br></p>
<blockquote>
<p>Creates a new coroutine, with body f. f must be a function. Returns a function that resumes the coroutine each time it is called. Any arguments passed to the function behave as the extra arguments to resume. Returns the same values returned by resume, except the first boolean. In case of error, propagates the error.</p>
</blockquote>
<p><code>coroutine.isyieldable ()</code> <br></p>
<blockquote>
<p>Returns true when the running coroutine can yield.</p>
</blockquote>
<blockquote>
<p>A running coroutine is yieldable if it is not the main thread and it is not inside a non-yieldable C function.</p>
</blockquote>
<h2 id="对称协同与不对称协同"><a href="#对称协同与不对称协同" class="headerlink" title="对称协同与不对称协同"></a>对称协同与不对称协同</h2><p>待补充..</p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2>]]></content>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>一次短暂的逃离</title>
    <url>/2019-11-21-%E4%B8%80%E6%AC%A1%E7%9F%AD%E6%9A%82%E7%9A%84%E9%80%83%E7%A6%BB/</url>
    <content><![CDATA[<p>今天缘于一点惰性,早上睁开眼犹豫了一会之后决定修一天假.可能也和最近几天的状态有关吧,处理了半年的局点问题,现在终于可以脱身出来做别的事情.在这交接的过渡阶段，上面安排的任务也不够具体,给了自己一些可以自我发挥的空间,直白的说,就是可以适当偷偷懒.</p>
<p>这的确很美好,我早已经想脱离出来,做做需求特性了.哪怕是比较坑的特性,总需要转换下给点新鲜感,尤其是长期做这种很纠缠,很折磨人的局点.但是突然间生活节奏变慢了,长期的惯性很难短时间去适应。导致最近整个人没有状态,完全的无精打采,迷迷糊糊.</p>
<a id="more"></a>

<p>今天请假,我给了自己很多充分的理由来做这个决定.前段时间工作任务很多,自己最近游戏也晚的多,透支了很多精力.天宫也不作美,鼻炎在这种天气很受罪.的确是需要自我放松下了.</p>
<p>现在回想起来今天毫无目的的漫步,总体还是蛮有意思的.我凭记忆把今天的大致路线记录了下来:</p>
<p><img src="https://i.loli.net/2019/11/22/V3uGLC9vxjcEMDI.png" alt="路线.png"></p>
<p>整段路程有意思的地方,首先是村庄,拆迁的村庄.每家每户都在盖房,有的已经盖好了,全新的瓷钻,大概6层到8层左右的高度.可以明显的看出来,都是在原先1层或者2层的基础上加盖的,新加的楼层显得很粗糙,内部都没有用水泥粉刷.外面崭新的瓷砖上写的拆迁，验收的字样.房子的高度在这样原先2层左右的村庄布局下显得十分拥挤,我误打误撞来到这里目睹了这一切.看到坐在自己门前的户主的眼神,我能体会到一些他们的感受.别人都在盖房,大家都想多拿点拆迁补助款,都跟着盖.有些房子明显之前没人住的,或者以前是很简陋的土房,现在都一致的在做同样的事情。这些人里面,我看到了部分很久没回过村庄的人,应该是在外面打工或者已经搬进城里,现在确有一人(大多是妻子)回来看着盖房,给工人烧水.为了拿这些可以说是中彩票一样的中国这个阶段特有的意外之财.还有一些可以看到以前比较贫苦的人家，现在也在盖高层,只为了不久后把新房推倒.我想这些人的亲戚在这个阶段应该是最慷概的,不管盖几层高的房子应该都是可以借到钱的吧.还有一个房子,可以看到不久前刚办完丧事,现在屋内已经没人了.从这个村庄走过,让我有一种走进dayuejin的感觉。所有人家都在盖房,邻居打招呼都是:房子盖好了没？这是怎样一种景观.真是有趣啊.</p>
<p>穿过村庄,可以看到基本每个出村的路口都有一些穿着保安制服的人.和办公大楼的保安不同的是,这里的保安对陌生人(我)总是格外的感兴趣,异样的看着我,似乎想在我身上找到摄像头一般的东西.看得出来,他们非常的警惕和专业.话说回来,黑社会的人应该也挺专业的吧.</p>
<p>在往后面走,是一片片一望无际的田野.我已经很久没遇到过这种景观了.真的是一望无际,没有那么多信号塔,没有高楼,田野中还有野鸡.我似乎一下子回到了童年,在我小学阶段，故乡的麦田也是这样,还可以放风筝.压抑许久的我终于得到了可以释放的途径,不由自主的奔跑了起来.穿惯了紧身的衣服,在办公室兢兢业业的工作,这是我努力得来的体面的工作.我为此压抑了自己的天性,自己的孩子气,就为了这一点点相对于工地的优越性,真是一点点,却又是那么遥远,那么难.需要从小学到大学毕业这么久的时间.</p>
<p>说到工地,旁边拆迁完的地方已经在盖新楼了,有盖居民楼的,有修净水厂的,有建科研中心的,还有挖地铁的.不知道有多大面积,但确实目所能及,很大的一片规划用地被征用了.打工的人,来自全国各地,本地人居多,我漫步的过程种听到他们普通的交谈,这和我之前在深圳遇到的场面很是相似.一度我以为自己来到了深圳郊外.</p>
<p>如果说上个世纪,农民工的史诗是煤矿,是地下.那现在,一定是举世闻名的中国大基建了.所有的地方都在基建,人们已经习惯了这种噪音.在武汉的时候,那里到处在修,在深圳的时候,在修.我想每个城市都是这样,不过需要去寻找,一定会有某个城区,某个地段,全国各地同谋一样的在做这件事.在为国家经济的引擎加力.</p>
<p>回来的路上,比较孤单和无聊.一度还走错了路,人也已经筋疲力尽.在傍晚穿过城中村的时候,还能听到远处拆迁的声音,楼倒的声音.村里里现有人烟,看不到灯火.楼是那么的高,孤零零的我甚至有些恐惧.不时的可以遇见一些猫,这些在农村生活惯了的猫,会被村民搬迁的时候一并带走吗,还是就此成为了野猫.这里的人对自己遇到的这一切恐怕都解释不了吧,我想这些猫,心里更是感到奇怪吧.</p>
<p>不过这也许就是生活吧,时代的力量是阻止不了的,人也不过是一种生物.更何况我只是其中不起眼的一个.<br>挺晚了,早点睡了.许久没打字了,也的确是今天想到了很多事情.愿以后的生活会更好,世界会更好吧.</p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2019/11/22/PuDkwFTOLN6zHxy.jpg" alt="田野.jpg"></p>
]]></content>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx开篇和安装</title>
    <url>/2019-12-02-nginx%E5%BC%80%E7%AF%87%E5%92%8C%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>开始学习nginx,目前主要参考: <br><br><a href="http://tengine.taobao.org/book/">Nginx开发从入门到精通</a> <br><br><a href="https://github.com/dfa0328/book/blob/master/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Nginx%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90%E7%AC%AC2%E7%89%88.pdf">深入理解Nginx模块开发与架构解析第2版.pdf</a> <br></p>
<a id="more"></a>

<h2 id="nginx的安装"><a href="#nginx的安装" class="headerlink" title="nginx的安装"></a>nginx的安装</h2><p><a href="http://nginx.org/en/linux_packages.html">RHEL/CentOS</a></p>
<pre><code>Install the prerequisites:

sudo yum install yum-utils
To set up the yum repository, create the file named /etc/yum.repos.d/nginx.repo with 
the following contents:

[nginx-stable]
name=nginx stable repo
baseurl=http://nginx.org/packages/centos/$releasever/$basearch/
gpgcheck=1
enabled=1
gpgkey=https://nginx.org/keys/nginx_signing.key
module_hotfixes=true

[nginx-mainline]
name=nginx mainline repo
baseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/
gpgcheck=1
enabled=0
gpgkey=https://nginx.org/keys/nginx_signing.key
module_hotfixes=true
By default, the repository for stable nginx packages is used. If you would like to use
 mainline nginx packages, 
run the following command:

sudo yum-config-manager --enable nginx-mainline
To install nginx, run the following command:

sudo yum install nginx
When prompted to accept the GPG key, verify that the fingerprint matches 573B FD6B 3D8F
 BC64 1079 A6AB ABF5
 BD82 7BD9 BF62, and if so, accept it.</code></pre>
<p><a href="https://www.cnblogs.com/yjf512/archive/2012/05/10/2494635.html">makefile编译安装,附加-g参数</a></p>
<pre><code>修改auto/cc/conf文件
ngx_compile_opt=&quot;-c&quot;

变为

ngx_compile_opt=&quot;-c -g&quot;</code></pre>
<p>然后,基本的安装三步即可…</p>
<h2 id="内核参数优化"><a href="#内核参数优化" class="headerlink" title="内核参数优化"></a>内核参数优化</h2><p>使用nginx需要调整下服务器配置,因为默认的系统配置是最通用的,而不是最有效率的.书中提供的参考是修改/etc/sysctl.conf来优化内核参数: <br></p>
<pre><code>fs.file-max = 999999
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_keepalive_time = 600
net.ipv4.tcp_fin_timeout = 30
net.ipv4.tcp_max_tw_buckets = 5000
net.ipv4.ip_local_port_range = 1024 61000
net.ipv4.tcp_rmem = 4096 32768 262142
net.ipv4.tcp_wmem = 4096 32768 262142
net.core.netdev_max_backlog = 8096
net.core.rmem_default = 262144
net.core.wmem_default = 262144
net.core.rmem_max = 2097152
net.core.wmem_max = 2097152
net.ipv4.tcp_syncookies = 1
net.ipv4.tcp_max_syn.backlog=1024</code></pre>
<p><code>file-max</code> <br><br>这个参数表示进程（比如一个worker进程）可以同时打开的最大句柄数，这个参数直接限制最大并发连接数，需根据实际情况配置。</p>
<p><code>tcp_tw_reuse</code> <br><br>这个参数设置为1，表示允许将TIME-WAIT状态的socket重新用于新的TCP连接，这对于服务器来说很有意义，因为服务器上总会有大量TIME-WAIT状态的连接。</p>
<p><code>tcp_keepalive_time</code> <br><br>这个参数表示当keepalive启用时，TCP发送keepalive消息的频度。默认是2小时，若将其设置得小一些，可以更快地清理无效的连接。</p>
<p><code>tcp_fin_timeout</code> <br><br>这个参数表示当服务器主动关闭连接时，socket保持在FIN-WAIT-2状态的最大时间。</p>
<p><code>tcp_max_tw_buckets</code> <br><br>这个参数表示操作系统允许TIME_WAIT套接字数量的最大值，如果超过这个数字，TIME_WAIT套接字将立刻被清除并打印警告信息。该参数默认为180000，过多的TIME_WAIT套接字会使Web服务器变慢。</p>
<p><code>tcp_max_syn_backlog</code> <br><br>这个参数表示TCP三次握手建立阶段接收SYN请求队列的最大长度，默认为1024，将其设置得大一些可以使出现Nginx繁忙来不及accept新连接的情况,Linux不至于丢失客户端发起的连接请求。</p>
<p><code>ip_local_port_range</code> <br><br>这个参数定义了在UDP和TCP连接中本地（不包括连接的远端）端口的取值范围。</p>
<p><code>net.ipv4.tcp_rmem</code> <br><br>这个参数定义了TCP接收缓存（用于TCP接收滑动窗口）的最小值、默认值、最大值。</p>
<p><code>net.ipv4.tcp_wmem</code> <br><br>这个参数定义了TCP发送缓存（用于TCP发送滑动窗口）的最小值、默认值、最大值。</p>
<p><code>netdev_max_backlog</code> <br><br>当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。这个参数表示该队列的最大值。</p>
<p><code>rmem_default</code> <br><br>这个参数表示内核套接字接收缓存区默认的大小。</p>
<p><code>wmem_default</code> <br><br>这个参数表示内核套接字发送缓存区默认的大小。</p>
<p><code>rmem_max</code> <br><br>这个参数表示内核套接字接收缓存区的最大大小。</p>
<p><code>wmem_max</code> <br><br>这个参数表示内核套接字发送缓存区的最大大小。</p>
<p><code>tcp_syncookies</code> <br><br>该参数与性能无关，用于解决TCP的SYN攻击。</p>
<blockquote>
<p>注意 滑动窗口的大小与套接字缓存区会在一定程度上影响并发连接的数目。每个TCP连接都会为维护TCP滑动窗口而消耗内存，这个窗口会根据服务器的处理速度收缩或扩张。<br>参数wmem_max的设置，需要平衡物理内存的总大小、Nginx并发处理的最大连接数量（由nginx.conf中的worker_processes和worker_connections参数决定）而确定。当然，如果仅仅为了提高并发量使服务器不出现Out Of Memory问题而去降低滑动窗口大小，那么并不合<br>适，因为滑动窗口过小会影响大数据量的传输速度。rmem_default、wmem_default、rmem_max、wmem_max这4个参数的设置需要根据我们的业务特性以及实际的硬件成本来综合考虑。</p>
</blockquote>
<p>上面的部分参数我之前有总结过,还有部分比如滑动窗口还不是很熟悉,后面遇到了再单独总结.</p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2019/12/02/tEqDXMYQp6vSsFZ.jpg" alt="73735688_p0_little.jpg"></p>
]]></content>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>ping携带时间信息-NTP时间同步报错-vmware虚拟机克隆报错</title>
    <url>/2019-12-03-ping%E6%90%BA%E5%B8%A6%E6%97%B6%E9%97%B4%E4%BF%A1%E6%81%AF-NTP%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5%E6%8A%A5%E9%94%99-vmware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%85%8B%E9%9A%86%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<h2 id="ping携带时间信息"><a href="#ping携带时间信息" class="headerlink" title="ping携带时间信息"></a>ping携带时间信息</h2><pre><code>ping www.baidu.com | awk &#39;&#123; print strftime(&quot;%Y.%m.%d %H:%M:%S&quot;,systime())&quot;\t&quot; $0 &#125;&#39; &gt; ping.log</code></pre>
<a id="more"></a>

<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>awk目前还不太熟,暂不研究.<code>需要注意的是这个命令执行后不会立即生效,需要等一会</code>.我电脑上验证大概是每次打印50条左右的结果,然后等1分钟左右再次打印50条,以此循环.猜测应该和awk命令有关吧.网上的资料都没有提到这一点,第一次使用的时候我原以为该命令不可用,还觉得很是奇怪…</p>
<h2 id="NTP时间同步报错"><a href="#NTP时间同步报错" class="headerlink" title="NTP时间同步报错"></a>NTP时间同步报错</h2><p>参考： <br><br><a href="https://www.cnblogs.com/ajianbeyourself/p/4190883.html">ntpdate server时出错原因及解决</a> <br><br><a href="https://blog.51cto.com/kmt1994/1934812">centos7安装设置NTP服务器</a> <br><br><a href="https://blog.csdn.net/tsh123321/article/details/72901972">两台windows上NTP服务器和客户端的安装与使用总结</a> <br><br><a href="https://www.ibm.com/support/knowledgecenter/en/ssw_aix_72/filesreference/ntp.keys.html">/etc/ntp/keys</a> <br><br><a href="https://access.redhat.com/solutions/393663">如何使用对称密钥配置经过身份验证的NTP</a> <br></p>
<p>服务器端安装成功:</p>
<pre><code>[root@localhost ~]# ntpq -p
     remote           refid      st t when poll reach   delay   offset  jitter
==============================================================================
 192.168.1.200   .INIT.          16 u    -   64    0    0.000    0.000   0.000
 h199-182-204-19 .INIT.          16 u    -   64    0    0.000    0.000   0.000
*stratum2-1.ntp. 89.175.20.7      2 u   49   64    3  196.692  -288005   1.946
 ntp1.flashdance .INIT.          16 u    -   64    0    0.000    0.000   0.000
 ntp1.ams1.nl.le 130.133.1.10     2 u   45   64    1  301.453  -288005   0.247
 LOCAL(0)        .LOCL.           5 l  115   64    2    0.000    0.000   0.000</code></pre>
<p>linux客户端同步成功:</p>
<pre><code>[root@localhost ~]# ntpdate 192.168.1.200
 5 Dec 07:56:54 ntpdate[47053]: step time server 192.168.1.200 offset 83532.353696 sec</code></pre>
<p>windows客户端同步成功:</p>
<pre><code>C:\Windows\system32&gt;ntpdate -b 192.168.1.200
5 Dec 08:17:52 ntpdate[59164]: Raised to realtime priority class
5 Dec 08:17:58 ntpdate[59164]: step time server 192.168.1.200 offset 0.001218 sec</code></pre>
<p>这里主要想说明遇到的一个问题,就是自己搭建的ntp服务器和客户端.当服务器刚启动后,客户端ntpdate -d ServerIp连接服务器会报错:no server suitable for synchronization found.并且错误信息中有stratum 16，stratum是ntp服务器层级，正常情况下stratum的值为“0~15”。而<br>stratum=16是因为NTP server还没有和它的上层NTP server同步上。具体愿意可以看上面的参考文章.</p>
<p>我自己在家里电脑搭了两个虚拟机进行复现居然没复现出来,我怀疑可能是我ntpd服务版本太高,已经把这一点完善了? </p>
<pre><code>[root@localhost ~]# ntpd --version
ntpd 4.2.6p5

exit 0</code></pre>
<p>so, 本来想记录一个问题的解决方法,最后阴差阳错,变成了Ntpd的安装过程记录.</p>
<h3 id="卸载ntp"><a href="#卸载ntp" class="headerlink" title="卸载ntp"></a>卸载ntp</h3><pre><code>systemctl stop ntpd       #停止ntp服务
systemctl disable ntpd    #禁止ntp服务随系统启动
yum remove ntp            #卸载ntp软件包</code></pre>
<h3 id="libopts-so-25"><a href="#libopts-so-25" class="headerlink" title="libopts.so.25"></a>libopts.so.25</h3><p>安装完后有包过一次过,提示没有libopts.so.25这个库文件,下载地址: <a href="https://rpmfind.net/linux/rpm2html/search.php?query=libopts.so.25()(64bit)">libopts.so.25</a>  然后rpm -iv autogen-libopts-5.18-5.el7.x86_64</p>
<h2 id="vmware虚拟机克隆报错"><a href="#vmware虚拟机克隆报错" class="headerlink" title="vmware虚拟机克隆报错"></a>vmware虚拟机克隆报错</h2><p>参考: <br><br><a href="https://blog.csdn.net/xiaoyangsavvy/article/details/73718473">VMware虚拟机中如何配置静态IP</a> <br><br><a href="https://www.cnblogs.com/zyw-205520/p/5328887.html">CentOS7 Failed to start LSB: Bring up/down networking</a></p>
<h3 id="说明-1"><a href="#说明-1" class="headerlink" title="说明 "></a>说明 <br></h3><p>我电脑只装了一个虚拟机,这回需要两台配合使用.从头搭建比较麻烦,就使用了vmware的克隆功能,克隆后出现了一些问题,记录下: <br><br>首先是网络问题,克隆后所有配置都和上一台原始机器一致,导致ip地址不可用.我上一台机器的网络都是配置好了的,这里克隆机需要修改的地方不多.</p>
<pre><code>路径 /etc/sysconfig/network-scripts/ifcfg-eth0
[root@localhost network-scripts]# cat ifcfg-eno16777736
HWADDR=**:**:**:**:**:**
TYPE=Ethernet
BOOTPROTO=static
DEFROUTE=yes
PEERDNS=yes
PEERROUTES=yes
IPV4_FAILURE_FATAL=no
IPV6INIT=no
IPV6_AUTOCONF=yes
IPV6_DEFROUTE=yes
IPV6_PEERDNS=yes
IPV6_PEERROUTES=yes
IPV6_FAILURE_FATAL=no
NAME=eno16777736
UUID=9b89c5b7-6cd0-488f-baf4-59aa6f711264
ONBOOT=yes
IPADDR=192.***.*.***
GATEWAY=192.168.1.2
NETMASK=255.255.255.0
DNS1=8.8.8.8</code></pre>
<p>将上面文件中的IPADDR这一项IP地址修改为新的值,然后我尝试重启network:</p>
<p><img src="https://i.loli.net/2019/12/03/eA5JDdCiwZcyFab.png" alt="network_err.png"></p>
<p><code>Failed to start LSB: Bring up/down networking</code> 原因是mac地址不对,通过ip addr查看本机mac地址填入/etc/sysconfig/network-scripts/ifcfg-eth0文件对应HWADDR即可.</p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2019/12/03/kjsuyGRZHqe5OiD.jpg" alt="78075718_p0_lit.jpg"></p>
]]></content>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>linux文件系统</title>
    <url>/2019-12-05-linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>linux文件系统内部结构是一直感兴趣的地方,但这块网上资料很少也很零散,并且浮于表面的居多.正好近期遇到的项目和这块有一丁点关系,今天先开个篇.希望后面能够把这块整体梳理一遍.</p>
<a id="more"></a>

<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2019/12/05/ctrF9aUQNqxwyR3.jpg" alt="77861107_p0.jpg"></p>
]]></content>
      <tags>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx源码分析-main</title>
    <url>/2019-12-10-nginx%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-main/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="http://tengine.taobao.org/book/">Nginx开发从入门到精通</a> <br><br><a href="https://github.com/y123456yz/reading-code-of-nginx-1.9.2">reading-code-of-nginx-1.9.2</a> <br></p>
<a id="more"></a>

<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><pre><code>//用最新的nginx版本和源码进行学习
[root@localhost ~]# nginx -v
nginx version: nginx/1.17.6</code></pre>
<p><img src="https://i.loli.net/2019/12/10/BIJPQ6m3zCL5lMO.png" alt="nginx_process.png"></p>
<table>
    <thead align="center">
        <tr>
            <th style="text-align:center">pid</th>
            <th style="text-align:center">process</th>
        </tr>
    </thead>
    <tbody align="center">
        <tr>
            <td>9774</td>
            <td>master</td>
        </tr>
        <tr>
            <td>9775</td>
            <td>worker</td>
        </tr>
    </tbody>
</table>

<pre><code>root       9774  0.0  0.0  46380   996 ?        Ss   23:05   0:00 nginx: master process nginx
nginx      9775  0.0  0.0  46776  1944 ?        S    23:05   0:00 nginx: worker process
root      10019  0.0  0.0 112676   976 pts/0    R+   23:10   0:00 grep --color=auto nginx

nginx,9774
      └─nginx,9775

stack 9775
#0  0x00007f39d163f763 in __epoll_wait_nocancel () from /lib64/libc.so.6
#1  0x00007f39d2d241c3 in ngx_epoll_process_events ()
#2  0x00007f39d2d1a8e4 in ngx_process_events_and_timers ()
#3  0x00007f39d2d226e1 in ngx_worker_process_cycle ()
#4  0x00007f39d2d20b8b in ngx_spawn_process ()
#5  0x00007f39d2d21d90 in ngx_start_worker_processes ()
#6  0x00007f39d2d230a3 in ngx_master_process_cycle ()
#7  0x00007f39d2cfa12f in main ()

stack 9774
#0  0x00007f39d157e916 in sigsuspend () from /lib64/libc.so.6
#1  0x00007f39d2d230f6 in ngx_master_process_cycle ()
#2  0x00007f39d2cfa12f in main ()</code></pre>
<h3 id="master-gt-main"><a href="#master-gt-main" class="headerlink" title="master &gt; main"></a><code>master</code> &gt; main</h3><pre><code>ngx_int_t ngx_strerror_init(void);</code></pre>
<p>函数作用:把系统错误信息保存到数组ngx_sys_errlist内,相当于重写了stderr: <br></p>
<p><a href="https://juejin.im/post/5d6341bd6fb9a06ada54bdac">NGX_SYS_NERR，这是一个宏定义，是在auto/unix脚本中设置的</a></p>
<p>ngx_sys_errlist:</p>
<pre><code>len = 7, data = 0x6d0890 &quot;Success&quot;
len = 23, data = 0x6d08b0 &quot;Operation not permitted&quot;
len = 25, data = 0x6d08d0 &quot;No such file or directory&quot;
len = 15, data = 0x6d0900 &quot;No such process&quot;
len = 23, data = 0x6d0920 &quot;Interrupted system call&quot;
len = 18, data = 0x6d0940 &quot;Input/output error&quot;
len = 25, data = 0x6d0960 &quot;No such device or address&quot;
len = 22, data = 0x6d0990 &quot;Argument list too long&quot;
len = 17, data = 0x6d09b0 &quot;Exec format error&quot;
len = 19, data = 0x6d09d0 &quot;Bad file descriptor&quot;
len = 18, data = 0x6d09f0 &quot;No child processes&quot;
len = 32, data = 0x6d0a10 &quot;Resource temporarily unavailable&quot;
len = 22, data = 0x6d0a40 &quot;Cannot allocate memory&quot;
len = 17, data = 0x6d0a60 &quot;Permission denied&quot;
len = 11, data = 0x6d0a80 &quot;Bad address&quot;
len = 21, data = 0x6d0aa0 &quot;Block device required&quot;
len = 23, data = 0x6d0ac0 &quot;Device or resource busy&quot;
len = 11, data = 0x6d0ae0 &quot;File exists&quot;
... 数组大小135</code></pre>
<p>linux错误码：</p>
<pre><code>errno.00 is: Success
errno.01 is: Operation not permitted
errno.02 is: No such file or directory
errno.03 is: No such process
errno.04 is: Interrupted system call
errno.05 is: Input/output error
errno.06 is: No such device or address
errno.07 is: Argument list too long
errno.08 is: Exec format error
errno.09 is: Bad file descriptor
errno.10 is: No child processes
errno.11 is: Resource temporarily unavailable
errno.12 is: Cannot allocate memory
errno.13 is: Permission denied
errno.14 is: Bad address
errno.15 is: Block device required
errno.16 is: Device or resource busy
errno.17 is: File exists</code></pre>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2019/12/10/dywZQ4F5ISYDzPU.jpg" alt="77803726_p0_lit.jpg"></p>
]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>编码格式-utf8-gbk</title>
    <url>/2019-12-25-%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8Futf8-gbk/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/batsing/p/charset.html">彻底搞懂编码 GBK 和 UTF8</a> <br><br><a href="https://zh.wikipedia.org/wiki/UTF-8">维基百科</a> <br><br><a href="https://github.com/chcg/NPP_HexEdit/releases">HexEditor</a> <br><br><a href="https://zhuanlan.zhihu.com/p/46216008">程序员必备：彻底弄懂常见的7种中文字符编码</a></p>
<hr>
<a id="more"></a>

<p><img src="https://i.loli.net/2019/12/25/QLbpmh6oAtHZMq2.jpg" alt="encode.jpg"></p>
<h3 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a><code>GB2312</code></h3><blockquote>
<p>GB2312中对所收汉字进行了“分区”处理，每区含有94个汉字／符号，共计94个区。用所在的区和位来表示字符（实际上就是码位），因此称为区位码（或许叫“区位号”更为恰当）。表示方式也称为区位码。例如“万”字在45区82位，所以“万”字的区位码是：45 82. GB2312编码就是基于区位码的，用双字节编码表示中文和中文符号。GB2312编码方式是：0xA0+区号，0xA0+位号。<br>对于GB 2312，是8比特双字节编码。其汉字编码空间为94 x 94，即有94个区，每个区有94个位（用来编码字符）。实际使用了16-55区编码一级汉字，56-87区编码二级汉字。这些汉字均放在了G1字符块区。这种区位码方案是GB 2312的逻辑设计。其具体的字符编码方案（Character Encoding Scheme）：<code>字节值在0x00-0x7F，为单字节表示一个字符，构成了C0、G0区，与ASCII码兼容。因此，GB 2312是单、双字节混合编码</code>。</p>
</blockquote>
<p><code>单字节和双字节gbk</code></p>
<p><img src="https://i.loli.net/2019/12/25/ItZEgLhjJc5Uo74.png" alt="gbk.png"></p>
<blockquote>
<p>对于遵从ISO 2022的8比特编码字符集，也是按照上述7比特编码原则设计的编码方案。这种8比特编码字符集很容易兼容当时的7比特宽的通信协议/通信设备。8比特字符编码时，0x00-0x1F表示C0或称CL区（L是left缩写，因为其在字符表的左侧），0x80-0x9F表示C1或称CR（R是Right缩写，因为其在字符表的右侧）。0x20-0x7F表示G0（称GL区），0xA0-0xFF（称GR区）可表示G1, G2, G3。</p>
</blockquote>
<p><code>EUC-CN</code></p>
<blockquote>
<p>EUC最初是针对Unix系统，由一些Unix公司所开发，于1991年标准化。EUC基于ISO/IEC 2022的7位编码标准，因此单字节的编码空间为94，双字节的编码空间（区位码）为94x94。把每个区位加上0xA0来表示，以便符合ISO 2022。它主要用于表示及储存汉语文字、日语文字及朝鲜文字。</p>
</blockquote>
<p><code>字符块</code></p>
<ul>
<li>低端控制字符(C0)</li>
<li>US-ASCII字符集(GL)</li>
<li>高端控制字符(C1)</li>
<li>高端字符(GR)是特定于每个ISO-8859-X变种。例如ISO-8859-1是由ISO-IR-1, ISO-IR-6, ISO-IR-77, ISO-IR-100 组成。</li>
</ul>
<p><code>区位码</code></p>
<blockquote>
<p>区位码是1980年中国制定的一个字符编码标准。每一个字符都有对应一个4位十进制数字码位表示，其中前两位为“区”，后两位为“位”。中文汉字的编号区号是从16开始的，位号从1开始。 </p>
</blockquote>
<ul>
<li>01~09区（682个）：特殊符号、数字、英文字符、制表符等，包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母等在内的682个全角字符；</li>
<li>10~15区：空区，留待扩展；在附录3，第10区推荐作为 GB 1988–80 中的94个图形字符区域（即第3区字符之半形版本）。</li>
<li>16~55区（3755个）：常用汉字（也称一级汉字），按拼音排序；</li>
<li>56~87区（3008个）：非常用汉字（也称二级汉字），按部首/笔画排序；</li>
<li>88~94区：空区，留待扩展。</li>
</ul>
<p>啊(1601)     阿(1602)     埃(1603)     挨(1604)     哎(1605)     唉(1606)     哀(1607)     皑(1608)     癌(1609)     蔼(1610)<br>矮(1611)     艾(1612)     碍(1613)     爱(1614)     隘(1615)     鞍(1616)     氨(1617)     安(1618)     俺(1619)     按(1620)<br>暗(1621)     岸(1622)     胺(1623)     案(1624)     肮(1625)     昂(1626)     盎(1627)     凹(1628)     敖(1629)     熬(1630)<br>翱(1631)     袄(1632)     傲(1633)     奥(1634)     懊(1635)     澳(1636)     芭(1637)     捌(1638)     扒(1639)     叭(1640)<br>吧(1641)     笆(1642)     八(1643)     疤(1644)     巴(1645)     拔(1646)     跋(1647)     靶(1648)     把(1649)     耙(1650)<br>坝(1651)     霸(1652)     罢(1653)     爸(1654)     白(1655)     柏(1656)     百(1657)     摆(1658)     佰(1659)     败(1660)<br>拜(1661)     稗(1662)     斑(1663)     班(1664)     搬(1665)     扳(1666)     般(1667)     颁(1668)     板(1669)     版(1670)<br>扮(1671)     拌(1672)     伴(1673)     瓣(1674)     半(1675)     办(1676)     绊(1677)     邦(1678)     帮(1679)     梆(1680)<br>榜(1681)     膀(1682)     绑(1683)     棒(1684)     磅(1685)     蚌(1686)     镑(1687)     傍(1688)     谤(1689)     苞(1690)<br>胞(1691)     包(1692)     褒(1693)     剥(1694)     薄(1701)     雹(1702)     保(1703)     堡(1704)     饱(1705)     宝(1706)<br>抱(1707)     报(1708)     暴(1709)     豹(1710)     鲍(1711)     爆(1712)     杯(1713)     碑(1714)     悲(1715)     卑(1716)<br>北(1717)     辈(1718)     背(1719)     贝(1720)     钡(1721)     倍(1722)     狈(1723)     备(1724)     惫(1725)     焙(1726) </p>
<pre><code>                    葡(3847)                萄(4449)
hex+0XA0:            0XA0+38 0XA0+47        0XA0+44 0XA0+49
                    C6            CF        CC            D1</code></pre>
<p><img src="https://i.loli.net/2019/12/25/woIypnRu6lMmCNa.png" alt="gb2312.png"></p>
<h3 id="utf-8"><a href="#utf-8" class="headerlink" title="utf-8"></a><code>utf-8</code></h3><p>###　FSS-UTF (1992) / UTF-8 (1993)[1]</p>
<table>
    <thead align="center">
        <tr>
            <th style="text-align:center">Number of bytes</th>
            <th style="text-align:center">Firstcode point</th>
            <th style="text-align:center">Lastcode point</th>
            <th style="text-align:center">Byte 1</th>
            <th style="text-align:center">Byte 2</th>
            <th style="text-align:center">Byte 3</th>
            <th style="text-align:center">Byte 4</th>
            <th style="text-align:center">Byte 5</th>
            <th style="text-align:center">Byte 6</th>
        </tr>
    </thead>
    <tbody align="center">
        <tr>
            <td>１</td>
            <td>U+0000</td>
            <td>U+007F</td>
            <td>0xxxxxxx</td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
        </tr>

<pre><code>    &lt;tr&gt;
        &lt;td&gt;２&lt;/td&gt;
        &lt;td&gt;U+0080&lt;/td&gt;
        &lt;td&gt;U+07FF&lt;/td&gt;
        &lt;td&gt;110xxxxx&lt;/td&gt;
        &lt;td&gt;10xxxxxx&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;

    &lt;tr&gt;
        &lt;td&gt;３&lt;/td&gt;
        &lt;td&gt;U+0800&lt;/td&gt;
        &lt;td&gt;U+FFFF&lt;/td&gt;
        &lt;td&gt;1110xxxx&lt;/td&gt;
        &lt;td&gt;10xxxxxx&lt;/td&gt;
        &lt;td&gt;10xxxxxx&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;

    &lt;tr&gt;
        &lt;td&gt;４&lt;/td&gt;
        &lt;td&gt;U+10000&lt;/td&gt;
        &lt;td&gt;U+1FFFFF&lt;/td&gt;
        &lt;td&gt;11110xxx&lt;/td&gt;
        &lt;td&gt;10xxxxxx&lt;/td&gt;
        &lt;td&gt;10xxxxxx&lt;/td&gt;
        &lt;td&gt;10xxxxxx&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;

    &lt;tr&gt;
        &lt;td&gt;５&lt;/td&gt;
        &lt;td&gt;U+200000&lt;/td&gt;
        &lt;td&gt;U+3FFFFFF&lt;/td&gt;
        &lt;td&gt;111110xx&lt;/td&gt;
        &lt;td&gt;10xxxxxx&lt;/td&gt;
        &lt;td&gt;10xxxxxx&lt;/td&gt;
        &lt;td&gt;10xxxxxx&lt;/td&gt;
        &lt;td&gt;10xxxxxx&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;

    &lt;tr&gt;
        &lt;td&gt;６&lt;/td&gt;
        &lt;td&gt;U+4000000&lt;/td&gt;
        &lt;td&gt;U+7FFFFFFF&lt;/td&gt;
        &lt;td&gt;1111110x&lt;/td&gt;
        &lt;td&gt;10xxxxxx&lt;/td&gt;
        &lt;td&gt;10xxxxxx&lt;/td&gt;
        &lt;td&gt;10xxxxxx&lt;/td&gt;
        &lt;td&gt;10xxxxxx&lt;/td&gt;
        &lt;td&gt;10xxxxxx&lt;/td&gt;
    &lt;/tr&gt;
&lt;/tbody&gt;</code></pre>
</table>

<ul>
<li>对于UTF-8编码中的任意字节B，如果B的第一位为0，则B独立的表示一个字符(ASCII码)；</li>
<li>如果B的第一位为1，第二位为0，则B为一个多字节字符中的一个字节(非ASCII字符)；</li>
<li>如果B的前两位为1，第三位为0，则B为两个字节表示的字符中的第一个字节，第2个字节是10开头.</li>
<li>如果B的前三位为1，第四位为0，则B为三个字节表示的字符中的第一个字节；第2，3个字节是10开头.</li>
<li>如果B的前四位为1，第五位为0，则B为四个字节表示的字符中的第一个字节；第2，3，4个字节是10开头.</li>
<li>如果B的前五位为1，第五位为0，则B为四个字节表示的字符中的第一个字节；第2，3，4，5个字节是10开头.</li>
<li>如果B的前六位为1，第五位为0，则B为四个字节表示的字符中的第一个字节；第2，3，4，5，6个字节是10开头.</li>
</ul>
<p><code>UTF-8使用一至六个字节为每个字符编码（尽管如此，2003年11月UTF-8被RFC 3629重新规范，只能使用原来Unicode定义的区域，U+0000到U+10FFFF，也就是说最多四个字节）：</code></p>
<h3 id="再淡UNICODE"><a href="#再淡UNICODE" class="headerlink" title="再淡UNICODE"></a><code>再淡UNICODE</code></h3><p>待补充</p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2019/12/25/QBlD1wxSyAuvLc4.jpg" alt="69382276_p0_master1200.jpg"></p>
]]></content>
      <tags>
        <tag>encoding format</tag>
      </tags>
  </entry>
  <entry>
    <title>编解码函数</title>
    <url>/2019-12-26-%E7%BC%96%E8%A7%A3%E7%A0%81%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><a id="more"></a>


<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2>]]></content>
      <tags>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title>cgdb安装</title>
    <url>/2020-01-14-cgdb%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.51cto.com/990487026/1967727">CentOS7 安装cgdb</a></p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>在没有外网的centos6下尝试离线安装cgdb,花了很多时间，最后都没有成功，很挫败了。晚上在centos7下联网再试了一次,参考上面的文章轻轻松松搞定，这篇文章主要记录一下,跟参考的连接没有多大区别.</p>
<a id="more"></a>

<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><pre><code>[root@localhost ~]# yum install ncurses-devel
[root@localhost ~]# yum install texinfo
[root@localhost ~]# yum install readline-devel</code></pre>
<h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><pre><code>[root@localhost ~]# wget https://github.com/cgdb/cgdb/archive/v0.7.0.tar.gz
[root@localhost ~]# tar xf v0.7.0.tar.gz 
[root@localhost ~]# cd cgdb-0.7.0/
[root@localhost cgdb-0.7.0]# ./autogen.sh 
[root@localhost cgdb-0.7.0]# ./configure --prefix=$&#123;HOME&#125;/cgdb
[root@localhost cgdb-0.7.0]# make &amp;&amp; make install</code></pre>
<h3 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h3><p><img src="https://i.loli.net/2020/01/14/sTnBIog2GYzH8Om.png" alt="cgdb.png"></p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/01/14/kyeWh2xLdfU3gvF.jpg" alt="64585758_p0.jpg"></p>
]]></content>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb进阶</title>
    <url>/2020-01-14-gdb%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://wizardforcel.gitbooks.io/100-gdb-tips/">100个gdb小技巧</a> <br><br><a href="https://github.com/hellogcc/100-gdb-tips/blob/master/src/index.md">100-gdb-tips</a></p>
<a id="more"></a>

<h2 id="整理"><a href="#整理" class="headerlink" title="整理"></a>整理</h2><h3 id="显示gdb版本"><a href="#显示gdb版本" class="headerlink" title="显示gdb版本"></a><code>显示gdb版本</code></h3><pre><code>(gdb) show version
GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-114.el7
Copyright (C) 2013 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;
and &quot;show warranty&quot; for details.
This GDB was configured as &quot;x86_64-redhat-linux-gnu&quot;.
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;.
(gdb) </code></pre>
<h3 id="显示版权信息"><a href="#显示版权信息" class="headerlink" title="显示版权信息"></a><code>显示版权信息</code></h3><pre><code>(gdb) show copying</code></pre>
<h3 id="启动时不显示提示信息"><a href="#启动时不显示提示信息" class="headerlink" title="启动时不显示提示信息"></a><code>启动时不显示提示信息</code></h3><pre><code>gdb -q</code></pre>
<p>也可以在~/.bashrc中，为gdb设置一个别名:</p>
<pre><code>alias rm=&#39;rm -i&#39;
alias cp=&#39;cp -i&#39;
alias mv=&#39;mv -i&#39;    
alias gdb=&quot;gdb -q&quot;</code></pre>
<h3 id="退出时不显示提示信息"><a href="#退出时不显示提示信息" class="headerlink" title="退出时不显示提示信息"></a><code>退出时不显示提示信息</code></h3><pre><code>(gdb) set confirm off</code></pre>
<p>也可以把这个命令加到.gdbinit文件里,在~路径下</p>
<h3 id="输出信息不会暂停"><a href="#输出信息不会暂停" class="headerlink" title="输出信息不会暂停"></a><code>输出信息不会暂停</code></h3><pre><code>(gdb) set height 0            //方式一
(gdb) set pagination off    //方式二</code></pre>
<h3 id="列出函数的名字"><a href="#列出函数的名字" class="headerlink" title="列出函数的名字"></a><code>列出函数的名字</code></h3><pre><code>(gdb) info function                             
All defined functions:

File client.c:
int main();

Non-debugging symbols:
0x0000000000400630  _init
0x0000000000400630  _init                       
0x0000000000400660  inet_pton@plt
0x0000000000400670  close@plt
0x0000000000400680  __gmon_start__@plt
0x0000000000400690  puts@plt
0x00000000004006a0  htons@plt
0x00000000004006b0  __libc_start_main@plt
0x00000000004006c0  connect@plt
0x00000000004006d0  socket@plt
0x00000000004006e0  send@plt
0x00000000004006f0  perror@plt
0x0000000000400700  _start
0x0000000000400730  deregister_tm_clones
0x0000000000400760  register_tm_clones
0x00000000004007a0  __do_global_dtors_aux
0x00000000004007c0  frame_dummy
0x0000000000400940  __libc_csu_init
0x00000000004009b0  __libc_csu_fini
0x00000000004009b4  _fini</code></pre>
<p>支持正则：</p>
<pre><code>(gdb) info function ^ma 
All functions matching regular expression &quot;^ma&quot;:

File client.c:
int main();</code></pre>
<h3 id="进入带调试信息的函数"><a href="#进入带调试信息的函数" class="headerlink" title="进入带调试信息的函数"></a><code>进入带调试信息的函数</code></h3><pre><code>step    s
next    n</code></pre>
<h3 id="进入不带调试信息的函数"><a href="#进入不带调试信息的函数" class="headerlink" title="进入不带调试信息的函数"></a><code>进入不带调试信息的函数</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> iConnFd = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> szAddr[] = &#123;<span class="string">&quot;127.0.0.1&quot;</span>&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>  <span class="title">stServerAddr</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ((iConnFd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			perror(<span class="string">&quot;Failed to create socket!&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		stServerAddr.sin_family = AF_INET;</span><br><span class="line">		stServerAddr.sin_port = htons(<span class="number">7777</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (inet_pton(AF_INET, szAddr, (<span class="keyword">void</span>*)&amp;stServerAddr.sin_addr) &lt;= <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			perror(<span class="string">&quot;Failed to swicth ip addr!&quot;</span>);</span><br><span class="line">			close(iConnFd);</span><br><span class="line">			iConnFd = <span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (connect(iConnFd, (struct sockaddr*)&amp;stServerAddr, <span class="keyword">sizeof</span>(stServerAddr)) &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			perror(<span class="string">&quot;Failed to connect!&quot;</span>);</span><br><span class="line">			close(iConnFd);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;connect ok!&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (i &gt;= <span class="number">7</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			send(iConnFd,<span class="string">&quot;12345&quot;</span>,<span class="number">6</span>,<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i &gt; <span class="number">10</span>)</span><br><span class="line">			<span class="keyword">while</span>(<span class="number">1</span>);	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在socket这行，step 1,默认是不进入socket函数的，可以修改</p>
<pre><code>(gdb) set step-mode on</code></pre>
<p><img src="https://i.loli.net/2020/01/14/XoCcxWKYvypwmAE.png" alt="step-mode.png"></p>
<h3 id="退出正在调试的函数"><a href="#退出正在调试的函数" class="headerlink" title="退出正在调试的函数"></a><code>退出正在调试的函数</code></h3><pre><code>finish                    //到函数运行结束
return expression        //直接返回</code></pre>
<h3 id="直接执行函数"><a href="#直接执行函数" class="headerlink" title="直接执行函数"></a><code>直接执行函数</code></h3><pre><code>call func()
print func()</code></pre>
<h3 id="打印函数堆栈帧信息"><a href="#打印函数堆栈帧信息" class="headerlink" title="打印函数堆栈帧信息"></a><code>打印函数堆栈帧信息</code></h3><pre><code>(gdb) i    frame
Stack level 0, frame at 0x7fffffffe260:
 rip = 0x4007f8 in main (client.c:13); saved rip 0x7ffff721caf5
 source language c++.
 Arglist at 0x7fffffffe250, args:
 Locals at 0x7fffffffe250, Previous frame&#39;s sp is 0x7fffffffe260
 Saved registers:
  rbp at 0x7fffffffe250, rip at 0x7fffffffe258
(gdb) </code></pre>
<h3 id="打印尾调用堆栈帧信息"><a href="#打印尾调用堆栈帧信息" class="headerlink" title="打印尾调用堆栈帧信息"></a><code>打印尾调用堆栈帧信息</code></h3><p>这个感觉没啥用，也测试不出来</p>
<h3 id="选择函数堆栈帧"><a href="#选择函数堆栈帧" class="headerlink" title="选择函数堆栈帧"></a><code>选择函数堆栈帧</code></h3><pre><code>frame n
frame addr    //很少用</code></pre>
<h3 id="上下切换函数堆栈帧"><a href="#上下切换函数堆栈帧" class="headerlink" title="上下切换函数堆栈帧"></a><code>上下切换函数堆栈帧</code></h3><pre><code>(gdb) bt        
#0  a () at test.c:4
#1  0x0000000000400549 in b () at test.c:9
#2  0x0000000000400554 in c () at test.c:14
#3  0x000000000040055f in main () at test.c:19
(gdb) where
#0  a () at test.c:4
#1  0x0000000000400549 in b () at test.c:9
#2  0x0000000000400554 in c () at test.c:14
#3  0x000000000040055f in main () at test.c:19
(gdb) up 1
#1  0x0000000000400549 in b () at test.c:9
(gdb) 
#2  0x0000000000400554 in c () at test.c:14
(gdb) down 1
#1  0x0000000000400549 in b () at test.c:9
(gdb) 
#0  a () at test.c:4
(gdb) </code></pre>
<p>切换后不打印信息，可以用：</p>
<pre><code>up-silently n
down-silently n</code></pre>
<h3 id="在匿名空间设置断点"><a href="#在匿名空间设置断点" class="headerlink" title="在匿名空间设置断点"></a><code>在匿名空间设置断点</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Foo</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>(gdb) b Foo::foo
(gdb) b (anonymous namespace)::bar    
英 /əˈnɒnɪməs/ </code></pre>
<p>``</p>
<h3 id="在程序地址上打断点"><a href="#在程序地址上打断点" class="headerlink" title="在程序地址上打断点"></a><code>在程序地址上打断点</code></h3><pre><code>(gdb) b *address</code></pre>
<h3 id="在程序入口处打断点"><a href="#在程序入口处打断点" class="headerlink" title="在程序入口处打断点"></a><code>在程序入口处打断点</code></h3><p>先查询入口处地址,在b *address</p>
<p><code>readelf</code></p>
<pre><code>[root@localhost wang]# readelf -h client
ELF 头：
  Magic：  7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2&#39;s complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (可执行文件)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  入口点地址：              0x400700
  程序头起点：              64 (bytes into file)
  Start of section headers:          4504 (bytes into file)
  标志：             0x0
  本头的大小：       64 (字节)
  程序头大小：       56 (字节)
  Number of program headers:         9
  节头大小：         64 (字节)
  节头数量：         28
  字符串表索引节头： 27</code></pre>
<p><code>info files</code></p>
<pre><code>(gdb) info files                                                        
Symbols from &quot;/home/wang/test&quot;.
Local exec file:
    `/home/wang/test&#39;, file type elf64-x86-64.
    Entry point: 0x400440
    0x0000000000400238 - 0x0000000000400254 is .interp
    0x0000000000400254 - 0x0000000000400274 is .note.ABI-tag
    0x0000000000400274 - 0x0000000000400298 is .note.gnu.build-id
    0x0000000000400298 - 0x00000000004002b4 is .gnu.hash
    0x00000000004002b8 - 0x0000000000400318 is .dynsym
       0x0000000000400318 - 0x0000000000400355 is .dynstr
    0x0000000000400318 - 0x0000000000400355 is .dynstr              
    0x0000000000400356 - 0x000000000040035e is .gnu.version
    0x0000000000400360 - 0x0000000000400380 is .gnu.version_r
    0x0000000000400380 - 0x0000000000400398 is .rela.dyn
    0x0000000000400398 - 0x00000000004003e0 is .rela.plt
    0x00000000004003e0 - 0x00000000004003fa is .init
    0x0000000000400400 - 0x0000000000400440 is .plt
    0x0000000000400440 - 0x00000000004005e2 is .text
    0x00000000004005e4 - 0x00000000004005ed is .fini
    0x00000000004005f0 - 0x0000000000400610 is .rodata
    0x0000000000400610 - 0x000000000040065c is .eh_frame_hdr
    0x0000000000400660 - 0x00000000004007b4 is .eh_frame
    0x0000000000600e10 - 0x0000000000600e18 is .init_array
    0x0000000000600e18 - 0x0000000000600e20 is .fini_array
    0x0000000000600e20 - 0x0000000000600e28 is .jcr
    0x0000000000600e28 - 0x0000000000600ff8 is .dynamic
    0x0000000000600ff8 - 0x0000000000601000 is .got
    0x0000000000601000 - 0x0000000000601030 is .got.plt
    0x0000000000601030 - 0x0000000000601034 is .data
    0x0000000000601034 - 0x0000000000601038 is .bss</code></pre>
<h3 id="在文件行号打断点"><a href="#在文件行号打断点" class="headerlink" title="在文件行号打断点"></a><code>在文件行号打断点</code></h3><pre><code>b filename:linenum

(gdb) b    test.c:10
Breakpoint 2 at 0x400549: file test.c, line 10.</code></pre>
<p>文件名重复的时候可以加路径</p>
<h3 id="保存已经设置的断点"><a href="#保存已经设置的断点" class="headerlink" title="保存已经设置的断点"></a><code>保存已经设置的断点</code></h3><pre><code>(gdb) save break b.log
Saved to file &#39;b.log&#39;.

[root@localhost wang]# cat b.log 
break main
break test.c:10

(gdb) source b.log
Breakpoint 1 at 0x40055a: file test.c, line 19.
Breakpoint 2 at 0x400549: file test.c, line 10.</code></pre>
<h3 id="设置临时断点"><a href="#设置临时断点" class="headerlink" title="设置临时断点"></a><code>设置临时断点</code></h3><pre><code>(gdb) tbreak test.c:11
Temporary breakpoint 3 at 0x40054f: file test.c, line 11.</code></pre>
<p>只生效一次</p>
<h3 id="设置条件断点"><a href="#设置条件断点" class="headerlink" title="设置条件断点"></a><code>设置条件断点</code></h3><pre><code>break ... if cond</code></pre>
<p><img src="https://i.loli.net/2020/01/15/ROwuLzfHtKIbjxN.png" alt="break_if.png"></p>
<h3 id="忽略断点"><a href="#忽略断点" class="headerlink" title="忽略断点"></a><code>忽略断点</code></h3><pre><code>ignore breaknum count</code></pre>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">200</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/01/15/kJgmCM6ROB31iVN.png" alt="ignore.png"></p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/01/14/lY7jS6MEm4cxpg9.jpg" alt="545_lit.jpg"></p>
]]></content>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>http协议</title>
    <url>/2020-01-15-http%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><a id="more"></a>


<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2>]]></content>
      <tags>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title>sip协议</title>
    <url>/2020-01-15-sip%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><a id="more"></a>


<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2>]]></content>
      <tags>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx-配置静态网页</title>
    <url>/2020-01-18-nginx-%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>代理服务器配置，待补充</p>
<a id="more"></a>

<h2 id="nginx-conf"><a href="#nginx-conf" class="headerlink" title="nginx.conf"></a>nginx.conf</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">1   # riverferry.site</span><br><span class="line">2  	#user  nobody;</span><br><span class="line">3  	worker_processes  4;</span><br><span class="line">4  </span><br><span class="line">5  	#error_log  logs/error.log;</span><br><span class="line">6  	#error_log  logs/error.log  notice;</span><br><span class="line">7  	#error_log  logs/error.log  info;</span><br><span class="line">8  </span><br><span class="line">9  	#pid        logs/nginx.pid;</span><br><span class="line">10 </span><br><span class="line">11 </span><br><span class="line">12 	events &#123;</span><br><span class="line">13 		worker_connections  1024;</span><br><span class="line">14 	&#125;</span><br><span class="line">15 </span><br><span class="line">16 </span><br><span class="line">17 	http &#123;</span><br><span class="line">18 		include       mime.types;</span><br><span class="line">19 		default_type  application/octet-stream;</span><br><span class="line">20 </span><br><span class="line">21 		log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">22 		#                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">23 		#                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line">24 </span><br><span class="line">25 		access_log  logs/access.log  main;</span><br><span class="line">26 </span><br><span class="line">27 		sendfile        on;</span><br><span class="line">28 		#tcp_nopush     on;</span><br><span class="line">29 </span><br><span class="line">30 		#keepalive_timeout  0;</span><br><span class="line">31 		keepalive_timeout  65;</span><br><span class="line">32 </span><br><span class="line">33 		gzip  on;</span><br><span class="line">34 </span><br><span class="line">35 		server &#123;</span><br><span class="line">36 			listen       8000;</span><br><span class="line">37 			server_name  localhost;</span><br><span class="line">38 </span><br><span class="line">39 			#charset koi8-r;</span><br><span class="line">40 </span><br><span class="line">41 			access_log  logs/host.access.log  main;</span><br><span class="line">42 </span><br><span class="line">43 			location / &#123;</span><br><span class="line">44 			alias  wang/;</span><br><span class="line">45 			autoindex on;</span><br><span class="line">46 				#root   html;</span><br><span class="line">47 				#index  index.html index.htm;</span><br><span class="line">48 			&#125;</span><br><span class="line">49 </span><br><span class="line">50 			#error_page  404              /404.html;</span><br><span class="line">51 </span><br><span class="line">52 			# redirect server error pages to the static page /50x.html</span><br><span class="line">53 			#</span><br><span class="line">54 			error_page   500 502 503 504  /50x.html;</span><br><span class="line">55 			location = /50x.html &#123;</span><br><span class="line">56 				root   html;</span><br><span class="line">57 			&#125;</span><br><span class="line">58 </span><br><span class="line">59 			# proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">60 			#</span><br><span class="line">61 			#location ~ \.php$ &#123;</span><br><span class="line">62 			#    proxy_pass   http://127.0.0.1;</span><br><span class="line">63 			#&#125;</span><br><span class="line">64 </span><br><span class="line">65 			# pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">66 			#</span><br><span class="line">67 			#location ~ \.php$ &#123;</span><br><span class="line">68 			#    root           html;</span><br><span class="line">69 			#    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">70 			#    fastcgi_index  index.php;</span><br><span class="line">71 			#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class="line">72 			#    include        fastcgi_params;</span><br><span class="line">73 			#&#125;</span><br><span class="line">74 </span><br><span class="line">75 			# deny access to .htaccess files, if Apache&#x27;s document root</span><br><span class="line">76 			# concurs with nginx&#x27;s one</span><br><span class="line">77 			#</span><br><span class="line">78 			#location ~ /\.ht &#123;</span><br><span class="line">79 			#    deny  all;</span><br><span class="line">80 			#&#125;</span><br><span class="line">81 		&#125;</span><br><span class="line">82 </span><br><span class="line">83 </span><br><span class="line">84 		# another virtual host using mix of IP-, name-, and port-based configuration</span><br><span class="line">85 		#</span><br><span class="line">86 		#server &#123;</span><br><span class="line">87 		#    listen       8000;</span><br><span class="line">88 		#    listen       somename:8080;</span><br><span class="line">89 		#    server_name  somename  alias  another.alias;</span><br><span class="line">90 </span><br><span class="line">91 		#    location / &#123;</span><br><span class="line">92 		#        root   html;</span><br><span class="line">93 		#        index  index.html index.htm;</span><br><span class="line">94 		#    &#125;</span><br><span class="line">95 		#&#125;</span><br><span class="line">96 </span><br><span class="line">97 </span><br><span class="line">98 		# HTTPS server</span><br><span class="line">99 		#</span><br><span class="line">100		#server &#123;</span><br><span class="line">101		#    listen       443 ssl;</span><br><span class="line">102		#    server_name  localhost;</span><br><span class="line">103</span><br><span class="line">104		#    ssl_certificate      cert.pem;</span><br><span class="line">105		#    ssl_certificate_key  cert.key;</span><br><span class="line">106</span><br><span class="line">107		#    ssl_session_cache    shared:SSL:1m;</span><br><span class="line">108		#    ssl_session_timeout  5m;</span><br><span class="line">109</span><br><span class="line">110		#    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">111		#    ssl_prefer_server_ciphers  on;</span><br><span class="line">112</span><br><span class="line">113		#    location / &#123;</span><br><span class="line">114		#        root   html;</span><br><span class="line">115		#        index  index.html index.htm;</span><br><span class="line">116		#    &#125;</span><br><span class="line">117		#&#125;</span><br><span class="line">118</span><br><span class="line">119	&#125;</span><br><span class="line">120</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="文件路径和索引"><a href="#文件路径和索引" class="headerlink" title="文件路径和索引"></a>文件路径和索引</h2><p>line 44：指定访问的根目录 prefix/wang <br><br>line 45: 使用自动索引</p>
<p><img src="https://i.loli.net/2020/01/18/d5KABiQqHZmSXvE.png" alt="index.png"></p>
<h2 id="设置日志路径和格式"><a href="#设置日志路径和格式" class="headerlink" title="设置日志路径和格式"></a>设置日志路径和格式</h2><p>line 21-25,41</p>
<pre><code>[root@localhost logs]# tailf host.access.log 
192.1.1.1 - - [18/Jan/2020:23:16:20 +0800] &quot;GET / HTTP/1.1&quot; access_loglogs/access.logmain
192.1.1.1 - - [18/Jan/2020:23:16:33 +0800] &quot;GET / HTTP/1.1&quot; access_loglogs/access.logmain
192.1.1.1 - - [18/Jan/2020:23:17:21 +0800] &quot;GET / HTTP/1.1&quot; access_loglogs/access.logmain
192.1.1.1 - - [18/Jan/2020:23:17:34 +0800] &quot;GET / HTTP/1.1&quot; access_loglogs/access.logmain
192.1.1.1 - - [18/Jan/2020:23:17:34 +0800] &quot;GET /favicon.ico HTTP/1.1&quot; access_loglogs/access.logmain
192.1.1.1 - - [18/Jan/2020:23:19:08 +0800] &quot;GET / HTTP/1.1&quot; access_loglogs/access.logmain
192.1.1.1 - - [18/Jan/2020:23:19:08 +0800] &quot;GET /favicon.ico HTTP/1.1&quot; access_loglogs/access.logmain
192.1.1.1 - - [18/Jan/2020:23:19:20 +0800] &quot;GET / HTTP/1.1&quot; access_loglogs/access.logmain
192.1.1.1 - - [18/Jan/2020:23:23:11 +0800] &quot;GET / HTTP/1.1&quot; access_loglogs/access.logmain
192.1.1.1 - - [18/Jan/2020:23:23:11 +0800] &quot;GET / HTTP/1.1&quot; access_loglogs/access.logmain</code></pre>
<p><code>日志备份</code></p>
<p>nginx -s reopen 重新打开日志</p>
<h2 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h2><p>line 33</p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/01/18/V7sJ1QMloh3k8Op.jpg" alt="cute-little.jpg"></p>
]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>epoll的原理</title>
    <url>/2020-02-26-epoll%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/63179839">游戏研究院</a></p>
<p><a href="https://www.jianshu.com/p/ee381d365a29">Epoll的使用详解</a></p>
<p><a href="http://gityuan.com/2019/01/06/linux-epoll/">源码解读epoll内核机制</a></p>
<a id="more"></a>

<h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p><code>select原理</code></p>
<p>图片来源： <a href="https://zhuanlan.zhihu.com/p/63179839">游戏研究院</a></p>
<p><img src="https://i.loli.net/2020/03/07/DsIwYzcTWJxjnqH.jpg" alt="select_1.jpg"></p>
<p><img src="https://i.loli.net/2020/03/07/fp2d4V9mlMrTNU8.jpg" alt="select_2.jpg"></p>
<p>select将进程信息保存在每个需要监视的fd的等待列表中，当任何一个fd有读写事件发生，都会触发中断处理程序进行处理，包括将网卡中数据拷贝到内核空间，以及进行进程调度，让等待的进程优先执行</p>
<p>这里存在几个问题：</p>
<ul>
<li>select函数每次执行前，需要修改FD_SET结构体，更新监视的句柄，每次都要把进程信息加到所有句柄的等待队列中，涉及一次遍历</li>
<li>当select从阻塞状态唤醒，也需要遍历确认是哪个句柄上有动静</li>
<li>要传递所有的fd给内核</li>
</ul>
<hr>
<p><code>epoll_create</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create1</span><span class="params">(<span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<pre><code>   epoll_create() creates a new epoll(7) instance.  Since Linux 2.6.8,
   the size argument is ignored, but must be greater than zero; see
   NOTES below.

   epoll_create() returns a file descriptor referring to the new epoll
   instance.  This file descriptor is used for all the subsequent calls
   to the epoll interface.  When no longer required, the file descriptor
   returned by epoll_create() should be closed by using close(2).  When
   all file descriptors referring to an epoll instance have been closed,
   the kernel destroys the instance and releases the associated
   resources for reuse.</code></pre>
<hr>
<p><code>epoll函数</code></p>
<p><code>epoll_ctl</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<pre><code>   This system call is used to add, modify, or remove entries in the
   interest list of the epoll(7) instance referred to by the file
   descriptor epfd.  It requests that the operation op be performed for
   the target file descriptor, fd.

   Valid values for the op argument are:

   EPOLL_CTL_ADD
          Add fd to the interest list and associate the settings
          specified in event with the internal file linked to fd.

   EPOLL_CTL_MOD
          Change the settings associated with fd in the interest list to
          the new settings specified in event.

   EPOLL_CTL_DEL
          Remove (deregister) the target file descriptor fd from the
          interest list.  The event argument is ignored and can be NULL
          (but see BUGS below).</code></pre>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>        *ptr;</span><br><span class="line">    <span class="keyword">int</span>          fd;</span><br><span class="line">    <span class="keyword">uint32_t</span>     u32;</span><br><span class="line">    <span class="keyword">uint64_t</span>     u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>events这个参数是一个字节的掩码构成的。下面是可以用的事件：</p>
<ul>
<li>EPOLLIN - 当关联的文件可以执行 read ()操作时。</li>
<li>EPOLLOUT - 当关联的文件可以执行 write ()操作时。</li>
<li>EPOLLRDHUP - (从 linux 2.6.17 开始)当socket关闭的时候，或者半关闭写段的(当使用边缘触发的时候，这个标识在写一些测试代码去检测关闭的* 时候特别好用)</li>
<li>EPOLLPRI - 当 read ()能够读取紧急数据的时候。</li>
<li>EPOLLERR - 当关联的文件发生错误的时候，epoll_wait() 总是会等待这个事件，并不是需要必须设置的标识。</li>
<li>EPOLLHUP - 当指定的文件描述符被挂起的时候。epoll_wait() 总是会等待这个事件，并不是需要必须设置的标识。当socket从某一个地方读取数据的时候(管道或者socket),这个事件只是标识出这个已经读取到最后了(EOF)。所有的有效数据已经被读取完毕了，之后任何的读取都会返回0(EOF)。</li>
<li>EPOLLET - 设置指定的文件描述符模式为边缘触发，默认的模式是水平触发。</li>
<li>EPOLLONESHOT - (从 linux 2.6.17 开始)设置指定文件描述符为单次模式。这意味着，在设置后只会有一次从epoll_wait() 中捕获到事件，之后你必须要重新调用 epoll_ctl() 重新设置。</li>
</ul>
<p>返回值：如果成功，返回0。如果失败，会返回-1， errno将会被设置</p>
<p>有以下几种错误：</p>
<ul>
<li>EBADF - epfd 或者 fd 是无效的文件描述符。</li>
<li>EEXIST - op是EPOLL_CTL_ADD，同时 fd 在之前，已经被注册到epoll中了。</li>
<li>EINVAL - epfd不是一个epoll描述符。或者fd和epfd相同，或者op参数非法。</li>
<li>ENOENT - op是EPOLL_CTL_MOD或者EPOLL_CTL_DEL，但是fd还没有被注册到epoll上。</li>
<li>ENOMEM - 内存不足。</li>
<li>EPERM - 目标的fd不支持epoll。</li>
</ul>
<hr>
<p><code>epoll_wait</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events,<span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//epoll_pwait() 在内核版本 2.6.19 加入。glibc 从版本 2.6 开始支持。 增加了信号的处理</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_pwait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events,<span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout, </span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">const</span> <span class="keyword">sigset_t</span> *sigmask)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<pre><code>   The epoll_wait() system call waits for events on the epoll(7)
   instance referred to by the file descriptor epfd.  The memory area
   pointed to by events will contain the events that will be available
   for the caller.  Up to maxevents are returned by epoll_wait().  The
   maxevents argument must be greater than zero.

   The timeout argument specifies the number of milliseconds that
   epoll_wait() will block.  Time is measured against the
   CLOCK_MONOTONIC clock.  The call will block until either:

   *  a file descriptor delivers an event;

   *  the call is interrupted by a signal handler; or

   *  the timeout expires.</code></pre>
<p><img src="https://i.loli.net/2020/03/07/BUrIsdH9ARptzJu.png" alt="eventpoll.png"></p>
<p>epoll_create的过程主要是创建并初始化数据结构eventpoll，以及创建file实例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mtx</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> wq; <span class="comment">//sys_epoll_wait（）使用的等待队列</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> poll_wait; <span class="comment">//file-&gt;poll()使用的等待队列</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllist</span>;</span> <span class="comment">//所有准备就绪的文件描述符列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">rbr</span>;</span> <span class="comment">//用于储存已监控fd的红黑树根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当正在向用户空间传递事件，则就绪事件会临时放到该队列，否则直接放到rdllist</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">ovflist</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wakeup_source</span> *<span class="title">ws</span>;</span> <span class="comment">// 当ep_scan_ready_list运行时使用wakeup_source</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span> <span class="comment">//创建eventpoll描述符的用户</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="keyword">int</span> visited;           <span class="comment">//用于优化循环检测检查</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">visited_list_link</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rbn</span>;</span> <span class="comment">//RB树节点将此结构链接到eventpoll RB树</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span> <span class="comment">//用于释放结构体epitem</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllink</span>;</span> <span class="comment">//用于将此结构链接到eventpoll就绪列表的列表标头</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">next</span>;</span> <span class="comment">//配合ovflist一起使用来保持单向链的条目</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span> <span class="title">ffd</span>;</span> <span class="comment">//此条目引用的文件描述符信息</span></span><br><span class="line">    <span class="keyword">int</span> nwait; <span class="comment">//附加到poll轮询中的活跃等待队列数</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pwqlist</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span>  <span class="comment">//epi所属的ep</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">fllink</span>;</span> <span class="comment">//链接到file条目列表的列表头</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wakeup_source</span> __<span class="title">rcu</span> *<span class="title">ws</span>;</span> <span class="comment">//设置EPOLLWAKEUP时使用的wakeup_source</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span> <span class="comment">//监控的事件和文件描述符</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p><code>就绪队列</code></p>
<p>rdllist是用于存储就绪的fd信息，使用双向链表删除，插入效率高</p>
<p><code>索引结构</code></p>
<p>红黑树是自平衡二叉查找树，搜索，插入，删除效率高。在epoll_ctrl添加监听fd的时候能够快速判断是否已经存在，以及快速插入，或者移除</p>
<hr>
<p><a href="http://gityuan.com/2019/01/06/linux-epoll/">源码解读epoll内核机制</a></p>
<p>ep_poll_callback()：目标fd的就绪事件到来时，将epi-&gt;rdllink加入ep-&gt;rdllist的队列，导致rdlist不空，从而进程被唤醒，epoll_wait得以继续执行。</p>
<p>到epoll_wait()，从队列中移除wait，再将传输就绪事件到用户空间。</p>
<p>epoll比select更高效的一点是：epoll监控的每一个文件fd就绪事件触发，导致相应fd上的回调函数ep_poll_callback()被调用</p>
<p>select poll epoll这三个都是对poll机制的封装</p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/03/01/IVkWzmdH81NxXaT.jpg" alt="tumblr_p48vtlizBP1sfie3io1_1280.jpg"></p>
]]></content>
      <tags>
        <tag>epoll</tag>
      </tags>
  </entry>
  <entry>
    <title>同步,异步,阻塞,非阻塞</title>
    <url>/2020-02-26-%E5%90%8C%E6%AD%A5,%E5%BC%82%E6%AD%A5,%E9%98%BB%E5%A1%9E,%E9%9D%9E%E9%98%BB%E5%A1%9E/</url>
    <content><![CDATA[<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul>
<li><p><code>NIO(Non-blocked IO)</code></p>
</li>
<li><p><code>BIO(blocked IO)</code></p>
</li>
<li><p><code>AIO(asynchronous I/O)</code></p>
</li>
</ul>
<a id="more"></a>

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="阻塞-非阻塞"><a href="#阻塞-非阻塞" class="headerlink" title="阻塞/非阻塞"></a>阻塞/非阻塞</h3><p>阻塞和非阻塞说的是程序在等待调用结果时的状态，取决与CPU会不会在进程时间片未用尽的情况下进行进程切换，将进程变成非运行状态(挂起进程)。</p>
<p><code>阻塞调用</code></p>
<p><img src="https://i.loli.net/2020/02/26/4MtLJBV3UehfgTn.jpg" alt="阻塞.jpg"></p>
<p>accept队列为空的时候，进程被挂起，等accept队列不为空了，cpu再唤醒进程</p>
<p><code>非阻塞调用</code></p>
<p>不管accept队列内部情况，每次系统调用accept函数都会立即得到一个返回值，进程不会被挂起</p>
<p><img src="https://i.loli.net/2020/02/26/F17R29ZqcfEBsNn.jpg" alt="非阻塞.jpg"></p>
<p>可能阻塞的系统调用：</p>
<ul>
<li>输入操作：read, readv, recv, recvfrom, recvmsg</li>
<li>输出操作：write, writev, send, sendto, sendmsg</li>
<li>接收外来连接：accept</li>
<li>发起外出连接：connect</li>
</ul>
<h3 id="阻塞IO-非阻塞IO"><a href="#阻塞IO-非阻塞IO" class="headerlink" title="阻塞IO/非阻塞IO"></a>阻塞IO/非阻塞IO</h3><p>因为IO操作导致的进程被cpu挂起，唤醒即是阻塞IO和非阻塞IO <br></p>
<hr>
<h3 id="同步-异步"><a href="#同步-异步" class="headerlink" title="同步/异步"></a>同步/异步</h3><p><code>同步：</code> A发出一个’请求’后，一直等待，直到请求执行结束，得到请求的返回值(B发来的)</p>
<p><code>异步：</code> A发出一个’请求’后，直接返回，此时并不知道执行的结果/返回值。等其他地方(B)处理请求完成后，把结果主动发过来(A通过回调之类的方法去获取)，这个时候A才认为请求执行完成</p>
<h3 id="同步IO-异步IO"><a href="#同步IO-异步IO" class="headerlink" title="同步IO/异步IO"></a>同步IO/异步IO</h3><p><img src="https://i.loli.net/2020/02/26/uYNOg2J6jFiXxLA.jpg" alt="异步IO.jpg"></p>
<p>异步IO在poxis中的规定： 告诉内核启动某个操作(包括将数据从内核态复制到用户态)完成后通知我们。 <br><br>需要注意的是同步IO需要进程主动将数据从内核空间拷贝到用户空间，异步则是从内核空间拷贝到用户空间完成后才通知进程。 <br><br>信号驱动IO就是同步的，因为是内核通知我们何时可以启动IO操作，但IO操作(内核-用户)还未开始 <br></p>
<p>POXIS中的术语：</p>
<p><code>同步IO操作：</code> 导致请求进程阻塞，直到IO操作完成</p>
<p><code>异步IO操作：</code> 不导致请求进程阻塞</p>
<h3 id="5种IO的对比"><a href="#5种IO的对比" class="headerlink" title="5种IO的对比"></a>5种IO的对比</h3><p><img src="https://i.loli.net/2020/02/26/c7TnmVRwSrADYW9.jpg" alt="5种IO.jpg"></p>
<hr>
<h3 id="ET触发下，为什么一定要是非阻塞"><a href="#ET触发下，为什么一定要是非阻塞" class="headerlink" title="ET触发下，为什么一定要是非阻塞"></a>ET触发下，为什么一定要是非阻塞</h3><p>边缘触发下，用阻塞模型会存在功能上的问题，所以要用非阻塞 <br><br>当阻塞模式下，recv会一直阻塞接受数据，如果没有一次读取完成所有的数据，ET是边缘触发，只能触发一次epoll_wait更新，剩下的未读取完成的数据就不能继续读入了，除非网络另一端发来新的消息。 <br><br>同样的，如果一次没有写完，则其他待发送数据，只能等到新的写请求才能触发。所以ET再非阻塞模式下要求循环把数据读取完成。</p>
<h3 id="ET触发下，accept问题"><a href="#ET触发下，accept问题" class="headerlink" title="ET触发下，accept问题"></a>ET触发下，accept问题</h3><p>accept事件一次只能从syn就绪队列中取一个放进accept队列，如果同一时刻有多个就绪连接，只accept一次，剩下的连接在下一次epoll_wait也不会触发，LT模式下就没问题</p>
<p>ET模式下，不管阻塞还是非阻塞，都要一次把所有的就绪队列accept成功。可以使用循环。<br><br><a href="https://www.zhihu.com/question/23614342">使用epoll时需要将socket设为非阻塞吗？</a></p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/02/26/QU2bC314ig65HBk.jpg" alt="图像 006_2.jpg"></p>
]]></content>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-中断和异常</title>
    <url>/2020-02-28-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>主要参考了：陈向群操作系统</p>
<p><strong>图1:</strong></p>
<p><img src="https://i.loli.net/2020/02/28/pRhGSbaUJCmwzTM.jpg" alt="操作系统.jpg"></p>
<a id="more"></a>

<h3 id="处理器的概念"><a href="#处理器的概念" class="headerlink" title="处理器的概念"></a>处理器的概念</h3><p>处理器由<code>运算器</code>、<code>控制器</code>、一系列的<code>寄存器以及高速缓存</code>构成</p>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>寄存器分为用户可见寄存器，<code>控制和状态寄存器</code> <br></p>
<p><code>常见的控制和状态寄存器:</code></p>
<ul>
<li>程序计数器（PC：Program Counter），记录将要取出的指令的地址  </li>
<li>指令寄存器（IR：Instruction Register），记录最近取出的指令</li>
<li>程序状态字（PSW：Program Status Word），记录处理器的运行状态如条件码、模式、控制位等信息</li>
</ul>
<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p><code>操作系统的两种状态：</code></p>
<ul>
<li>内核态(Kernel Mode)：运行操作系统程序</li>
<li>用户态(User Mode)：运行用户程序</li>
</ul>
<h3 id="CPU状态的转换"><a href="#CPU状态的转换" class="headerlink" title="CPU状态的转换"></a>CPU状态的转换</h3><p><code>用户态 → 内核态:</code> <br></p>
<blockquote>
<p>唯一途径 → 中断/异常/陷入机制</p>
</blockquote>
<p><code>内核态 → 用户态:</code> <br></p>
<blockquote>
<p>设置程序状态字PSW</p>
</blockquote>
<h3 id="陷入指令-访管指令"><a href="#陷入指令-访管指令" class="headerlink" title="陷入指令(访管指令)"></a>陷入指令(访管指令)</h3><p>提供给用户程序的接口，用于调用操作系统的功能（服务） <br><br>例如：int，trap，syscall，sysenter/sysexit</p>
<hr>
<h2 id="中断异常机制"><a href="#中断异常机制" class="headerlink" title="中断异常机制"></a>中断异常机制</h2><p><code>中断异常的概念：</code> <br></p>
<ul>
<li>CPU对系统发生的某个事件作出的一种反应</li>
<li>CPU暂停正在执行的程序，保留现场后自动转去执行相应事件的处理程序，处理完成后返回断点，继续执行被打断的程序</li>
</ul>
<p><code>中断的引入:为了支持CPU和设备之间的并行操作</code> <br><br>    当CPU启动设备进行输入/输出后，设备便可以独立工作，CPU转去处理与此次输入/输出不相关的事情；当设备完成输入/输出后，通过向CPU发中断报告此次输入/输出的结果，让CPU决定如何处理以后的事情</p>
<p><code>异常的引入：表示CPU执行指令时本身出现的问题</code> <br><br>    如算术溢出、除零、取数时的奇偶错，访存地址时越界或执行了“陷入指令” 等，这时硬件改变了CPU当前的执行流程，转到相应的错误处理程序或异常处理程序或执行系统调用</p>
<p><strong>图2:</strong></p>
<p><img src="https://i.loli.net/2020/02/28/mwL4CqnH7oPATRS.jpg" alt="中断分类.jpg"></p>
<p><code>硬件和软件的角色：</code> <br></p>
<ul>
<li>硬件：捕获中断源发出的中断/异常请求，以一定方式响应，将处理器控制权交给特定的处理程序</li>
<li>软件：识别中断/异常类型并完成相应的处理 </li>
</ul>
<p><strong>图3:</strong></p>
<p><img src="https://i.loli.net/2020/02/28/QHXS4youKkrwZLP.jpg" alt="中断异常小结.jpg"></p>
<p><code>中断向量:</code> <br><br>一个内存单元，存放中断处理<code>程序入口地址</code>和程序运行时所需的<code>处理机状态字</code></p>
<p><code>中断处理程序步骤：</code> <br><br>系统运行时若响应中断，中断硬件部件将CPU控制权转给中断处理程序: <br></p>
<ul>
<li>保存相关寄存器信息</li>
<li>分析中断/异常的具体原因</li>
<li>执行对应的处理功能</li>
<li>恢复现场，返回被事件打断的程序</li>
</ul>
<p><strong>图4:</strong></p>
<p><img src="https://i.loli.net/2020/02/28/oA8sHjQX1O3d2WE.jpg" alt="中断响应过程示意.jpg"></p>
<hr>
<h2 id="x86处理器对于中断的处理"><a href="#x86处理器对于中断的处理" class="headerlink" title="x86处理器对于中断的处理"></a>x86处理器对于中断的处理</h2><p><strong>图5:</strong></p>
<p><img src="https://i.loli.net/2020/02/28/k6gVUCBpcdv1YTf.jpg" alt="x86_1.jpg"></p>
<p><strong>图6:</strong></p>
<p><img src="https://i.loli.net/2020/02/28/VfIwhxsJ4lvQc52.jpg" alt="x86_2.jpg"></p>
<p><code>中断/异常的硬件处理过程:</code> </p>
<ul>
<li>确定与中断或异常关联的向量i</li>
<li>通过IDTR寄存器找到IDT表，获得中断描述符（表中的第i项）</li>
<li>从GDTR寄存器获得GDT的地址；结合中断描述符中的段选择符，在GDT表获取对应的段描述符；从该段描述符中得到中断或异常处理程序所在的段基址</li>
<li>特权级检查</li>
<li>检查是否发生了特权级的变化，如果是，则进行堆栈切换(必须使用与新的特权级相关的栈)</li>
<li>硬件压栈，保存上下文环境；如果异常产生了硬件出错码，也将它保存在栈中</li>
<li>如果是中断，清IF位</li>
<li>通过中断描述符中的段内偏移量和段描述符中的基地址，找到中断/异常处理程序的入口地址，执行其第一条指令</li>
</ul>
<hr>
<h2 id="系统调用机制"><a href="#系统调用机制" class="headerlink" title="系统调用机制"></a>系统调用机制</h2><p><strong>图7:</strong></p>
<p><img src="https://i.loli.net/2020/02/28/Rlt569NbcHzDUyr.jpg" alt="系统调用1.jpg"></p>
<p><strong>图8:</strong></p>
<p><img src="https://i.loli.net/2020/02/28/t47wKvklYQ15ZuC.jpg" alt="系统调用2.jpg"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;Hello World\n&quot;</span>, <span class="number">12</span>); <span class="comment">/* write &quot;Hello World&quot; to stdout */</span></span><br><span class="line">    _exit(<span class="number">0</span>);                      <span class="comment">/* exit with error code 0 (no error) */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>x86架构常用int 0x80 指令作为陷入指令，x86_64多用 syscall指令</p>
<p><a href="https://en.wikibooks.org/wiki/X86_Assembly/Interfacing_with_Linux">链接</a></p>
<p><a href="https://stackoverflow.com/questions/2535989/what-are-the-calling-conventions-for-unix-linux-system-calls-on-i386-and-x86-6">链接</a></p>
<h3 id="x86-汇编"><a href="#x86-汇编" class="headerlink" title="x86 汇编"></a>x86 汇编</h3><p><code>In x86-32 parameters for Linux system call are passed using registers. %eax for syscall_number. %ebx, %ecx, %edx, %esi, %edi, %ebp are used for passing 6 parameters to system calls.</code> <br></p>
<blockquote>
<p>在x86-32中，使用寄存器传递用于Linux系统调用的参数。%eax用于syscall_number。％ebx，％ecx，％edx，％esi，％edi，％ebp用于将6个参数传递给系统调用。</p>
</blockquote>
<p><code>The return value is in %eax. All other registers (including EFLAGS) are preserved across the int $0x80.</code> <br></p>
<blockquote>
<p>返回值为in %eax。所有其他寄存器（包括EFLAGS）都保留在内int $0x80。</p>
</blockquote>
<pre><code>_start:
    movl $4, %eax   ; use the write syscall
    movl $1, %ebx   ; write to stdout
    movl $msg, %ecx ; use string &quot;Hello World&quot;
    movl $12, %edx  ; write 12 characters
    int $0x80       ; make syscall

    movl $1, %eax   ; use the _exit syscall
    movl $0, %ebx   ; error code 0
    int $0x80       ; make syscall</code></pre>
<h3 id="x86-64-汇编"><a href="#x86-64-汇编" class="headerlink" title="x86_64 汇编"></a>x86_64 汇编</h3><p>1 <code>User-level applications use as integer registers for passing the sequence %rdi, %rsi, %rdx, %rcx, %r8 and %r9. The kernel interface uses %rdi, %rsi, %rdx, %r10, %r8 and %r9.</code> <br></p>
<blockquote>
<p>用户级应用程序用作整数寄存器，以传递序列％rdi，％rsi，％rdx，％rcx，％r8和％r9。内核接口使用％rdi，％rsi，％rdx，％r10，％r8和％r9。</p>
</blockquote>
<p>2 <code>A system-call is done via the syscall instruction. This clobbers %rcx and %r11 as well as the %rax return value, but other registers are preserved.</code> <br></p>
<blockquote>
<p>通过syscall指令进行系统调用。此副本％rcx和％r11以及％rax返回值，但是保留了其他寄存器。</p>
</blockquote>
<p>3 <code>The number of the syscall has to be passed in register %rax.</code> <br></p>
<blockquote>
<p>系统调用的编号必须在寄存器％rax中传递。</p>
</blockquote>
<p>4 <code>System-calls are limited to six arguments, no argument is passed directly on the stack.</code> <br></p>
<blockquote>
<p>系统调用仅限于六个参数，没有参数直接在堆栈上传递。</p>
</blockquote>
<p>5 <code>Returning from the syscall, register %rax contains the result of the system-call. A value in the range between -4095 and -1 indicates an error, it is -errno.</code> <br></p>
<blockquote>
<p>从系统调用返回，寄存器％rax包含系统调用的结果。介于-4095到-1之间的值表示错误，它是-errno。</p>
</blockquote>
<p>6 <code>Only values of class INTEGER or class MEMORY are passed to the kernel.</code> <br></p>
<blockquote>
<p>仅将类INTEGER或类MEMORY的值传递到内核。</p>
</blockquote>
<pre><code>_start:
    movq $1, %rax   ; use the write syscall
    movq $1, %rdi   ; write to stdout
    movq $msg, %rsi ; use string &quot;Hello World&quot;
    movq $12, %rdx  ; write 12 characters
    syscall         ; make syscall

    movq $60, %rax  ; use the _exit syscall
    movq $0, %rdi   ; error code 0
    syscall         ; make syscall</code></pre>
<hr>
<h3 id="从trap指令来看系统调用的过程"><a href="#从trap指令来看系统调用的过程" class="headerlink" title="从trap指令来看系统调用的过程"></a>从trap指令来看系统调用的过程</h3><p><a href="https://books.google.com/books?id=UYajDwAAQBAJ&pg=PT354&lpg=PT354&dq=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F++%E9%99%B7%E5%85%A5%E6%8C%87%E4%BB%A4&source=bl&ots=FUvj4XBDlB&sig=ACfU3U3dFn8CcwlZEdsc4cNwgvJLyy8NGA&hl=zh-CN&sa=X&ved=2ahUKEwjK28ym_vHnAhV4ITQIHbT8AqYQ6AEwB3oECAoQAQ#v=onepage&q=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20%20%E9%99%B7%E5%85%A5%E6%8C%87%E4%BB%A4&f=false">操作系统</a></p>
<p>设用户进程A在运行中要向已打开的文件写一批数据，为此再用户C源程序中可用如下系统调用语句：<br><br>rw = write(fd, buf, count);</p>
<p>这条语句编译后的汇编指令： </p>
<pre><code>trap4
参数1
参数2
参数3
k1:....</code></pre>
<p>其中，参数1，2，3分别对应该文件的文件描述符fd,用户信息所在内存始址buf,传送字节数count.这个系统调用的过程如下7步：</p>
<p>1 CPU执行到trap4指令时，产生陷入事件，硬件做出中断响应：保留进程A的PSW和PC的值，取中断向量并放入寄存器(PSW,PC)中。程序控制转向一段核心代码，将进程状态改为核心态。进一步保留现场信息(各通用寄存器的值)，然后进入统一的处理程序trap中，trap程序根据系统低矮用号4查找到系统调用入口表，得到相应处理子程序的入口地址write</p>
<p>2 转入文件系统管理。根据文件描述符fd找到该文件的控制结构-活动I节点，进行权限验证 等操作之后，如果都合法，则调用相应的核心程序将文件的逻辑地址映射到物理块号。再申请和分配缓冲区，将进程A内存区BUF中的信息传送到所分配的缓冲区中。然后，经由内部控制结构(即块设备转接表)进入设备驱动程序。</p>
<p>3 启动设备驱动程序(即磁盘驱动程序)，将缓冲区中的信息写道想用的盘块中。在进行磁盘IO工作时，进程A要等待IO完成，所以进程A让出CPU，处于睡眠状态</p>
<p>4 处理机管理和调用工作。进程调度程序从就绪队列中选中一个合适的进程。例如B,为它恢复现场，使其在CPU上运行。此时CPU在进程B的用户空间运行</p>
<p>5 当写盘工作完成后(即缓冲区的信息都传送到盘块上)磁盘控制器发生IO中断信号。该信号终止进程B的继续运行，硬件做出中断响应，然后转入磁盘中断处理程序</p>
<p>6 磁盘中断处理程序运行。它验证中断来源，如传输无错，则唤醒因等待IO而睡眠的进程A</p>
<p>7 设进程A比进程B的优先级高，则中断处理程序完成后，执行进程调度程序。选中进程A，为进程A恢复现场，然后进程A的程序接着向下执行</p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/02/28/9F3bnxgqRtrdm5W.jpg" alt="tumblr_pd5u6bUYXH1sfie3io1_1280.jpg"></p>
]]></content>
      <tags>
        <tag>OperatingSystem</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-编译链接</title>
    <url>/2020-02-28-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>主要参考了：陈向群操作系统, 程序员的自我修养</p>
<p><a href="https://github.com/tinyclub/open-c-book/blob/master/zh/chapters/02-chapter2.markdown">Gcc 编译的背后</a></p>
<p><a href="http://cnblogs.com/qytan36/archive/2010/05/25/1743955.html">GCC编程四个过程:预处理-编译-汇编-链接</a></p>
<a id="more"></a>

<h3 id="helloworld程序的运行过程"><a href="#helloworld程序的运行过程" class="headerlink" title="helloworld程序的运行过程"></a>helloworld程序的运行过程</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="built_in">puts</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>用户告诉操作系统执行helloworld程序</li>
<li>操作系统：找到helloworld程序的相关信息，检查其类型是否是<code>可执行文件</code>；并通过程序首部信息，确定代码和数据在可执行文件中的位置并计算出对应的磁盘块地址</li>
<li>操作系统：创建一个新的进程，并将helloworld可执行文件映射到该进程结构，表示由该进程执行helloworld程序</li>
<li>操作系统：为helloworld程序设置CPU上下文环境，并跳到程序开始处</li>
<li>执行helloworld程序的第一条指令，发生缺页异常</li>
<li>操作系统：分配一页物理内存，并将代码从磁盘读入内存，然后继续执行helloworld程序</li>
<li>helloworld程序执行puts函数（系统调用），在显示器上写一字符串</li>
<li>操作系统：找到要将字符串送往的显示设备，通常设备是由一个进程控制的，所以，操作系统将要写的字符串送给该进程</li>
<li>操作系统：控制设备的进程告诉设备的窗口系统它要显示字符串，窗口系统确定这是一个合法的操作，然后将字符串转换成像素，将像素写入设备的存储映像区</li>
<li>视频硬件将像素转换成显示器可接收的一组控制/数据信号</li>
<li>显示器解释信号，激发液晶屏</li>
<li>OK！！！我们在屏幕上看到了“hello world”</li>
</ul>
<h3 id="操作系统的5大功能-从资源管理的角度"><a href="#操作系统的5大功能-从资源管理的角度" class="headerlink" title="操作系统的5大功能(从资源管理的角度)"></a>操作系统的5大功能(从资源管理的角度)</h3><p>1 <code>进程/线程管理</code>（CPU管理）<br><br>进程线程状态、控制、同步互斥、通信、调度、……</p>
<p>2 <code>存储管理</code> <br><br>分配/回收、地址转换、存储保护、内存扩充、……</p>
<p>3 <code>文件管理</code> <br><br>文件目录、文件操作、磁盘空间、文件存取控制、……</p>
<p>4 <code>设备管理</code> <br><br>设备驱动、分配回收、缓冲技术、……</p>
<p>5 <code>用户接口</code> <br><br>系统命令、编程接口</p>
<h3 id="操作系统的主要特征"><a href="#操作系统的主要特征" class="headerlink" title="操作系统的主要特征"></a>操作系统的主要特征</h3><p>1 <code>并发</code></p>
<p>2 <code>共享</code></p>
<p>3 <code>虚拟</code></p>
<p>4 <code>随机/异常</code></p>
<h3 id="linux内核组件"><a href="#linux内核组件" class="headerlink" title="linux内核组件"></a>linux内核组件</h3><p><img src="https://i.loli.net/2020/02/28/UYi4z9gFhcR8e7d.jpg" alt="linux_kernel.jpg"></p>
<hr>
<h2 id="可执行文件的装载与进程"><a href="#可执行文件的装载与进程" class="headerlink" title="可执行文件的装载与进程"></a>可执行文件的装载与进程</h2><p><code>可执行文件:</code> </p>
<pre><code>[root@localhost bin]# file cgdb
cgdb: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs)
for GNU/Linux 2.6.32, BuildID[sha1]=0x7e94e0eb5975bd6a1eb4c7a8c0af6b77475f4362, not stripped

[root@localhost bin]# file ShadowsocksR-dotnet2.0.exe
ShadowsocksR-dotnet2.0.exe: PE32 executable (GUI) Intel 80386 Mono/.Net assembly,for MS Windows</code></pre>
<p><code>进程的建立：</code> <br></p>
<ul>
<li>创建一个独立的虚拟地址空间(页目录)  <code>虚拟空间和物理内存的映射关系</code></li>
<li>读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系 <code>虚拟空间和可执行文件的映射关系</code></li>
<li>将CPU的指令寄存器设置成可执行文件的入口地址，启动运行</li>
</ul>
<blockquote>
<p>可执行文件在装载时实际是被映射的虚拟空间，所以可执行文件很多时候又被叫做映像文件</p>
</blockquote>
<h3 id="gcc编译的四步"><a href="#gcc编译的四步" class="headerlink" title="gcc编译的四步"></a>gcc编译的四步</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;hello, it,s me!&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="预处理阶段"><a href="#预处理阶段" class="headerlink" title="预处理阶段"></a><code>预处理阶段</code></h4><blockquote>
<p>头文件的包含，宏定义的扩展，条件编译的选择</p>
</blockquote>
<pre><code>gcc -E test.c -o test.i</code></pre>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;test.c&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;built-in&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;命令行&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/usr/include/stdc-predef.h&quot;</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;命令行&gt;&quot;</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;test.c&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/usr/include/stdio.h&quot;</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">27</span> <span class="string">&quot;/usr/include/stdio.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/usr/include/features.h&quot;</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">375</span> <span class="string">&quot;/usr/include/features.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/usr/include/sys/cdefs.h&quot;</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">392</span> <span class="string">&quot;/usr/include/sys/cdefs.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/usr/include/bits/wordsize.h&quot;</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">393</span> <span class="string">&quot;/usr/include/sys/cdefs.h&quot;</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">376</span> <span class="string">&quot;/usr/include/features.h&quot;</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">399</span> <span class="string">&quot;/usr/include/features.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/usr/include/gnu/stubs.h&quot;</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">10</span> <span class="string">&quot;/usr/include/gnu/stubs.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/usr/include/gnu/stubs-64.h&quot;</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">11</span> <span class="string">&quot;/usr/include/gnu/stubs.h&quot;</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">400</span> <span class="string">&quot;/usr/include/features.h&quot;</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">28</span> <span class="string">&quot;/usr/include/stdio.h&quot;</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/stddef.h&quot;</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">212</span> <span class="string">&quot;/usr/lib/gcc/x86_64-redhat-linux/4.8.5/include/stddef.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">size_t</span>;</span><br><span class="line"># <span class="number">34</span> <span class="string">&quot;/usr/include/stdio.h&quot;</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/usr/include/bits/types.h&quot;</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">27</span> <span class="string">&quot;/usr/include/bits/types.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/usr/include/bits/wordsize.h&quot;</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">28</span> <span class="string">&quot;/usr/include/bits/types.h&quot;</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> __u_char;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> __u_short;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> __u_int;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> __u_long;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">char</span> <span class="keyword">__int8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="keyword">__uint8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="keyword">__int16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="keyword">__uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">int</span> <span class="keyword">__int32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">__uint32_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="keyword">__int64_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="keyword">__uint64_t</span>;</span><br><span class="line"></span><br><span class="line">---------------省略一大部分内容------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------省略一大部分内容------------------------------</span><br><span class="line"></span><br><span class="line"># <span class="number">2</span> <span class="string">&quot;test.c&quot;</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">puts</span>(<span class="string">&quot;hello, it,s me!&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a><code>编译阶段</code></h4><blockquote>
<p>词法分析，语法分析，将源文件代码转为中间汇编代码</p>
</blockquote>
<pre><code>gcc -S test.i -o test.s</code></pre>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">	.file	<span class="string">&quot;test.c&quot;</span></span><br><span class="line">	.section	.rodata</span><br><span class="line">.LC0:</span><br><span class="line">	.<span class="built_in">string</span>	<span class="string">&quot;hello, it,s me!&quot;</span></span><br><span class="line">	.text</span><br><span class="line">	.globl	main</span><br><span class="line">	.type	main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line">	.cfi_startproc</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	.cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">	.cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	.cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">	movl	$.LC0, %edi</span><br><span class="line">	call	<span class="built_in">puts</span></span><br><span class="line">	movl	$<span class="number">0</span>, %eax</span><br><span class="line">	popq	%rbp</span><br><span class="line">	.cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">	ret</span><br><span class="line">	.cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">	.size	main, .-main</span><br><span class="line">	.ident	<span class="string">&quot;GCC: (GNU) 4.8.5 20150623 (Red Hat 4.8.5-36)&quot;</span></span><br><span class="line">	.section	.note.GNU-<span class="built_in">stack</span>,<span class="string">&quot;&quot;</span>,@progbits</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="汇编阶段"><a href="#汇编阶段" class="headerlink" title="汇编阶段"></a><code>汇编阶段</code></h4><blockquote>
<p>将汇编代码翻译为目标代码(机器代码),即二进制文件</p>
</blockquote>
<pre><code>gcc -c test.s -o test.o    </code></pre>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Offset: 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 	</span></span><br><span class="line"><span class="comment">00000000: 7F 45 4C 46 02 01 01 00 00 00 00 00 00 00 00 00    .ELF............</span></span><br><span class="line"><span class="comment">00000010: 01 00 3E 00 01 00 00 00 00 00 00 00 00 00 00 00    ..&gt;.............</span></span><br><span class="line"><span class="comment">00000020: 00 00 00 00 00 00 00 00 38 01 00 00 00 00 00 00    ........8.......</span></span><br><span class="line"><span class="comment">00000030: 00 00 00 00 40 00 00 00 00 00 40 00 0D 00 0A 00    ....@.....@.....</span></span><br><span class="line"><span class="comment">00000040: 55 48 89 E5 BF 00 00 00 00 E8 00 00 00 00 B8 00    UH.e?....h....8.</span></span><br><span class="line"><span class="comment">00000050: 00 00 00 5D C3 00 00 00 68 65 6C 6C 6F 2C 20 69    ...]C...hello,.i</span></span><br><span class="line"><span class="comment">00000060: 74 2C 73 20 6D 65 21 00 00 47 43 43 3A 20 28 47    t,s.me!..GCC:.(G</span></span><br><span class="line"><span class="comment">00000070: 4E 55 29 20 34 2E 38 2E 35 20 32 30 31 35 30 36    NU).4.8.5.201506</span></span><br><span class="line"><span class="comment">00000080: 32 33 20 28 52 65 64 20 48 61 74 20 34 2E 38 2E    23.(Red.Hat.4.8.</span></span><br><span class="line"><span class="comment">00000090: 35 2D 33 36 29 00 00 00 14 00 00 00 00 00 00 00    5-36)...........</span></span><br><span class="line"><span class="comment">000000a0: 01 7A 52 00 01 78 10 01 1B 0C 07 08 90 01 00 00    .zR..x..........</span></span><br><span class="line"><span class="comment">000000b0: 1C 00 00 00 1C 00 00 00 00 00 00 00 15 00 00 00    ................</span></span><br><span class="line"><span class="comment">000000c0: 00 41 0E 10 86 02 43 0D 06 50 0C 07 08 00 00 00    .A....C..P......</span></span><br><span class="line"><span class="comment">000000d0: 00 2E 73 79 6D 74 61 62 00 2E 73 74 72 74 61 62    ..symtab..strtab</span></span><br><span class="line"><span class="comment">000000e0: 00 2E 73 68 73 74 72 74 61 62 00 2E 72 65 6C 61    ..shstrtab..rela</span></span><br><span class="line"><span class="comment">000000f0: 2E 74 65 78 74 00 2E 64 61 74 61 00 2E 62 73 73    .text..data..bss</span></span><br><span class="line"><span class="comment">00000100: 00 2E 72 6F 64 61 74 61 00 2E 63 6F 6D 6D 65 6E    ..rodata..commen</span></span><br><span class="line"><span class="comment">00000110: 74 00 2E 6E 6F 74 65 2E 47 4E 55 2D 73 74 61 63    t..note.GNU-stac</span></span><br><span class="line"><span class="comment">00000120: 6B 00 2E 72 65 6C 61 2E 65 68 5F 66 72 61 6D 65    k..rela.eh_frame</span></span><br><span class="line"><span class="comment">-----------------------省略下面的内容----------------------------------</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a><code>链接阶段</code></h4><blockquote>
<p>重定位是将符号引用与符号定义进行链接的过程。因此链接是处理可重定位文件，把它们的各种符号引用和符号定义转换为可执行文件中的合适信息（一般是虚拟内存地址）的过程。</p>
</blockquote>
<blockquote>
<p>链接又分为静态链接和动态链接，前者是程序开发阶段程序员用 ld（gcc 实际上在后台调用了 ld）静态链接器手动链接的过程，而动态链接则是程序运行期间系统调用动态链接器（ld-linux.so）自动链接的过程。</p>
</blockquote>
<pre><code>gcc test.o -o test

[root@localhost test]# ldd test
linux-vdso.so.1 =&gt;  (0x00007fff22f44000)
libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f80760ec000)
/lib64/ld-linux-x86-64.so.2 (0x00007f80764c2000)</code></pre>
<blockquote>
<p>函数库一般分为静态库和动态库两种。静态库是指编译链接时，把库文件的代码全部加入到可执行文件中，因此生成的文件比较大，但在运行时也就不再需要库文件了。其后缀名一般为”.a”。动态库与之相反，在编译链接时并没有把库文件的代码加入到可执行文件中，而是在程序执行时由运行时链接文件加载库，这样可以节省系统的开销。动态库一般后缀名为”.so”，如前面所述的libc.so.6就是动态库。gcc在编译时默认使用动态库。</p>
</blockquote>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/02/28/8tj4PrqosTxHGhm.jpg" alt="tumblr_ph8vgsw3hl1sfie3io1_1280.jpg"></p>
]]></content>
      <tags>
        <tag>OperatingSystem</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-进程线程-原理</title>
    <url>/2020-02-29-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B-%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="">陈向群操作系统</a></p>
<p><a href="https://docs.microsoft.com/zh-cn/windows/win32/procthread/about-processes-and-threads?redirectedfrom=MSDN">关于进程和线程</a></p>
<p><a href="https://blog.csdn.net/gatieme/article/details/51892437">线程的3种实现方式–内核级线程, 用户级线程和混合型线程</a></p>
<hr>
<a id="more"></a>

<h3 id="多道处理程序"><a href="#多道处理程序" class="headerlink" title="多道处理程序"></a>多道处理程序</h3><p><img src="https://i.loli.net/2020/03/01/nkl2eiShoA3xvmY.jpg" alt="20200301_多道程序设计.jpg"></p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p><code>定义：</code> <br><br>进程是正在执行的(并发和并行)可执行程序的实例，进程和线程都可以称为<code>任务</code></p>
<p><code>特征</code> </p>
<ul>
<li>程序的一次执行过程</li>
<li>是正在运行程序的抽象</li>
<li>系统资源以进程为单位分配，如内存、文件、……</li>
<li>每个具有独立的地址空间</li>
</ul>
<p><code>进程的意义：</code> <br><br>多道程序允许多个程序同时进入内存并运行，每个程序在运行过程中的实例都可以称为进程，进程既包括了程序文件中的信息，还包括堆栈信息，进程表等维持程序运行，切换所需的信息</p>
<p><code>进程和程序的区别：</code> </p>
<ul>
<li>进程更能准确刻画并发，而程序不能(一个程序运行2次，就是2个进程)</li>
<li>程序是静态的，进程是动态的</li>
<li>进程有生命周期的，有诞生有消亡，是短暂的；而程序是相对长久的</li>
<li>一个程序可对应多个进程</li>
<li>进程具有创建其他进程的功能</li>
</ul>
<p><code>进程的运行状态：</code> <br><br><img src="https://i.loli.net/2020/03/01/ienkGjYAXErD2vP.jpg" alt="20200301_进程状态转换.jpg"></p>
<p><code>进程的其他状态:</code> <br></p>
<p>1 <strong>创建(new)</strong></p>
<blockquote>
<p>已完成创建一进程所必要的工作 – PID、PCB<br>但尚未同意执行该进程– 因为资源有限</p>
</blockquote>
<p>2 <strong>终止(terminated)</strong></p>
<blockquote>
<p>终止执行后，进程进入该状态<br>可完成一些数据统计工作<br>资源回收</p>
</blockquote>
<p>3 <strong>挂起(suspend)</strong></p>
<blockquote>
<p>用于调节负载<br>进程不占用内存空间，其进程映像交换到磁盘上</p>
</blockquote>
<p><img src="https://i.loli.net/2020/03/01/EqBLian16y3X5Jt.jpg" alt="20200301_linux状态示意图.jpg"></p>
<p><code>进程队列：</code> <br><br><img src="https://i.loli.net/2020/03/01/dahT24qE7M5Ncxp.jpg" alt="20200301_5状态进程队列模型.jpg"></p>
<ul>
<li>操作系统为每一类进程建立一个或多个队列</li>
<li>队列元素为PCB</li>
<li>伴随进程状态的改变，其PCB从一个队列进入另一个队列</li>
<li>多个等待队列等待的事件不同</li>
<li>就绪队列也可以多个</li>
<li>单CPU情况下，运行队列中只有一个进程</li>
</ul>
<p><code>进程创建：</code> </p>
<p>在Unix种只有一个系统调用可以创建新进程(fork),exec族函数是在原有的进程结构种重新加载程序，pid不变</p>
<p><code>进程的分类:</code> </p>
<ul>
<li><p>系统进程</p>
</li>
<li><p>用户进程</p>
</li>
<li><p>前台进程</p>
</li>
<li><p>后台进程</p>
</li>
<li><p>cpu密集型进程</p>
</li>
<li><p>I/O密集型进程</p>
</li>
</ul>
<p><code>进程地址空间：</code> <br><br><img src="https://i.loli.net/2020/03/01/XvkA1ORaxVP3fEm.jpg" alt="20200301_进程地址空间.jpg"></p>
<p><code>进程上下文切换：</code> <br></p>
<blockquote>
<p>将CPU硬件状态从一个进程换到另一个进程的过程称为上下文切换</p>
</blockquote>
<blockquote>
<p>进程运行时，其硬件状态保存在CPU上的寄存器(程序计数器、程序状态寄存器、栈指针、通用寄存器、其他控制寄存器的值)</p>
</blockquote>
<blockquote>
<p>进程不运行时，这些寄存器的值保存在进程控制块PCB中；当操作系统要运行一个新的进程时，将PCB中的相关值送到对应的寄存器中  </p>
</blockquote>
<hr>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p><code>引入线程的原因：</code> </p>
<ul>
<li>应用的需要</li>
<li>开销的考虑</li>
<li>性能的考虑</li>
</ul>
<p><img src="https://i.loli.net/2020/03/01/4JdCAEcRejDYHN6.jpg" alt="20200301_多线程的意义.jpg"></p>
<p>如果一个程序想要同时处理多个事情，这些事情又彼此联系，采用进程的话系统开销，资源分配都很大，且进程间交换数据比较麻烦，采用更小颗粒度的控制流显然比较好</p>
<hr>
<h3 id="线程和进程的不同"><a href="#线程和进程的不同" class="headerlink" title="线程和进程的不同"></a>线程和进程的不同</h3><p><img src="https://i.loli.net/2020/03/01/uD9pItA3aJqvFVc.jpg" alt="20200301_线程的基本概念.jpg"></p>
<p>线程享有进程的资源，但是可以独立运行的cpu最小调度单位</p>
<p>每个过程都提供执行程序所需的资源。进程具有虚拟地址空间，可执行代码，系统对象的打开句柄，安全上下文，唯一的进程标识符，环境变量，优先级类别，最小和最大工作集大小以及至少一个执行线程。每个进程都从单个线程（通常称为主线程）开始，但是可以从其任何线程中创建其他线程。</p>
<p>一个线程是可以调度执行过程中的实体。进程的所有线程共享其虚拟地址空间和系统资源。另外，每个线程维护异常处理程序，调度优先级，线程本地存储，唯一的线程标识符以及系统将用于保存线程上下文直到被调度的一组结构。的线程上下文包括线程的一组的机器寄存器，内核栈，线程环境块，并在该线程的进程的地址空间中的用户栈。线程也可以具有自己的安全上下文，可用于模拟客户端。</p>
<pre><code>Per process items             | Per thread items
------------------------------|-----------------
Address space                 | Program counter
Global variables              | Registers
Open files                    | Stack
Child processes               | State
Pending alarms                |
Signals and signal handlers   |
Accounting information        |</code></pre>
<p><code>用户级线程：</code> <br></p>
<blockquote>
<p>由应用程序所支持的线程实现, 内核意识不到用户级线程的实现</p>
</blockquote>
<ul>
<li>在用户空间建立线程库：提供一组管理线程的过程</li>
<li>运行时系统：完成线程的管理工作（操作、线程表）</li>
<li>内核管理的还是进程，不知道线程的存在</li>
<li>线程切换不需要内核态特权</li>
<li>例子：UNIX</li>
</ul>
<p>图片来源: <a href="https://blog.csdn.net/gatieme/article/details/51892437">https://blog.csdn.net/gatieme/article/details/51892437</a></p>
<p><img src="https://i.loli.net/2020/03/01/WQIOkqvdb4JACYZ.jpg" alt="20200301_用户级线程.jpeg"></p>
<hr>
<p><code>内核级线程：</code> <br></p>
<blockquote>
<p>内核级线程又称为内核支持的线程</p>
</blockquote>
<ul>
<li>内核管理所有线程管理，并向应用程序提供API接口</li>
<li>内核维护进程和线程的上下文</li>
<li>线程的切换需要内核支持</li>
<li>以线程为基础进行调度</li>
<li>例子：Windows</li>
</ul>
<p>图片来源: <a href="https://blog.csdn.net/gatieme/article/details/51892437">https://blog.csdn.net/gatieme/article/details/51892437</a></p>
<p><img src="https://i.loli.net/2020/03/01/kfEQXRquNtzlTw6.jpg" alt="20200301_内核级线程.jpeg"></p>
<hr>
<p><code>混合式线程：</code> <br></p>
<blockquote>
<p>两者结合方法</p>
</blockquote>
<ul>
<li>线程创建在用户空间完成</li>
<li>线程调度等在核心态完成</li>
<li>多个用户级线程多路复用多个内核级线程 </li>
</ul>
<p>图片来源: <a href="https://blog.csdn.net/gatieme/article/details/51892437">https://blog.csdn.net/gatieme/article/details/51892437</a></p>
<p><img src="https://i.loli.net/2020/03/01/Q3LkKJDUyXbWGnj.jpg" alt="20200301组合式线程.jpeg"></p>
<hr>
<p><code>用户级/内核级线程对比</code></p>
<p><img src="https://i.loli.net/2020/03/01/ktiEsVO8CDcMJ3e.jpg" alt="20200301_用户内核线程对比.jpg"></p>
<p><code>可再入程序（可重入）： </code> <br><br>可被多个进程同时调用的程序，具有下列性质：</p>
<p>它是纯代码的，即在执行过程中自身不改变；调用它的进程应该提供数据区 </p>
<p><code>并发和并行:</code> </p>
<blockquote>
<p>并发是指两个或多个任务可以在重叠的时间段内启动，运行和完成。但每个时刻只有一个任务在执行。例如，单核计算机上的多任务处理。</p>
</blockquote>
<blockquote>
<p>并行是指任务实际上在同一时间（例如，在多核处理器上）运行。</p>
</blockquote>
<p><code>其他：</code> <br><br>线程表和进程表是一样的task_struct</p>
<p>linux不支持内核级线程,线程只是进程的子集，主要区别就是是否有自己的独立的虚拟地址空间</p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/02/29/HpV3zjMb26An8NF.jpg" alt="tumblr_ppam2aBE4u1sfie3io1_1280.jpg"></p>
]]></content>
      <tags>
        <tag>OperatingSystem</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-处理器调度</title>
    <url>/2020-03-04-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>陈向群操作系统 ppt简要整理</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><code>CPU调度:</code></p>
<blockquote>
<p>即按一定的调度算法从就绪队列中选择一个进程，把CPU的使用权交给被选中的进程<br>如果没有就绪进程，系统会安排一个系统空闲进程或idle进程</p>
</blockquote>
<hr>
<a id="more"></a>

<p><code>进程切换：</code></p>
<blockquote>
<p>是指一个进程让出处理器，由另一个进程占用处理器的过程</p>
</blockquote>
<p><strong>主要做了两项工作：</strong></p>
<ul>
<li>切换全局页目录以加载一个新的地址空间</li>
<li>切换内核栈和硬件上下文，其中硬件上下文包括了内核执行新进程需要的全部信息，如CPU相关寄存器</li>
</ul>
<p><strong>场景：进程A下CPU，进程B上CPU</strong></p>
<ul>
<li>保存进程A的上下文环境（程序计数器、程序状态字、其他寄存器……）</li>
<li>用新状态和其他相关信息更新进程A的PCB</li>
<li>把进程A移至合适的队列（就绪、阻塞……）</li>
<li>将进程B的状态设置为运行态</li>
<li>从进程B的PCB中恢复上下文（程序计数器 、程序状态字、其他寄存器……）</li>
</ul>
<p><strong>上下文切换开销</strong></p>
<p><code>直接开销：内核完成切换所用的CPU时间</code></p>
<ul>
<li>保存和恢复寄存器……</li>
<li>切换地址空间（相关指令比较昂贵）</li>
</ul>
<p><code>间接开销</code></p>
<p>高速缓存(Cache)、缓冲区缓存(Buffer Cache)和TLB(Translation Look-aside Buffer)失效</p>
<hr>
<h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><p><code>FIFO 先来先服务</code></p>
<blockquote>
<p>按照进程就绪的先后顺序使用CPU</p>
</blockquote>
<blockquote>
<p>非抢占</p>
</blockquote>
<p><code>短作业优先(SJF)</code></p>
<blockquote>
<p>具有最短完成时间的进程优先执行</p>
</blockquote>
<blockquote>
<p>非抢占式</p>
</blockquote>
<p><code>最短剩余时间优先</code></p>
<blockquote>
<p>SJF抢占式版本，即当一个新就绪的进程比当前运行进程具有更短的完成时间时，系统抢占当前进程，选择新就绪的进程执行</p>
</blockquote>
<blockquote>
<p>容易产生饥饿现象</p>
</blockquote>
<p><code>最高相应比优先</code></p>
<blockquote>
<p>调度时，首先计算每个进程的响应比R；之后，总是选择 R 最高的进程执行</p>
</blockquote>
<blockquote>
<p>等待时间越久，补偿越大</p>
</blockquote>
<pre><code>响应比R = 周转时间 / 处理时间
 =（处理时间 + 等待时间）/ 处理时间
 = 1 +（等待时间 / 处理时间）</code></pre>
<p><code>时间片轮转</code></p>
<blockquote>
<p>每个进程分配一个时间片</p>
</blockquote>
<blockquote>
<p>时钟中断 → 轮换 </p>
</blockquote>
<p><code>虚拟轮转法</code></p>
<blockquote>
<p>不记录了</p>
</blockquote>
<p><code>最高优先级</code></p>
<blockquote>
<p>选择优先级最高的进程投入运行<br>优先级反转</p>
</blockquote>
<p><code>多级反馈队列</code></p>
<blockquote>
<p>是UNIX的一个分支BSD （加州大学伯克利分校开发和发布的）5.3版所采用的调度算法</p>
</blockquote>
<ul>
<li>设置多个就绪队列，第一级队列优先级最高</li>
<li>给不同就绪队列中的进程分配长度不同的时间片，第一级队列时间片最小；随着队列优先级别的降低，时间片增大</li>
<li>当第一级队列为空时，在第二级队列调度，以此类推</li>
<li>各级队列按照时间片轮转方式 进行调度</li>
<li>当一个新创建进程就绪后，进入第一级队列</li>
<li>进程用完时间片而放弃CPU，进入下一级就绪队列</li>
<li>由于阻塞而放弃CPU的进程进入相应的等待队列，一旦等待的事件发生，该进程回到原来一级就绪队列(阻塞完成后的进程优先级比较高)</li>
</ul>
<p><code>比较</code></p>
<p><img src="https://i.loli.net/2020/03/07/JBckRUxuvbaZw3P.png" alt="调度算法比较.png"></p>
<pre><code>FCFS:FIFO
Round Robin:
SJF:短作业有限
SRTN:最短时间优先
HRRN:最高响应比
Feedback:多级反馈队列</code></pre>
<hr>
<p><code>Linux调度算法</code></p>
<p><img src="https://i.loli.net/2020/03/07/KxOlUJZLQapws7n.png" alt="linux调度算法.png"></p>
<hr>
<h3 id="Windows线程调度"><a href="#Windows线程调度" class="headerlink" title="Windows线程调度"></a>Windows线程调度</h3><ul>
<li>调度单位是线程 </li>
<li>采用基于动态优先级的、抢占式调度，结合时间配额的调整</li>
</ul>
<p><code>调度策略</code></p>
<ul>
<li>主动切换</li>
<li>抢占</li>
<li>时间配额用完</li>
</ul>
<p><code>I/O完成后的线程优先级提升</code></p>
<ul>
<li>在完成I/O操作后，Windows 将临时提升等待该操作线程的优先级，保证该线程能更快上CPU运行进行数据处理</li>
<li>优先级的提升值由设备驱动程序决定，提升建议值保存在系统文件“Wdm.h”或“Ntddk.h”中</li>
<li>优先级的提升幅度与对I/O请求的响应时间要求是一致的，响应时间要求越高，优先级提升幅度越大</li>
<li>设备驱动程序在完成I/O请求时通过内核函数IoCompleteRequest来指定优先级提升的幅度</li>
<li>为避免不公平，在I/O操作完成唤醒等待线程时会将该线程的时间配额减1</li>
</ul>
<p><code>饥饿线程的优先级提升</code></p>
<ul>
<li>系统线程“平衡集管理器(balance set manager)”每秒钟扫描一次就绪队列，发现是否存在等待时间超过300个时钟中断间隔的线程</li>
<li>平衡集管理器将这些线程的优先级提升到15，并分配给它一个长度为正常值4倍的时间配额</li>
<li>当被提升的线程用完它的时间配额后，立即衰减到它原来的基本优先级 </li>
</ul>
<hr>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/03/07/37ehpHvqTidYrI4.jpg" alt="tumblr_p90a4bPTfp1sfie3io1_1280.jpg"></p>
]]></content>
      <tags>
        <tag>OperatingSystem</tag>
      </tags>
  </entry>
  <entry>
    <title>vs+linux编译环境</title>
    <url>/2020-03-10-vs+linux%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>虚拟机的samba有点问题，恰好电脑之前装过vs 2017,就用了下vs的linux编译项目，也算是一种选择</p>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><code>step 1</code></p>
<p><img src="https://i.loli.net/2020/03/10/7AL6ey9OTnsFxgG.png" alt="vs_1.png"></p>
<p><code>step 2</code></p>
<p>调试-&gt;选项</p>
<p><img src="https://i.loli.net/2020/03/10/qBXly9AK5HohU1M.png" alt="vs_2.png"></p>
<p><code>step 3</code></p>
<p><img src="https://i.loli.net/2020/03/10/aXcu7pSC9eJVHMF.png" alt="vs_3.png"></p>
<p><code>step 4</code></p>
<p><img src="https://i.loli.net/2020/03/10/zmNJtZdegPIp51S.png" alt="vs_4.png"></p>
<p><code>step 5</code></p>
<p><img src="https://i.loli.net/2020/03/10/raYw7GRsTUmzukB.png" alt="vs_5.png"></p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/03/10/K2mWJGFDYNBkxtb.jpg" alt="hiker-in-rocky-iceland-field_4460x4460_2.jpg"></p>
]]></content>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>ace-简单的server-client</title>
    <url>/2020-03-16-ace-%E7%AE%80%E5%8D%95%E7%9A%84server-client/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.google.com/?hl=zh_CN">ACE技术内幕：深入解析ACE架构设计与实现原理</a></p>
<hr>
<a id="more"></a>

<h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ace/Log_Msg.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ace/INET_Addr.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ace/SOCK_Acceptor.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">ACE_INET_Addr <span class="title">listen</span><span class="params">(<span class="number">6666</span>)</span></span>;</span><br><span class="line">	ACE_SOCK_ACCEPTOR acceptor;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">-1</span> == acceptor.<span class="built_in">open</span>(listen, <span class="number">1</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//ACE_ERROR_RETURN((LM_ERROR, ACE_TEXT(&quot;%p \n&quot;), ACE_TEXT(&quot;acceptor.open()&quot;)), -1);</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;acceptor.open error!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ACE_SOCK_Stream peer;</span><br><span class="line">		ACE_INET_Addr peer_addr;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="number">-1</span> == acceptor.<span class="built_in">accept</span>(peer, &amp;peer_addr))</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;acceptor.accept error!&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			ACE_TCHAR peer_name[HOST_NAME_MAX];</span><br><span class="line">			peer_addr.<span class="built_in">addr_to_string</span>(peer_name, HOST_NAME_MAX);</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;connect from: &quot;</span> &lt;&lt; peer_name &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">char</span> buffer[<span class="number">4096</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">			<span class="keyword">ssize_t</span> bytes_num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> ((bytes_num = peer.<span class="built_in">recv</span>(buffer, <span class="built_in"><span class="keyword">sizeof</span></span>(buffer))) &gt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				buffer[bytes_num] = <span class="number">0</span>;</span><br><span class="line">				cout &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			peer.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;close socket!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>pic: client-tcp</strong></p>
<p><a href="https://imgchr.com/i/8YIZss"><img src="https://s1.ax1x.com/2020/03/16/8YIZss.png" alt="8YIZss.png"></a></p>
<hr>
<h2 id="client"><a href="#client" class="headerlink" title="client"></a>client</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ace/Log_Msg.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ace/INET_Addr.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ace/SOCK_Connector.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ACE_SOCK_CONNECTOR connector;</span><br><span class="line">	ACE_SOCK_Stream peer;</span><br><span class="line">	<span class="function">ACE_INET_Addr <span class="title">addr</span><span class="params">(<span class="number">5555</span>, <span class="string">&quot;127.0.0.1&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">-1</span> == connector.<span class="built_in">connect</span>(peer, addr))</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;connector.connect error!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> buffer[<span class="number">100</span>] = <span class="string">&quot;This is a test!&quot;</span>;</span><br><span class="line">	peer.<span class="built_in">send_n</span>(buffer, <span class="built_in">strlen</span>(buffer));</span><br><span class="line"></span><br><span class="line">	peer.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>pic: server-tcp</strong></p>
<p><a href="https://imgchr.com/i/8YIVMj"><img src="https://s1.ax1x.com/2020/03/16/8YIVMj.png" alt="8YIVMj.png"></a></p>
<hr>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><strong>pic: woman-in-black-high-heels-standing-next-to-a-car-picjumbo-com_lit</strong></p>
<p><img src="https://s1.ax1x.com/2020/03/16/8YoSl4.jpg" alt="8YoSl4.jpg"></p>
]]></content>
      <tags>
        <tag>ace</tag>
      </tags>
  </entry>
  <entry>
    <title>ace在vs下编译</title>
    <url>/2020-03-16-ace%E5%9C%A8vs%E4%B8%8B%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/misskissC/article/details/9793433">ACE在windows下的编译及配置</a></p>
<p><a href="https://www.cnblogs.com/defen/p/4402161.html">ACE_TEST1.obj : error LNK2019: 无法解析的外部符号</a></p>
<p><a href="https://bbs.csdn.net/topics/100136500">fatal error LNK1104: 无法打开文件”ACEd.lib”</a></p>
<a id="more"></a>


<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="1-添加配置文件"><a href="#1-添加配置文件" class="headerlink" title="1 添加配置文件"></a>1 添加配置文件</h3><pre><code>touch /ACE_wrappers/ace/config.h

#define ACE_HAS_STANDARD_CPP_LIBRARY 1

#include &quot;ace/config-win32.h&quot;</code></pre>
<h3 id="2-编译aced库"><a href="#2-编译aced库" class="headerlink" title="2 编译aced库"></a>2 编译aced库</h3><p>在/ACE_wrappers下选中对应版本的工程ACE_vs2017.sln.打开后选中ace项目进行编译，最终生成aced.lib aced.dll</p>
<h3 id="3-环境变量"><a href="#3-环境变量" class="headerlink" title="3 环境变量"></a>3 环境变量</h3><p><code>添加环境变量</code> 变量名：ACE_ROOT，变量值：/ACE_wrappers</p>
<h3 id="4-vs中添加环境变量ACE-ROOT"><a href="#4-vs中添加环境变量ACE-ROOT" class="headerlink" title="4 vs中添加环境变量ACE_ROOT"></a>4 vs中添加环境变量ACE_ROOT</h3><p>可执行文件目录 <br></p>
<blockquote>
<p> $(VC_ExecutablePath_x86);$(WindowsSDK_ExecutablePath);$(VS_ExecutablePath);$(MSBuild_ExecutablePath);$(SystemRoot)\SysWow64;$(FxCopDir);$(PATH);$(ACE_ROOT);</p>
</blockquote>
<p>包含目录 <br></p>
<blockquote>
<p>$(VC_IncludePath);$(WindowsSDK_IncludePath);$(ACE_ROOT);</p>
</blockquote>
<p>库目录 <br></p>
<blockquote>
<p>$(VC_LibraryPath_x86);$(WindowsSDK_LibraryPath_x86);$(NETFXKitsDir)Lib\um\x86;$(ACE_ROOT);</p>
</blockquote>
<h3 id="5-新建项目编译"><a href="#5-新建项目编译" class="headerlink" title="5 新建项目编译"></a>5 新建项目编译</h3><p>新建控制台应用程序，将aced.dll/aced.lib加到项目路径下，main函数格式：int main(int argc, char** argv)，然后编译”hello world!”</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ace/Log_Msg.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	ACE_TRACE(ACE_TEXT(<span class="string">&quot;main&quot;</span>));</span><br><span class="line">	ACE_DEBUG((LM_INFO, ACE_TEXT(<span class="string">&quot;Hello world/n&quot;</span>)));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>






<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/03/16/YsySL1GvDWUKEcu.jpg" alt="tumblr_og2ppfmQNq1tomxvuo7_1280.jpg"></p>
]]></content>
      <tags>
        <tag>ace</tag>
      </tags>
  </entry>
  <entry>
    <title>stl-reverse_iterator</title>
    <url>/2020-03-16-stl-reverse_iterator/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><img src="https://i.loli.net/2020/03/16/1X5ibVWNwfBDd76.png" alt="rbegin.png"></p>
<hr>
<a id="more"></a>

<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p><code>INPUT</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector = &#123; <span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;myvector contains:&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::reverse_iterator it = myvector.rbegin(); it != myvector.rend(); ++it)</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; *it;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>OUTPUT</code></p>
<pre><code>myvector contains: 50 40 30 20 10</code></pre>
<hr>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//end()</span></span><br><span class="line">const_iterator</span><br><span class="line">     <span class="built_in">end</span>() <span class="keyword">const</span> _GLIBCXX_NOEXCEPT</span><br><span class="line">     &#123; </span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">const_iterator</span>(<span class="keyword">this</span>-&gt;_M_impl._M_finish); </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//begin()</span></span><br><span class="line">reverse_iterator</span><br><span class="line">      <span class="built_in">rbegin</span>() _GLIBCXX_NOEXCEPT</span><br><span class="line">      &#123; </span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">reverse_iterator</span>(<span class="built_in">end</span>()); </span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造函数</span></span><br><span class="line"><span class="keyword">explicit</span></span><br><span class="line">     <span class="built_in">reverse_iterator</span>(iterator_type __x) : <span class="built_in">current</span>(__x) </span><br><span class="line">  &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类声明，成员变量</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Iterator&gt;</span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">reverse_iterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	_Iterator current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>rbegin把_M_finish作为初始化值传入reverse_iterator类的构造函数进行初始化，最后reverse_iterator的成员变量current是iterator类型的迭代器，值为_M_finish对应的某种类型。也就是说rbegin生成的迭代器对应的值是空，因为_M_finish是最后一个元素的后面的地址，那使用时候为什么察觉不到？原因在于operator的实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// *</span></span><br><span class="line">reference</span><br><span class="line">     <span class="keyword">operator</span>*() <span class="keyword">const</span></span><br><span class="line">     &#123;</span><br><span class="line">	_Iterator __tmp = current;</span><br><span class="line">	<span class="keyword">return</span> *--__tmp;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line">pointer</span><br><span class="line">     <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span></span><br><span class="line">     &#123; </span><br><span class="line">	<span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ++</span></span><br><span class="line">reverse_iterator&amp;</span><br><span class="line">     <span class="keyword">operator</span>++()</span><br><span class="line">     &#123;</span><br><span class="line">	--current;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --</span></span><br><span class="line">reverse_iterator&amp;</span><br><span class="line">     <span class="keyword">operator</span>--()</span><br><span class="line">     &#123;</span><br><span class="line">	++current;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>类似障眼法的东西，其本质还是iterator迭代器，不过实现方法上是相反的逻辑，也可以用base函数进行转换，变为正常的身份：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">iterator_type</span><br><span class="line">     <span class="built_in">base</span>() <span class="keyword">const</span></span><br><span class="line">     &#123; </span><br><span class="line">	<span class="keyword">return</span> current; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/03/16/2mhrbEe7kdYCGxw.jpg" alt="snow_covered_spruce_in_bw_lit.jpg"></p>
]]></content>
      <tags>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title>itchat构建微信自动回复</title>
    <url>/2020-03-17-itchat%E6%9E%84%E5%BB%BA%E5%BE%AE%E4%BF%A1%E8%87%AA%E5%8A%A8%E5%9B%9E%E5%A4%8D/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本来想着做个微信菜单，自定义一些服务，增加点情趣。网上查了下发现python+itchat用起来很好上手，最后安装必要软件调试完成，扫二维码，and：</p>
<blockquote>
<p>为了你的帐号安全，此微信号不能登录网页微信。你可以使用Windows微信或Mac微信在电脑端登录。Windows微信下载地址：<a href="https://pc.weixin.qq.com/">https://pc.weixin.qq.com</a>  Mac微信下载地址：<a href="https://mac.weixin.qq.com/">https://mac.weixin.qq.com</a></message></error><br>Start auto replying.</p>
</blockquote>
<p>网上查了下，大概是微信把网页登录的接口给禁用了，而我来的太晚了。可以在线测试下微信是否可以网页登录：<a href="https://wx.qq.com/">微信网页版入口</a></p>
<hr>
<a id="more"></a>

<h2 id="itchat使用步骤"><a href="#itchat使用步骤" class="headerlink" title="itchat使用步骤"></a>itchat使用步骤</h2><p><code>安装</code></p>
<pre><code>yum install -y epel-release

yum install python34-pip</code></pre>
<p>具体步骤记不太全了，可以网上查下，安装完python+pip后，安装<code>itchat</code></p>
<pre><code>pip3 install itchat --upgrade</code></pre>
<p>这一步可能会报错：</p>
<blockquote>
<p>pip._vendor.urllib3.exceptions.ReadTimeoutError: HTTPSConnectionPool(host=’files.pythonhosted.org’, port=443): Read timed out.    </p>
</blockquote>
<p>应该是网络不好，超时了，解决办法：<a href="https://blog.csdn.net/sinat_26811377/article/details/99698807">Python报错pip._vendor.urllib3.exceptions.ReadTimeoutError: HTTPSConnectionPool解决方法</a></p>
<pre><code>pip --default-timeout=10000 install itchat --upgrade</code></pre>
<p><code>运行</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> itchat</span><br><span class="line"></span><br><span class="line"><span class="meta">@itchat.msg_register(<span class="params">itchat.content.TEXT</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_content</span>(<span class="params">msg</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(msg[<span class="string">&#x27;Text&#x27;</span>])</span><br><span class="line"></span><br><span class="line">itchat.auto_login()</span><br><span class="line">itchat.run()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行：</p>
<pre><code>python3 test.py</code></pre>
<p>然后报错：</p>
<blockquote>
<p>FileNotFoundError: [Errno 2] No such file or directory: ‘xdg-open’: ‘xdg-open’</p>
</blockquote>
<p>解决办法：安装xdg</p>
<pre><code>yum install xdg-utils</code></pre>
<p>继续报错：</p>
<blockquote>
<p>xdg-open: no method available for opening ‘QR.png’ </p>
</blockquote>
<p>解决办法：在当前路径下找QR.png这个图片打开，即是微信网页版登录的二维码，but,如前文所说，我来迟了，现在腾讯不给开这个接口了，所以我的美景(让别人开心，增加情趣)没有生效。暂时记录在这，日后有了闲情逸致再在此基础上继续探索。</p>
<p><code>后续</code></p>
<p>采用了微信公众号的方式，达到了一定的效果，具体不再多言.</p>
<hr>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/03/17/jKrDz4T76ALQ5vI.jpg" alt="p957707651.jpg"></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口</title>
    <url>/2020-03-19-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhihu.com/question/32255109">TCP协议的滑动窗口具体是怎样控制流量的？</a></p>
<p><a href="">TCP/IP详解</a></p>
<hr>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><strong><code>流量控制</code></strong> </p>
<p>在接收方跟不上发送方的时候，会强迫发送方慢下来，这称为流量控制。流量控制通常有两种形式：</p>
<p>1 <strong>基于速率</strong>流量控制：给发送方指定某个速率，同时确保速率永远不会超过这个速率发送</p>
<p>2 <strong>基于窗口</strong>流量控制：使用滑动窗口(sliding window)</p>
<p><strong><code>滑动窗口</code></strong></p>
<p>TCP是全双工的协议，每一方都可以收发数据。连接的收发数据量是根据一组窗口结构维护的。</p>
<p><img src="https://i.loli.net/2020/03/19/z93KCvL4SBRiVEl.jpg" alt="报文头.jpg"></p>
<p>windows是一个16bit字段，代表滑动窗口的大小，默认最大是65535，可以根据option-kind,option-lenth,option-data进行扩厂。</p>
<p>每个TCP报文段(除了连接建立之初的包交换)都包含一个有效的序列号字段，一个ACK号或确认字段，以及一个窗口大小：</p>
<p><img src="https://i.loli.net/2020/03/19/wXmipMO3HyGIqFU.png" alt="滑动窗口win.png"></p>
<pre><code>clint-&gt;server:

31:31:31:0d:0a  //frame number 56


32:32:32:0d:0a  //frame number 67</code></pre>
<p>发送方发了2次数据，每次5个字节，服务方回复6,11表示期待的下一个节点，通过此方法保证可靠传输 <br><br>从图中也可以看出发送方窗口和接收方窗口的大小</p>
<p><code>接收方窗口</code></p>
<p><img src="https://i.loli.net/2020/03/19/3zB2HFZkXorsmty.jpg"></p>
<p><code>发送方窗口</code></p>
<p><img src="https://i.loli.net/2020/03/19/vPDFa56jBVh2opz.jpg"></p>
<p>发送方滑动窗口大小SND.WND = SND.UNA + SND.WND <br><br>如图所示，当4，5字节报文发送给接收方并收到接收方的ack=6,则发送方的滑动窗口右移：</p>
<pre><code>[4-9] -&gt; [6-11]</code></pre>
<p>这是在SND.WND不变的情况下，实际上SND.WND可能是根据实际情况变化的。这个右移的过程是即将发送(可用窗口)变大的过程。如果发送者一直发，但收不到ack,或者ack的序号不对，则可用窗口变小，已发送未经确认窗口变大，直到<code>接收方窗口已满</code>,接收方会发给发送方调整窗口大小为0来阻止发送方继续发送。</p>
<p><code>注意</code></p>
<p>当发送方窗口 &gt; 接收方窗口：接收方的能力限制发送方的窗口大小</p>
<p>当发送方窗口 &lt; 接收方窗口：是网络拥塞限制发送方的窗口大小</p>
<p><code>零窗口演示</code></p>
<p><img src="https://i.loli.net/2020/03/19/YBsHKTPb1EZMjk4.png" alt="tcp-零窗口.png"></p>
<p>整个程序的逻辑：服务端accept后不recv,客户端一直发数据，最后客户端(发送方)窗口满，服务端(接收方)返回零窗口，客户端不再发送数据给服务端。</p>
<p>报文如下：</p>
<pre><code>链接：https://pan.baidu.com/s/1Drh4_I42s0WIyebAvFvU5A 
提取码：lti3 
复制这段内容后打开百度网盘手机App，操作更方便哦</code></pre>
<p><code>滑动窗口的作用</code></p>
<ul>
<li>提供TCP的可靠性(依赖确认ack重传)</li>
<li>提供TCP的流控特性(第二种流量控制)</li>
</ul>
<hr>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/03/19/V5AshMI2vtqHxTi.jpg" alt="79810064_p0_master1200.jpg"></p>
]]></content>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>拥塞控制(慢启动+拥塞避免+超时重传+快速重传+快速恢复)</title>
    <url>/2020-03-20-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/wdscq1234/article/details/52517420">TCP-IP详解: 慢启动和拥塞控制</a></p>
<p><a href="https://juejin.im/post/5dbd893ee51d452a07570339">TCP/IP之RTO、RTT</a></p>
<p><a href="https://www.zhihu.com/question/267728663">如何测量和确定Linux系统中tcp初始发送窗口的大小？</a></p>
<p><a href="https://blog.stackpath.com/glossary-cwnd-and-rwnd/">什么是CWND和RWND</a></p>
<p><a href="https://blog.xieyangzhe.com/archives/769">TCP复习拥塞控制</a></p>
<hr>
<a id="more"></a>

<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>当某一路由器在单位时间内接收到的数据量多于其可发送的数据量时，他就把多余的部分存储起来。假如这种情况持续，存储资源将会耗尽，最后路由器不得不丢弃一部分数据，这种现象成为<code>拥塞</code>。在TCP的两端看到的就是丢包现象，为避免或在一定情况下缓解这种情况，TCP通信的每一方都实行<code>拥塞控制</code>机制。TCP是全双工通信，每一方都可能发送数据，途经路由器，所以两个发送方(server/client)都应该支持拥塞控制，而上一篇文章的<code>滑动窗口</code>是接收方主动的一种行为。</p>
<hr>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul>
<li>Tahoe 提出了 <code>慢启动</code> <code>拥塞避免</code> <code>超时重传</code></li>
<li>Reno 在Tahoe的基础上增加了 <code>快速重传</code> <code>快速恢复</code></li>
<li>谷歌BBR</li>
</ul>
<hr>
<h2 id="TCP的发送窗口"><a href="#TCP的发送窗口" class="headerlink" title="TCP的发送窗口"></a>TCP的发送窗口</h2><p>wnd = min(rwnd, cwnd*mss)</p>
<p>rwnd:接收方的窗口大小</p>
<p>cwnd:发送方的窗口大小</p>
<p><img src="https://i.loli.net/2020/03/21/4GSrBdOmjZxgoc7.png" alt="cwnd.png"></p>
<hr>
<h2 id="RTT-RTO"><a href="#RTT-RTO" class="headerlink" title="RTT/RTO"></a>RTT/RTO</h2><p><code>RTT(Round Trip Time)</code></p>
<blockquote>
<p>一个连接的往返时间，即数据发送时刻到接收到确认的时刻的差值；</p>
</blockquote>
<p><code>RTO(Retransmission Time Out)</code></p>
<blockquote>
<p>重传超时时间，即从数据发送时刻算起，超过这个时间便执行重传, RTO协议实现值最小1s</p>
</blockquote>
<hr>
<h2 id="状态切换"><a href="#状态切换" class="headerlink" title="状态切换"></a>状态切换</h2><p>当cwnd &lt; ssthresh，执行慢启动 <br><br>当cwnd &gt; ssthresh, 执行拥塞避免 <br><br>当cwnd = ssthresh, 执行慢启动/拥塞避免的一种 <br><br>当超过RTO时间，触发超时重传<br>当收到3个以上的重复ACK,就进入快速重传</p>
<p><img src="https://i.loli.net/2020/03/21/NeGo3zLTquE49Ck.jpg" alt="拥塞控制状态图.jpg"></p>
<p><strong>图片来源</strong><br><a href="https://zhuanlan.zhihu.com/p/59656144">TCP 拥塞控制算法</a></p>
<hr>
<h2 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h2><p><code>慢启动的时机</code></p>
<ul>
<li>当一个新的TCP连接建立</li>
<li>检测到由重传超时(RTO)导致的丢包时</li>
<li>TCP发送端长时间处于空闲状态</li>
</ul>
<p><code>慢启动的目的</code></p>
<p>使TCP在用拥塞避免探寻更多可用带宽之前得到CWND(拥塞窗口)值，以及帮助TCP建立ACK时钟。</p>
<hr>
<p><code>cwnd变化</code></p>
<p><strong>在慢启动拥塞控制中，TCP快速增加窗口的大小(指数增加)，以尽快达到最大传输速率(指数)</strong></p>
<p>每当收到一个ACK，cwnd + 1;<br>每当过了一个RTT，cwnd = cwnd*2; </p>
<p>不考虑ack丢失的情况，则是2，4，8的指数增加</p>
<p><img src="https://i.loli.net/2020/03/21/qEHRiNx7cFGdt3K.png" alt="慢启动.png"></p>
<p><strong>图片来源</strong><br><a href="https://blog.xieyangzhe.com/archives/769">TCP复习拥塞控制</a></p>
<hr>
<h2 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h2><p>当达到阈值，迅速调整发送速率</p>
<pre><code>If   cwnd &lt; ssthresh then 
        Each time an Ack is received: 
        cwnd = cwnd + 1 
else   /*  cwnd &gt;  ssthresh  */ 
                    Each time an Ack is received: 
        cwnd = cwnd + 1 / [ cwnd ] 
endif</code></pre>
<p>每当收到一个ACK，cwnd = cwnd + 1 / cwnd； <br><br>每当过了一个RTT，cwnd = cwnd + 1; </p>
<hr>
<h2 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h2><p>最为早期的TCP Tahoe算法使用下面的算法，但效率较差</p>
<ul>
<li>由于发生丢包，将慢启动阈值ssthresh设置为当前cwnd的一半，即ssthresh = cwnd / 2.</li>
<li>cwnd重置为1</li>
<li>进入慢启动过程</li>
</ul>
<p><img src="https://i.loli.net/2020/03/21/DmIRLvUtPGrhpTn.png" alt="ssthresh.png"></p>
<p><strong>图片来源</strong><br><a href="https://blog.xieyangzhe.com/archives/769">TCP复习拥塞控制</a></p>
<hr>
<h2 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h2><p>Reno算法在超时重传的基础上，对于收到三次以上的重复ack后，直接进行处理，不用等待定时器超时(RTO),并且处理策略也进行了优化</p>
<ul>
<li>cwnd大小缩小为当前的一半</li>
<li>ssthresh设置为缩小后的cwnd大小</li>
<li>然后进入快速恢复算法Fast Recovery。</li>
</ul>
<hr>
<h2 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h2><p>Reno引入了快速恢复算法</p>
<ul>
<li>cwnd = cwnd + 3 * MSS，加3 * MSS的原因是因为收到3个重复的ACK。</li>
<li>重传DACKs(重复确认)指定的数据包。</li>
<li>如果再收到DACKs，那么cwnd大小增加一。</li>
<li>如果收到新的ACK，表明重传的包成功了，那么退出快速恢复算法。将cwnd设置为ssthresh，然后进入拥塞避免算法。</li>
</ul>
<p><img src="https://i.loli.net/2020/03/21/anFEbQ46xwA1jYy.jpg" alt="Fast Recovery.jpg"></p>
<p><strong>图片来源</strong><br><a href="https://zhuanlan.zhihu.com/p/59656144">TCP 拥塞控制算法</a></p>
<pre><code>收到第三个重复ack后 
ssthresh=cwnd=6/2=3(快速重传)
cwnd=3+3=6(快速恢复)
如果继续收到ack5,则cwnd++
重传pkt5数据包
如果收到新的ack,则cwnd=ssthresh,进入拥塞避免</code></pre>
<p>快速恢复cwnd&gt;ssthresh属于<code>裸奔</code>状态,是特事特办，在重传的同时可以发送新的包，在重传结束，需要快速切换回拥塞避免状态</p>
<hr>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/03/31/pqIaR6ykKE3vQgL.jpg" alt="76259440_p0_master1200.jpg"></p>
]]></content>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>c++11四种cast转换</title>
    <url>/2020-03-21-c++11%E5%9B%9B%E7%A7%8Dcast%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/27966225">C++类型转换</a></p>
<p><a href="https://blog.csdn.net/caroline_wendy/article/details/19042529">四种类型转换(cast)的关键字 详解 及 代码</a></p>
<p><a href="https://www.geeksforgeeks.org/static_cast-in-c-type-casting-operators/">C ++中的static_cast 类型转换运算符</a></p>
<p><a href="https://stackoverflow.com/questions/2253168/dynamic-cast-and-static-cast-in-c">C ++中的dynamic_cast和static_cast</a></p>
<hr>
<a id="more"></a>

<h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><blockquote>
<p>const_cast用于移除类型的const、volatile和__unaligned属性。</p>
</blockquote>
<pre><code>const int a = 1;
int *b = const_cast&lt;int*&gt;(&amp;a);

int c = 1;
const int *d = const_cast&lt;const int *&gt;(&amp;c);</code></pre>
<p><code>注意点</code></p>
<p>如果变量原来是const类型的常量，新的指针或引用是非常量，解除const限定后再去修改值是未定义的行为，const_cast只是用于修改变量的const属性，使用者应该考虑清楚操作的安全性.</p>
<p><strong>INPUT</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> *b = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;a);</span><br><span class="line">	*b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>OUTPUT</strong></p>
<pre><code>1
2
0139F748
0139F748</code></pre>
<hr>
<h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><blockquote>
<p>static_cast&lt; Type* &gt;(ptr)</p>
</blockquote>
<p>This takes the pointer in ptr and tries to safely cast it to a pointer of type Type*. This cast is done at compile time. It will only perform the cast if the type types are related. If the types are not related, you will get a compiler error.</p>
<p><strong>主要用在：</strong></p>
<ul>
<li>类的上行转换(派生类转基类,public继承)，下行转换是不安全的，需要编码时确认清楚</li>
<li>基本数据类型的转换(int,char,double),安全性需要编码时确认</li>
<li>将void指针转换成非void指针</li>
</ul>
<p><code>数据类型转换</code></p>
<p><strong>INPUT</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">float</span> f = <span class="number">3.5</span>; </span><br><span class="line">    <span class="keyword">int</span> a = f; <span class="comment">// this is how you do in C </span></span><br><span class="line">    <span class="keyword">int</span> b = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(f); </span><br><span class="line">    cout &lt;&lt; b; </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>OUTPUT</strong></p>
<pre><code>3</code></pre>
<hr>
<p><code>指针类型转换</code></p>
<p><strong>INPUT</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>; </span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// pass at compile time, may fail at run time </span></span><br><span class="line">    <span class="keyword">int</span>* q = (<span class="keyword">int</span>*)&amp;c;  <span class="comment">//c语言可以</span></span><br><span class="line">    <span class="keyword">int</span>* p = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;c); <span class="comment">//c++的失败 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>OUTPUT</strong></p>
<p>错误    C2440    “static_cast”: 无法从“char *”转换为“int *”    test    </p>
<hr>
<p><code>空指针</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>; </span><br><span class="line">    <span class="keyword">void</span>* v = <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>*&gt;(&amp;i); </span><br><span class="line">    <span class="keyword">int</span>* ip = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(v); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p><code>类对象转换</code></p>
<p><strong>INPUT</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">private</span> Base &#123; <span class="comment">// Inherited private/protected not public </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Derived d1; </span><br><span class="line">    Base* b1 = (Base*)(&amp;d1); <span class="comment">// allowed </span></span><br><span class="line">    Base* b2 = <span class="keyword">static_cast</span>&lt;Base*&gt;(&amp;d1); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>OUTPUT</strong></p>
<p>错误(活动)    E0269    不允许对不可访问的基类 “Base” 进行转换    test    </p>
<p>**:**上行转换的时候，一定要是public继承，private/protected都会编译报错</p>
<hr>
<h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><blockquote>
<p>dynamic_cast&lt; Type* &gt;(ptr)</p>
</blockquote>
<p><strong>以下拷贝自:</strong><a href="https://stackoverflow.com/questions/2253168/dynamic-cast-and-static-cast-in-c">链接</a></p>
<p>This again tries to take the pointer in ptr and safely cast it to a pointer of type Type*. But this cast is executed at runtime, not compile time. Because this is a run-time cast, it is useful especially when combined with polymorphic classes. In fact, in certian cases the classes must be polymorphic in order for the cast to be legal.</p>
<p>Casts can go in one of two directions: from base to derived (B2D) or from derived to base (D2B). It’s simple enough to see how D2B casts would work at runtime. Either ptr was derived from Type or it wasn’t. In the case of D2B dynamic_cast&lt;&gt;s, the rules are simple. You can try to cast anything to anything else, and if ptr was in fact derived from Type, you’ll get a Type* pointer back from dynamic_cast. Otherwise, you’ll get a NULL pointer.</p>
<p>But B2D casts are a little more complicated. Consider the following code:</p>
<p><strong>INPUT</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DoIt</span><span class="params">()</span> </span>= <span class="number">0</span>;    <span class="comment">// pure virtual</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DoIt</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Foo&quot;</span>; &#125;; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FooIt</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Fooing It...&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DoIt</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Bar&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BarIt</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;baring It...&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Base* <span class="title">CreateRandom</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( (<span class="built_in">rand</span>()%<span class="number">2</span>) == <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Foo;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="number">10</span>; ++n )</span><br><span class="line">    &#123;</span><br><span class="line">        Base* base = <span class="built_in">CreateRandom</span>();</span><br><span class="line"></span><br><span class="line">            base-&gt;<span class="built_in">DoIt</span>();</span><br><span class="line"></span><br><span class="line">        Bar* bar = (Bar*)base;</span><br><span class="line">        bar-&gt;<span class="built_in">BarIt</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>OUTPUT</strong></p>
<pre><code>Bar
baring It...
---------------
Bar
baring It...
---------------
Foo
baring It...
---------------
Foo
baring It...
---------------
Bar
baring It...
---------------
Foo
baring It...
---------------
Foo
baring It...
---------------
Foo
baring It...
---------------
Foo
baring It...
---------------
Foo
baring It...
---------------</code></pre>
<p>main() can’t tell what kind of object CreateRandom() will return, so the C-style cast Bar* bar = (Bar*)base; is decidedly not type-safe. How could you fix this? One way would be to add a function like bool AreYouABar() const = 0; to the base class and return true from Bar and false from Foo. But there is another way: use dynamic_cast&lt;&gt;:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="number">10</span>; ++n )</span><br><span class="line">    &#123;</span><br><span class="line">        Base* base = <span class="built_in">CreateRandom</span>();</span><br><span class="line"></span><br><span class="line">        base-&gt;<span class="built_in">DoIt</span>();</span><br><span class="line"></span><br><span class="line">        Bar* bar = <span class="keyword">dynamic_cast</span>&lt;Bar*&gt;(base);</span><br><span class="line">        Foo* foo = <span class="keyword">dynamic_cast</span>&lt;Foo*&gt;(base);</span><br><span class="line">        <span class="keyword">if</span>( bar )</span><br><span class="line">            bar-&gt;<span class="built_in">BarIt</span>();</span><br><span class="line">        <span class="keyword">if</span>( foo )</span><br><span class="line">            foo-&gt;<span class="built_in">FooIt</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>The casts execute at runtime, and work by querying the object (no need to worry about how for now), asking it if it the type we’re looking for. If it is, dynamic_cast&lt;Type*&gt; returns a pointer; otherwise it returns NULL.</p>
<p>In order for this base-to-derived casting to work using dynamic_cast&lt;&gt;, Base, Foo and Bar must be what the Standard calls polymorphic types. In order to be a polymorphic type, your class must have at least one virtual function. If your classes are not polymorphic types, the base-to-derived use of dynamic_cast will not compile. Example:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Der</span> :</span> <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base* base = <span class="keyword">new</span> Der;</span><br><span class="line">    Der* der = <span class="keyword">dynamic_cast</span>&lt;Der*&gt;(base); <span class="comment">// ERROR - Won&#x27;t compile</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Adding a virtual function to base, such as a virtual dtor, will make both Base and Der polymorphic types:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Der</span> :</span> <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base* base = <span class="keyword">new</span> Der;</span><br><span class="line">    Der* der = <span class="keyword">dynamic_cast</span>&lt;Der*&gt;(base); <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h2><p>reinterpret_cast is a type of casting operator used in C++.</p>
<ul>
<li>It is used to convert one pointer of another pointer of any type, no matter either the class is related to each other or not.</li>
<li>It does not check if the pointer type and data pointed by the pointer is same or not.</li>
</ul>
<p><code>syntax:</code></p>
<pre><code>data_type *var_name = 
    reinterpret_cast &lt;data_type *&gt;(pointer_variable);</code></pre>
<p><code>Return Type：</code></p>
<p>It doesn’t have any return type. It simply converts the pointer type.</p>
<p><code>Purpose for using reinterpret_cast:</code></p>
<p>1 reinterpret_cast is a very special and dangerous type of casting operator. And is suggested to use it using proper data type i.e., (pointer data type should be same as original data type). <br><br>2 It can typecast any pointer to any other data type. <br><br>3 It is used when we want to work with bits. <br><br>4 If we use this type of cast then it becomes a non-portable product. So, it is suggested not to use this concept unless required. <br><br>5 It is only used to typecast any pointer to its original type. <br><br>6 Boolean value will be converted into integer value i.e., 0 for false and 1 for true. <br></p>
<p><strong>谷歌翻译</strong></p>
<p>1 reinterpret_cast是一种非常特殊且危险的类型转换操作符。建议使用它的时候要是合适的数据类型（指针数据类型应与原始数据类型相同） <br><br>2 它可以将任何指针类型转换为任何其他数据类型 <br><br>3 当我们要使用位时使用 <br><br>4 如果我们使用这种类型的演员表，那么它将成为不可携带的产品。因此，建议除非必要，否则不要使用此概念 <br><br>5 它仅用于将任何指针转换为原始类型 <br><br>6 布尔值将转换为整数值，即0代表false和1代表true <br></p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>static_cast,const_cast转换指针类型都会在编译期报错，这比c语言那种显示类型转换要安全 <br><br>const_cast修改最初声明为const的值是未定义的行为 <br><br>static_cast上行转换的时候，继承方式需要是public <br><br>dynamic_cast运行期转换，向下转换是安全的(会抛出异常或返回空指针)，但是向下转换的时候基类必须是多态的 <br></p>
<hr>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/03/31/dCyHLxeAhMwzm3s.jpg" alt="76654577_p0_lit.jpg"></p>
]]></content>
      <tags>
        <tag>c++11</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-fork和clone</title>
    <url>/2020-03-22-Linux-fork%E5%92%8Cclone/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/WzIZbqgahFakPozdeLGRtg">Linux fork那些隐藏的开销</a></p>
<p><a href="https://blog.csdn.net/dog250/article/details/100560290">Unix/Linux fork后传-clone</a></p>
<p><a href="https://blog.csdn.net/dog250/article/details/100538009">Unix/Linux fork/exec的前世今生</a></p>
<p><a href="https://blog.csdn.net/dog250/article/details/40208219">朴素的UNIX之-进程/线程模型</a></p>
<p><a href="https://root1iu.github.io/2019/02/02/athread%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%80%80%E5%87%BA%EF%BC%88%E4%B8%80%EF%BC%89/">线程库中的创建线程和退出线程</a></p>
<p><a href="https://blog.csdn.net/gatieme/article/details/51417488">Linux中fork，vfork和clone详解（区别与联系）</a></p>
<hr>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h3><p><a href="http://man7.org/linux/man-pages/man2/fork.2.html">man-pages</a></p>
<pre><code>   #include &lt;sys/types.h&gt;
   #include &lt;unistd.h&gt;

   pid_t fork(void);</code></pre>
<blockquote>
<p>fork() creates a new process by duplicating(复制) the calling process.  The new process is referred to as the child process.  The calling process is referred to as the parent process.</p>
</blockquote>
<p><strong>图片来源：</strong> <a href="https://blog.csdn.net/dog250/article/details/100538009">链接</a></p>
<p><img src="https://i.loli.net/2020/03/22/OaE1UPulbAFpT8X.png" alt="fork.png"></p>
<h3 id="fork的开销"><a href="#fork的开销" class="headerlink" title="fork的开销"></a>fork的开销</h3><ul>
<li>写时复制导致的内存开销</li>
<li>页目录和页表</li>
<li>vm_area_struct对象</li>
<li>死锁问题</li>
</ul>
<h3 id="写时复制导致的内存开销"><a href="#写时复制导致的内存开销" class="headerlink" title="写时复制导致的内存开销"></a>写时复制导致的内存开销</h3><p>fork后exec前,父进程修改常驻内存中的值,因为写时复制的原因,子进程会讲这些在内存中建立一个新的副本.(如果父进程不修改这些值,写时复制下,就没有这样的开销).可以使用vfork避免(子进程和父进程公用地址空间,子进程先于父进程执行,直到子进程exit/exec后父进程执行)</p>
<h3 id="页目录和页表"><a href="#页目录和页表" class="headerlink" title="页目录和页表"></a>页目录和页表</h3><p>fork后,在子进程exec执行前(刷新新的页目录，页表)，子进程会把父进程的页目录与页表进行复制，占用了内存，浪费了时间。具体参考<a href="https://mp.weixin.qq.com/s/WzIZbqgahFakPozdeLGRtg">Linux fork那些隐藏的开销</a></p>
<h3 id="vm-area-struct对象"><a href="#vm-area-struct对象" class="headerlink" title="vm_area_struct对象"></a>vm_area_struct对象</h3><p>fork后子进程也会复制父进程的vm_area_struct对象，如果父进程malloc/mmap很多，并且vm_area_struct对象都已经实际生成，则又造成大量的浪费。(exec前)具体参考<a href="https://mp.weixin.qq.com/s/WzIZbqgahFakPozdeLGRtg">Linux fork那些隐藏的开销</a></p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>具体参考<a href="https://mp.weixin.qq.com/s/WzIZbqgahFakPozdeLGRtg">Linux fork那些隐藏的开销</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap_unmap</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">		<span class="built_in">sleep</span> (<span class="number">4</span>);</span><br><span class="line">		<span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">pthread_mutex_init</span>(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, mmap_unmap, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">		<span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;未死锁!\n\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sleep</span>(<span class="number">1000</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<pre><code>//父进程        103420
//父进程线程    103421
//子进程        103423
a.out(103420)─┬─a.out(103423)
          └─&#123;a.out&#125;(103421)

Thread 2 (Thread 0x7f3e22f18700 (LWP 103421)):
#0  0x00007f3e22fd648d in nanosleep () from /lib64/libc.so.6
#1  0x00007f3e22fd6324 in sleep () from /lib64/libc.so.6
#2  0x0000000000400820 in mmap_unmap(void*) ()
#3  0x00007f3e23b00df5 in start_thread () from /lib64/libpthread.so.0
#4  0x00007f3e2300f1ad in clone () from /lib64/libc.so.6
Thread 1 (Thread 0x7f3e23f1c740 (LWP 103420)):
#0  0x00007f3e22fd648d in nanosleep () from /lib64/libc.so.6
#1  0x00007f3e22fd6324 in sleep () from /lib64/libc.so.6
#2  0x00000000004008a5 in main ()

//103423
#0  0x00007f3e23b06f7d in __lll_lock_wait () from /lib64/libpthread.so.0
#1  0x00007f3e23b02d32 in _L_lock_791 () from /lib64/libpthread.so.0
#2  0x00007f3e23b02c38 in pthread_mutex_lock () from /lib64/libpthread.so.0
#3  0x0000000000400887 in main ()</code></pre>
<p><strong>子进程在持有锁的情况下，再次lock,导致死锁</strong>   </p>
<pre><code>(gdb) p mutex
$1 = 2
(gdb) call pthread_mutex_unlock(&amp;mutex)
$2 = 0
(gdb) p mutex
$3 = 0</code></pre>
<h2 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h2><p><a href="http://man7.org/linux/man-pages/man2/clone.2.html">man page</a></p>
<pre><code>#define _GNU_SOURCE
#include &lt;sched.h&gt;

 int clone(int (*fn)(void *), void *stack, int flags, void *arg, ...
             /* pid_t *parent_tid, void *tls, pid_t *child_tid */ );

/* For the prototype of the raw clone() system call, see NOTES */</code></pre>
<p><code>flags mask</code></p>
<table>
    <thead align="center">
        <tr>
            <th style="text-align:center">mask</th>
            <th style="text-align:center">description</th>
        </tr>
    </thead>
    <tbody align="center">
        <tr>
            <td>CLONE_FILES</td>
            <td>共享文件描述符</td>
        </tr>
    </tbody>
    <tbody align="center">
        <tr>
            <td>CLONE_PID</td>
            <td>父子进程pid相同</td>
        </tr>
    </tbody>
    <tbody align="center">
        <tr>
            <td>CLONE_PTRACE</td>
            <td>若父进程被trace，子进程也被trace</td>
        </tr>
    </tbody>
    <tbody align="center">
        <tr>
            <td>CLONE_THREAD</td>
            <td>支持POSIX线程标准，子进程与父进程共享相同的线程群(内核级线程)</td>
        </tr>
    </tbody>
    <tbody align="center">
        <tr>
            <td>CLONE_SIGHAND</td>
            <td>共享信号表</td>
        </tr>
    </tbody>
    <tbody align="center">
        <tr>
            <td>CLONE_VFORK</td>
            <td>子进程先于父进程执行,类似vfrok</td>
        </tr>
    </tbody>
    <tbody align="CLONE_VM">
        <tr>
            <td>CLONE_FILES</td>
            <td>公用虚拟空间,mm_struct引用加一,不需要再复制一份vm_are_struct</td>
        </tr>
    </tbody>
</table>

<p>与fork（2）相比，这些系统调用可以更精确地控制在       调用进程和子进程之间共享哪些执行上下文。例如，使用这些系统调用，调用者可以控制两个进程是否共享虚拟地址空间，文件描述符表和信号处理程序表。这些系统调用还允许将新的子进程放置在单独的namespaces（7）中。</p>
<h3 id="CLONE-SIGHAND"><a href="#CLONE-SIGHAND" class="headerlink" title="CLONE_SIGHAND"></a>CLONE_SIGHAND</h3><p><strong>这里拷贝自:</strong><a href="https://root1iu.github.io/2019/02/02/athread%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%80%80%E5%87%BA%EF%BC%88%E4%B8%80%EF%BC%89/">线程库中的创建线程和退出线程</a></p>
<p>如果CLONE_SIGHAND被设置，调用进程和子进程共享信号处理器表。如果某个进程修改了信号的行为(通过sigaction(2))，会影响到另外的一个进程。但调用进程和子进程仍然拥有独立的信号掩码和信号处理集。所以他们可以使用sigprocmask(2)来阻塞和释放信号而不影响另外一个。</p>
<p>如果CLONE_SIGHAND没有被设置，子进程只会继承调用进程的信号处理函数副本，两个进程修改信号的行为不会影响另一个进程。</p>
<p>从Linux2.6.0开始，如果CLONE_SIGHAND被设置了，那么CLONE_VM也需要被设置。</p>
<h3 id="CLONE-VM"><a href="#CLONE-VM" class="headerlink" title="CLONE_VM"></a>CLONE_VM</h3><p><strong>这里拷贝自:</strong><a href="https://root1iu.github.io/2019/02/02/athread%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%80%80%E5%87%BA%EF%BC%88%E4%B8%80%EF%BC%89/">线程库中的创建线程和退出线程</a></p>
<p>如果CLONE_VM被设置了，那么调用进程和子进程共享内存空间。特别的，两个进程的内存写操作对另一个进程是透明的。更进一步，任何内存映射和释放映射都会影响另一个进程。</p>
<p>如果CLONE_VM没有被设置，那么子进程和调用进程运行在不同的内存空间中，即不共享内存空间。对进程中的内存操作不会影响另外一个进程。</p>
<h3 id="CLONE-THREAD"><a href="#CLONE-THREAD" class="headerlink" title="CLONE_THREAD"></a>CLONE_THREAD</h3><p><strong>这里拷贝自:</strong><a href="https://root1iu.github.io/2019/02/02/athread%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%80%80%E5%87%BA%EF%BC%88%E4%B8%80%EF%BC%89/">线程库中的创建线程和退出线程</a></p>
<p>CLONE_THREAD如果被设置，那么这个clone出来的子进程会和调用clone的进程进一个线程组，这里的”线程”指的是线程组里的进程</p>
<p>线程组是Linux 2.4版本加入的，用来支持POSIX thread的一个概念，即一个线程组共享一个PID。在内部，这个共享PID被叫做线程组ID，即TGID。从Linux 2.4开始，getpid(2)会返回调用者的TGID。</p>
<p>如果clone(2)没有指定CLONE_THREAD，那么新线程将会自己一个作为一个新的线程组，其中，TGID = TID。这个线程是新线程的头儿。</p>
<p>带CLONE_THREAD新建的线程和clone(2)的调用者有着一样的父进程。表现为getppid(2)返回相同的值。当一个CLONE_THREAD线程终止时，创建它的线程不会发送SIGCHLD信号以及其他终止信号；终止线程的状态也不会被wait(2)捕捉。(线程称为分离的)。只有当线程组中的线程都终止时，父进程会收到SIGCHLD信号。</p>
<p>如果线程组中的线程执行了execve(2)，那么除了线程头外的所有线程会终止，并且这个execve执行的新程序会在线程组头执行。</p>
<p>如果线程组中的一个线程使用fork(2)，那么线程组中的所有线程能够wait(2)这个子进程。</p>
<p>从Linux2.5.35开始，如果CLONE_THREAD被设置，那么CLONE_SIGHAND也需要被设置。需要注意的是，从Linux 2.6.0开始，CLONE_VM也需要跟着CLONE_SIGHAND一起被设置。</p>
<p>使用kill(2)来向线程组所有线程发送信号，使用tgkill()来向特定的线程发送信号。</p>
<p>信号的处理和行为是进程范围的，比如一个未处理的信号发送给一个线程，那么这个信号会影响到线程组中的所有线程。</p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap_unmap</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;hello!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, mmap_unmap, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>关键的系统调用:</p>
<blockquote>
<p>clone(child_stack=0x7fccd9a28fb0, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0x7fccd9a299d0, tls=0x7fccd9a29700, child_tidptr=0x7fccd9a299d0) = 109622</p>
</blockquote>
<pre><code>[pid 109622] exit(0)

exit_group(0)                           = ?</code></pre>
<p>CLONE_THREAD会将新的”进程”和调用进程加入一个相同的线程组,TGID.线程组的头线程推出调用exit_group,其他线程推出调用exit.再结合CLONE_VM就是常见的线程的实现(内核级线程)</p>
<p><strong>图片来自:</strong><a href="https://blog.csdn.net/dog250/article/details/100560290">Unix/Linux fork后传-clone</a></p>
<p><img src="https://i.loli.net/2020/03/23/XJi8eb1A2PgZSoB.jpg" alt="TGID_lit.jpg"></p>
<h3 id="linux内核级线程"><a href="#linux内核级线程" class="headerlink" title="linux内核级线程"></a>linux内核级线程</h3><p><code>内核级线程：</code> <br></p>
<blockquote>
<p>内核级线程又称为内核支持的线程</p>
</blockquote>
<ul>
<li>内核管理所有线程管理，并向应用程序提供API接口</li>
<li>内核维护进程和线程的上下文</li>
<li>线程的切换需要内核支持</li>
<li>以线程为基础进行调度</li>
<li>例子：Windows</li>
</ul>
<p>图片来源: <a href="https://blog.csdn.net/gatieme/article/details/51892437">https://blog.csdn.net/gatieme/article/details/51892437</a></p>
<p><img src="https://i.loli.net/2020/03/01/kfEQXRquNtzlTw6.jpg" alt="20200301_内核级线程.jpeg"></p>
<p>linux下,进程线程都是task_struct,通过CLONE_THREAD,新的进程和调用者进程的TGID是一样的,都是线程组头线程的PID.从Linux 2.4开始，getpid(2)会返回调用者的TGID。所以看到的表象就是线程组内的进程都是一个进程ID,通过CLONE_VM,这些线程组内的进程还可以公用虚拟空间,没有地址隔离,和进程的概念完全区别了.最后,exit只推出当前的task_struct,而exit_group退出线程组内所有线程的task_struct.</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文参考了大量文章,有的地方也还不是特别清楚,没有亲自去验证,去看底层实现.只能站在别人的肩膀上瞧瞧了.</p>
<hr>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/03/22/HBbD4hG2JdO57AU.jpg" alt="76922689_p0_master1200.jpg"></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>epoll惊群</title>
    <url>/2020-03-23-epoll%E6%83%8A%E7%BE%A4/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/dog250/article/details/80837278">再谈Linux epoll惊群问题的原因和解决方案</a></p>
<hr>
<a id="more"></a>

<h2 id="accept惊群问题"><a href="#accept惊群问题" class="headerlink" title="accept惊群问题"></a>accept惊群问题</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __wake_up_common(struct wait_queue_head *wq_head, <span class="keyword">unsigned</span> <span class="keyword">int</span> mode,</span><br><span class="line">			<span class="keyword">int</span> nr_exclusive, <span class="keyword">int</span> wake_flags, <span class="keyword">void</span> *key,</span><br><span class="line">			<span class="keyword">wait_queue_entry_t</span> *bookmark)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">wait_queue_entry_t</span> *curr, *next;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;wq_head-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bookmark &amp;&amp; (bookmark-&gt;flags &amp; WQ_FLAG_BOOKMARK)) &#123;</span><br><span class="line">		curr = list_next_entry(bookmark, entry);</span><br><span class="line"></span><br><span class="line">		list_del(&amp;bookmark-&gt;entry);</span><br><span class="line">		bookmark-&gt;flags = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		curr = list_first_entry(&amp;wq_head-&gt;head, <span class="keyword">wait_queue_entry_t</span>, entry);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (&amp;curr-&gt;entry == &amp;wq_head-&gt;head)</span><br><span class="line">		<span class="keyword">return</span> nr_exclusive;</span><br><span class="line"></span><br><span class="line">	list_for_each_entry_safe_from(curr, next, &amp;wq_head-&gt;head, entry) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> flags = curr-&gt;flags;</span><br><span class="line">		<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (flags &amp; WQ_FLAG_BOOKMARK)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//唤醒函数</span></span><br><span class="line">		ret = curr-&gt;func(curr, mode, wake_flags, key);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (ret &amp;&amp; (flags &amp; WQ_FLAG_EXCLUSIVE) &amp;&amp; !--nr_exclusive)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (bookmark &amp;&amp; (++cnt &gt; WAITQUEUE_WALK_BREAK_CNT) &amp;&amp;</span><br><span class="line">				(&amp;next-&gt;entry != &amp;wq_head-&gt;head)) &#123;</span><br><span class="line">			bookmark-&gt;flags = WQ_FLAG_BOOKMARK;</span><br><span class="line">			list_add_tail(&amp;bookmark-&gt;entry, &amp;next-&gt;entry);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> nr_exclusive;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WQ_FLAG_EXCLUSIVE参数可以确保只wake one,而不是wake many.可以解决该问题 <br><br>如果是WQ_FLAG_EXCLUSIVE，则wake一次就退出循环</p>
<h2 id="epoll惊群问题"><a href="#epoll惊群问题" class="headerlink" title="epoll惊群问题"></a>epoll惊群问题</h2><p><code>linux 3.10.1 kernel</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_send_events_proc</span><span class="params">(struct eventpoll *ep, struct list_head *head,</span></span></span><br><span class="line"><span class="function"><span class="params">			       <span class="keyword">void</span> *priv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ep_send_events_data</span> *<span class="title">esed</span> =</span> priv;</span><br><span class="line">	<span class="keyword">int</span> eventcnt;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> revents;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> __<span class="title">user</span> *<span class="title">uevent</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wakeup_source</span> *<span class="title">ws</span>;</span></span><br><span class="line">	poll_table pt;</span><br><span class="line"></span><br><span class="line">	init_poll_funcptr(&amp;pt, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (eventcnt = <span class="number">0</span>, uevent = esed-&gt;events;</span><br><span class="line">	     !list_empty(head) &amp;&amp; eventcnt &lt; esed-&gt;maxevents;) &#123;</span><br><span class="line">		epi = list_first_entry(head, struct epitem, rdllink);</span><br><span class="line"></span><br><span class="line">		ws = ep_wakeup_source(epi);</span><br><span class="line">		<span class="keyword">if</span> (ws) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ws-&gt;active)</span><br><span class="line">				__pm_stay_awake(ep-&gt;ws);</span><br><span class="line">			__pm_relax(ws);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//先从就绪链表删除</span></span><br><span class="line">		list_del_init(&amp;epi-&gt;rdllink);</span><br><span class="line"></span><br><span class="line">		revents = ep_item_poll(epi, &amp;pt);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (revents) &#123;</span><br><span class="line">			<span class="keyword">if</span> (__put_user(revents, &amp;uevent-&gt;events) ||</span><br><span class="line">			    __put_user(epi-&gt;event.data, &amp;uevent-&gt;data)) &#123;</span><br><span class="line">				list_add(&amp;epi-&gt;rdllink, head);</span><br><span class="line">				ep_pm_stay_awake(epi);</span><br><span class="line">				<span class="keyword">return</span> eventcnt ? eventcnt : -EFAULT;</span><br><span class="line">			&#125;</span><br><span class="line">			eventcnt++;</span><br><span class="line">			uevent++;</span><br><span class="line">			<span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLONESHOT)</span><br><span class="line">				epi-&gt;event.events &amp;= EP_PRIVATE_BITS;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!(epi-&gt;event.events &amp; EPOLLET)) &#123;</span><br><span class="line">				<span class="comment">//LT模式下会继续加入就绪链表 </span></span><br><span class="line">				list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">				ep_pm_stay_awake(epi);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> eventcnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_scan_ready_list</span><span class="params">(struct eventpoll *ep,</span></span></span><br><span class="line"><span class="function"><span class="params">			      <span class="keyword">int</span> (*sproc)(struct eventpoll *,</span></span></span><br><span class="line"><span class="function"><span class="params">					   struct list_head *, <span class="keyword">void</span> *),</span></span></span><br><span class="line"><span class="function"><span class="params">			      <span class="keyword">void</span> *priv,</span></span></span><br><span class="line"><span class="function"><span class="params">			      <span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> error, pwake = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>, *<span class="title">nepi</span>;</span></span><br><span class="line">	LIST_HEAD(txlist);</span><br><span class="line"></span><br><span class="line">	mutex_lock_nested(&amp;ep-&gt;mtx, depth);</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">	list_splice_init(&amp;ep-&gt;rdllist, &amp;txlist);</span><br><span class="line">	ep-&gt;ovflist = <span class="literal">NULL</span>;</span><br><span class="line">	spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">	error = (*sproc)(ep, &amp;txlist, priv);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//回调函数中判断如果是LT模式，则继续加入就绪链表</span></span><br><span class="line">	spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (nepi = ep-&gt;ovflist; (epi = nepi) != <span class="literal">NULL</span>;</span><br><span class="line">	     nepi = epi-&gt;next, epi-&gt;next = EP_UNACTIVE_PTR) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!ep_is_linked(&amp;epi-&gt;rdllink)) &#123;</span><br><span class="line">			list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">			ep_pm_stay_awake(epi);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ep-&gt;ovflist = EP_UNACTIVE_PTR;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!list_empty(&amp;ep-&gt;rdllist)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Wake up (if active) both the eventpoll wait list and</span></span><br><span class="line"><span class="comment">		 * the -&gt;poll() wait list (delayed after we release the lock).</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">			wake_up_locked(&amp;ep-&gt;wq);</span><br><span class="line">		<span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">			pwake++;</span><br><span class="line">	&#125;</span><br><span class="line">	spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;ep-&gt;mtx);</span><br><span class="line">	<span class="comment">//.............................</span></span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>LT模式下<strong>惊群</strong>的原因：如果是水平触发，从就绪链表中取出后发送给用户空间然后又加入了就绪链表，然会判断队列非空，会唤醒其他阻塞在epoll_wait的进程/线程。这里的关键是epoll是怎么唤醒的</p>
<h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p>用这个作者<a href="https://blog.csdn.net/dog250/article/details/80837278">再谈Linux epoll惊群问题的原因和解决方案</a>的demo测试</p>
<p>里面有个值需要改大点才能复现出来，把这个彩蛋留下来，本文只复制人间的demo,不改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;socket.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;epoll.h&gt;</span><br><span class="line">#include &lt;netdb.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;wait.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">#define COUNT 1</span><br><span class="line"></span><br><span class="line">int mode &#x3D; 0;</span><br><span class="line">int slp &#x3D; 0;</span><br><span class="line"></span><br><span class="line">int pid[COUNT] &#x3D; &#123;0&#125;;</span><br><span class="line">int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">void server(int epfd) </span><br><span class="line">&#123;</span><br><span class="line">    struct epoll_event *events;</span><br><span class="line">    int num, i;</span><br><span class="line">        struct timespec ts;</span><br><span class="line"></span><br><span class="line">    events &#x3D; calloc(64, sizeof(struct epoll_event));</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line">        int sd, csd;</span><br><span class="line">        struct sockaddr in_addr;</span><br><span class="line"></span><br><span class="line">        num &#x3D; epoll_wait(epfd, events, 64, -1);</span><br><span class="line">        if (num &lt;&#x3D; 0) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;*</span><br><span class="line">        ts.tv_sec &#x3D; 0;</span><br><span class="line">        ts.tv_nsec &#x3D; 1;</span><br><span class="line">        if(nanosleep(&amp;ts, NULL) !&#x3D; 0) &#123;</span><br><span class="line">            perror(&quot;nanosleep&quot;);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">        *&#x2F;</span><br><span class="line">        &#x2F;&#x2F; 用于测试ET模式下丢事件的情况</span><br><span class="line">        if (slp) &#123;</span><br><span class="line">            sleep(slp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sd &#x3D; events[0].data.fd;</span><br><span class="line">        socklen_t in_len &#x3D; sizeof(in_addr);</span><br><span class="line"></span><br><span class="line">        csd &#x3D; accept(sd, &amp;in_addr, &amp;in_len);</span><br><span class="line">        if (csd &#x3D;&#x3D; -1) &#123;</span><br><span class="line">            &#x2F;&#x2F; 打印这个说明中了epoll LT惊群的招了。</span><br><span class="line">            printf(&quot;shit xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx:%d\n&quot;, getpid()); </span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 本进程一共成功处理了多少个请求。</span><br><span class="line">        count ++;</span><br><span class="line">        printf(&quot;get client:%d\n&quot;, getpid()); </span><br><span class="line">        close(csd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void siguser_handler(int sig)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 在主进程被Ctrl-C退出的时候，每一个子进程均要打印自己处理了多少个请求。</span><br><span class="line">    printf(&quot;pid:%d  count:%d\n&quot;, getpid(), count);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void sigint_handler(int sig)</span><br><span class="line">&#123;</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; 给每一个子进程发信号，要求其打印自己处理了多少个请求。</span><br><span class="line">    for (i &#x3D; 0; i &lt; COUNT; i++) &#123;</span><br><span class="line">        kill(pid[i], SIGUSR1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main (int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int ret &#x3D; 0;</span><br><span class="line">        int listener;</span><br><span class="line">    int c &#x3D; 0;</span><br><span class="line">    struct sockaddr_in saddr;</span><br><span class="line">    int port;</span><br><span class="line">    int status;</span><br><span class="line">        int flags;</span><br><span class="line">    int epfd;</span><br><span class="line">    struct epoll_event event;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if (argc &lt; 4) &#123;</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 0为LT模式，1为ET模式</span><br><span class="line">    mode &#x3D; atoi(argv[1]);</span><br><span class="line">    port &#x3D; atoi(argv[2]);</span><br><span class="line">    &#x2F;&#x2F; 是否在处理accept之前耽搁一会儿，这个参数更容易重现问题</span><br><span class="line">    slp &#x3D; atoi(argv[3]);</span><br><span class="line"></span><br><span class="line">    signal(SIGINT, sigint_handler);</span><br><span class="line"></span><br><span class="line">    listener &#x3D; socket(PF_INET, SOCK_STREAM, 0);</span><br><span class="line"></span><br><span class="line">    saddr.sin_family &#x3D; AF_INET;</span><br><span class="line">    saddr.sin_port &#x3D; htons(port);</span><br><span class="line">    saddr.sin_addr.s_addr &#x3D; INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    bind(listener, (struct sockaddr*)&amp;saddr, sizeof(saddr));</span><br><span class="line">    listen(listener, SOMAXCONN);</span><br><span class="line"></span><br><span class="line">    flags &#x3D; fcntl (listener, F_GETFL, 0);</span><br><span class="line">    flags |&#x3D; O_NONBLOCK;</span><br><span class="line">    fcntl (listener, F_SETFL, flags);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    epfd &#x3D; epoll_create(64);</span><br><span class="line">    if (epfd &#x3D;&#x3D; -1) &#123;</span><br><span class="line">        perror(&quot;epoll_create&quot;);</span><br><span class="line">        abort();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event.data.fd &#x3D; listener;</span><br><span class="line">    event.events &#x3D; EPOLLIN;</span><br><span class="line">    if (mode &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        event.events |&#x3D; EPOLLET;</span><br><span class="line">    &#125; else if (mode &#x3D;&#x3D; 2) &#123;</span><br><span class="line">        event.events |&#x3D; EPOLLONESHOT;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    ret &#x3D; epoll_ctl(epfd, EPOLL_CTL_ADD, listener, &amp;event);</span><br><span class="line">    if (ret &#x3D;&#x3D; -1) &#123;</span><br><span class="line">        perror(&quot;epoll_ctl&quot;);</span><br><span class="line">        abort();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    for(c &#x3D; 0; c &lt; COUNT; c++) &#123;</span><br><span class="line">        int child;</span><br><span class="line">            child &#x3D; fork();</span><br><span class="line">            if(child &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 安装打印count值的信号处理函数</span><br><span class="line">                    signal(SIGUSR1, siguser_handler);</span><br><span class="line">                    server(epfd);</span><br><span class="line">            &#125;</span><br><span class="line">        pid[c] &#x3D; child;</span><br><span class="line">        printf(&quot;server:%d  pid:%d\n&quot;, c+1, child);</span><br><span class="line">        &#125;</span><br><span class="line">    wait(&amp;status);</span><br><span class="line">    sleep(1000000);</span><br><span class="line">    close (listener);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>遗留问题</strong></p>
<p>再有的服务器上测试上面的代码可以复现(试了kernel 2.6版本和3.10版本).但在我虚拟机(3.10 版本)死活复现不出来。不知道具体原因了。按照上面csdn那篇文章理解是会出现这种情况(前提是，一个epoll_wait释放了wait链后，其他epoll_wait的wait还是生效的，不过分析感觉应该是生效的，也可能跟进程还是线程监控有关系把)。这个留作以后有时间了再研究吧。</p>
<hr>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/03/22/2ilWXtmQakFgfRv.jpg" alt="71671791_p0_master1200_lit.jpg"></p>
]]></content>
      <tags>
        <tag>IO复用</tag>
      </tags>
  </entry>
  <entry>
    <title>sizeof</title>
    <url>/2020-03-23-sizeof/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://stackoverflow.com/questions/8225776/why-does-sizeofx-not-increment-x">Why does sizeof(x++) not increment x?</a></p>
<p><a href="https://www.cnblogs.com/chio/archive/2007/06/11/778934.html">C++ sizeof 使用规则及陷阱分析</a></p>
<hr>
<a id="more"></a>

<h2 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h2><blockquote>
<p>The sizeof operator yields the size (in bytes) of its operand, which may be an expression or the parenthesized name of a type. The size is determined from the type of the operand. The result is an integer. If the type of the operand is a variable length array type, the operand is evaluated; otherwise, the operand is not evaluated and the result is an integer constant.</p>
</blockquote>
<p><strong>这段话有几个重要的点:</strong> <br></p>
<ul>
<li>sizeof是运算符，不是函数</li>
<li>如果操作数的类型是可变长度数组类型，则对操作数求值。否则不对操作数求值</li>
</ul>
<p>基于以上两点，再细化下</p>
<pre><code>cout &lt;&lt; sizeof(5) &lt;&lt; endl; // 4
cout &lt;&lt; sizeof 5 &lt;&lt; endl; // 4</code></pre>
<p>上面两种方式都是正确的，但要注意，如果操作数是类型不是对象，则要加().</p>
<pre><code>cout &lt;&lt; sizeof(int) &lt;&lt; endl; // 4
//cout &lt;&lt; sizeof int &lt;&lt; endl;  //error</code></pre>
<p>sizeof(i++)问题：</p>
<pre><code>int i = 5;
cout &lt;&lt; sizeof(i++) &lt;&lt; endl; //4
cout &lt;&lt; i &lt;&lt; endl; //5</code></pre>
<p>原因开头也讲了:<code>如果操作数的类型是可变长度数组类型，则对操作数求值。否则不对操作数求值</code>.</p>
<hr>
<h2 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h2><p>记录下<a href="https://www.cnblogs.com/chio/archive/2007/06/11/778934.html">这篇文章</a>中提到的一些sizeof容易搞错的点，挑了一部分</p>
<p><strong>001</strong> </p>
<pre><code>int a = 0;
cout&lt;&lt;sizeof(a=3)&lt;&lt;endl;    //4
cout&lt;&lt;a&lt;&lt;endl;              //0</code></pre>
<ul>
<li>和上面的一样，不对操作数求值</li>
</ul>
<p><strong>002</strong> </p>
<pre><code>int f1() &#123; return 0; &#125;
void f3() &#123;&#125;
cout &lt;&lt; sizeof(f3()) &lt;&lt; endl;   //错误    C2070    “void”: 非法的 sizeof 操作数
cout &lt;&lt; sizeof(f1) &lt;&lt; endl;     //错误    C2070    “int (void)”: 非法的 sizeof 操作数</code></pre>
<ul>
<li>不能求void的大小</li>
<li>不能求函数地址的大小(*f3或者f3()是正确的)</li>
</ul>
<p><strong>003</strong> </p>
<pre><code>char a[] = &quot;abcdef&quot;;
char b[] = &#123; &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39; &#125;;
int c[20] = &#123; 3, 4 &#125;;
char d[2][3] = &#123; &quot;aa&quot;, &quot;bb&quot; &#125;;


cout &lt;&lt; sizeof(a) &lt;&lt; endl; // 7, 表示字符串
cout &lt;&lt; sizeof(b) &lt;&lt; endl; // 6， 仅表示字符数组
cout &lt;&lt; sizeof(c) &lt;&lt; endl; // 80
cout &lt;&lt; sizeof(d) &lt;&lt; endl; // 6 = 2*3</code></pre>
<ul>
<li>注意常量字符串的末尾的结束符    </li>
<li>注意数组的大小是元素大小*元素个数</li>
</ul>
<p><strong>004</strong> </p>
<pre><code>int *d = new int[10];
cout &lt;&lt; sizeof(d) &lt;&lt; endl; // 4
cout &lt;&lt; d &lt;&lt; endl;    //014852D8</code></pre>
<ul>
<li>d实际还是指针</li>
</ul>
<p><strong>005</strong> </p>
<pre><code>double* (*a)[3][6];

cout &lt;&lt; sizeof(a) &lt;&lt; endl;  // 4
cout &lt;&lt; sizeof(*a) &lt;&lt; endl;  // 72 
cout &lt;&lt; sizeof(**a) &lt;&lt; endl; // 24
cout &lt;&lt; sizeof(***a) &lt;&lt; endl; // 4
cout &lt;&lt; sizeof(****a) &lt;&lt; endl; // 8</code></pre>
<ul>
<li>a是指针</li>
<li><em>a是二维数组的数组名 72 = 3</em>6*4</li>
<li>**a指向一维数组 24 = 6 * 4</li>
<li>***a指向一维数组的第一个元素(指针) 4</li>
<li>****a指向第一个指针指向的double类型的值 8</li>
</ul>
<p><strong>006</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sum</span><span class="params">(<span class="keyword">int</span> i[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; endl;	<span class="comment">//0053F9A8</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(i) &lt;&lt; endl; <span class="comment">//4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i[<span class="number">5</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Sum</span>(i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>这里的i是存放地址的指针</li>
</ul>
<p><strong>OTHER</strong> </p>
<p>空类的大小是1 <br><br>内存对齐的问题另外整理</p>
<hr>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/03/23/ROnQXMFVjdNzvT4.jpg" alt="80111456_p0_master1200.jpg"></p>
]]></content>
      <tags>
        <tag>sizeof</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-虚拟存储系统</title>
    <url>/2020-03-23-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://sylvanassun.github.io/2017/10/29/2017-10-29-virtual_memory/">虚拟内存的那点事儿</a></p>
<p><a href="">陈向群操作系统</a></p>
<hr>
<a id="more"></a>

<h2 id="虚拟存储系统"><a href="#虚拟存储系统" class="headerlink" title="虚拟存储系统"></a>虚拟存储系统</h2><p><strong>所谓虚拟存储技术是指：当进程运行时，先将其一部分装入内存，另一部分暂留在磁盘，当要执行的指令或访问的数据不在内存时，由操作系统自动完成将它们从磁盘调入内存的工作</strong></p>
<h3 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h3><blockquote>
<p>分配给进程的虚拟内存</p>
</blockquote>
<h3 id="虚拟页式存储"><a href="#虚拟页式存储" class="headerlink" title="虚拟页式存储"></a>虚拟页式存储</h3><p><strong><code>即虚拟存储技术+页式存储管理方案</code></strong></p>
<p>基本思想：</p>
<ul>
<li>进程开始运行之前，不是装入全部页面，而是装入一个或零个页面</li>
<li>之后，根据进程运行的需要，动态装入其他页面</li>
<li>当内存空间已满，而又需要装入新的页面时，则根据某种算法置换内存中的某个页面，以便装入新的页面</li>
</ul>
<hr>
<h2 id="页式存储"><a href="#页式存储" class="headerlink" title="页式存储"></a>页式存储</h2><ul>
<li>用户进程地址空间被划分为大小相等的部分，称为页（page）或页面，从0开始编号</li>
<li>内存空间按同样大小划分为大小相等的区域，称为页框（page frame），从0开始编号；也称为物理页面，页帧，内存块</li>
</ul>
<p><strong><code>以页为单位进行分配，并按进程需要的页数来分配；逻辑上相邻的页，物理上不一定相邻</code></strong></p>
<h3 id="页表项"><a href="#页表项" class="headerlink" title="页表项"></a>页表项</h3><blockquote>
<p>记录了逻辑页号与页框号的对应关系</p>
</blockquote>
<p><img src="https://i.loli.net/2020/03/23/E5XH31jGcble6mS.png" alt="页表.png"></p>
<hr>
<h3 id="一级页表"><a href="#一级页表" class="headerlink" title="一级页表"></a>一级页表</h3><p><strong>图片来源:</strong><a href="https://sylvanassun.github.io/2017/10/29/2017-10-29-virtual_memory/">虚拟内存的那点事儿</a><br><img src="https://i.loli.net/2020/03/23/2MB7InqceVy1jY5.png" alt="一级页表.png"></p>
<hr>
<h3 id="2级页表"><a href="#2级页表" class="headerlink" title="2级页表"></a>2级页表</h3><p><strong>图片来源:</strong><a href="https://sylvanassun.github.io/2017/10/29/2017-10-29-virtual_memory/">虚拟内存的那点事儿</a><br><img src="https://i.loli.net/2020/03/23/rgcOa3Jp4CDLEHZ.png" alt="2级页表.png"></p>
<p><img src="https://i.loli.net/2020/03/23/E7NoPdGaBt3AshX.png" alt="2级页表结构.png"></p>
<p><strong>计算</strong></p>
<p>2^10 * 2^10 * 2^12 = 1024 * 1024 * 4KB = 4G</p>
<hr>
<h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p><img src="https://i.loli.net/2020/03/23/wnSDGxPIldBZbiK.png" alt="多级页表.png"></p>
<p><strong>优势：</strong></p>
<ul>
<li>多级页表的第一层目录全部加载在内存，其余层部分加载，这样节省了内存</li>
<li>前面的目录项都是索引，如果第一层就不存在，后面也就不用继续遍历了，提高了查询效率</li>
</ul>
<hr>
<p><code>页表起始地址保存在何处？</code></p>
<p>mm_struct的pgd保存了进程的页表项起始地址，当执行一个进程的时候，页表项起始地址会被放到页表基址寄存器中。</p>
<p><img src="https://i.loli.net/2020/03/04/qi568fuBnzmxDHc.png" alt="task_struct.png"></p>
<hr>
<p><code>页表保存在哪里？</code></p>
<p>页表保存在磁盘，内存，MMU的TLB(快表)缓存中</p>
<p><img src="https://i.loli.net/2020/03/23/oriMy2RXVU5fjIL.png" alt="存储器.png"></p>
<hr>
<h2 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h2><h3 id="MMU-memory-management-unit"><a href="#MMU-memory-management-unit" class="headerlink" title="MMU(memory management unit)"></a>MMU(memory management unit)</h3><blockquote>
<p>内存管理单元</p>
</blockquote>
<p><img src="https://i.loli.net/2020/03/23/rT6Ze7v4bjGSMIk.png" alt="mmu1.png"></p>
<p><img src="https://i.loli.net/2020/03/23/z7SroZuvncpqFMX.png" alt="mmu2.png"></p>
<hr>
<h3 id="TBL-translation-lookaside-buffer"><a href="#TBL-translation-lookaside-buffer" class="headerlink" title="TBL(translation lookaside buffer)"></a>TBL(translation lookaside buffer)</h3><ul>
<li>在CPU中引入的高速缓存（Cache），可以匹配CPU的处理速率和内存的访问速度</li>
<li>一种随机存取型存储器，除连线寻址机制外，还有接线逻辑，能按特定的匹配标志在一个存储周期内对所有的字同时进行比较</li>
</ul>
<p><img src="https://i.loli.net/2020/03/23/xqPJronleHQXtgR.png" alt="tlb.png"></p>
<hr>
<h2 id="页错误"><a href="#页错误" class="headerlink" title="页错误"></a>页错误</h2><ul>
<li>又称页面错误、页故障、页面失效</li>
<li>地址转换过程中硬件产生的异常</li>
</ul>
<p><strong>具体原因：</strong></p>
<ul>
<li>所访问的虚拟页面没有调入物理内存(<code>缺页异常</code>)</li>
<li>页面访问违反权限（读/写、用户/内核）</li>
<li>错误的访问地址</li>
</ul>
<h3 id="缺页异常"><a href="#缺页异常" class="headerlink" title="缺页异常"></a>缺页异常</h3><ul>
<li>是一种Page Fault</li>
<li>在地址映射过程中，硬件检查页表时发现所要访问的页面不在内存，则产生该异常——缺页异常</li>
<li>操作系统执行缺页异常处理程序：获得磁盘地址，启动磁盘，将该页调入内存</li>
</ul>
<hr>
<h2 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h2><p><strong>内存空间紧张时，系统将内存中某些进程暂时移到外存，把外存中某些进程换进内存，占据前者所占用的区域（进程在内存与磁盘之间的动态调度）</strong></p>
<p>进程的哪些内容要交换到磁盘？会遇到什么困难？</p>
<blockquote>
<p>运行时创建或修改的内容：栈和堆</p>
</blockquote>
<p>在磁盘的什么位置保存被换出的进程？</p>
<blockquote>
<p>交换区：一般系统会指定一块特殊的磁盘区域作为交换空间（swap space），包含连续的磁道，操作系统可以使用底层的磁盘读写操作对其高效访问</p>
</blockquote>
<p>交换时机？</p>
<blockquote>
<p>只要不用就换出（很少再用）；内存空间不够或有不够的危险时换出</p>
</blockquote>
<p>如何选择被换出的进程？</p>
<blockquote>
<p>考虑进程的各种属性；不应换出处于等待I/O状态的进程</p>
</blockquote>
<hr>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/03/23/pHqQ4w6uMUinO8J.jpg" alt="77766200_p0_master1200.jpg"></p>
]]></content>
      <tags>
        <tag>OperatingSystem</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-waitqueue</title>
    <url>/2020-03-24-linux-waitqueue/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/dagefeijiqumeiguo/article/details/53941333">Linux设备驱动六 (1)等待队列</a></p>
<p><a href="https://www.cnblogs.com/johnnyflute/p/3823393.html">IO多路复用的几种实现机制的分析</a></p>
<p><a href="http://janfan.cn/chinese/2015/01/05/select-poll-impl-inside-the-kernel.html">select()/poll() 的内核实现</a></p>
<p><a href="">内核源码</a></p>
<a id="more"></a>

<hr>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="wait-queue-head-t"><a href="#wait-queue-head-t" class="headerlink" title="wait_queue_head_t"></a>wait_queue_head_t</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /include/linux/wait.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wait_queue_head</span> &#123;</span></span><br><span class="line">	<span class="keyword">spinlock_t</span>		lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">head</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">wait_queue_head</span> <span class="title">wait_queue_head_t</span>;</span></span><br></pre></td></tr></table></figure>

<h3 id="wait-queue-t"><a href="#wait-queue-t" class="headerlink" title="wait_queue_t"></a>wait_queue_t</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /include/linux/wait.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wait_queue_entry</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		flags;      <span class="comment">//唤醒方式 WQ_FLAG_EXCLUSIVE/0</span></span><br><span class="line">	<span class="keyword">void</span>			*<span class="keyword">private</span>;       <span class="comment">//保存睡眠进程描述符地址task_struct</span></span><br><span class="line">	<span class="keyword">wait_queue_func_t</span>	func;       <span class="comment">//唤醒方法</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">entry</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>唤醒方式有 WQ_FLAG_EXCLUSIVE 或者 0；WQ_FLAG_EXCLUSIVE：表示节点对应进程对临界资源使用具有排他性。在唤醒是会唤醒所有非排他性进程和一定数量的排他性进程。</p>
<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><h3 id="init-waitqueue-head"><a href="#init-waitqueue-head" class="headerlink" title="init_waitqueue_head"></a>init_waitqueue_head</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> init_waitqueue_head(wq_head)						\</span></span><br><span class="line">	<span class="keyword">do</span> &#123;									\</span><br><span class="line">		<span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> __<span class="title">key</span>;</span>				\</span><br><span class="line">										\</span><br><span class="line">		__init_waitqueue_head((wq_head), #wq_head, &amp;__key);		\</span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> __init_waitqueue_head(struct wait_queue_head *wq_head, </span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name, struct lock_class_key *);	</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __init_waitqueue_head(struct wait_queue_head *wq_head, </span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name, struct lock_class_key *key)</span><br><span class="line">&#123;</span><br><span class="line">	spin_lock_init(&amp;wq_head-&gt;lock);</span><br><span class="line">	lockdep_set_class_and_name(&amp;wq_head-&gt;lock, key, name);</span><br><span class="line">	INIT_LIST_HEAD(&amp;wq_head-&gt;head);</span><br><span class="line">&#125;</span><br><span class="line">```	</span><br><span class="line">----------------------------------</span><br><span class="line"></span><br><span class="line">### add_wait_queue</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_wait_queue</span><span class="params">(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	wq_entry-&gt;flags &amp;= ~WQ_FLAG_EXCLUSIVE;</span><br><span class="line">	spin_lock_irqsave(&amp;wq_head-&gt;lock, flags); <span class="comment">//自旋锁加锁并禁用中断</span></span><br><span class="line">	__add_wait_queue(wq_head, wq_entry);		<span class="comment">//wait_queue_entry添加到链表wait_queue_head</span></span><br><span class="line">	spin_unlock_irqrestore(&amp;wq_head-&gt;lock, flags); <span class="comment">//自旋锁解锁并开启中断</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(add_wait_queue);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __add_wait_queue(</span><br><span class="line">	struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)</span><br><span class="line">&#123;</span><br><span class="line">	list_add(&amp;wq_entry-&gt;entry, &amp;wq_head-&gt;head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="add-wait-queue-exclusive"><a href="#add-wait-queue-exclusive" class="headerlink" title="add_wait_queue_exclusive"></a>add_wait_queue_exclusive</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Used for wake-one threads:</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_wait_queue_exclusive</span><span class="params">(struct wait_queue_head *wq_head, </span></span></span><br><span class="line"><span class="function"><span class="params">	struct wait_queue_entry *wq_entry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	wq_entry-&gt;flags |= WQ_FLAG_EXCLUSIVE;</span><br><span class="line">	spin_lock_irqsave(&amp;wq_head-&gt;lock, flags);</span><br><span class="line">	__add_wait_queue_entry_tail(wq_head, wq_entry);</span><br><span class="line">	spin_unlock_irqrestore(&amp;wq_head-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(add_wait_queue_exclusive);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __add_wait_queue_entry_tail(</span><br><span class="line">	struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)</span><br><span class="line">&#123;</span><br><span class="line">	list_add_tail(&amp;wq_entry-&gt;entry, &amp;wq_head-&gt;head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="remove-wait-queue"><a href="#remove-wait-queue" class="headerlink" title="remove_wait_queue"></a>remove_wait_queue</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove_wait_queue</span><span class="params">(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;wq_head-&gt;lock, flags);</span><br><span class="line">	__remove_wait_queue(wq_head, wq_entry);</span><br><span class="line">	spin_unlock_irqrestore(&amp;wq_head-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">__remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)</span><br><span class="line">&#123;</span><br><span class="line">	list_del(&amp;wq_entry-&gt;entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="wait-event"><a href="#wait-event" class="headerlink" title="wait_event"></a>wait_event</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**					***********************************************</span></span><br><span class="line"><span class="comment"> * wait_event - sleep until a condition gets true</span></span><br><span class="line"><span class="comment"> * @wq_head: the waitqueue to wait on</span></span><br><span class="line"><span class="comment"> * @condition: a C expression for the event to wait for</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The process is put to sleep (TASK_UNINTERRUPTIBLE) until the</span></span><br><span class="line"><span class="comment"> * @condition evaluates to true. The @condition is checked each time</span></span><br><span class="line"><span class="comment"> * the waitqueue @wq_head is woken up.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * wake_up() has to be called after changing any variable that could</span></span><br><span class="line"><span class="comment"> * change the result of the wait condition.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wait_event(wq_head, condition)						\</span></span><br><span class="line"><span class="keyword">do</span> &#123;										\</span><br><span class="line">	might_sleep();								\</span><br><span class="line">	<span class="keyword">if</span> (condition)								\</span><br><span class="line">		<span class="keyword">break</span>;								\</span><br><span class="line">	__wait_event(wq_head, condition);					\</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//__wait_event		***********************************************</span></span><br><span class="line"><span class="comment">//设置状态为不可打断</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __wait_event(wq_head, condition)					\</span></span><br><span class="line">	(<span class="keyword">void</span>)___wait_event(wq_head, condition, TASK_UNINTERRUPTIBLE, <span class="number">0</span>, <span class="number">0</span>,	\</span><br><span class="line">			    schedule())</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//___wait_event     ***********************************************</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The below macro ___wait_event() has an explicit(明确的) shadow of the __ret</span></span><br><span class="line"><span class="comment"> * variable when used from the wait_event_*() macros.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is so that both can use the ___wait_cond_timeout() construct</span></span><br><span class="line"><span class="comment"> * to wrap the condition.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The type inconsistency of the wait_event_*() __ret variable is also</span></span><br><span class="line"><span class="comment"> * on purpose; we use long where we can return timeout values and int</span></span><br><span class="line"><span class="comment"> * otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ___wait_event(wq_head, condition, state, exclusive, ret, cmd)		\</span></span><br><span class="line">(&#123;										\</span><br><span class="line">	__label__ __out;							\</span><br><span class="line">	struct wait_queue_entry __wq_entry;					\</span><br><span class="line">	<span class="keyword">long</span> __ret = ret;	<span class="comment">/* explicit shadow */</span>				\</span><br><span class="line">										\</span><br><span class="line">	init_wait_entry(&amp;__wq_entry, exclusive ? WQ_FLAG_EXCLUSIVE : <span class="number">0</span>);	\</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;								\</span><br><span class="line">		<span class="keyword">long</span> __int = prepare_to_wait_event(&amp;wq_head, &amp;__wq_entry, state);\</span><br><span class="line">										\</span><br><span class="line">		<span class="keyword">if</span> (condition)							\</span><br><span class="line">			<span class="keyword">break</span>;							\</span><br><span class="line">										\</span><br><span class="line">		<span class="keyword">if</span> (___wait_is_interruptible(state) &amp;&amp; __int) &#123;			\</span><br><span class="line">			__ret = __int;						\</span><br><span class="line">			<span class="keyword">goto</span> __out;						\</span><br><span class="line">		&#125;								\</span><br><span class="line">										\</span><br><span class="line">		cmd;								\</span><br><span class="line">	&#125;									\</span><br><span class="line">	finish_wait(&amp;wq_head, &amp;__wq_entry);					\</span><br><span class="line">__out:	__ret;									\</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>condition为true时，是等待事件唤醒 <br><br>condition为false时，是信号唤醒</p>
<hr>
<h3 id="prepare-to-wait-event"><a href="#prepare-to-wait-event" class="headerlink" title="prepare_to_wait_event"></a>prepare_to_wait_event</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">prepare_to_wait_event</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, <span class="keyword">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;wq_head-&gt;lock, flags); <span class="comment">//加锁禁中断</span></span><br><span class="line">	<span class="keyword">if</span> (signal_pending_state(state, current)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Exclusive waiter must not fail if it was selected by wakeup,</span></span><br><span class="line"><span class="comment">		 * it should &quot;consume&quot; the condition we were waiting for.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * The caller will recheck the condition and return success if</span></span><br><span class="line"><span class="comment">		 * we were already woken up, we can not miss the event because</span></span><br><span class="line"><span class="comment">		 * wakeup locks/unlocks the same wq_head-&gt;lock.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * But we need to ensure that set-condition + wakeup after that</span></span><br><span class="line"><span class="comment">		 * can&#x27;t see us, it should wake up another exclusive waiter if</span></span><br><span class="line"><span class="comment">		 * we fail.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		list_del_init(&amp;wq_entry-&gt;entry);</span><br><span class="line">		ret = -ERESTARTSYS;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (list_empty(&amp;wq_entry-&gt;entry)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (wq_entry-&gt;flags &amp; WQ_FLAG_EXCLUSIVE)</span><br><span class="line">				__add_wait_queue_entry_tail(wq_head, wq_entry); <span class="comment">//加到等待链表，互斥</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				__add_wait_queue(wq_head, wq_entry);	<span class="comment">//加到等待链表，不互斥</span></span><br><span class="line">		&#125;</span><br><span class="line">		set_current_state(state);</span><br><span class="line">	&#125;</span><br><span class="line">	spin_unlock_irqrestore(&amp;wq_head-&gt;lock, flags); <span class="comment">//解锁开中断</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(prepare_to_wait_event);</span><br></pre></td></tr></table></figure>

<p>引用自：<a href="https://blog.csdn.net/dagefeijiqumeiguo/article/details/53941333">Linux设备驱动六 (1)等待队列</a></p>
<blockquote>
<p>当一个系统调用处于等待状态时，比如等待输入缓冲区不为空，此时产生了信号，这个信号仅仅是在该进程的thread_info结构中标识一下，就是所谓的“发信号”，然后唤醒进程的系统调用，系统调用醒来后，此时仅仅用signal_pending_state()检查一下是否有信号，这里，不处理信号的，当此时有信号，系统调用返回ERESTARTSYS，在从系统调用的返回用户空间时，会根据thread_info中信号标识位调用相应的信号处理函数，这里就是所谓的“接收信号”，对于Linux，上层库函数会根据系统调用的ERESTARTSYS返回值重启该系统调用。</p>
</blockquote>
<hr>
<h3 id="wake-up"><a href="#wake-up" class="headerlink" title="__wake_up"></a>__wake_up</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//wake_flags永远是0</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __wake_up - wake up threads blocked on a waitqueue.</span></span><br><span class="line"><span class="comment"> * @wq_head: the waitqueue</span></span><br><span class="line"><span class="comment"> * @mode: which threads</span></span><br><span class="line"><span class="comment"> * @nr_exclusive: how many wake-one or wake-many threads to wake up</span></span><br><span class="line"><span class="comment"> * @key: is directly passed to the wakeup function</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If this function wakes up a task, it executes a full memory barrier before</span></span><br><span class="line"><span class="comment"> * accessing the task state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> __wake_up(struct wait_queue_head *wq_head, <span class="keyword">unsigned</span> <span class="keyword">int</span> mode,</span><br><span class="line">			<span class="keyword">int</span> nr_exclusive, <span class="keyword">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">	__wake_up_common_lock(wq_head, mode, nr_exclusive, <span class="number">0</span>, key);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__wake_up);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __wake_up_common_lock(struct wait_queue_head *wq_head, <span class="keyword">unsigned</span> <span class="keyword">int</span> mode,</span><br><span class="line">			<span class="keyword">int</span> nr_exclusive, <span class="keyword">int</span> wake_flags, <span class="keyword">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="keyword">wait_queue_entry_t</span> bookmark;</span><br><span class="line"></span><br><span class="line">	bookmark.flags = <span class="number">0</span>;</span><br><span class="line">	bookmark.<span class="keyword">private</span> = <span class="literal">NULL</span>;</span><br><span class="line">	bookmark.func = <span class="literal">NULL</span>;</span><br><span class="line">	INIT_LIST_HEAD(&amp;bookmark.entry);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		spin_lock_irqsave(&amp;wq_head-&gt;lock, flags);</span><br><span class="line">		nr_exclusive = __wake_up_common(wq_head, mode, nr_exclusive,</span><br><span class="line">						wake_flags, key, &amp;bookmark);</span><br><span class="line">		spin_unlock_irqrestore(&amp;wq_head-&gt;lock, flags);</span><br><span class="line">	&#125; <span class="keyword">while</span> (bookmark.flags &amp; WQ_FLAG_BOOKMARK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The core wakeup function. Non-exclusive wakeups (nr_exclusive == 0) just</span></span><br><span class="line"><span class="comment"> * wake everything up. If it&#x27;s an exclusive wakeup (nr_exclusive == small +ve</span></span><br><span class="line"><span class="comment"> * number) then we wake all the non-exclusive tasks and one exclusive task.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * There are circumstances in which we can try to wake a task which has already</span></span><br><span class="line"><span class="comment"> * started to run but is not in state TASK_RUNNING. try_to_wake_up() returns</span></span><br><span class="line"><span class="comment"> * zero in this (rare) case, and we handle it by continuing to scan the queue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在某些情况下，我们可以尝试唤醒已经开始运行但未处于TASK_RUNNING状态的任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __wake_up_common(struct wait_queue_head *wq_head, <span class="keyword">unsigned</span> <span class="keyword">int</span> mode,</span><br><span class="line">			<span class="keyword">int</span> nr_exclusive, <span class="keyword">int</span> wake_flags, <span class="keyword">void</span> *key,</span><br><span class="line">			<span class="keyword">wait_queue_entry_t</span> *bookmark)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">wait_queue_entry_t</span> *curr, *next;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;wq_head-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bookmark &amp;&amp; (bookmark-&gt;flags &amp; WQ_FLAG_BOOKMARK)) &#123;</span><br><span class="line">		curr = list_next_entry(bookmark, entry);</span><br><span class="line"></span><br><span class="line">		list_del(&amp;bookmark-&gt;entry);</span><br><span class="line">		bookmark-&gt;flags = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		curr = list_first_entry(&amp;wq_head-&gt;head, <span class="keyword">wait_queue_entry_t</span>, entry);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (&amp;curr-&gt;entry == &amp;wq_head-&gt;head)</span><br><span class="line">		<span class="keyword">return</span> nr_exclusive;</span><br><span class="line"></span><br><span class="line">	list_for_each_entry_safe_from(curr, next, &amp;wq_head-&gt;head, entry) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> flags = curr-&gt;flags;</span><br><span class="line">		<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (flags &amp; WQ_FLAG_BOOKMARK)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//唤醒函数</span></span><br><span class="line">		ret = curr-&gt;func(curr, mode, wake_flags, key);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (ret &amp;&amp; (flags &amp; WQ_FLAG_EXCLUSIVE) &amp;&amp; !--nr_exclusive)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (bookmark &amp;&amp; (++cnt &gt; WAITQUEUE_WALK_BREAK_CNT) &amp;&amp;</span><br><span class="line">				(&amp;next-&gt;entry != &amp;wq_head-&gt;head)) &#123;</span><br><span class="line">			bookmark-&gt;flags = WQ_FLAG_BOOKMARK;</span><br><span class="line">			list_add_tail(&amp;bookmark-&gt;entry, &amp;next-&gt;entry);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> nr_exclusive;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="wake-up-sync"><a href="#wake-up-sync" class="headerlink" title="__wake_up_sync"></a>__wake_up_sync</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//wake_flags永远是1 </span></span><br><span class="line"><span class="comment">//#define WF_SYNC			0x01		/* Waker goes to sleep after wakeup */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * __wake_up_sync - see __wake_up_sync_key()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> __wake_up_sync(struct wait_queue_head *wq_head, <span class="keyword">unsigned</span> <span class="keyword">int</span> mode)</span><br><span class="line">&#123;</span><br><span class="line">	__wake_up_sync_key(wq_head, mode, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __wake_up_sync_key - wake up threads blocked on a waitqueue.</span></span><br><span class="line"><span class="comment"> * @wq_head: the waitqueue</span></span><br><span class="line"><span class="comment"> * @mode: which threads</span></span><br><span class="line"><span class="comment"> * @key: opaque value to be passed to wakeup targets</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The sync wakeup differs that the waker knows that it will schedule</span></span><br><span class="line"><span class="comment"> * away soon, so while the target thread will be woken up, it will not</span></span><br><span class="line"><span class="comment"> * be migrated to another CPU - ie. the two threads are &#x27;synchronized&#x27;</span></span><br><span class="line"><span class="comment"> * with each other. This can prevent needless bouncing between CPUs.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On UP it can prevent extra preemption.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If this function wakes up a task, it executes a full memory barrier before</span></span><br><span class="line"><span class="comment"> * accessing the task state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> __wake_up_sync_key(struct wait_queue_head *wq_head, <span class="keyword">unsigned</span> <span class="keyword">int</span> mode,</span><br><span class="line">			<span class="keyword">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!wq_head))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//#define WF_SYNC			0x01		/* Waker goes to sleep after wakeup */</span></span><br><span class="line">	__wake_up_common_lock(wq_head, mode, <span class="number">1</span>, WF_SYNC, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __wake_up_common_lock(struct wait_queue_head *wq_head, <span class="keyword">unsigned</span> <span class="keyword">int</span> mode,</span><br><span class="line">			<span class="keyword">int</span> nr_exclusive, <span class="keyword">int</span> wake_flags, <span class="keyword">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="keyword">wait_queue_entry_t</span> bookmark;</span><br><span class="line"></span><br><span class="line">	bookmark.flags = <span class="number">0</span>;</span><br><span class="line">	bookmark.<span class="keyword">private</span> = <span class="literal">NULL</span>;</span><br><span class="line">	bookmark.func = <span class="literal">NULL</span>;</span><br><span class="line">	INIT_LIST_HEAD(&amp;bookmark.entry);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		spin_lock_irqsave(&amp;wq_head-&gt;lock, flags);</span><br><span class="line">		nr_exclusive = __wake_up_common(wq_head, mode, nr_exclusive,</span><br><span class="line">						wake_flags, key, &amp;bookmark);</span><br><span class="line">		spin_unlock_irqrestore(&amp;wq_head-&gt;lock, flags);</span><br><span class="line">	&#125; <span class="keyword">while</span> (bookmark.flags &amp; WQ_FLAG_BOOKMARK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>网上如是说：最终wake_flags 会传递给用户自己定义的wakeup的callback函数，这个wake_flags的意义就在于用户可以根据这个是0还是1判断当前thread是否被独占.待论证吧</p>
<h2 id="EPOLL唤醒"><a href="#EPOLL唤醒" class="headerlink" title="EPOLL唤醒"></a>EPOLL唤醒</h2><p>epoll_create创建epfd,这个epfd会有一个等待队列：epfd-&gt;wq(wait_queue_head_t). <br><br>队列的回调函数是怎么加入的： <br></p>
<pre><code>epoll_wait
    |-&gt;ep_poll
        |-&gt;init_waitqueue_entry(&amp;wait, current)
            |-&gt;default_wake_function(wake_up唤醒)</code></pre>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init_waitqueue_entry</span><span class="params">(<span class="keyword">wait_queue_t</span> *q, struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	q-&gt;flags = <span class="number">0</span>;</span><br><span class="line">	q-&gt;<span class="keyword">private</span> = p;</span><br><span class="line">	<span class="comment">//进程调度，加入可运行链表</span></span><br><span class="line">	q-&gt;func = default_wake_function;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>epoll_wait怎么被唤醒: <br></p>
<pre><code>wake_up
    |-&gt;__wake_up
        //执行回调函数
        |-&gt;curr-&gt;func
            |-&gt;default_wake_function</code></pre>
<p><strong>再看ep_poll_callback：</strong>        <br></p>
<pre><code>epoll_ctl
|-&gt;do_epoll_ctl
    |-&gt;ep_find
        |-&gt;ep_insert
            |-&gt;ep_item_poll
                |-&gt;poll_wait(epi-&gt;ffd.file, &amp;ep-&gt;poll_wait, pt)
                    |-&gt;ep_ptable_queue_proc
                        |-&gt;waitqueue中    //poll_table添加唤醒回调函数ep_poll_callback
                        |-&gt;add_wait_queue(将当前的waitqueue链入到epitem对应的等待列表)
                |-&gt;ep_scan_ready_list
        |-&gt;ep_remove
        |-&gt;ep_modify</code></pre>
<p>ep_poll_callback回调函数注入epfd-&gt;poll_wait(wait_queue_head_t)中每个epitm对应的fd的poll_table的回调函数。select/poll对应的回调是default_wake_function。然后哪个fd上面有事件了，就执行ep_poll_callback，ep_poll_callback一共有2个作用:</p>
<ul>
<li>将epitem插入就绪链表</li>
<li>wake_up唤醒epoll_wait</li>
</ul>
<p>epfd的等待队列epfd-&gt;wq何时移除： <br></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_poll</span><span class="params">(struct eventpoll *ep, struct epoll_event __user *events,</span></span></span><br><span class="line"><span class="function"><span class="params">		   <span class="keyword">int</span> maxevents, <span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//省略................................</span></span><br><span class="line">fetch_events:</span><br><span class="line">	spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ep_events_available(ep)) &#123;</span><br><span class="line">		init_waitqueue_entry(&amp;wait, current);</span><br><span class="line">		__add_wait_queue_exclusive(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">			set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">			<span class="keyword">if</span> (ep_events_available(ep) || timed_out)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">				res = -EINTR;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line">			<span class="keyword">if</span> (!schedule_hrtimeout_range(to, slack, HRTIMER_MODE_ABS))</span><br><span class="line">				timed_out = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">			spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//这里移除了</span></span><br><span class="line">		__remove_wait_queue(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line"></span><br><span class="line">		set_current_state(TASK_RUNNING);</span><br><span class="line">	&#125;</span><br><span class="line">check_events:</span><br><span class="line">	eavail = ep_events_available(ep);</span><br><span class="line"></span><br><span class="line">	spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!res &amp;&amp; eavail &amp;&amp;</span><br><span class="line">	    !(res = ep_send_events(ep, events, maxevents)) &amp;&amp; !timed_out)</span><br><span class="line">		<span class="keyword">goto</span> fetch_events;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="select唤醒"><a href="#select唤醒" class="headerlink" title="select唤醒"></a>select唤醒</h2><pre><code>SYSCALL_DEFINE5
        |-&gt;core_sys_select
            |-&gt;do_select
                |-&gt;poll_initwait
                    |-&gt;init_poll_funcptr(&amp;pwq-&gt;pt, __pollwait)
                        |-&gt;pollwake
                            |-&gt;__pollwake
                                |-&gt;default_wake_function
                |-&gt;f_op-&gt;poll
                |-&gt;poll_freewait</code></pre>
<h2 id="poll唤醒"><a href="#poll唤醒" class="headerlink" title="poll唤醒"></a>poll唤醒</h2><pre><code>SYSCALL_DEFINE3
|-&gt;do_sys_poll
    |-&gt;poll_initwait
        |-&gt;init_poll_funcptr(&amp;pwq-&gt;pt, __pollwait)
                        |-&gt;pollwake
                            |-&gt;__pollwake
                                |-&gt;default_wake_function
    |-&gt;do_poll
        |-&gt;do_pollfd
            |-&gt;f.file-&gt;f_op-&gt;poll</code></pre>
<h2 id="f-op-gt-poll"><a href="#f-op-gt-poll" class="headerlink" title="f_op-&gt;poll"></a>f_op-&gt;poll</h2><pre><code>f_op-&gt;poll(设备驱动程序实现)
    |-&gt;poll_wait
        |-&gt;func(之前注册的回调函数ep_poll_callback/default_wake_function)</code></pre>
<hr>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/03/24/QvkhRwgqfb1zLaC.jpg" alt="78867560_p0_master1200.jpg"></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>webbench</title>
    <url>/2020-03-24-webbench/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/leejianjun/article/details/48020147">Centos7安装及使用webbench进行并发测试</a></p>
<p><a href="https://github.com/EZLippi/WebBench">EZLippi/WebBench</a></p>
<p><a href="http://home.tiscali.cz/~cz210552/webbench.html">下载地址</a></p>
<a id="more"></a>

<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Web Bench是用于基准测试WWW或代理服务器的非常简单的工具。使用fork（）模拟多个客户端，并可以使用HTTP / 0.9-HTTP / 1.1请求。该基准不是很现实，但是它可以测试HTTPD是否确实可以一次处理多个客户端（尝试运行一些CGI）而不会导致计算机停机。显示页面/分钟和字节/秒。可以在带有-f开关的更激进的模式下使用。</p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>webbench首先fork出多个子进程，每个子进程都循环做web访问测试。子进程把访问的结果通过pipe告诉父进程，父进程做最终的统计结果。</p>
<h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><table>
    <thead align="center">
        <tr>
            <th style="text-align:center">参数</th>
            <th style="text-align:center">说明</th>
        </tr>
    </thead>
    <tbody align="center">
        <tr>
            <td>-V</td>
            <td>显示版本号</td>
        </tr>
    </tbody>
    <tbody align="center">
        <tr>
            <td>-t</td>
            <td>运行webbench的时间,单位：秒</td>
        </tr>
    </tbody>
    <tbody align="center">
        <tr>
            <td>-c</td>
            <td>创建多少个客户端，默认1个</td>
        </tr>
    </tbody>
    <tbody align="center">
        <tr>
            <td>-f</td>
            <td>不需要等待服务器响应</td>
        </tr>
    </tbody>
</table>

<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="webbench-c"><a href="#webbench-c" class="headerlink" title="webbench.c"></a>webbench.c</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (C) Radim Kolar 1997-2004</span></span><br><span class="line"><span class="comment"> * This is free software, see GNU Public License version 2 for</span></span><br><span class="line"><span class="comment"> * details.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Simple forking WWW Server benchmark:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Usage:</span></span><br><span class="line"><span class="comment"> *   webbench --help</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return codes:</span></span><br><span class="line"><span class="comment"> *    0 - sucess</span></span><br><span class="line"><span class="comment"> *    1 - benchmark failed (server is not on-line)</span></span><br><span class="line"><span class="comment"> *    2 - bad param</span></span><br><span class="line"><span class="comment"> *    3 - internal error, fork failed</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;socket.c&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/param.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rpc/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;getopt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* values */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> timerexpired=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> speed=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> failed=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> bytes=<span class="number">0</span>;</span><br><span class="line"><span class="comment">/* globals */</span></span><br><span class="line"><span class="keyword">int</span> http10=<span class="number">1</span>; <span class="comment">/* 0 - http/0.9, 1 - http/1.0, 2 - http/1.1 */</span></span><br><span class="line"><span class="comment">/* Allow: GET, HEAD, OPTIONS, TRACE */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> METHOD_GET 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> METHOD_HEAD 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> METHOD_OPTIONS 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> METHOD_TRACE 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROGRAM_VERSION <span class="meta-string">&quot;1.5&quot;</span></span></span><br><span class="line"><span class="keyword">int</span> method=METHOD_GET;</span><br><span class="line"><span class="keyword">int</span> clients=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> force=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> force_reload=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> proxyport=<span class="number">80</span>;</span><br><span class="line"><span class="keyword">char</span> *proxyhost=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> benchtime=<span class="number">30</span>;</span><br><span class="line"><span class="comment">/* internal */</span></span><br><span class="line"><span class="keyword">int</span> mypipe[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">char</span> host[MAXHOSTNAMELEN];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REQUEST_SIZE 2048</span></span><br><span class="line"><span class="keyword">char</span> request[REQUEST_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">option</span> <span class="title">long_options</span>[]=</span></span><br><span class="line">&#123;</span><br><span class="line"> &#123;<span class="string">&quot;force&quot;</span>,no_argument,&amp;force,<span class="number">1</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&quot;reload&quot;</span>,no_argument,&amp;force_reload,<span class="number">1</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&quot;time&quot;</span>,required_argument,<span class="literal">NULL</span>,<span class="string">&#x27;t&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&quot;help&quot;</span>,no_argument,<span class="literal">NULL</span>,<span class="string">&#x27;?&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&quot;http09&quot;</span>,no_argument,<span class="literal">NULL</span>,<span class="string">&#x27;9&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&quot;http10&quot;</span>,no_argument,<span class="literal">NULL</span>,<span class="string">&#x27;1&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&quot;http11&quot;</span>,no_argument,<span class="literal">NULL</span>,<span class="string">&#x27;2&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&quot;get&quot;</span>,no_argument,&amp;method,METHOD_GET&#125;,</span><br><span class="line"> &#123;<span class="string">&quot;head&quot;</span>,no_argument,&amp;method,METHOD_HEAD&#125;,</span><br><span class="line"> &#123;<span class="string">&quot;options&quot;</span>,no_argument,&amp;method,METHOD_OPTIONS&#125;,</span><br><span class="line"> &#123;<span class="string">&quot;trace&quot;</span>,no_argument,&amp;method,METHOD_TRACE&#125;,</span><br><span class="line"> &#123;<span class="string">&quot;version&quot;</span>,no_argument,<span class="literal">NULL</span>,<span class="string">&#x27;V&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&quot;proxy&quot;</span>,required_argument,<span class="literal">NULL</span>,<span class="string">&#x27;p&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&quot;clients&quot;</span>,required_argument,<span class="literal">NULL</span>,<span class="string">&#x27;c&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="literal">NULL</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* prototypes */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">benchcore</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* host,<span class="keyword">const</span> <span class="keyword">int</span> port, <span class="keyword">const</span> <span class="keyword">char</span> *request)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bench</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">build_request</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *url)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alarm_handler</span><span class="params">(<span class="keyword">int</span> signal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   timerexpired=<span class="number">1</span>;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">usage</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</span><br><span class="line">	<span class="string">&quot;webbench [option]... URL\n&quot;</span></span><br><span class="line">	<span class="string">&quot;  -f|--force               Don&#x27;t wait for reply from server.\n&quot;</span></span><br><span class="line">	<span class="string">&quot;  -r|--reload              Send reload request - Pragma: no-cache.\n&quot;</span></span><br><span class="line">	<span class="string">&quot;  -t|--time &lt;sec&gt;          Run benchmark for &lt;sec&gt; seconds. Default 30.\n&quot;</span></span><br><span class="line">	<span class="string">&quot;  -p|--proxy &lt;server:port&gt; Use proxy server for request.\n&quot;</span></span><br><span class="line">	<span class="string">&quot;  -c|--clients &lt;n&gt;         Run &lt;n&gt; HTTP clients at once. Default one.\n&quot;</span></span><br><span class="line">	<span class="string">&quot;  -9|--http09              Use HTTP/0.9 style requests.\n&quot;</span></span><br><span class="line">	<span class="string">&quot;  -1|--http10              Use HTTP/1.0 protocol.\n&quot;</span></span><br><span class="line">	<span class="string">&quot;  -2|--http11              Use HTTP/1.1 protocol.\n&quot;</span></span><br><span class="line">	<span class="string">&quot;  --get                    Use GET request method.\n&quot;</span></span><br><span class="line">	<span class="string">&quot;  --head                   Use HEAD request method.\n&quot;</span></span><br><span class="line">	<span class="string">&quot;  --options                Use OPTIONS request method.\n&quot;</span></span><br><span class="line">	<span class="string">&quot;  --trace                  Use TRACE request method.\n&quot;</span></span><br><span class="line">	<span class="string">&quot;  -?|-h|--help             This information.\n&quot;</span></span><br><span class="line">	<span class="string">&quot;  -V|--version             Display program version.\n&quot;</span></span><br><span class="line">	);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> opt=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">int</span> options_index=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">char</span> *tmp=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(argc==<span class="number">1</span>)</span><br><span class="line"> &#123;</span><br><span class="line">	  usage();</span><br><span class="line">          <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span>((opt=getopt_long(argc,argv,<span class="string">&quot;912Vfrt:p:c:?h&quot;</span>,long_options,&amp;options_index))!=EOF )</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">switch</span>(opt)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">case</span>  <span class="number">0</span> : <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>: force=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>: force_reload=<span class="number">1</span>;<span class="keyword">break</span>; </span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;9&#x27;</span>: http10=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>: http10=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>: http10=<span class="number">2</span>;<span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>: <span class="built_in">printf</span>(PROGRAM_VERSION<span class="string">&quot;\n&quot;</span>);<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>: benchtime=atoi(optarg);<span class="keyword">break</span>;	     </span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>: </span><br><span class="line">	     <span class="comment">/* proxy server parsing server:port */</span></span><br><span class="line">	     tmp=<span class="built_in">strrchr</span>(optarg,<span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">	     proxyhost=optarg;</span><br><span class="line">	     <span class="keyword">if</span>(tmp==<span class="literal">NULL</span>)</span><br><span class="line">	     &#123;</span><br><span class="line">		     <span class="keyword">break</span>;</span><br><span class="line">	     &#125;</span><br><span class="line">	     <span class="keyword">if</span>(tmp==optarg)</span><br><span class="line">	     &#123;</span><br><span class="line">		     <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Error in option --proxy %s: Missing hostname.\n&quot;</span>,optarg);</span><br><span class="line">		     <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	     &#125;</span><br><span class="line">	     <span class="keyword">if</span>(tmp==optarg+<span class="built_in">strlen</span>(optarg)<span class="number">-1</span>)</span><br><span class="line">	     &#123;</span><br><span class="line">		     <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Error in option --proxy %s Port number is missing.\n&quot;</span>,optarg);</span><br><span class="line">		     <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	     &#125;</span><br><span class="line">	     *tmp=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	     proxyport=atoi(tmp+<span class="number">1</span>);<span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;:&#x27;</span>:</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>: usage();<span class="keyword">return</span> <span class="number">2</span>;<span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>: clients=atoi(optarg);<span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span>(optind==argc) &#123;</span><br><span class="line">                      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;webbench: Missing URL!\n&quot;</span>);</span><br><span class="line">		      usage();</span><br><span class="line">		      <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(clients==<span class="number">0</span>) clients=<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">if</span>(benchtime==<span class="number">0</span>) benchtime=<span class="number">60</span>;</span><br><span class="line"> <span class="comment">/* Copyright */</span></span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Webbench - Simple Web Benchmark &quot;</span>PROGRAM_VERSION<span class="string">&quot;\n&quot;</span></span><br><span class="line">	 <span class="string">&quot;Copyright (c) Radim Kolar 1997-2004, GPL Open Source Software.\n&quot;</span></span><br><span class="line">	 );</span><br><span class="line"> build_request(argv[optind]);</span><br><span class="line"> <span class="comment">/* print bench info */</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;\nBenchmarking: &quot;</span>);</span><br><span class="line"> <span class="keyword">switch</span>(method)</span><br><span class="line"> &#123;</span><br><span class="line">	 <span class="keyword">case</span> METHOD_GET:</span><br><span class="line">	 <span class="keyword">default</span>:</span><br><span class="line">		 <span class="built_in">printf</span>(<span class="string">&quot;GET&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">	 <span class="keyword">case</span> METHOD_OPTIONS:</span><br><span class="line">		 <span class="built_in">printf</span>(<span class="string">&quot;OPTIONS&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">	 <span class="keyword">case</span> METHOD_HEAD:</span><br><span class="line">		 <span class="built_in">printf</span>(<span class="string">&quot;HEAD&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">	 <span class="keyword">case</span> METHOD_TRACE:</span><br><span class="line">		 <span class="built_in">printf</span>(<span class="string">&quot;TRACE&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot; %s&quot;</span>,argv[optind]);</span><br><span class="line"> <span class="keyword">switch</span>(http10)</span><br><span class="line"> &#123;</span><br><span class="line">	 <span class="keyword">case</span> <span class="number">0</span>: <span class="built_in">printf</span>(<span class="string">&quot; (using HTTP/0.9)&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">	 <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">printf</span>(<span class="string">&quot; (using HTTP/1.1)&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span>(clients==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;1 client&quot;</span>);</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d clients&quot;</span>,clients);</span><br><span class="line"></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;, running %d sec&quot;</span>, benchtime);</span><br><span class="line"> <span class="keyword">if</span>(force) <span class="built_in">printf</span>(<span class="string">&quot;, early socket close&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span>(proxyhost!=<span class="literal">NULL</span>) <span class="built_in">printf</span>(<span class="string">&quot;, via proxy server %s:%d&quot;</span>,proxyhost,proxyport);</span><br><span class="line"> <span class="keyword">if</span>(force_reload) <span class="built_in">printf</span>(<span class="string">&quot;, forcing reload&quot;</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;.\n&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> bench();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_request</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *url)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> tmp[<span class="number">10</span>];</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  bzero(host,MAXHOSTNAMELEN);</span><br><span class="line">  bzero(request,REQUEST_SIZE);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(force_reload &amp;&amp; proxyhost!=<span class="literal">NULL</span> &amp;&amp; http10&lt;<span class="number">1</span>) http10=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(method==METHOD_HEAD &amp;&amp; http10&lt;<span class="number">1</span>) http10=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(method==METHOD_OPTIONS &amp;&amp; http10&lt;<span class="number">2</span>) http10=<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span>(method==METHOD_TRACE &amp;&amp; http10&lt;<span class="number">2</span>) http10=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(method)</span><br><span class="line">  &#123;</span><br><span class="line">	  <span class="keyword">default</span>:</span><br><span class="line">	  <span class="keyword">case</span> METHOD_GET: <span class="built_in">strcpy</span>(request,<span class="string">&quot;GET&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">	  <span class="keyword">case</span> METHOD_HEAD: <span class="built_in">strcpy</span>(request,<span class="string">&quot;HEAD&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">	  <span class="keyword">case</span> METHOD_OPTIONS: <span class="built_in">strcpy</span>(request,<span class="string">&quot;OPTIONS&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">	  <span class="keyword">case</span> METHOD_TRACE: <span class="built_in">strcpy</span>(request,<span class="string">&quot;TRACE&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">		  </span><br><span class="line">  <span class="built_in">strcat</span>(request,<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="literal">NULL</span>==<span class="built_in">strstr</span>(url,<span class="string">&quot;://&quot;</span>))</span><br><span class="line">  &#123;</span><br><span class="line">	  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n%s: is not a valid URL.\n&quot;</span>,url);</span><br><span class="line">	  <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">strlen</span>(url)&gt;<span class="number">1500</span>)</span><br><span class="line">  &#123;</span><br><span class="line">         <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;URL is too long.\n&quot;</span>);</span><br><span class="line">	 <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(proxyhost==<span class="literal">NULL</span>)</span><br><span class="line">	   <span class="keyword">if</span> (<span class="number">0</span>!=strncasecmp(<span class="string">&quot;http://&quot;</span>,url,<span class="number">7</span>)) </span><br><span class="line">	   &#123; <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;\nOnly HTTP protocol is directly supported, set --proxy for others.\n&quot;</span>);</span><br><span class="line">             <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">           &#125;</span><br><span class="line">  <span class="comment">/* protocol/host delimiter */</span></span><br><span class="line">  i=<span class="built_in">strstr</span>(url,<span class="string">&quot;://&quot;</span>)-url+<span class="number">3</span>;</span><br><span class="line">  <span class="comment">/* printf(&quot;%d\n&quot;,i); */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">strchr</span>(url+i,<span class="string">&#x27;/&#x27;</span>)==<span class="literal">NULL</span>) &#123;</span><br><span class="line">                                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;\nInvalid URL syntax - hostname don&#x27;t ends with &#x27;/&#x27;.\n&quot;</span>);</span><br><span class="line">                                <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">                              &#125;</span><br><span class="line">  <span class="keyword">if</span>(proxyhost==<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="comment">/* get port from hostname */</span></span><br><span class="line">   <span class="keyword">if</span>(index(url+i,<span class="string">&#x27;:&#x27;</span>)!=<span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">      index(url+i,<span class="string">&#x27;:&#x27;</span>)&lt;index(url+i,<span class="string">&#x27;/&#x27;</span>))</span><br><span class="line">   &#123;</span><br><span class="line">	   <span class="built_in">strncpy</span>(host,url+i,<span class="built_in">strchr</span>(url+i,<span class="string">&#x27;:&#x27;</span>)-url-i);</span><br><span class="line">	   bzero(tmp,<span class="number">10</span>);</span><br><span class="line">	   <span class="built_in">strncpy</span>(tmp,index(url+i,<span class="string">&#x27;:&#x27;</span>)+<span class="number">1</span>,<span class="built_in">strchr</span>(url+i,<span class="string">&#x27;/&#x27;</span>)-index(url+i,<span class="string">&#x27;:&#x27;</span>)<span class="number">-1</span>);</span><br><span class="line">	   <span class="comment">/* printf(&quot;tmp=%s\n&quot;,tmp); */</span></span><br><span class="line">	   proxyport=atoi(tmp);</span><br><span class="line">	   <span class="keyword">if</span>(proxyport==<span class="number">0</span>) proxyport=<span class="number">80</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">     <span class="built_in">strncpy</span>(host,url+i,<span class="built_in">strcspn</span>(url+i,<span class="string">&quot;/&quot;</span>));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// printf(&quot;Host=%s\n&quot;,host);</span></span><br><span class="line">   <span class="built_in">strcat</span>(request+<span class="built_in">strlen</span>(request),url+i+<span class="built_in">strcspn</span>(url+i,<span class="string">&quot;/&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">   <span class="comment">// printf(&quot;ProxyHost=%s\nProxyPort=%d\n&quot;,proxyhost,proxyport);</span></span><br><span class="line">   <span class="built_in">strcat</span>(request,url);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(http10==<span class="number">1</span>)</span><br><span class="line">	  <span class="built_in">strcat</span>(request,<span class="string">&quot; HTTP/1.0&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (http10==<span class="number">2</span>)</span><br><span class="line">	  <span class="built_in">strcat</span>(request,<span class="string">&quot; HTTP/1.1&quot;</span>);</span><br><span class="line">  <span class="built_in">strcat</span>(request,<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(http10&gt;<span class="number">0</span>)</span><br><span class="line">	  <span class="built_in">strcat</span>(request,<span class="string">&quot;User-Agent: WebBench &quot;</span>PROGRAM_VERSION<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(proxyhost==<span class="literal">NULL</span> &amp;&amp; http10&gt;<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">	  <span class="built_in">strcat</span>(request,<span class="string">&quot;Host: &quot;</span>);</span><br><span class="line">	  <span class="built_in">strcat</span>(request,host);</span><br><span class="line">	  <span class="built_in">strcat</span>(request,<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(force_reload &amp;&amp; proxyhost!=<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">	  <span class="built_in">strcat</span>(request,<span class="string">&quot;Pragma: no-cache\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(http10&gt;<span class="number">1</span>)</span><br><span class="line">	  <span class="built_in">strcat</span>(request,<span class="string">&quot;Connection: close\r\n&quot;</span>);</span><br><span class="line">  <span class="comment">/* add empty line at end */</span></span><br><span class="line">  <span class="keyword">if</span>(http10&gt;<span class="number">0</span>) <span class="built_in">strcat</span>(request,<span class="string">&quot;\r\n&quot;</span>); </span><br><span class="line">  <span class="comment">// printf(&quot;Req=%s\n&quot;,request);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* vraci system rc error kod */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bench</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i,j,k;	</span><br><span class="line">  <span class="keyword">pid_t</span> pid=<span class="number">0</span>;</span><br><span class="line">  FILE *f;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* check avaibility of target server */</span></span><br><span class="line">  i=Socket(proxyhost==<span class="literal">NULL</span>?host:proxyhost,proxyport);</span><br><span class="line">  <span class="keyword">if</span>(i&lt;<span class="number">0</span>) &#123; </span><br><span class="line">	   <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;\nConnect to server failed. Aborting benchmark.\n&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">  close(i);</span><br><span class="line">  <span class="comment">/* create pipe */</span></span><br><span class="line">  <span class="keyword">if</span>(pipe(mypipe))</span><br><span class="line">  &#123;</span><br><span class="line">	  perror(<span class="string">&quot;pipe failed.&quot;</span>);</span><br><span class="line">	  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* not needed, since we have alarm() in childrens */</span></span><br><span class="line">  <span class="comment">/* wait 4 next system clock tick */</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  cas=time(NULL);</span></span><br><span class="line"><span class="comment">  while(time(NULL)==cas)</span></span><br><span class="line"><span class="comment">        sched_yield();</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* fork childs */</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;clients;i++)</span><br><span class="line">  &#123;</span><br><span class="line">	   pid=fork();</span><br><span class="line">	   <span class="keyword">if</span>(pid &lt;= (<span class="keyword">pid_t</span>) <span class="number">0</span>)</span><br><span class="line">	   &#123;</span><br><span class="line">		   <span class="comment">/* child process or error*/</span></span><br><span class="line">	           sleep(<span class="number">1</span>); <span class="comment">/* make childs faster */</span></span><br><span class="line">		   <span class="keyword">break</span>;</span><br><span class="line">	   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>( pid&lt; (<span class="keyword">pid_t</span>) <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">          <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;problems forking worker no. %d\n&quot;</span>,i);</span><br><span class="line">	  perror(<span class="string">&quot;fork failed.&quot;</span>);</span><br><span class="line">	  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(pid== (<span class="keyword">pid_t</span>) <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* I am a child */</span></span><br><span class="line">    <span class="keyword">if</span>(proxyhost==<span class="literal">NULL</span>)</span><br><span class="line">      benchcore(host,proxyport,request);</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">      benchcore(proxyhost,proxyport,request);</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* write results to pipe */</span></span><br><span class="line">	 f=fdopen(mypipe[<span class="number">1</span>],<span class="string">&quot;w&quot;</span>);</span><br><span class="line">	 <span class="keyword">if</span>(f==<span class="literal">NULL</span>)</span><br><span class="line">	 &#123;</span><br><span class="line">		 perror(<span class="string">&quot;open pipe for writing failed.&quot;</span>);</span><br><span class="line">		 <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="comment">/* fprintf(stderr,&quot;Child - %d %d\n&quot;,speed,failed); */</span></span><br><span class="line">	 <span class="built_in">fprintf</span>(f,<span class="string">&quot;%d %d %d\n&quot;</span>,speed,failed,bytes);</span><br><span class="line">	 fclose(f);</span><br><span class="line">	 <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">	  f=fdopen(mypipe[<span class="number">0</span>],<span class="string">&quot;r&quot;</span>);</span><br><span class="line">	  <span class="keyword">if</span>(f==<span class="literal">NULL</span>) </span><br><span class="line">	  &#123;</span><br><span class="line">		  perror(<span class="string">&quot;open pipe for reading failed.&quot;</span>);</span><br><span class="line">		  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">	  setvbuf(f,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">	  speed=<span class="number">0</span>;</span><br><span class="line">          failed=<span class="number">0</span>;</span><br><span class="line">          bytes=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	  &#123;</span><br><span class="line">		  pid=<span class="built_in">fscanf</span>(f,<span class="string">&quot;%d %d %d&quot;</span>,&amp;i,&amp;j,&amp;k);</span><br><span class="line">		  <span class="keyword">if</span>(pid&lt;<span class="number">2</span>)</span><br><span class="line">                  &#123;</span><br><span class="line">                       <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Some of our childrens died.\n&quot;</span>);</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">		  speed+=i;</span><br><span class="line">		  failed+=j;</span><br><span class="line">		  bytes+=k;</span><br><span class="line">		  <span class="comment">/* fprintf(stderr,&quot;*Knock* %d %d read=%d\n&quot;,speed,failed,pid); */</span></span><br><span class="line">		  <span class="keyword">if</span>(--clients==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">	  fclose(f);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\nSpeed=%d pages/min, %d bytes/sec.\nRequests: %d susceed, %d failed.\n&quot;</span>,</span><br><span class="line">		  (<span class="keyword">int</span>)((speed+failed)/(benchtime/<span class="number">60.0f</span>)),</span><br><span class="line">		  (<span class="keyword">int</span>)(bytes/(<span class="keyword">float</span>)benchtime),</span><br><span class="line">		  speed,</span><br><span class="line">		  failed);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">benchcore</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *host,<span class="keyword">const</span> <span class="keyword">int</span> port,<span class="keyword">const</span> <span class="keyword">char</span> *req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> rlen;</span><br><span class="line"> <span class="keyword">char</span> buf[<span class="number">1500</span>];</span><br><span class="line"> <span class="keyword">int</span> s,i;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/* setup alarm signal handler */</span></span><br><span class="line"> sa.sa_handler=alarm_handler;</span><br><span class="line"> sa.sa_flags=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">if</span>(sigaction(SIGALRM,&amp;sa,<span class="literal">NULL</span>))</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line"> alarm(benchtime);</span><br><span class="line"></span><br><span class="line"> rlen=<span class="built_in">strlen</span>(req);</span><br><span class="line"> nexttry:<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="keyword">if</span>(timerexpired)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span>(failed&gt;<span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="comment">/* fprintf(stderr,&quot;Correcting failed by signal\n&quot;); */</span></span><br><span class="line">          failed--;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s=Socket(host,port);                          </span><br><span class="line">    <span class="keyword">if</span>(s&lt;<span class="number">0</span>) &#123; failed++;<span class="keyword">continue</span>;&#125; </span><br><span class="line">    <span class="keyword">if</span>(rlen!=write(s,req,rlen)) &#123;failed++;close(s);<span class="keyword">continue</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(http10==<span class="number">0</span>) </span><br><span class="line">	    <span class="keyword">if</span>(shutdown(s,<span class="number">1</span>)) &#123; failed++;close(s);<span class="keyword">continue</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(force==<span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">            <span class="comment">/* read all available data from socket */</span></span><br><span class="line">	    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">              <span class="keyword">if</span>(timerexpired) <span class="keyword">break</span>; </span><br><span class="line">	      i=read(s,buf,<span class="number">1500</span>);</span><br><span class="line">              <span class="comment">/* fprintf(stderr,&quot;%d\n&quot;,i); */</span></span><br><span class="line">	      <span class="keyword">if</span>(i&lt;<span class="number">0</span>) </span><br><span class="line">              &#123; </span><br><span class="line">                 failed++;</span><br><span class="line">                 close(s);</span><br><span class="line">                 <span class="keyword">goto</span> nexttry;</span><br><span class="line">              &#125;</span><br><span class="line">	       <span class="keyword">else</span></span><br><span class="line">		       <span class="keyword">if</span>(i==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		       <span class="keyword">else</span></span><br><span class="line">			       bytes+=i;</span><br><span class="line">	    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(close(s)) &#123;failed++;<span class="keyword">continue</span>;&#125;</span><br><span class="line">    speed++;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="socket-c"><a href="#socket-c" class="headerlink" title="socket.c"></a>socket.c</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* $Id: socket.c 1.1 1995/01/01 07:11:14 cthuang Exp $</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This module has been modified by Radim Kolar for OS/2 emx</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">  module:       socket.c</span></span><br><span class="line"><span class="comment">  program:      popclient</span></span><br><span class="line"><span class="comment">  SCCS ID:      @(#)socket.c    1.5  4/1/94</span></span><br><span class="line"><span class="comment">  programmer:   Virginia Tech Computing Center</span></span><br><span class="line"><span class="comment">  compiler:     DEC RISC C compiler (Ultrix 4.1)</span></span><br><span class="line"><span class="comment">  environment:  DEC Ultrix 4.3 </span></span><br><span class="line"><span class="comment">  description:  UNIX sockets code.</span></span><br><span class="line"><span class="comment"> ***********************************************************************/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Socket</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *host, <span class="keyword">int</span> clientPort)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> inaddr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ad</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">hp</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(&amp;ad, <span class="number">0</span>, <span class="keyword">sizeof</span>(ad));</span><br><span class="line">    ad.sin_family = AF_INET;</span><br><span class="line"></span><br><span class="line">    inaddr = inet_addr(host);</span><br><span class="line">    <span class="keyword">if</span> (inaddr != INADDR_NONE)</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;ad.sin_addr, &amp;inaddr, <span class="keyword">sizeof</span>(inaddr));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        hp = gethostbyname(host);</span><br><span class="line">        <span class="keyword">if</span> (hp == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;ad.sin_addr, hp-&gt;h_addr, hp-&gt;h_length);</span><br><span class="line">    &#125;</span><br><span class="line">    ad.sin_port = htons(clientPort);</span><br><span class="line">    </span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> sock;</span><br><span class="line">    <span class="keyword">if</span> (connect(sock, (struct sockaddr *)&amp;ad, <span class="keyword">sizeof</span>(ad)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> sock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/03/31/b89ZDVyHdtYLIRX.jpg" alt="63773649_p0_master1200.jpg"></p>
]]></content>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>字节对齐</title>
    <url>/2020-03-24-%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/chio/archive/2007/06/11/778934.html">C++ sizeof 使用规则及陷阱分析</a></p>
<p><a href="https://blog.csdn.net/hairetz/article/details/4084088">５分钟搞定内存字节对齐</a></p>
<a id="more"></a>

<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/04/02/MawOyk7KgnYHWsV.jpg" alt="80463452_p0_master1200.jpg"></p>
]]></content>
      <tags>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title>华为机试1-30</title>
    <url>/2020-03-28-%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%951-30/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.nowcoder.com/ta/huawei/">华为机试在线训练</a></p>
<a id="more"></a>

<h2 id="001-字符串最后一个单词的长度"><a href="#001-字符串最后一个单词的长度" class="headerlink" title="001 字符串最后一个单词的长度"></a>001 字符串最后一个单词的长度</h2><p>计算字符串最后一个单词的长度，单词以空格隔开</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;str)</span><br><span class="line">        ;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; str.<span class="built_in">length</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="002-计算字符个数"><a href="#002-计算字符个数" class="headerlink" title="002 计算字符个数"></a>002 计算字符个数</h2><p>写出一个程序，接受一个由字母和数字组成的字符串，和一个字符，然后输出输入字符串中含有该字符的个数。不区分大小写。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch1  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;str&gt;&gt;ch1)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (ch1 &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; ch1 &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">            ch2 = ch1 + <span class="string">&#x27;a&#x27;</span> - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch1 &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; ch1 &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">            ch2 = ch1 - (<span class="string">&#x27;a&#x27;</span> - <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch1 &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch1 &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>((pos = str.<span class="built_in">find</span>(ch1, pos)) != string::npos)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pos = <span class="number">0</span>;</span><br><span class="line">             <span class="keyword">while</span>((pos = str.<span class="built_in">find</span>(ch2, pos)) != string::npos)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="003-明明的随机数"><a href="#003-明明的随机数" class="headerlink" title="003  明明的随机数"></a>003  明明的随机数</h2><p>明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤1000），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作(同一个测试用例里可能会有多组数据，希望大家能正确处理)。</p>
<p>Input Param</p>
<p>n               输入随机数的个数</p>
<p>inputArray      n个随机整数组成的数组</p>
<p>Return Value</p>
<p>OutputArray    输出处理后的随机整数</p>
<p>注：测试用例保证输入参数的正确性，答题者无需验证。测试用例不止一组。</p>
<p>样例输入解释：<br>样例有两组测试<br>第一组是3个数字，分别是：2，2，1。<br>第二组是11个数字，分别是：10，20，40，32，67，40，20，89，300，400，15。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; inputArray;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        inputArray.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">while</span>(n-- &amp;&amp; cin&gt;&gt;num)</span><br><span class="line">        &#123;</span><br><span class="line">            inputArray.<span class="built_in">insert</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        set&lt;<span class="keyword">int</span>&gt;::iterator it = inputArray.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">for</span>(; it != inputArray.<span class="built_in">end</span>() ; it++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="004-字符串分隔"><a href="#004-字符串分隔" class="headerlink" title="004 字符串分隔"></a>004 字符串分隔</h2><p>题目描述</p>
<ul>
<li>连续输入字符串，请按长度为8拆分每个字符串后输出到新的字符串数组；</li>
<li>长度不是8整数倍的字符串请在后面补数字0，空字符串不处理。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STEP 8</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt;arr;</span><br><span class="line">    string str;</span><br><span class="line">    string str2;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;str)</span><br><span class="line">    &#123;</span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((str2 = str.<span class="built_in">substr</span>(pos, STEP)).<span class="built_in">length</span>() &gt;= STEP)</span><br><span class="line">        &#123;</span><br><span class="line">            arr.<span class="built_in">push_back</span>(str2);</span><br><span class="line">            pos += STEP;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (str2.<span class="built_in">length</span>() &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            str2.<span class="built_in">append</span>(STEP - str2.<span class="built_in">length</span>(),<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            arr.<span class="built_in">push_back</span>(str2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;string&gt;::iterator it = arr.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span>(; it != arr.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="005-进制转换"><a href="#005-进制转换" class="headerlink" title="005 进制转换"></a>005 进制转换</h2><p>写出一个程序，接受一个十六进制的数，输出该数值的十进制表示。（多组同时输入 ）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; hex &gt;&gt; num )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> bbb = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> ch = <span class="number">0</span>;</span><br><span class="line">	string str;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; str)</span><br><span class="line">	&#123;</span><br><span class="line">		string::reverse_iterator it = str.<span class="built_in">rbegin</span>();</span><br><span class="line">		num = <span class="number">0</span>;</span><br><span class="line">        bbb = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">for</span> (; it != str.<span class="built_in">rend</span>(); it++)</span><br><span class="line">		&#123;</span><br><span class="line">			ch = *it;</span><br><span class="line">			<span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">				ch -= <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">				ch = ch - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			num = num + ch * bbb;</span><br><span class="line">            bbb *= <span class="number">16</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="006-质数因子"><a href="#006-质数因子" class="headerlink" title="006 质数因子"></a>006 质数因子</h2><h2 id="007-取近似值"><a href="#007-取近似值" class="headerlink" title="007 取近似值"></a>007 取近似值</h2><p>写出一个程序，接受一个正浮点数值，输出该数值的近似整数值。如果小数点后数值大于等于5,向上取整；小于5，则向下取整。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    string str2;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n = <span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;str;</span><br><span class="line">    </span><br><span class="line">    str2 = str.<span class="built_in">substr</span>(<span class="number">0</span>, str.<span class="built_in">find</span>(<span class="string">&#x27;.&#x27;</span>));</span><br><span class="line">    n = <span class="built_in">atoi</span>(str2.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*(str.<span class="built_in">c_str</span>() + str.<span class="built_in">find</span>(<span class="string">&#x27;.&#x27;</span>) + <span class="number">1</span>) &gt;= <span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">        n++;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> num;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,(<span class="keyword">int</span>)(num + <span class="number">0.5</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="008-合并表记录"><a href="#008-合并表记录" class="headerlink" title="008 合并表记录"></a>008 合并表记录</h2><p>数据表记录包含表索引和数值（int范围的整数），请对表索引相同的记录进行合并，即将相同索引的数值进行求和运算，输出按照key值升序进行输出。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> key = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;mapp;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; count;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; key &gt;&gt; value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mapp.<span class="built_in">find</span>(key) != mapp.<span class="built_in">end</span>())</span><br><span class="line">            mapp[key] += value;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            mapp.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(key, value));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = mapp.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span> (; it != mapp.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="009-提取不重复的整数"><a href="#009-提取不重复的整数" class="headerlink" title="009 提取不重复的整数"></a>009 提取不重复的整数</h2><p>输入一个int型整数，按照从右向左的阅读顺序，返回一个不含重复数字的新的整数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    </span><br><span class="line">    string str;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.<span class="built_in">find</span>(s[n]) == string::npos)</span><br><span class="line">            str += s[n];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="010-字符个数统计"><a href="#010-字符个数统计" class="headerlink" title="010 字符个数统计"></a>010 字符个数统计</h2><p>编写一个函数，计算字符串中含有的不同字符的个数。字符在ACSII码范围内(0~127)，换行表示结束符，不算在字符里。不在范围内的不作统计。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    string str2;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] &gt;= <span class="number">0</span> &amp;&amp; str[i] &lt;= <span class="number">127</span> &amp;&amp; str[i] != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (str2.<span class="built_in">find</span>(str[i]) == string::npos)</span><br><span class="line">            &#123;</span><br><span class="line">                str2 += str[i];</span><br><span class="line">                count++;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2>]]></content>
      <tags>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>谷歌云搭建v2ray</title>
    <url>/2020-03-29-%E8%B0%B7%E6%AD%8C%E4%BA%91%E6%90%AD%E5%BB%BAv2ray/</url>
    <content><![CDATA[<h2 id="搭建VPS"><a href="#搭建VPS" class="headerlink" title="搭建VPS"></a>搭建VPS</h2><p><a href="https://cloud.google.com/">gcp首页</a></p>
<p><img src="https://i.loli.net/2020/04/02/RusFpUc6iKToMYt.png" alt="gcp_1.png"></p>
<p><img src="https://i.loli.net/2020/04/02/adRf3SQHb1OuEGz.png" alt="gcp_2.png"></p>
<p><img src="https://i.loli.net/2020/04/02/JYkavUXz5lnbqhN.png" alt="gcp_3.png"></p>
<p><img src="https://i.loli.net/2020/04/02/IH8x4nZtVOamLlS.png" alt="gcp_4.png"></p>
<a id="more"></a>


<h2 id="V2Ray配置"><a href="#V2Ray配置" class="headerlink" title="V2Ray配置"></a>V2Ray配置</h2><p><a href="https://www.v2ray.com/chapter_00/install.html">下载安装</a></p>
<p>xshell通过密钥登录服务器，切换到root(sudo -i)</p>
<pre><code>bash &lt;(curl -L -s https://install.direct/go.sh)</code></pre>
<p><strong>此脚本会自动安装以下文件：</strong> <br><br>/usr/bin/v2ray/v2ray：V2Ray 程序； <br><br>/usr/bin/v2ray/v2ctl：V2Ray 工具； <br><br>/etc/v2ray/config.json：配置文件； <br><br>/usr/bin/v2ray/geoip.dat：IP 数据文件 <br><br>/usr/bin/v2ray/geosite.dat：域名数据文件 <br><br>此脚本会配置自动运行脚本。自动运行脚本会在系统重启之后，自动运行 V2Ray。目前自动运行脚本只支持带有 Systemd 的系统，以及 Debian / Ubuntu 全系列。 <br></p>
<p><strong>运行脚本位于系统的以下位置：</strong> <br><br>/etc/systemd/system/v2ray.service: Systemd <br><br>/etc/init.d/v2ray: SysV <br></p>
<p><strong>脚本运行完成后，你需要：</strong>  <br><br>1 编辑 /etc/v2ray/config.json 文件来配置你需要的代理方式；<br><br>2 运行 service v2ray start 来启动 V2Ray 进程； <br><br>3 之后可以使用 service v2ray start|stop|status|reload|restart|force-reload 控制 V2Ray 的运行。    <br></p>
<p><strong>下载客户端(windows)</strong> <br></p>
<p><a href="https://github.com/2dust/v2rayN/releases">下载链接</a></p>
<p><img src="https://i.loli.net/2020/04/02/T1kEHRAVOSC59xq.png" alt="gcp_5.png"></p>
<p>相关参数参考：/etc/v2ray/config.json</p>
<h2 id="ssr配置"><a href="#ssr配置" class="headerlink" title="ssr配置"></a>ssr配置</h2><p><a href="https://www.wmsoho.com/install-shadowsocks/">参考这篇文章</a></p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/04/02/FM4LxvbnUorPVkR.jpg" alt="68010895_p0_master1200_lit.jpg"></p>
]]></content>
      <tags>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-进程互斥的实现方案</title>
    <url>/2020-04-04-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="">陈向群操作系统</a></p>
<a id="more"></a>

<h2 id="软件解法"><a href="#软件解法" class="headerlink" title="软件解法"></a>软件解法</h2><h3 id="DEJKKER算法"><a href="#DEJKKER算法" class="headerlink" title="DEJKKER算法"></a>DEJKKER算法</h3><p><img src="https://i.loli.net/2020/04/05/4TbpmLua2DQGnki.png" alt="dekker算法.png"></p>
<hr>
<h3 id="PETERSON算法"><a href="#PETERSON算法" class="headerlink" title="PETERSON算法"></a>PETERSON算法</h3><p><img src="https://i.loli.net/2020/04/05/CpIeGYRBvfyliSr.png" alt="peterson算法.png"></p>
<h2 id="硬件解法"><a href="#硬件解法" class="headerlink" title="硬件解法"></a>硬件解法</h2><h3 id="开关中断指令"><a href="#开关中断指令" class="headerlink" title="开关中断指令"></a>开关中断指令</h3><p><img src="https://i.loli.net/2020/04/04/eJsyACQirMVjYPa.png" alt="中断指令.png"></p>
<ul>
<li>开关中断指令属于特权级指令，用户态无法调用。</li>
<li>针对单个CPU有效</li>
<li>会导致开关中断时期CPU无法切换</li>
</ul>
<hr>
<h3 id="XCHG指令"><a href="#XCHG指令" class="headerlink" title="XCHG指令"></a>XCHG指令</h3><p><img src="https://i.loli.net/2020/04/04/Jgr7SQGmq1x9KVo.png" alt="XCHG指令.png"></p>
<ul>
<li>给寄存器置1 <br></li>
<li>交换寄存器的值1和锁的值0/1 <br></li>
<li>判断寄存器的值是否为0 <br></li>
<li>busy waiting or return</li>
<li>对单个cpu有效</li>
</ul>
<hr>
<h3 id="TSL指令"><a href="#TSL指令" class="headerlink" title="TSL指令"></a>TSL指令</h3><p><img src="https://i.loli.net/2020/04/04/HgtXIWvjq7FMQTN.png" alt="TSL指令.png"></p>
<ul>
<li>复制锁的值到寄存器，修改锁的值为1</li>
<li>判断寄存器的值是否为0</li>
<li>busy waiting or return</li>
<li>对多cpu有效,因为TSL指令会锁住cpu总线</li>
</ul>
<hr>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/04/04/so7fjPhIHJrXuqL.jpg" alt="80519962_p0_master1200.jpg"></p>
]]></content>
      <tags>
        <tag>OperatingSystem</tag>
      </tags>
  </entry>
  <entry>
    <title>EPOLLONESHOT</title>
    <url>/2020-04-07-EPOLLONESHOT/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.xiyoulinux.org/detail.jsp?id=5309">I/O代表之EPOLLONESHOT事件</a></p>
<a id="more"></a>


<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2>]]></content>
      <tags>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title>dns解析</title>
    <url>/2020-04-07-dns%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhihu.com/question/23042131">DNS解析的过程是什么，求详细的？</a></p>
<a id="more"></a>


<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2>]]></content>
      <tags>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title>1号进程</title>
    <url>/2020-04-07-linux-1%E5%8F%B7%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/gatieme/article/details/51532804">Linux下1号进程的前世(kernel_init)今生(init进程)—-Linux进程的管理与调度（六）</a></p>
<a id="more"></a>


<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2>]]></content>
      <tags>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-posix共享内存</title>
    <url>/2020-04-07-linux-posxi%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h2 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h2><p>内存映射文件（Memory-mapped file），或称“文件映射”、“映射文件”，是一段虚内存逐字节对应于一个文件或类文件的资源，使得应用程序处理映射部分如同访问主内存。</p>
<a id="more"></a>

<p>主要用处是增加I/O性能，特别是用于大文件。对于小文件，内存映射文件会导致碎片空间浪费，[1]因为内存映射总是要对齐页边界，这起码是4 KiB。因而一个5 KiB文件将会映射占用8 KiB内存，浪费了3 KiB内存。访问内存映射文件比直接文件读写要快几个数量级。</p>
<p>内存映射文件可以只加载一部分内容到用户的逻辑内存空间。这对非常大的文件特别有用。</p>
<p>使用内存映射文件可以避免颠簸：把相当大的文件直接加载到内存时，由于可用内存不足，使得一边读取文件内存，同时把部分已经加载的文件从内存写入硬盘虚存文件中。</p>
<p>内存映射文件由操作系统的内存管理程序负责，因此绕过了硬盘虚存的分页文件（page file）。[2]</p>
<h2 id="mmap函数"><a href="#mmap函数" class="headerlink" title="mmap函数"></a>mmap函数</h2><pre><code>//用户空间函数
void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);

//内核空间函数
int mmap(struct file *filp, struct vm_area_struct *vma)</code></pre>
<p>概念类的在之前的那篇文章已经写过了，这里把一些细致的点再梳理下。先看看函数参数：</p>
<p><strong>start:</strong> 指定被映射到的进程内空间的起始地址。它通常被指定为一个空指针，这样告诉内核自己去选择起始地址。无论哪种情况下，该函数的返回值都是描述符fd所映射到内存的起始地址.</p>
<p><strong>len:</strong> 是映射到调用进程地址空间中的字节数，它从被映射文件开头第offset个字节处开始算.offset通常被被设置为0</p>
<p><strong>prot:</strong> 内存映射区的保护由prot参数指定.</p>
<table>
    <thead align="center">
        <tr>
            <th style="text-align:center">prot</th>
            <th style="text-align:center">说明</th>
        </tr>
    </thead>
    <tbody align="center">
        <tr>
            <td>PROT_READ</td>
            <td>数据可读</td>
        </tr>
    </tbody>
    <tbody align="center">
        <tr>
            <td>PROT_WRITE</td>
            <td>数据可写</td>
        </tr>
    </tbody>
    <tbody align="center">
        <tr>
            <td>PROT_EXEC</td>
            <td>数据可执行</td>
        </tr>
    </tbody>
    <tbody align="center">
        <tr>
            <td>PROT_NONE</td>
            <td>数据不可访问</td>
        </tr>
    </tbody>
</table>

<p><strong>flags:</strong> MAP_SHARED和MAP_PRAVITE必须指定一个，并可有选择的或上MAP_FIXED</p>
<p>MAP_PRIVATE：映射区域的修改只对当前进程有效，修改的时候类似写时复制，会拷贝一个映射区域的副本。如果内存不足，该区域将正常交换。由于私有映射在写入时会有效地还原为普通内存，因此，如果将此模式配合使用，则必须具有足够的虚拟内存来存储整个映射区域</p>
<p>MAP_SHARED：对映射区域的修改对所有共享的进程有效，实际是直接修改映射区在内存raw中的值，并且会写回到底层对象(文件)中，但不一定及时写。如果底层对象是只读打开，则会出现问题。</p>
<p>从移植性上考虑，MAP_FIXED不应该指定。如果没有指定该标志，但是start不是一个空指针，那么start如何处置取决于实现。不为空的start值通常被当作有关该内存区应如何具体定位的线索。可移植的代码应把start指定成一个空指针，并且不指定MAP_FIXED</p>
<table>
    <thead align="center">
        <tr>
            <th style="text-align:center">flags</th>
            <th style="text-align:center">说明</th>
        </tr>
    </thead>
    <tbody align="center">
        <tr>
            <td>MAP_SHARED</td>
            <td>变动是共享的</td>
        </tr>
    </tbody>
    <tbody align="center">
        <tr>
            <td>MAP_PRIVATE</td>
            <td>变动是私自的</td>
        </tr>
    </tbody>
    <tbody align="center">
        <tr>
            <td>MAP_ANONYMOUS</td>
            <td>建立匿名映射,此时会忽略参数fd</td>
        </tr>
    </tbody>
    <tbody align="center">
        <tr>
            <td>MAP_FIXED</td>
            <td>准确的解释start参数</td>
        </tr>
    </tbody>
</table>

<p><strong>fd:</strong> 文件描述符，可以为-1.表示匿名映射</p>
<p><strong>offset:</strong> 偏移值，从文件的起始位置偏移多少字节</p>
<p><img src="https://i.loli.net/2020/04/11/IVx7c6vk3joMRtd.png" alt="mmap图示.png"></p>
<h2 id="mmap分类"><a href="#mmap分类" class="headerlink" title="mmap分类"></a>mmap分类</h2><ul>
<li>使用普通文件以提供内存映射IO</li>
<li>使用特殊文件提供匿名内存映射</li>
<li>使用shm_open提供无亲缘进程间的Posix共享内存区(和第一种差不多)</li>
</ul>
<h2 id="匿名内存映射"><a href="#匿名内存映射" class="headerlink" title="匿名内存映射"></a>匿名内存映射</h2><p>看下程序启动阶段的mmap: <br></p>
<pre><code>mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f7484b16000</code></pre>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *ptr = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(<span class="built_in">mmap</span>(<span class="literal">NULL</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>), PROT_READ | </span><br><span class="line">        PROT_WRITE, MAP_PRIVATE | MAP_ANON, <span class="number">-1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* int *ptr = static_cast&lt;int*&gt;(mmap(NULL, sizeof(int), </span></span><br><span class="line"><span class="comment">        PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANON, -1, 0)); */</span></span><br><span class="line"></span><br><span class="line">	*ptr = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;child:&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; *ptr &lt;&lt; endl;</span><br><span class="line">		*ptr = <span class="number">200</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;parent:&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; *ptr &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">wait</span>(<span class="literal">nullptr</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>MAP_PRIVATE</code></p>
<pre><code>child:
0x7f09d5b71000
100
parent:
0x7f09d5b71000
100</code></pre>
<p><code>MAP_SHARED</code></p>
<pre><code>child:
0x7fba08864000
100
parent:
0x7fba08864000
200</code></pre>
<h2 id="实现匿名映射："><a href="#实现匿名映射：" class="headerlink" title="实现匿名映射："></a>实现匿名映射：</h2><p>有的系统可能不支持匿名映射，可以通过open /dev/zero来自己实现.</p>
<p>/dev/zero在类UNIX系统中是一个特殊的设备文件，当你读它的时候，它会提供无限的空字符（NULL, ASCII NUL, 0x00）。其中的一个典型用法是用它提供的字符流来覆盖信息，另一个常见用法是产生一个特定大小的空白文件。BSD就是通过mmap把/dev/zero映射到虚地址空间实现共享内存的。可以使用mmap将/dev/zero映射到一个虚拟的内存空间，这个操作的效果等同于使用一段匿名的内存（没有和任何文件相关）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;/dev/zero&quot;</span>, O_RDWR);</span><br><span class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> *ptr = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(<span class="built_in">mmap</span>(<span class="literal">NULL</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>), PROT_READ | PROT_WRITE, </span><br><span class="line">        MAP_SHARED , fd, <span class="number">0</span>));</span><br><span class="line">	*ptr = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;child:&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; *ptr &lt;&lt; endl;</span><br><span class="line">		*ptr = <span class="number">200</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;parent:&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; *ptr &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">wait</span>(<span class="literal">nullptr</span>);</span><br><span class="line">		<span class="built_in">pause</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/11/eqV7fJwZi2MyjTR.png" alt="zero.png"></p>
<h2 id="posix共享内存"><a href="#posix共享内存" class="headerlink" title="posix共享内存"></a>posix共享内存</h2><p>posix共享内存的实现也是映射文件，不过会给文件路径加上前缀：/dev/shm/. <br><br>从使用上来说就是把open替换成shm_open,不过shm_open内部还是调用了open,花里胡哨的</p>
<p><strong>shm_open</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	_PATH_DEV	<span class="meta-string">&quot;/dev/&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHMDIR	(_PATH_DEV <span class="meta-string">&quot;shm/&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Open shared memory object.  */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">shm_open (<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> oflag, <span class="keyword">mode_t</span> mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">size_t</span> namelen;</span><br><span class="line">  <span class="keyword">char</span> *fname;</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Construct the filename.  */</span></span><br><span class="line">  <span class="keyword">while</span> (name[<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    ++name;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (name[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* The name &quot;/&quot; is not supported.  */</span></span><br><span class="line">      __set_errno (EINVAL);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  namelen = <span class="built_in">strlen</span> (name);</span><br><span class="line">  fname = (<span class="keyword">char</span> *) __alloca (<span class="keyword">sizeof</span> SHMDIR - <span class="number">1</span> + namelen + <span class="number">1</span>);</span><br><span class="line">  __mempcpy (__mempcpy (fname, SHMDIR, <span class="keyword">sizeof</span> SHMDIR - <span class="number">1</span>),</span><br><span class="line">	     name, namelen + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  fd = open (name, oflag, mode);</span><br><span class="line">  <span class="keyword">if</span> (fd != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We got a descriptor.  Now set the FD_CLOEXEC bit.  */</span></span><br><span class="line">      <span class="keyword">int</span> flags = fcntl (fd, F_GETFD, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (flags, <span class="number">0</span>) != <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  flags |= FD_CLOEXEC;</span><br><span class="line">	  flags = fcntl (fd, F_SETFD, flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (flags == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* Something went wrong.  We cannot return the descriptor.  */</span></span><br><span class="line">	  <span class="keyword">int</span> save_errno = errno;</span><br><span class="line">	  close (fd);</span><br><span class="line">	  fd = <span class="number">-1</span>;</span><br><span class="line">	  __set_errno (save_errno);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>测试程序</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//shm_unlink(&quot;/ShareMemory&quot;);</span></span><br><span class="line">	<span class="keyword">int</span> fd = <span class="built_in">shm_open</span>(<span class="string">&quot;/ShareMemory&quot;</span>, O_RDWR |  O_CREAT , <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">		cout &lt;&lt; fd &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">ftruncate</span>(fd, <span class="number">1024</span>);	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> s[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">char</span> *ptr = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(<span class="built_in">mmap</span>(<span class="literal">NULL</span>, <span class="number">1024</span>, PROT_READ | PROT_WRITE,</span><br><span class="line">         MAP_SHARED, fd, <span class="number">0</span> ));</span><br><span class="line">	cout &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">time_t</span> ti = <span class="built_in">time</span>(&amp;ti);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">ptm</span> =</span> <span class="literal">nullptr</span>;</span><br><span class="line">	ptm = <span class="built_in">localtime</span>(&amp;ti);</span><br><span class="line">	<span class="built_in">strftime</span>(s, <span class="number">1024</span>, <span class="string">&quot;%Y %m %d %H %M %S&quot;</span>, ptm);</span><br><span class="line">	<span class="built_in">strcat</span>(ptr, s);</span><br><span class="line">	<span class="built_in">strcat</span>(ptr, <span class="string">&quot;\n&quot;</span>);	</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">close</span>(fd);</span><br><span class="line">	<span class="comment">//shm_unlink(&quot;/ShareMemory&quot;);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<pre><code>[root@localhost ~]# ./a.out 

2020 04 11 22 54 59
2020 04 11 22 55 00
2020 04 11 22 55 01
2020 04 11 22 55 08
2020 04 11 22 55 08
2020 04 11 22 55 09
2020 04 11 22 55 49
2020 04 11 22 55 50

ok
[root@localhost ~]# ./a.out 

2020 04 11 22 54 59
2020 04 11 22 55 00
2020 04 11 22 55 01
2020 04 11 22 55 08
2020 04 11 22 55 08
2020 04 11 22 55 09
2020 04 11 22 55 49
2020 04 11 22 55 50
2020 04 11 22 56 19

ok
[root@localhost ~]# ./a.out 

2020 04 11 22 54 59
2020 04 11 22 55 00
2020 04 11 22 55 01
2020 04 11 22 55 08
2020 04 11 22 55 08
2020 04 11 22 55 09
2020 04 11 22 55 49
2020 04 11 22 55 50
2020 04 11 22 56 19
2020 04 11 22 56 31

ok

[root@localhost shm]# pwd
/dev/shm
[root@localhost shm]# ls -lrt
总用量 24
-rw------- 1 postgres postgres 19916 4月  11 17:28 PostgreSQL.1900869883
---------- 1 root     root      1024 4月  11 22:56 ShareMemory

[root@localhost shm]# cat ShareMemory 

2020 04 11 22 54 59
2020 04 11 22 55 00
2020 04 11 22 55 01
2020 04 11 22 55 08
2020 04 11 22 55 08
2020 04 11 22 55 09
2020 04 11 22 55 49
2020 04 11 22 55 50
2020 04 11 22 56 19
2020 04 11 22 56 31
2020 04 11 22 56 32</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>MAP_PRIVATE会创建内存副本，只对单个进程有效，不可用于共享</li>
<li>MAP_SHARED在内存只有一个映射对象，修改对所有共享进程生效。并且修改后会写入底层对象(文件)中</li>
<li>mmap匿名文件映射fd赋值-1, flag或上MAP_ANON.或者通过/dev/zero自己实现</li>
<li>shm_open作为posix标准的共享内存实现，内部也是open打开文件/dev/shm/youfilename来实现的</li>
<li>编译的时候 -lrt</li>
</ul>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/04/11/QYGbd4MqTfvOgmK.jpg" alt="69810542_p0_master1200.jpg"></p>
]]></content>
      <tags>
        <tag>ipc</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-spinlock</title>
    <url>/2020-04-07-linux-spinlock/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.wowotech.net/kernel_synchronization/spinlock.html">Linux内核同步机制之（四）：spin lock</a></p>
<p><a href="https://www.linuxjournal.com/article/5833">内核锁定技术</a></p>
<p><a href="https://stackoverflow.com/questions/1957398/what-exactly-are-spin-locks">What exactly are “spin-locks”?</a></p>
<p><a href="https://www.windsings.com/posts/2a85d31f/">X86与ARM中的原子操作-原理及实现</a></p>
<p><a href="https://www.cnblogs.com/cwcheng/p/10698428.html">原子操作对同步与互斥的意义</a></p>
<p><a href="http://linuxperf.com/?p=138">LINUX KERNEL SPINLOCK使用不当的后果</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-spinlock/index.html">Linux 内核的排队自旋锁</a></p>
<a id="more"></a>

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E6%97%8B%E9%94%81">wikepedia</a></p>
<p>自旋锁是计算机科学用于多线程同步的一种锁，线程反复检查锁变量是否可用。由于线程在这一过程中保持执行，因此是一种忙等待。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。</p>
<p>自旋锁避免了进程上下文的调度开销，因此对于线程只会阻塞很短时间的场合是有效的。因此操作系统的实现在很多地方往往用自旋锁。Windows操作系统提供的轻型读写锁（SRW Lock）内部就用了自旋锁。显然，单核CPU不适于使用自旋锁，这里的单核CPU指的是单核单线程的CPU，因为，在同一时间只有一个线程是处在运行状态，假设运行线程A发现无法获取锁，只能等待解锁，但因为A自身不挂起，所以那个持有锁的线程B没有办法进入运行状态，只能等到操作系统分给A的时间片用完，才能有机会被调度。这种情况下使用自旋锁的代价很高。</p>
<p>获取、释放自旋锁，实际上是读写自旋锁的存储内存或寄存器。因此这种读写操作必须是原子的。通常用test-and-set等原子操作来实现</p>
<p>上面说通常使用TSL指令实现，之前总结过TSL指令是同步的硬件实现方式，会锁住CPU的地址总线，所以是对多核CPU生效的，并且内部实现是忙等待机制。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">raw_spinlock</span> <span class="title">rlock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> LOCK_PADSIZE (offsetof(struct raw_spinlock, dep_map))</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			u8 __padding[LOCK_PADSIZE];</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">dep_map</span>;</span></span><br><span class="line">		&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125; <span class="keyword">spinlock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">raw_spinlock</span> &#123;</span></span><br><span class="line">	<span class="keyword">arch_spinlock_t</span> raw_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_GENERIC_LOCKBREAK</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> break_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_SPINLOCK</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> magic, owner_cpu;</span><br><span class="line">	<span class="keyword">void</span> *owner;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">dep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; <span class="keyword">raw_spinlock_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>spin_lock/spin_unlock — 禁止内核抢占 <br><br>spin_lock_irq/spin_unlock_irq — 禁止内核抢占并屏蔽中断 <br><br>spin_lock_irqsave/spin_unlock_irqrestore — 禁止内核抢占并屏蔽中断，事先保存中断屏蔽位并事后恢复原状 <br></p>
<p>内核版本：<br>VERSION = 3<br>PATCHLEVEL = 10<br>SUBLEVEL = 1</p>
<h3 id="spin-lock"><a href="#spin-lock" class="headerlink" title="spin_lock"></a>spin_lock</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spin_lock</span><span class="params">(<span class="keyword">spinlock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	raw_spin_lock(&amp;lock-&gt;rlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> raw_spin_lock(lock)	_raw_spin_lock(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_INLINE_SPIN_LOCK</span></span><br><span class="line"><span class="keyword">void</span> __lockfunc _raw_spin_lock(<span class="keyword">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">	__raw_spin_lock(lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __raw_spin_lock(<span class="keyword">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> tmp;</span><br><span class="line"></span><br><span class="line">	__asm__ __volatile__(</span><br><span class="line">			<span class="string">&quot;       movi    %0, 0\n&quot;</span></span><br><span class="line">			<span class="string">&quot;       wsr     %0, scompare1\n&quot;</span></span><br><span class="line">			<span class="string">&quot;1:     movi    %0, 1\n&quot;</span></span><br><span class="line">			<span class="string">&quot;       s32c1i  %0, %1, 0\n&quot;</span></span><br><span class="line">			<span class="string">&quot;       bnez    %0, 1b\n&quot;</span></span><br><span class="line">			: <span class="string">&quot;=&amp;a&quot;</span> (tmp)</span><br><span class="line">			: <span class="string">&quot;a&quot;</span> (&amp;lock-&gt;slock)</span><br><span class="line">			: <span class="string">&quot;memory&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __raw_spin_lock(<span class="keyword">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">	preempt_disable();</span><br><span class="line">	spin_acquire(&amp;lock-&gt;dep_map, <span class="number">0</span>, <span class="number">0</span>, _RET_IP_);</span><br><span class="line">	LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="spin-unlock"><a href="#spin-unlock" class="headerlink" title="spin_unlock"></a>spin_unlock</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spin_unlock</span><span class="params">(<span class="keyword">spinlock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	raw_spin_unlock(&amp;lock-&gt;rlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> raw_spin_unlock(lock)		_raw_spin_unlock(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_UNINLINE_SPIN_UNLOCK</span></span><br><span class="line"><span class="keyword">void</span> __lockfunc _raw_spin_unlock(<span class="keyword">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">	__raw_spin_unlock(lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __raw_spin_unlock(<span class="keyword">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> tmp;</span><br><span class="line"></span><br><span class="line">	__asm__ __volatile__(</span><br><span class="line">			<span class="string">&quot;       movi    %0, 0\n&quot;</span></span><br><span class="line">			<span class="string">&quot;       s32ri   %0, %1, 0\n&quot;</span></span><br><span class="line">			: <span class="string">&quot;=&amp;a&quot;</span> (tmp)</span><br><span class="line">			: <span class="string">&quot;a&quot;</span> (&amp;lock-&gt;slock)</span><br><span class="line">			: <span class="string">&quot;memory&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __raw_spin_unlock(<span class="keyword">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">	spin_release(&amp;lock-&gt;dep_map, <span class="number">1</span>, _RET_IP_);</span><br><span class="line">	do_raw_spin_unlock(lock);</span><br><span class="line">	preempt_enable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="spin-lock-irq"><a href="#spin-lock-irq" class="headerlink" title="spin_lock_irq"></a>spin_lock_irq</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spin_lock_irq</span><span class="params">(<span class="keyword">spinlock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	raw_spin_lock_irq(&amp;lock-&gt;rlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> raw_spin_lock_irq(lock)		_raw_spin_lock_irq(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_INLINE_SPIN_LOCK_IRQ</span></span><br><span class="line"><span class="keyword">void</span> __lockfunc _raw_spin_lock_irq(<span class="keyword">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">	__raw_spin_lock_irq(lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __raw_spin_lock_irq(<span class="keyword">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">	local_irq_disable();</span><br><span class="line">	preempt_disable();</span><br><span class="line">	spin_acquire(&amp;lock-&gt;dep_map, <span class="number">0</span>, <span class="number">0</span>, _RET_IP_);</span><br><span class="line">	LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="spin-unlock-irq"><a href="#spin-unlock-irq" class="headerlink" title="spin_unlock_irq"></a>spin_unlock_irq</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spin_unlock_irq</span><span class="params">(<span class="keyword">spinlock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	raw_spin_unlock_irq(&amp;lock-&gt;rlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> raw_spin_unlock_irq(lock)	_raw_spin_unlock_irq(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_INLINE_SPIN_UNLOCK_IRQ</span></span><br><span class="line"><span class="keyword">void</span> __lockfunc _raw_spin_unlock_irq(<span class="keyword">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">	__raw_spin_unlock_irq(lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __raw_spin_unlock_irq(<span class="keyword">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">	spin_release(&amp;lock-&gt;dep_map, <span class="number">1</span>, _RET_IP_);</span><br><span class="line">	do_raw_spin_unlock(lock);</span><br><span class="line">	local_irq_enable();</span><br><span class="line">	preempt_enable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="spin-lock-irqsave"><a href="#spin-lock-irqsave" class="headerlink" title="spin_lock_irqsave"></a>spin_lock_irqsave</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> spin_lock_irqsave(lock, flags)				\</span></span><br><span class="line"><span class="keyword">do</span> &#123;								\</span><br><span class="line">	raw_spin_lock_irqsave(spinlock_check(lock), flags);	\</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//#if</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_SMP) || defined(CONFIG_DEBUG_SPINLOCK)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> raw_spin_lock_irqsave(lock, flags)			\</span></span><br><span class="line">	<span class="keyword">do</span> &#123;						\</span><br><span class="line">		typecheck(<span class="keyword">unsigned</span> <span class="keyword">long</span>, flags);	\</span><br><span class="line">		flags = _raw_spin_lock_irqsave(lock);	\</span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//#else</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> raw_spin_lock_irqsave(lock, flags)		\</span></span><br><span class="line">	<span class="keyword">do</span> &#123;						\</span><br><span class="line">		typecheck(<span class="keyword">unsigned</span> <span class="keyword">long</span>, flags);	\</span><br><span class="line">		_raw_spin_lock_irqsave(lock, flags);	\</span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"><span class="comment">//#endif</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _raw_spin_lock_irqsave(lock, flags)	__LOCK_IRQSAVE(lock, flags)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_INLINE_SPIN_LOCK_IRQSAVE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _raw_spin_lock_irqsave(lock) __raw_spin_lock_irqsave(lock)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#if</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(CONFIG_GENERIC_LOCKBREAK) || defined(CONFIG_DEBUG_LOCK_ALLOC)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __raw_spin_lock_irqsave(<span class="keyword">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	local_irq_save(flags);</span><br><span class="line">	preempt_disable();</span><br><span class="line">	spin_acquire(&amp;lock-&gt;dep_map, <span class="number">0</span>, <span class="number">0</span>, _RET_IP_);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * On lockdep we dont want the hand-coded irq-enable of</span></span><br><span class="line"><span class="comment">	 * do_raw_spin_lock_flags() code, because lockdep assumes</span></span><br><span class="line"><span class="comment">	 * that interrupts are not re-enabled during lock-acquire:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">	LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	do_raw_spin_lock_flags(lock, &amp;flags);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> flags;</span><br><span class="line">&#125;  </span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="spin-unlock-irqrestore"><a href="#spin-unlock-irqrestore" class="headerlink" title="spin_unlock_irqrestore"></a>spin_unlock_irqrestore</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spin_unlock_irqrestore</span><span class="params">(<span class="keyword">spinlock_t</span> *lock, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;lock-&gt;rlock, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> raw_spin_unlock_irqrestore(lock, flags)		\</span></span><br><span class="line">	<span class="keyword">do</span> &#123;							\</span><br><span class="line">		typecheck(<span class="keyword">unsigned</span> <span class="keyword">long</span>, flags);		\</span><br><span class="line">		_raw_spin_unlock_irqrestore(lock, flags);	\</span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _raw_spin_unlock_irqrestore(lock, flags) \</span></span><br><span class="line">					__UNLOCK_IRQRESTORE(lock, flags)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE</span></span><br><span class="line"><span class="keyword">void</span> __lockfunc _raw_spin_unlock_irqrestore(<span class="keyword">raw_spinlock_t</span> *lock, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">	__raw_spin_unlock_irqrestore(lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __raw_spin_unlock_irqrestore(<span class="keyword">raw_spinlock_t</span> *lock,</span><br><span class="line">					    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">	spin_release(&amp;lock-&gt;dep_map, <span class="number">1</span>, _RET_IP_);</span><br><span class="line">	do_raw_spin_unlock(lock);</span><br><span class="line">	local_irq_restore(flags);</span><br><span class="line">	preempt_enable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>spinlock比较底层，跟踪代码有多种实现不好界定，目前使用的比较少，就不继续深究了</li>
<li>spinlock可以禁用内核抢占，也可以禁用中断</li>
<li>spinlock底层通常用TSL实现</li>
<li>spinlock对多核cpu有效(TSL)</li>
<li>uni core不适用spinlock,需要等待时间片用尽然后等待其他进程释放锁，代价高</li>
<li>spinlock是busy waiting,没有进程切换的代价，但是占用cpu,所以加锁时间不宜过长</li>
</ul>
<hr>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/04/04/Yq35KdRCga8jQsV.jpg" alt="80546350_p0.jpg"></p>
]]></content>
      <tags>
        <tag>ipc</tag>
      </tags>
  </entry>
  <entry>
    <title>信号和信号处理函数</title>
    <url>/2020-04-07-linux-%E4%BF%A1%E5%8F%B7/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/66051508">Linux信号（signal) 机制分析</a> <br><br><a href="https://www.cnblogs.com/charlesblc/p/6262783.html">SIGSEGV 和 SIGBUS &amp; gdb看汇编</a></p>
<a id="more"></a>

<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>信号是软件中断,很多比较重要的应用程序都需处理信号.信号提供了一种处理异步事件的方法，例如,终端用户键入中断键，会通过信号机制停止一个程序，或及早终止管道中的下一个程序.</p>
<h3 id="常见信号"><a href="#常见信号" class="headerlink" title="常见信号"></a>常见信号</h3><pre><code>1) SIGHUP     2) SIGINT     3) SIGQUIT     4) SIGILL     5) SIGTRAP
 6) SIGABRT     7) SIGBUS     8) SIGFPE     9) SIGKILL    10) SIGUSR1
11) SIGSEGV    12) SIGUSR2    13) SIGPIPE    14) SIGALRM    15) SIGTERM
16) SIGSTKFLT    17) SIGCHLD    18) SIGCONT    19) SIGSTOP    20) SIGTSTP
21) SIGTTIN    22) SIGTTOU    23) SIGURG    24) SIGXCPU    25) SIGXFSZ
26) SIGVTALRM    27) SIGPROF    28) SIGWINCH    29) SIGIO    30) SIGPWR
31) SIGSYS    34) SIGRTMIN    35) SIGRTMIN+1    36) SIGRTMIN+2    37) SIGRTMIN+3
38) SIGRTMIN+4    39) SIGRTMIN+5    40) SIGRTMIN+6    41) SIGRTMIN+7    42) SIGRTMIN+8
43) SIGRTMIN+9    44) SIGRTMIN+10    45) SIGRTMIN+11    46) SIGRTMIN+12    47) SIGRTMIN+13
48) SIGRTMIN+14    49) SIGRTMIN+15    50) SIGRTMAX-14    51) SIGRTMAX-13    52) SIGRTMAX-12
53) SIGRTMAX-11    54) SIGRTMAX-10    55) SIGRTMAX-9    56) SIGRTMAX-8    57) SIGRTMAX-7
58) SIGRTMAX-6    59) SIGRTMAX-5    60) SIGRTMAX-4    61) SIGRTMAX-3    62) SIGRTMAX-2
63) SIGRTMAX-1    64) SIGRTMAX    </code></pre>
<h3 id="信号的分类"><a href="#信号的分类" class="headerlink" title="信号的分类"></a>信号的分类</h3><p>前32种信号表示非实时信号，是不可靠的，信号不能排队，可能丢失  <br><br>不知道为什么kill列出的信号没有32的值,但在signal.h中是SIGRTMIN=32 </p>
<pre><code>#define SIGRTMIN        32</code></pre>
<p>后32个信号表示实时信号，是可靠的，支持排队</p>
<h3 id="SIGHUP"><a href="#SIGHUP" class="headerlink" title="SIGHUP"></a><code>SIGHUP</code></h3><p>如果终端接口检测到一个连接断开,则将此信号送给与该终端相关的控制进程(会话首进程)。此信号被送给session结构中s_leader字段所指向的进程。仅当终端的CLOCAL标志没有设置时，在上述条件下才产生此信号。(详情以后研究)<br>接到此信号的会话首进程也可能在后台，这区别与由终端正常产生的几个信号(中断，退出和挂起)，这些信号总是传递给前台进程组中的每一个进程<br>如果会话首进程终止，也产生此信号。在这种情况下，此信号送给前台进程组中的每一个进程。<br>通常用此信号通知守护进程再次读取他们的配置文件。选用SIGHUP的理由是，守护进程不会有控制终端，通常绝不会收到此种信号。</p>
<h3 id="SIGINT"><a href="#SIGINT" class="headerlink" title="SIGINT"></a><code>SIGINT</code></h3><p>当用户按中断键(一般采用DELETE/CRTL+C)时，终端驱动程序产生此信号并发送至前台进程组中的每一个进程。当一个进程在运行时失控，特别是它正在屏幕上产生大量不需要的输出时，常用此信号终止它。<br><code>对后台进程不起作用</code></p>
<h3 id="SIGQUIT"><a href="#SIGQUIT" class="headerlink" title="SIGQUIT"></a><code>SIGQUIT</code></h3><p>当用户在终端上按退出键(一般采用CTRL+)时，中断驱动程序产生此信号，并发送给前台进程组的所有进程。此信号不仅终止前台进程组(如SIGINT所作的那样)，同时产生一个core文件。<br><code>对后台进程不起作用</code></p>
<h3 id="SIGILL"><a href="#SIGILL" class="headerlink" title="SIGILL"></a><code>SIGILL</code></h3><p>此信号表示进程已执行一条非法硬件指令。</p>
<h3 id="SIGTRAP"><a href="#SIGTRAP" class="headerlink" title="SIGTRAP"></a><code>SIGTRAP</code></h3><p>表示一个实现定义的硬件故障 <br></p>
<blockquote>
<p>此信号名来自于PDP-11的TRAP指令。当执行断点指令时，实现常用此信号将控制转移至调试程序。<br>gdb有时候会产生此信号,后续研究</p>
</blockquote>
<h3 id="SIGABRT"><a href="#SIGABRT" class="headerlink" title="SIGABRT"></a><code>SIGABRT</code></h3><p>调用abort（英 /əˈbɔːt/ ）函数产生此信号，进程异常终止</p>
<h3 id="SIGBUS"><a href="#SIGBUS" class="headerlink" title="SIGBUS"></a><code>SIGBUS</code></h3><p>表示一个实现定义的硬件故障。当出现某些类型的内存故障时，实现常常产生此信号。<br><br>所述SIGBUS信号被发送到时它会导致一流程总线错误。导致发送信号的条件是例如错误的内存访问对齐或不存在的物理地址。</p>
<h3 id="SIGALRM"><a href="#SIGALRM" class="headerlink" title="SIGALRM"></a><code>SIGALRM</code></h3><p>在POSIX兼容的平台上，SIGALRM是在定时器终止时发送给进程的信号。它们的符号常量在头文件signal.h中定义。在不同的平台上，信号的编号可能发生变化，因此需要使用符号名称。</p>
<h3 id="SIGCHLD"><a href="#SIGCHLD" class="headerlink" title="SIGCHLD"></a><code>SIGCHLD</code></h3><p>当某一子进程结束、中断或恢复执行时，内核会发送SIGCHLD信号予其父进程。在默认情况下，父进程会以SIG_IGN函数忽略之</p>
<h3 id="SIGFPE"><a href="#SIGFPE" class="headerlink" title="SIGFPE"></a>SIGFPE</h3><p>在POSIX兼容的平台上，SIGFPE是当一个进程执行了一个错误的算术操作(除0，浮点溢出)时发送给它的信号。SIGFPE的符号常量在头文件signal.h中定义。因为在不同平台上，信号数字可能变化，因此常使用信号名称</p>
<h3 id="SIGIO-and-SIGPOLL"><a href="#SIGIO-and-SIGPOLL" class="headerlink" title="SIGIO and SIGPOLL"></a>SIGIO and SIGPOLL</h3><p>当在明确监视的文件描述符上发生事件时，将发送SIGPOLL信号。[14]有效使用它会导致发出异步I / O请求，因为内核将轮询描述符代替调用者。它提供了主动轮询的替代方法。</p>
<h3 id="SIGPIPE"><a href="#SIGPIPE" class="headerlink" title="SIGPIPE"></a>SIGPIPE</h3><p>SIGPIPE信号在尝试写入管道而没有另一端连接进程时将其发送到进程。</p>
<h3 id="SIGSEGV"><a href="#SIGSEGV" class="headerlink" title="SIGSEGV"></a>SIGSEGV</h3><p>如果进程尝试访问其虚拟地址空间之外的内存地址，则内核将通过SIGSEGV信号将该冲突通知进程</p>
<h3 id="SIGKILL"><a href="#SIGKILL" class="headerlink" title="SIGKILL"></a>SIGKILL</h3><p>SIGKILL信号被发送到一个进程，以使其立即终止（kill）。与SIGTERM和SIGINT相比，此信号无法捕获或忽略，并且接收过程在接收到此信号后无法执行任何清理。下列例外情况适用：</p>
<ul>
<li>僵尸进程无法被杀死，因为它们已经死亡并且正在等待其父进程获得它们。</li>
<li>处于阻塞状态的进程只有在再次唤醒后才会消失。</li>
<li>在初始化过程是特殊的：它没有得到信号，它不希望处理，因此可以忽略SIGKILL。[10]从这个规则的一个例外是当init的ptraced在Linux上。[11] [12]</li>
<li>一个不可中断睡眠过程中不得终止（并释放其资源）发送SIGKILL也是如此。这是为解决临时软件问题而必须重新引导UNIX系统的少数情况之一。</li>
</ul>
<p>如果在大多数系统关闭过程中终止进程，并且没有响应SIGTERM而自动退出，则SIGKILL将用作最后的手段。为了加快计算机关闭过程的速度，Mac OS X 10.6（也称为Snow Leopard）会将SIGKILL发送给标记为“干净”的应用程序，从而缩短了关闭时间，并且没有不良影响。[13]该命令killall -9在Linux中执行时具有类似的危险效果。它不允许程序保存未保存的数据。它具有其他选择，并且没有其他选择使用更安全的SIGTERM信号。</p>
<h3 id="SIGTERM"><a href="#SIGTERM" class="headerlink" title="SIGTERM"></a>SIGTERM</h3><p>SIGTERM信号被发送到进程以请求终止。与SIGKILL信号不同，该信号可以被过程捕获，解释或忽略。这允许进程执行适当的终止，以释放资源并在适当时保存状态。SIGINT与SIGTERM几乎相同。</p>
<h3 id="SIGSTOP"><a href="#SIGSTOP" class="headerlink" title="SIGSTOP"></a>SIGSTOP</h3><p>作业控制信号，停止一个进程，不能被捕捉或忽略</p>
<h3 id="SIGTRAP-1"><a href="#SIGTRAP-1" class="headerlink" title="SIGTRAP"></a>SIGTRAP</h3><p>发生异常（或陷阱）时，将SIGTRAP信号发送到进程：调试器已要求通知的条件-例如，当执行特定功能时，或当特定变量更改值时。 <br><br>当执行断点指令时，实现常用此信号将控制转移到调试程序</p>
<h3 id="SIGURG"><a href="#SIGURG" class="headerlink" title="SIGURG"></a>SIGURG</h3><p>当套接字具有可读取的紧急或带外数据时，将SIGURG信号发送到进程。</p>
<h3 id="SIGUSR1-and-SIGUSR2"><a href="#SIGUSR1-and-SIGUSR2" class="headerlink" title="SIGUSR1 and SIGUSR2"></a>SIGUSR1 and SIGUSR2</h3><p>SIGUSR1和SIGUSR2信号被发送到进程以指示用户定义的条件。</p>
<h2 id="信号处理函数"><a href="#信号处理函数" class="headerlink" title="信号处理函数"></a>信号处理函数</h2><h3 id="Fake-signal-functions"><a href="#Fake-signal-functions" class="headerlink" title="Fake signal functions"></a>Fake signal functions</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Fake signal functions.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIG_ERR ((__sighandler_t) -1) <span class="comment">/* Error return.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIG_DFL ((__sighandler_t) 0) <span class="comment">/* Default action.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIG_IGN ((__sighandler_t) 1) <span class="comment">/* Ignore signal.  */</span></span></span><br></pre></td></tr></table></figure>

<h3 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Type of a signal handler.  */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">__sighandler_t</span>)</span> <span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __USE_BSD</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">__sighandler_t</span> <span class="title">signal</span> <span class="params">(<span class="keyword">int</span> __sig, <span class="keyword">__sighandler_t</span> __handler)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>DEMO</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (SIGUSR1 == signo)</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;recv SIGUSR1&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (SIGUSR2 == signo)</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;recv SIGUSR2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;signal num is &quot;</span> &lt;&lt; signo &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">signal</span>(SIGUSR1, sig) == SIG_ERR)</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;can,t catch SIGUSR1&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">signal</span>(SIGUSR2, sig) == SIG_ERR)</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;can,t catch SIGUSR2&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">		<span class="built_in">pause</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>[root@localhost signal]# kill -USR1 16747
[root@localhost signal]# recv SIGUSR1
^C
[root@localhost signal]# kill -USR2 16747
[root@localhost signal]# recv SIGUSR2
^C</code></pre>
<h3 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction"></a>sigaction</h3><h3 id="sigemptyset"><a href="#sigemptyset" class="headerlink" title="sigemptyset"></a>sigemptyset</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sigemptyset() initializes the signal set given by set to empty, with all signals excluded from the set.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="sigfillset"><a href="#sigfillset" class="headerlink" title="sigfillset"></a>sigfillset</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//sigfillset() initializes set to full, including all signals.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="sigaddset-sigdelset"><a href="#sigaddset-sigdelset" class="headerlink" title="sigaddset/sigdelset"></a>sigaddset/sigdelset</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sigaddset() and sigdelset() add and delete respectively signal signum from set.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="sigismember"><a href="#sigismember" class="headerlink" title="sigismember"></a>sigismember</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//sigismember() tests whether signum is a member of set.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/01/13/i6X9R4SyIOBTQ71.jpg" alt="sa55_lit.jpg"></p>
]]></content>
      <tags>
        <tag>ipc</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-文件系统</title>
    <url>/2020-04-07-linux-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/44267768">深入理解 ext4 等 Linux 文件系统</a></p>
<p><a href="https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/content/59.html">认识 Linux 文件系统</a></p>
<a id="more"></a>

<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2>]]></content>
      <tags>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title>mmap共享内存</title>
    <url>/2020-04-07-mmap%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://stackoverflow.com/questions/30542428/does-malloc-use-brk-or-mmap">brk/mmap</a></p>
<p><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html">认真分析mmap：是什么 为什么 怎么用</a></p>
<p><a href="https://blog.csdn.net/gfgdsg/article/details/42709943">Linux内存分配小结–malloc、brk、mmap</a></p>
<p><a href="https://www.cnblogs.com/LoyenWang/p/12037658.html">十三 Linux内存管理之vma/malloc/mmap</a></p>
<p><a href="http://abcdxyzk.github.io/blog/2015/09/11/kernel-mm-mmap/">linux mmap 详解</a></p>
<a id="more"></a>

<h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><pre><code>//用户空间函数
void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);

//内核空间函数
int mmap(struct file *filp, struct vm_area_struct *vma)</code></pre>
<p><img src="https://i.loli.net/2020/03/04/qi568fuBnzmxDHc.png" alt="task_struct.png"></p>
<p>task_struct结构是linux上pcb的实现，用户空间函数mmap创建vm_area_struct数据结构，映射到进程的虚拟地址空间<br>内核空间函数mmap建立页表，将文件磁盘地址和虚拟空间地址进行映射</p>
<p>linux加载可执行程序(ELF)就是使用的mmap</p>
<h3 id="mmap和read-write的区别"><a href="#mmap和read-write的区别" class="headerlink" title="mmap和read/write的区别"></a>mmap和read/write的区别</h3><p>read/write是系统调用函数，用于内核态和用户态之间的数据读写。文件磁盘的数据–&gt;buffer/cache–&gt;用户空间<br>而mmap函数本身只是建立了一种进程虚拟地址空间到文件磁盘的映射关系，实际访问映射的这块地址时，才发生缺页异常，由操作系统将文件内容复制到内存的一个区域。文件磁盘的数据-&gt;内存中的页框(用户空间可见)</p>
<p>性能差异主要是系统调用，额外的复制与页错误的差异。</p>
<p><img src="https://i.loli.net/2020/03/05/NdRh64LEumzHSpD.jpg" alt="进程地址空间2.jpg"></p>
<h3 id="mmap与malloc"><a href="#mmap与malloc" class="headerlink" title="mmap与malloc"></a>mmap与malloc</h3><p><img src="https://i.loli.net/2020/03/05/NpfQeWoKhACSrTw.jpg" alt="brk-mmap在虚拟地址空间中.jpg"></p>
<p>1、brk是将数据段(.data)的最高地址指针_edata往高地址推；<br><br>2、mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。</p>
<p><code>brk/mmap各有优略</code></p>
<p>brk会造成一定程度的内存碎片问题，指针移到高位，地位已经释放的<code>虚拟内存</code>一定时间内未使用.但已经释放的<code>虚拟内存</code>不会立即返回给OS，有一定的缓存作用</p>
<p>mmap会造成多次缺页异常(size/4k),但是申请的<code>虚拟内存</code>是在栈和堆中间的区域，可以随时释放(munmap)</p>
<p><code>mallopt() could set parameters to control behavior of malloc(), and there is a parameter named M_MMAP_THRESHOLD, in general:</code></p>
<ul>
<li>如果请求的内存少于它，brk()将使用；</li>
<li>如果请求的内存大于或等于它，mmap()则将使用；</li>
</ul>
<hr>
<p><code>brk/mmap实现</code></p>
<p><strong>图片来自:</strong><br><a href="https://www.cnblogs.com/LoyenWang/p/12037658.html">十三 Linux内存管理之vma/malloc/mmap</a></p>
<p><strong>sys_brk</strong></p>
<p><img src="https://i.loli.net/2020/03/23/xgoKpGSIVTi9yru.png" alt="malloc.png"></p>
<hr>
<p><strong>sys_mmap</strong></p>
<p><img src="https://i.loli.net/2020/03/23/scH7OdVgM5WpvwX.png" alt="mmap.png"></p>
<hr>
<p><code>brk/sbrk</code></p>
<pre><code>int brk(void *addr);</code></pre>
<blockquote>
<p>brk() sets the end of the data segment to the value specified by addr, when that value is reasonable, the system has enough memory, and the process does not exceed its maximum data size.</p>
</blockquote>
<blockquote>
<p>On success, brk() returns zero. On error, -1 is returned, and errno is set to ENOMEM.</p>
</blockquote>
<pre><code>void *sbrk(intptr_t increment);</code></pre>
<blockquote>
<p>sbrk() increments the program’s data space by increment bytes. Calling sbrk() with an increment of 0 can be used to find the current location of the program break.</p>
</blockquote>
<blockquote>
<p>On success, sbrk() returns the previous program break. (If the break was increased, then this value is a pointer to the start of the newly allocated memory). On error, (void *) -1 is returned, and errno is set to ENOMEM.</p>
</blockquote>
<h3 id="要注意的问题"><a href="#要注意的问题" class="headerlink" title="要注意的问题"></a>要注意的问题</h3><p>1 映射文件的5000个字节实际映射到内存中的是2页(2*4k)，5000-8191之间在内存中值是0</p>
<p><img src="https://i.loli.net/2020/03/06/BfI9UHryxTQFXmR.png" alt="mmap_情形1.png"></p>
<p>2 文件5000字节，映射15000字节。实际内存中是2页(2*4k),8192-15000之间不可读(sigbus)</p>
<p><img src="https://i.loli.net/2020/03/06/3iWAh5qvKUx9jMm.png" alt="mmap_情形2.png"></p>
<p>3 文件初始大小为0，映射1000<em>4K的大小,只要访问ptr指针前，扩展文件大小n字节(n&lt;1000</em>4k),则0-n之间的空间是可以读写并更新到文件的</p>
<h2 id="free命令"><a href="#free命令" class="headerlink" title="free命令"></a>free命令</h2><pre><code>[root@localhost ~]# free
             total       used       free     shared    buffers     cached
Mem:       3869020    3439104     429916      61128        764     400284
-/+ buffers/cache:    3038056     830964
Swap:      4079612          0    4079612</code></pre>
<p>第一行的used/free就是使用和剩余的实际内存,buffers/cached是内存中缓冲磁盘文件的区域，随时可能被换掉的</p>
<p>第二行的used/free是第一行中实际使用内存减去buffers/cached后剩余的空间下的[used/free  used = 3439104 - 764 - 400284 = 3038056]<br>swap是内存中没被当前使用的部分缓冲到磁盘中，作为back log的区域，在使用的时候再加载回内存</p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/03/02/xm37EcYylXgHaUb.jpg" alt="tumblr_p48vtapTM81sfie3io1_1280.jpg"></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-文件系统</title>
    <url>/2020-04-07-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/9aa66f634ed6">硬盘基本知识（磁头、磁道、扇区、柱面）</a></p>
<a id="more"></a>


<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2>]]></content>
      <tags>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title>类对象内存布局</title>
    <url>/2020-04-07-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://coolshell.cn/articles/12176.html">C++ 对象的内存布局</a></p>
<p><a href="https://www.cnblogs.com/qg-whz/p/4909359.html">图说C++对象模型：对象内存布局详解</a></p>
<a id="more"></a>

<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2>]]></content>
      <tags>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title>null和nullptr</title>
    <url>/2020-04-10-null%E5%92%8Cnullptr/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/Xiejingfa/article/details/50478512">【C++11新特性】 nullptr关键字</a></p>
<p><a href="https://blog.csdn.net/Demorngel/article/details/74025173">invalid conversion from void* to char*</a></p>
<p><a href="https://stackoverflow.com/questions/27951344/warning-passing-null-to-non-pointer-argument-of-stdthreadthread">warning: passing NULL to non-pointer argument of ‘std::thread::thread</a></p>
<p><a href="https://zh.wikipedia.org/wiki/Nullptr">nullptr</a></p>
<a id="more"></a>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近面试遇到的一个问题，平时没怎么注意到，今天研究了下，顺便记录下来.</p>
<h2 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NULL</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined __STDC__ &amp;&amp; __STDC__</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> NULL ((void *) 0)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> NULL 0</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h2><p>nullptr是C++11语言标准用来表示空指针的常量值[1]，可以指派给任意类型的指针变量[2]。部分编译器将之视为一个关键字，例如Visual Studio[3]，部分使用旧标准的C++编译器则未实现需要自行定义[4]或引入额外的头文件[2]。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _LIBCPP_NULLPTR</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _LIBCPP_NULLPTR</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;__config&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC system_header</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LIBCPP_HAS_NO_NULLPTR</span></span><br><span class="line">_LIBCPP_BEGIN_NAMESPACE_STD</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">LIBCPP_TEMPLATE_VIS</span> <span class="title">nullptr_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span>* __lx;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">nat</span> &#123;</span><span class="keyword">int</span> __for_bool_;&#125;;</span><br><span class="line">    <span class="function">_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR <span class="title">nullptr_t</span><span class="params">()</span> : __lx(<span class="number">0</span>) &#123;</span>&#125;</span><br><span class="line">    <span class="function">_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR <span class="title">nullptr_t</span><span class="params">(<span class="keyword">int</span> __nat::*)</span> : __lx(<span class="number">0</span>) &#123;</span>&#125;</span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR <span class="keyword">operator</span> <span class="keyword">int</span> __nat::*() <span class="keyword">const</span> &#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line">        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR</span><br><span class="line">        <span class="keyword">operator</span> _Tp* () <span class="keyword">const</span> &#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Up</span>&gt;</span></span><br><span class="line">        _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">        <span class="keyword">operator</span> _Tp _Up::* () <span class="keyword">const</span> &#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">friend</span> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">nullptr_t</span>, <span class="keyword">nullptr_t</span>) &#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line">    <span class="keyword">friend</span> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">nullptr_t</span>, <span class="keyword">nullptr_t</span>) &#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR <span class="keyword">nullptr_t</span> <span class="keyword">__get_nullptr_t</span>() &#123;<span class="keyword">return</span> <span class="built_in">nullptr_t</span>(<span class="number">0</span>);&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nullptr _VSTD::__get_nullptr_t()</span></span><br><span class="line">_LIBCPP_END_NAMESPACE_STD</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  <span class="comment">// _LIBCPP_HAS_NO_NULLPTR</span></span></span><br><span class="line"><span class="keyword">namespace</span> std</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(<span class="literal">nullptr</span>)</span> <span class="keyword">nullptr_t</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// _LIBCPP_HAS_NO_NULLPTR</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// _LIBCPP_NULLPTR</span></span></span><br></pre></td></tr></table></figure>

<p>在c语言中,NULL是<code>void*</code>,在C++中NULL是0.C++ 11中使用nullptr来表示空指针.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><code>C语言</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">(<span class="keyword">void</span>* a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;void\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;int\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun3</span><span class="params">(<span class="keyword">char</span>* a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;char*\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//fun1(NULL); //void*</span></span><br><span class="line">    <span class="comment">//fun2(NULL); //expected &#x27;int&#x27; but argument is of type &#x27;void *&#x27;|</span></span><br><span class="line">    fun3(<span class="literal">NULL</span>); <span class="comment">//char*</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>C++</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">void</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;void&quot;</span> &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int&quot;</span> &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">(<span class="keyword">char</span> *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;char*&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//fun(nullptr); //void*</span></span><br><span class="line">	<span class="built_in">fun</span>(<span class="literal">NULL</span>); <span class="comment">//int</span></span><br><span class="line">	<span class="comment">//fun2(0); //char*</span></span><br><span class="line">	<span class="comment">//fun2((void*)0); //无法将参数 1 从“void *”转换为“char *”</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>nullptr是关键字，并且是个prvalue,类型是nullptr_t。nullptr_t的原理是通过operator类型转换函数配合模板来进行任意指针类型的转换：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;int*&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">char</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;char*&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">(<span class="keyword">void</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;void*&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func4</span><span class="params">(string*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;string*&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func5</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;vector&lt;int&gt;*\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">a</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">	<span class="keyword">operator</span> _Tp*()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">func1</span>(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="built_in">func2</span>(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="built_in">func3</span>(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="built_in">func4</span>(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="built_in">func5</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">	a aa;</span><br><span class="line">	<span class="built_in">func1</span>(aa);</span><br><span class="line">	<span class="built_in">func2</span>(aa);</span><br><span class="line">	<span class="built_in">func3</span>(aa);</span><br><span class="line">	<span class="built_in">func4</span>(aa);</span><br><span class="line">	<span class="built_in">func5</span>(aa);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>int*
char*
void*
string*
vector&lt;int&gt;*
int*
char*
void*
string*
vector&lt;int&gt;*</code></pre>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/04/10/OHesDat49pSCylw.jpg" alt="74432233_p0_master1200.jpg"></p>
]]></content>
      <tags>
        <tag>c++11</tag>
      </tags>
  </entry>
  <entry>
    <title>c++11右值引用</title>
    <url>/2020-04-11-c++11%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.ibm.com/developerworks/cn/aix/library/1307_lisl_c11/index.html">右值引用与转移语义</a></p>
<a id="more"></a>



<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/04/14/e2CElTM9Bo3Adnq.jpg" alt="80708698_p0_master1200.jpg"></p>
]]></content>
      <tags>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-管道和FIFO</title>
    <url>/2020-04-12-linux-%E7%AE%A1%E9%81%93%E5%92%8CFIFO/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/mrpre/article/details/78760359">pipe函数内核实现</a></p>
<p><a href="http://luodw.cc/2016/08/01/pipeof/">从内核源码聊聊pipe实现</a></p>
<p><a href="https://www.twblogs.net/a/5b8cd8642b71771883361bf6/zh-cn">linux 文件操作函数 mount-mknod-mkdir</a></p>
<a id="more"></a>


<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>在类Unix操作系统（以及一些其他借用了这个设计的操作系统，如Windows）中，管道（英语：Pipeline）是一系列将标准输入输出链接起来的进程，其中每一个进程的输出被直接作为下一个进程的输入。 每一个链接都由匿名管道实现[来源请求]。管道中的组成元素也被称作过滤程序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* On Alpha, IA-64, MIPS, SuperH, and SPARC/SPARC64; see NOTES */</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">fd_pair</span> &#123;</span></span><br><span class="line">          <span class="keyword">long</span> fd[<span class="number">2</span>];</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="function">struct fd_pair <span class="title">pipe</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* On all other architectures */</span></span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> pipefd[<span class="number">2</span>])</span></span>;</span><br><span class="line"></span><br><span class="line">      <span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE             <span class="comment">/* See feature_test_macros(7) */</span></span></span><br><span class="line">      <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span>              <span class="comment">/* Obtain O_* constant definitions */</span></span></span><br><span class="line">      <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">pipe2</span><span class="params">(<span class="keyword">int</span> pipefd[<span class="number">2</span>], <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE1(pipe, <span class="keyword">int</span> __user *, fildes)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> sys_pipe2(fildes, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sys_pipe() is the normal C calling standard for creating</span></span><br><span class="line"><span class="comment"> * a pipe. It&#x27;s not the way Unix traditionally does this, though.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE2(pipe2, <span class="keyword">int</span> __user *, fildes, <span class="keyword">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">files</span>[2];</span></span><br><span class="line">	<span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">	error = __do_pipe_flags(fd, files, flags);</span><br><span class="line">	<span class="keyword">if</span> (!error) &#123;</span><br><span class="line">		<span class="keyword">if</span> (unlikely(copy_to_user(fildes, fd, <span class="keyword">sizeof</span>(fd)))) &#123;</span><br><span class="line">			fput(files[<span class="number">0</span>]);</span><br><span class="line">			fput(files[<span class="number">1</span>]);</span><br><span class="line">			put_unused_fd(fd[<span class="number">0</span>]);</span><br><span class="line">			put_unused_fd(fd[<span class="number">1</span>]);</span><br><span class="line">			error = -EFAULT;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fd_install(fd[<span class="number">0</span>], files[<span class="number">0</span>]);</span><br><span class="line">			fd_install(fd[<span class="number">1</span>], files[<span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>pipe</strong>函数的输出型参数返回2个fd,fd[0]用于读，fd[1]用于写.通常的管道是半双工的，全双工实现的暂时不考虑。管道是没有名字的，不可用于进程间通信，除非通过其他方法传输fd,一般使用管道主要是父子进程间通信，其他无亲缘关系进程可以用<strong>FIFO有名管道</strong>通信</p>
<p><strong>单向通信</strong></p>
<p><img src="https://i.loli.net/2020/04/12/1dKspWIAJtbBEeF.png" alt="管道_单向通信.png"></p>
<p><strong>双向通信</strong></p>
<p><img src="https://i.loli.net/2020/04/12/rhXtH47YNeivKFU.png" alt="管道_双向通信.png"></p>
<h2 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h2><p>命名管道是计算机进程间的一种先进先出通信机制。是类Unix系统传统管道的扩展。传统管道属于匿名管道，其生存期不超过创建管道的进程的生存期。但命名管道的生存期可以与操作系统运行期一样长。</p>
<p>与传统的无名的shell管道不同，命名管道利用了文件系统。使用mkfifo()[1]或mknod()[2]创建命名管道。两个进程可以通过管道的名字打开、读写管道。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span>           <span class="comment">/* Definition of AT_* constants */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifoat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Create a named pipe (FIFO) named PATH with protections MODE.  */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">mkfifo (<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">dev_t</span> dev = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> __xmknod (_MKNOD_VER, path, mode | S_IFIFO, &amp;dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//system V</span></span><br><span class="line"><span class="comment">/* Create a device file named PATH, with permission and special bits MODE</span></span><br><span class="line"><span class="comment">   and device number DEV (which can be constructed from major and minor</span></span><br><span class="line"><span class="comment">   device numbers with the `makedev&#x27; macro above).  */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">__xmknod (<span class="keyword">int</span> vers, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode, <span class="keyword">dev_t</span> *dev)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> k_dev;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (vers != _MKNOD_VER)</span><br><span class="line">    &#123;</span><br><span class="line">      __set_errno (EINVAL);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We must convert the value to dev_t type used by the kernel.  */</span></span><br><span class="line">  k_dev =  (*dev) &amp; ((<span class="number">1ULL</span> &lt;&lt; <span class="number">32</span>) - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (k_dev != *dev)</span><br><span class="line">    &#123;</span><br><span class="line">      __set_errno (EINVAL);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> INLINE_SYSCALL (mknod, <span class="number">3</span>, CHECK_STRING (path), mode,</span><br><span class="line">			 (<span class="keyword">unsigned</span> <span class="keyword">int</span>) k_dev);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/12/VIqEADSBi9wtNX6.png" alt="fifo.png"></p>
<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><ul>
<li>OPEN_MAX 进程打开描述符限制</li>
<li>PIPE_BUF 可原子的写往一个管道或FIFO的最大数据量</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PATH_MAX        4096	<span class="comment">/* # chars in a path name including nul */</span></span></span><br></pre></td></tr></table></figure>

<pre><code>[root@localhost /]# getconf OPEN_MAX
20000
[root@localhost /]# getconf PIPE_BUF /
4096</code></pre>
<p><img src="https://i.loli.net/2020/04/12/5hXeGym2bHD3Nda.png" alt="管道阻塞和返回值.png"></p>
<h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><p>TODO</p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/04/12/cgoCHtbKD4jGRS7.jpg" alt="76523900_p0_master1200.jpg"></p>
]]></content>
      <tags>
        <tag>ipc</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-消息队列</title>
    <url>/2020-04-13-linux-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="">unp</a></p>
<p><a href="https://dulishu.top/posix-mq_send/">进程间通信之POSIX消息队列</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">wikipedia</a></p>
<a id="more"></a>

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在计算机科学中，消息队列（英语：Message queue）是一种进程间通信或同一进程的不同线程间的通信方式，软件的贮列用来处理一系列的输入，通常是来自用户。消息队列提供了异步的通信协议，每一个贮列中的纪录包含详细说明的数据，包含发生的时间，输入设备的种类，以及特定的输入参数，也就是说：消息的发送者和接收者不需要同时与消息队列交互。消息会保存在队列中，直到接收者取回它。[1]</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>实际上，消息队列常常保存在链表结构中。[2]拥有权限的进程可以向消息队列中写入或读取消息。</p>
<p>当前，有很多消息队列有很多开源的实现，包括JBoss Messaging、JORAM、Apache ActiveMQ、Sun Open Message Queue、RabbitMQ[3]、IBM MQ[4]、Apache Qpid[5]、Apache RocketMQ[6]和HTTPSQS。[7]</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>消息队列本身是异步的，它允许接收者在消息发送很长时间后再取回消息，这和大多数通信协议是不同的。例如WWW中使用的HTTP协议（HTTP/2之前）是同步的，因为客户端在发出请求后必须等待服务器回应。然而，很多情况下我们需要异步的通信协议。比如，一个进程通知另一个进程发生了一个事件，但不需要等待回应。但消息队列的异步特点，也造成了一个缺点，就是接收者必须轮询消息队列，才能收到最近的消息。</p>
<p>和信号相比，消息队列能够传递更多的信息。与管道相比，消息队列提供了有格式的数据，这可以减少开发人员的工作量。[2]但消息队列仍然有大小限制。</p>
<p>消息队列除了可以当不同线程或进程间的缓冲外，更可以透过消息队列当前消息数量来侦测接收线程或进程性能是否有问题。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">mqd_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mq_attr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> mq_flags;	<span class="comment">/* Message queue flags.  */</span></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> mq_maxmsg;	<span class="comment">/* Maximum number of messages.  */</span></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> mq_msgsize;	<span class="comment">/* Maximum message size.  */</span></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> mq_curmsgs;	<span class="comment">/* Number of messages currently queued.  */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="mq-open"><a href="#mq-open" class="headerlink" title="mq_open"></a>mq_open</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Establish connection between a process and a message queue NAME and</span></span><br><span class="line"><span class="comment">   return message queue descriptor or (mqd_t) -1 on error.  OFLAG determines</span></span><br><span class="line"><span class="comment">   the type of access used.  If O_CREAT is on OFLAG, the third argument is</span></span><br><span class="line"><span class="comment">   taken as a `mode_t&#x27;, the mode of the created message queue, and the fourth</span></span><br><span class="line"><span class="comment">   argument is taken as `struct mq_attr *&#x27;, pointer to message queue</span></span><br><span class="line"><span class="comment">   attributes.  If the fourth argument is NULL, default attributes are</span></span><br><span class="line"><span class="comment">   used.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">mqd_t</span> <span class="title">mq_open</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *__name, <span class="keyword">int</span> __oflag, ...)</span></span></span><br><span class="line"><span class="function">  __THROW __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="mq-close"><a href="#mq-close" class="headerlink" title="mq_close"></a>mq_close</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Removes the association between message queue descriptor MQDES and its</span></span><br><span class="line"><span class="comment">   message queue.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">mq_close</span> <span class="params">(<span class="keyword">mqd_t</span> __mqdes)</span> __THROW</span>;</span><br></pre></td></tr></table></figure>

<h3 id="mq-getattr"><a href="#mq-getattr" class="headerlink" title="mq_getattr"></a>mq_getattr</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Query status and attributes of message queue MQDES.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">mq_getattr</span> <span class="params">(<span class="keyword">mqd_t</span> __mqdes, struct mq_attr *__mqstat)</span></span></span><br><span class="line"><span class="function">  __THROW __<span class="title">nonnull</span> <span class="params">((<span class="number">2</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="mq-setattr"><a href="#mq-setattr" class="headerlink" title="mq_setattr"></a>mq_setattr</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Set attributes associated with message queue MQDES and if OMQSTAT is</span></span><br><span class="line"><span class="comment">   not NULL also query its old attributes.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">mq_setattr</span> <span class="params">(<span class="keyword">mqd_t</span> __mqdes,</span></span></span><br><span class="line"><span class="function"><span class="params">		       <span class="keyword">const</span> struct mq_attr *__restrict __mqstat,</span></span></span><br><span class="line"><span class="function"><span class="params">		       struct mq_attr *__restrict __omqstat)</span></span></span><br><span class="line"><span class="function">  __THROW __<span class="title">nonnull</span> <span class="params">((<span class="number">2</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="mq-unlink"><a href="#mq-unlink" class="headerlink" title="mq_unlink"></a>mq_unlink</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Remove message queue named NAME.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">mq_unlink</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *__name)</span> __THROW __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="mq-notify"><a href="#mq-notify" class="headerlink" title="mq_notify"></a>mq_notify</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Register notification issued upon message arrival to an empty</span></span><br><span class="line"><span class="comment">   message queue MQDES.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">mq_notify</span> <span class="params">(<span class="keyword">mqd_t</span> __mqdes, <span class="keyword">const</span> struct sigevent *__notification)</span></span></span><br><span class="line"><span class="function">     __THROW</span>;</span><br></pre></td></tr></table></figure>

<h3 id="mq-receive"><a href="#mq-receive" class="headerlink" title="mq_receive"></a>mq_receive</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Receive the oldest from highest priority messages in message queue</span></span><br><span class="line"><span class="comment">   MQDES.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">ssize_t</span> <span class="title">mq_receive</span> <span class="params">(<span class="keyword">mqd_t</span> __mqdes, <span class="keyword">char</span> *__msg_ptr, <span class="keyword">size_t</span> __msg_len,</span></span></span><br><span class="line"><span class="function"><span class="params">			   <span class="keyword">unsigned</span> <span class="keyword">int</span> *__msg_prio)</span> __<span class="title">nonnull</span> <span class="params">((<span class="number">2</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="mq-send"><a href="#mq-send" class="headerlink" title="mq_send"></a>mq_send</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Add message pointed by MSG_PTR to message queue MQDES.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">mq_send</span> <span class="params">(<span class="keyword">mqd_t</span> __mqdes, <span class="keyword">const</span> <span class="keyword">char</span> *__msg_ptr, <span class="keyword">size_t</span> __msg_len,</span></span></span><br><span class="line"><span class="function"><span class="params">		    <span class="keyword">unsigned</span> <span class="keyword">int</span> __msg_prio)</span> __<span class="title">nonnull</span> <span class="params">((<span class="number">2</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="mq-timedreceive"><a href="#mq-timedreceive" class="headerlink" title="mq_timedreceive"></a>mq_timedreceive</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __USE_XOPEN2K</span></span><br><span class="line"><span class="comment">/* Receive the oldest from highest priority messages in message queue</span></span><br><span class="line"><span class="comment">   MQDES, stop waiting if ABS_TIMEOUT expires.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">ssize_t</span> <span class="title">mq_timedreceive</span> <span class="params">(<span class="keyword">mqd_t</span> __mqdes, <span class="keyword">char</span> *__restrict __msg_ptr,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">size_t</span> __msg_len,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">unsigned</span> <span class="keyword">int</span> *__restrict __msg_prio,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">const</span> struct timespec *__restrict __abs_timeout)</span></span></span><br><span class="line"><span class="function">  __<span class="title">nonnull</span> <span class="params">((<span class="number">2</span>, <span class="number">5</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="mq-timedsend"><a href="#mq-timedsend" class="headerlink" title="mq_timedsend"></a>mq_timedsend</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Add message pointed by MSG_PTR to message queue MQDES, stop blocking</span></span><br><span class="line"><span class="comment">   on full message queue if ABS_TIMEOUT expires.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">mq_timedsend</span> <span class="params">(<span class="keyword">mqd_t</span> __mqdes, <span class="keyword">const</span> <span class="keyword">char</span> *__msg_ptr,</span></span></span><br><span class="line"><span class="function"><span class="params">			 <span class="keyword">size_t</span> __msg_len, <span class="keyword">unsigned</span> <span class="keyword">int</span> __msg_prio,</span></span></span><br><span class="line"><span class="function"><span class="params">			 <span class="keyword">const</span> struct timespec *__abs_timeout)</span></span></span><br><span class="line"><span class="function">  __<span class="title">nonnull</span> <span class="params">((<span class="number">2</span>, <span class="number">5</span>))</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h2><h3 id="send-cpp"><a href="#send-cpp" class="headerlink" title="send.cpp"></a>send.cpp</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">mqd_t</span> mq = <span class="built_in">mq_open</span>(<span class="string">&quot;/mymq&quot;</span>, O_RDWR | O_CREAT, <span class="number">0644</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (mq &lt; <span class="number">0</span>)</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;open err!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">time_t</span> tt;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">time</span>(&amp;tt);</span><br><span class="line">        	<span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">ptm</span> =</span> <span class="literal">nullptr</span>;</span><br><span class="line">	        ptm = <span class="built_in">localtime</span>(&amp;tt);</span><br><span class="line">        </span><br><span class="line">        	<span class="built_in">strftime</span>(buf, <span class="built_in"><span class="keyword">sizeof</span></span>(buf), <span class="string">&quot;%Y %m %d %H %M %S&quot;</span>, ptm);</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">	        <span class="built_in">mq_send</span>(mq, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mq_close</span>(mq);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="recv-cpp"><a href="#recv-cpp" class="headerlink" title="recv.cpp"></a>recv.cpp</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">mqd_t</span> mq = <span class="built_in">mq_open</span>(<span class="string">&quot;/mymq&quot;</span>, O_RDWR | O_CREAT, <span class="number">0644</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (mq &lt; <span class="number">0</span>)</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;open err!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	mq_attr attr = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">ssize_t</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">mq_getattr</span>(mq, &amp;attr);</span><br><span class="line">	len = attr.mq_msgsize;	</span><br><span class="line">	<span class="keyword">char</span> *psz = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(len);</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	        <span class="keyword">if</span> (<span class="number">0</span> &gt; <span class="built_in">mq_receive</span>(mq, psz, len, <span class="literal">NULL</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;recv err!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="comment">//free not use, just test</span></span><br><span class="line">			<span class="built_in">free</span>(psz);</span><br><span class="line">			psz = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; psz &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(psz);</span><br><span class="line">	psz = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">mq_close</span>(mq);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="OUTPUT"><a href="#OUTPUT" class="headerlink" title="OUTPUT"></a>OUTPUT</h3><pre><code>  [root@localhost mq]# ./send 
  2020 04 14 23 03 23
  2020 04 14 23 03 24
  2020 04 14 23 03 25
  2020 04 14 23 03 26
  2020 04 14 23 03 27
  2020 04 14 23 03 28
  2020 04 14 23 03 29
  2020 04 14 23 03 30
  2020 04 14 23 03 31
  2020 04 14 23 03 32
  2020 04 14 23 03 33
  2020 04 14 23 03 34
  2020 04 14 23 03 35
  2020 04 14 23 03 36
  2020 04 14 23 03 37
  2020 04 14 23 03 38
  2020 04 14 23 03 39
  2020 04 14 23 03 40
  2020 04 14 23 03 41
  2020 04 14 23 03 42

  [root@localhost mq]# ./recv 
  2020 04 14 23 03 23
  2020 04 14 23 03 24
  2020 04 14 23 03 25
  2020 04 14 23 03 26
  2020 04 14 23 03 27
  2020 04 14 23 03 28
  2020 04 14 23 03 29
  2020 04 14 23 03 30
  2020 04 14 23 03 31
  2020 04 14 23 03 32
  2020 04 14 23 03 33
  2020 04 14 23 03 34
  2020 04 14 23 03 35
  2020 04 14 23 03 36
  2020 04 14 23 03 37
  2020 04 14 23 03 38
  2020 04 14 23 03 39
  2020 04 14 23 03 40
  2020 04 14 23 03 41
  2020 04 14 23 03 42
  ^C</code></pre>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/04/13/SqDy26sdgXh7eoY.jpg" alt="71944339_p0_master1200.jpg"></p>
]]></content>
      <tags>
        <tag>ipc</tag>
      </tags>
  </entry>
  <entry>
    <title>singleton模式</title>
    <url>/2020-04-17-singleton%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<table>
    <thead align="center">
        <tr>
            <th style="text-align:center">题目</th>
            <th style="text-align:center">来源</th>
            <th style="text-align:center">完成时间</th>
        </tr>
    </thead>
    <tbody align="center">
        <tr>
            <td>实现singleton模式</td>
            <td>剑指offer</td>
            <td>20200418</td>
        </tr>
    </tbody>
</table>

<a id="more"></a>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhihu.com/question/267013757">C++函数内的静态变量初始化以及线程安全问题</a></p>
<p><a href="https://segmentfault.com/a/1190000015950693">设计模式之单例模式</a></p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>单例模式，也叫单子模式，是一种常用的软件设计模式，属于创建型模式的一种。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。</p>
<h2 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h2><p><strong>懒汉模式</strong>：指全局的单例实例在第一次被使用时构建。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">std::mutex g_mutex;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">singleton</span>()&#123;&#125;</span><br><span class="line">	~<span class="built_in">singleton</span>()&#123;&#125;</span><br><span class="line">	<span class="built_in">singleton</span>(<span class="keyword">const</span> singleton&amp; single)&#123;&#125;</span><br><span class="line">	<span class="keyword">const</span> singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> singleton&amp; single)&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> singleton* m_Instance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> singleton* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="comment">//加锁与指针判空</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(g_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == m_Instance)</span><br><span class="line">        &#123;</span><br><span class="line">            m_Instance = <span class="keyword">new</span> <span class="built_in">singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> m_Instance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	    cout &lt;&lt; <span class="string">&quot;m_Instance:&quot;</span> &lt;&lt; m_Instance &lt;&lt;  endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">singleton* singleton::m_Instance = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">singleton2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">singleton2</span>()&#123;&#125;</span><br><span class="line">	~<span class="built_in">singleton2</span>()&#123;&#125;</span><br><span class="line">	<span class="built_in">singleton2</span>(<span class="keyword">const</span> singleton2&amp; single)&#123;&#125;</span><br><span class="line">	<span class="keyword">const</span> singleton2&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> singleton2&amp; single)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> singleton2* <span class="built_in">GetInstance</span>()</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//静态局部变量</span></span><br><span class="line">        <span class="keyword">static</span> singleton2 m_Instance;</span><br><span class="line">		<span class="keyword">return</span> &amp;m_Instance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	    cout &lt;&lt; <span class="string">&quot;m_Instance:&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt;  endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    singleton::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">print</span>();</span><br><span class="line">	singleton::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">print</span>();</span><br><span class="line">	singleton::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">print</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h2><p><strong>饿汉方式</strong>：指全局的单例实例在类装载时构建。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">singleton</span>() &#123;&#125;</span><br><span class="line">	~<span class="built_in">singleton</span>() &#123;&#125;</span><br><span class="line">	<span class="built_in">singleton</span>(<span class="keyword">const</span> singleton&amp; single) &#123;&#125;</span><br><span class="line">	<span class="keyword">const</span> singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> singleton&amp; single) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> singleton* m_Instance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> singleton* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Instance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;m_Instance:&quot;</span> &lt;&lt; m_Instance &lt;&lt;  endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">singleton* singleton::m_Instance = <span class="keyword">new</span> singleton;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	singleton::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">print</span>();</span><br><span class="line">	singleton::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">print</span>();</span><br><span class="line">	singleton::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">print</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>懒汉模式是在类被第一次使用时构建，时间上比较慢</li>
<li>饿汉模式是在类被装载时构建，时间上较快</li>
<li>懒汉模式下，先判空再上锁，是不安全的</li>
<li>静态局部变量只被初始化一次，并且是线程安全的，但是在c++11以后才这样</li>
</ul>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/04/04/GsgODjWZ79Tfn1x.jpg" alt="79633467_p0_master1200.jpg"></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>snprintf返回值</title>
    <url>/2020-04-20-snprintf%E8%BF%94%E5%9B%9E%E5%80%BC/</url>
    <content><![CDATA[<table>
    <thead align="center">
        <tr>
            <th style="text-align:center">标题</th>
            <th style="text-align:center">来源</th>
            <th style="text-align:center">完成时间</th>
            <th style="text-align:center">作者</th>
        </tr>
    </thead>
    <tbody align="center">
        <tr>
            <td>snprintf返回值</td>
            <td>崩溃问题定位</td>
            <td>20200420</td>
            <td>TheRiver</td>
        </tr>
    </tbody>
</table>

<a id="more"></a>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天调试程序崩溃了几次，后来定位是snprintf函数使用不恰当导致。这里把问题原因复现出来记录下</p>
<h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ps = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">8000</span>);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">8191</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">8191</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        buf[i]  = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">snprintf</span>(ps, <span class="number">8191</span>, <span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">free</span>(ps);</span><br><span class="line">    ps = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<pre><code>[root@localhost ~]# ./a.out 
8191
*** Error in `./a.out&#39;: free(): invalid next size (normal): 0x000000000247c010 ***
======= Backtrace: =========
/lib64/libc.so.6(+0x7d1fd)[0x7f49881dd1fd]
./a.out[0x4009d9]
/lib64/libc.so.6(__libc_start_main+0xf5)[0x7f4988181af5]
./a.out[0x400859]
======= Memory map: ========
00400000-00401000 r-xp 00000000 fd:01 148715783                          /root/a.out
00600000-00601000 r--p 00000000 fd:01 148715783                          /root/a.out
00601000-00602000 rw-p 00001000 fd:01 148715783                          /root/a.out
0247c000-0249e000 rw-p 00000000 00:00 0                                  [heap]
7f4988160000-7f4988316000 r-xp 00000000 fd:01 134383134                  /usr/lib64/libc-2.17.so
7f4988316000-7f4988516000 ---p 001b6000 fd:01 134383134                  /usr/lib64/libc-2.17.so
7f4988516000-7f498851a000 r--p 001b6000 fd:01 134383134                  /usr/lib64/libc-2.17.so
7f498851a000-7f498851c000 rw-p 001ba000 fd:01 134383134                  /usr/lib64/libc-2.17.so
7f498851c000-7f4988521000 rw-p 00000000 00:00 0 
7f4988521000-7f4988536000 r-xp 00000000 fd:01 146951362                  /usr/lib64/libgcc_s-4.8.5-20150702.so.1
7f4988536000-7f4988735000 ---p 00015000 fd:01 146951362                  /usr/lib64/libgcc_s-4.8.5-20150702.so.1
7f4988735000-7f4988736000 r--p 00014000 fd:01 146951362                  /usr/lib64/libgcc_s-4.8.5-20150702.so.1
7f4988736000-7f4988737000 rw-p 00015000 fd:01 146951362                  /usr/lib64/libgcc_s-4.8.5-20150702.so.1
7f4988737000-7f4988838000 r-xp 00000000 fd:01 134460818                  /usr/lib64/libm-2.17.so
7f4988838000-7f4988a37000 ---p 00101000 fd:01 134460818                  /usr/lib64/libm-2.17.so
7f4988a37000-7f4988a38000 r--p 00100000 fd:01 134460818                  /usr/lib64/libm-2.17.so
7f4988a38000-7f4988a39000 rw-p 00101000 fd:01 134460818                  /usr/lib64/libm-2.17.so
7f4988a39000-7f4988b22000 r-xp 00000000 fd:01 134383159                  /usr/lib64/libstdc++.so.6.0.19
7f4988b22000-7f4988d21000 ---p 000e9000 fd:01 134383159                  /usr/lib64/libstdc++.so.6.0.19
7f4988d21000-7f4988d29000 r--p 000e8000 fd:01 134383159                  /usr/lib64/libstdc++.so.6.0.19
7f4988d29000-7f4988d2b000 rw-p 000f0000 fd:01 134383159                  /usr/lib64/libstdc++.so.6.0.19
7f4988d2b000-7f4988d40000 rw-p 00000000 00:00 0 
7f4988d40000-7f4988d61000 r-xp 00000000 fd:01 134384031                  /usr/lib64/ld-2.17.so
7f4988f47000-7f4988f4c000 rw-p 00000000 00:00 0 
7f4988f5e000-7f4988f61000 rw-p 00000000 00:00 0 
7f4988f61000-7f4988f62000 r--p 00021000 fd:01 134384031                  /usr/lib64/ld-2.17.so
7f4988f62000-7f4988f63000 rw-p 00022000 fd:01 134384031                  /usr/lib64/ld-2.17.so
7f4988f63000-7f4988f64000 rw-p 00000000 00:00 0 
7fff53ec2000-7fff53ee3000 rw-p 00000000 00:00 0                          [stack]
7fff53ffe000-7fff54000000 r-xp 00000000 00:00 0                          [vdso]
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]
已放弃</code></pre>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__snprintf (<span class="keyword">char</span> *s, <span class="keyword">size_t</span> maxlen, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span><br><span class="line">&#123;</span><br><span class="line">  va_list arg;</span><br><span class="line">  <span class="keyword">int</span> done;</span><br><span class="line">  va_start (arg, format);</span><br><span class="line">  done = __vsnprintf_internal (s, maxlen, format, arg, <span class="number">0</span>);</span><br><span class="line">  va_end (arg);</span><br><span class="line">  <span class="keyword">return</span> done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>snprintf的返回值是写入的大小，如果长度参数超过缓冲区大小也会继续写入，不过缓冲区末尾最后的字符会被snprintf填入结束符，所以strlen看到字符串大小还是缓冲区的大小，但如果是malloc的缓冲区，free的时候就可能出问题。 <br><br>今天遇到的崩溃问题，最后的根因是消息体的起始位置算错了导致了，传给snprintf的长度参数倒是没问题，但总的写完还是越界了。并不能说这个问题的原因是snprintf,但是既然看到这里了，也可以关注下返回值的具体含义。snprintf的源码不好跟，就不费功夫了。</p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/04/20/Este1ublhpz8ALW.jpg" alt="77240705_p0_lit.jpg"></p>
]]></content>
      <tags>
        <tag>dump</tag>
      </tags>
  </entry>
  <entry>
    <title>list的splice与size</title>
    <url>/2020-04-21-list%E7%9A%84splice%E4%B8%8Esize/</url>
    <content><![CDATA[<table>
    <thead align="center">
        <tr>
            <th style="text-align:center">标题</th>
            <th style="text-align:center">来源</th>
            <th style="text-align:center">完成时间</th>
            <th style="text-align:center">作者</th>
            <th style="text-align:center">环境</th>
        </tr>
    </thead>
    <tbody align="center">
        <tr>
            <td>stl的splice与size</td>
            <td>工作接触</td>
            <td>20200421</td>
            <td>TheRiver</td>
            <td>gcc-4.8.8</td>
        </tr>
    </tbody>
</table>

<a id="more"></a>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/russell_tao/article/details/8572000">坑爹的list容器size方法–为了splice居然把复杂度设计为O(N)</a></p>
<p><a href="https://www.geeksforgeeks.org/list-splice-function-in-c-stl/">list splice() function in C++ STL</a></p>
<p><a href="http://www.cplusplus.com/reference/list/list/size/">cplusplus</a></p>
<p><a href="https://gcc.gnu.org/onlinedocs/gcc-4.6.2/libstdc++/api/a01053_source.html">https://gcc.gnu.org/</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>工作之前有看过其他人提到size函数放到for循环中对性能的影响，只是有这个印象，实际原因并不清楚。今天看splice函数的时候网上看到跟此有关，作此记录</p>
<h2 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h2><p>The list::splice() is a built-in function in C++ STL which is used to transfer elements from one list to another. The splice() function can be used in three ways:</p>
<p>1.Transfer all the elements of list x into another list at some position. <br><br>2.Transfer only the element pointed by i from list x into the list at some position. <br><br>3.Transfers the range [first, last) from list x into another list at some position. <br></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">list1_name.splice (iterator position, list2)</span><br><span class="line">                </span><br><span class="line">list1_name.splice (iterator position, list2, iterator i)</span><br><span class="line">                </span><br><span class="line">list1_name.splice (iterator position, list2, iterator first, iterator last)</span><br></pre></td></tr></table></figure>

<p><strong>c++98</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">entire <span class="title">list</span> <span class="params">(<span class="number">1</span>)</span>	</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splice</span> <span class="params">(iterator position, <span class="built_in">list</span>&amp; x)</span></span>;</span><br><span class="line"><span class="function">single <span class="title">element</span> <span class="params">(<span class="number">2</span>)</span>	</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splice</span> <span class="params">(iterator position, <span class="built_in">list</span>&amp; x, iterator i)</span></span>;</span><br><span class="line"><span class="function">element <span class="title">range</span> <span class="params">(<span class="number">3</span>)</span>	</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splice</span> <span class="params">(iterator position, <span class="built_in">list</span>&amp; x, iterator first, iterator last)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>c++11</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">entire <span class="title">list</span> <span class="params">(<span class="number">1</span>)</span>	</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splice</span> <span class="params">(const_iterator position, <span class="built_in">list</span>&amp; x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splice</span> <span class="params">(const_iterator position, <span class="built_in">list</span>&amp;&amp; x)</span></span>;</span><br><span class="line"><span class="function">single <span class="title">element</span> <span class="params">(<span class="number">2</span>)</span>	</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splice</span> <span class="params">(const_iterator position, <span class="built_in">list</span>&amp; x, const_iterator i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splice</span> <span class="params">(const_iterator position, <span class="built_in">list</span>&amp;&amp; x, const_iterator i)</span></span>;</span><br><span class="line"><span class="function">element <span class="title">range</span> <span class="params">(<span class="number">3</span>)</span>	</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splice</span> <span class="params">(const_iterator position, <span class="built_in">list</span>&amp; x,</span></span></span><br><span class="line"><span class="function"><span class="params">             const_iterator first, const_iterator last)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splice</span> <span class="params">(const_iterator position, <span class="built_in">list</span>&amp;&amp; x,</span></span></span><br><span class="line"><span class="function"><span class="params">             const_iterator first, const_iterator last)</span></span>;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>2个参数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">void</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">      splice(iterator __position, <span class="built_in">list</span>&amp;&amp; __x)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      splice(iterator __position, <span class="built_in">list</span>&amp; __x)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      &#123;</span><br><span class="line">	_GLIBCXX_DEBUG_VERIFY(&amp;__x != <span class="keyword">this</span>,</span><br><span class="line">			      _M_message(__gnu_debug::__msg_self_splice)</span><br><span class="line">			      ._M_sequence(*<span class="keyword">this</span>, <span class="string">&quot;this&quot;</span>));</span><br><span class="line">	<span class="keyword">this</span>-&gt;_M_transfer_from_if(__x, _Not_equal(__x._M_base().end()));</span><br><span class="line">	_Base::splice(__position.base(), _GLIBCXX_MOVE(__x._M_base()));</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p><strong>demo</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; list1;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; list2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        list1.push_back(i);</span><br><span class="line">        list2.push_front(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    list1.splice(list1.end(), list2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = list1.begin();</span><br><span class="line">    <span class="keyword">for</span> (; it != list1.end(); it++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>0 1 2 3 4 5 6 7 8 9 9 8 7 6 5 4 3 2 1 0

Process returned 0 (0x0)   execution time : 0.013 s
Press any key to continue.</code></pre>
<hr>
<p><strong>3个参数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">     <span class="keyword">void</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">      splice(iterator __position, <span class="built_in">list</span>&amp;&amp; __x, iterator __i)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      splice(iterator __position, <span class="built_in">list</span>&amp; __x, iterator __i)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      &#123;</span><br><span class="line">	__glibcxx_check_insert(__position);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We used to perform the splice_alloc check:  not anymore, redundant</span></span><br><span class="line">	<span class="comment">// after implementing the relevant bits of N1599.</span></span><br><span class="line"></span><br><span class="line">	_GLIBCXX_DEBUG_VERIFY(__i._M_dereferenceable(),</span><br><span class="line">			      _M_message(__gnu_debug::__msg_splice_bad)</span><br><span class="line">			      ._M_iterator(__i, <span class="string">&quot;__i&quot;</span>));</span><br><span class="line">	_GLIBCXX_DEBUG_VERIFY(__i._M_attached_to(&amp;__x),</span><br><span class="line">			      _M_message(__gnu_debug::__msg_splice_other)</span><br><span class="line">			     ._M_iterator(__i, <span class="string">&quot;__i&quot;</span>)._M_sequence(__x, <span class="string">&quot;__x&quot;</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// _GLIBCXX_RESOLVE_LIB_DEFECTS</span></span><br><span class="line">	<span class="comment">// 250. splicing invalidates iterators</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;_M_transfer_from_if(__x, _Equal(__i.base()));</span><br><span class="line">	_Base::splice(__position.base(), _GLIBCXX_MOVE(__x._M_base()),</span><br><span class="line">		      __i.base());</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p><strong>demo</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; list1;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; list2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        list1.push_back(i);</span><br><span class="line">        list2.push_front(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    list1.splice(list1.end(), list2, list2.begin());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = list1.begin();</span><br><span class="line">    <span class="keyword">for</span> (; it != list1.end(); it++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>0 1 2 3 4 5 6 7 8 9 9

Process returned 0 (0x0)   execution time : 0.065 s
Press any key to continue.</code></pre>
<p><strong>4个参数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">      splice(iterator __position, <span class="built_in">list</span>&amp;&amp; __x, iterator __first,</span><br><span class="line">	     iterator __last)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      splice(iterator __position, <span class="built_in">list</span>&amp; __x, iterator __first,</span><br><span class="line">	     iterator __last)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      &#123;</span><br><span class="line">	__glibcxx_check_insert(__position);</span><br><span class="line">	__glibcxx_check_valid_range(__first, __last);</span><br><span class="line">	_GLIBCXX_DEBUG_VERIFY(__first._M_attached_to(&amp;__x),</span><br><span class="line">			      _M_message(__gnu_debug::__msg_splice_other)</span><br><span class="line">			      ._M_sequence(__x, <span class="string">&quot;x&quot;</span>)</span><br><span class="line">			      ._M_iterator(__first, <span class="string">&quot;first&quot;</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We used to perform the splice_alloc check:  not anymore, redundant</span></span><br><span class="line">	<span class="comment">// after implementing the relevant bits of N1599.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (_Base_iterator __tmp = __first.base();</span><br><span class="line">	     __tmp != __last.base(); ++__tmp)</span><br><span class="line">	  &#123;</span><br><span class="line">	    _GLIBCXX_DEBUG_VERIFY(__tmp != _Base::end(),</span><br><span class="line">				  _M_message(__gnu_debug::__msg_valid_range)</span><br><span class="line">				  ._M_iterator(__first, <span class="string">&quot;first&quot;</span>)</span><br><span class="line">				  ._M_iterator(__last, <span class="string">&quot;last&quot;</span>));</span><br><span class="line">	    _GLIBCXX_DEBUG_VERIFY(&amp;__x != <span class="keyword">this</span> || __tmp != __position,</span><br><span class="line">				_M_message(__gnu_debug::__msg_splice_overlap)</span><br><span class="line">				  ._M_iterator(__tmp, <span class="string">&quot;position&quot;</span>)</span><br><span class="line">				  ._M_iterator(__first, <span class="string">&quot;first&quot;</span>)</span><br><span class="line">				  ._M_iterator(__last, <span class="string">&quot;last&quot;</span>));</span><br><span class="line">	    <span class="comment">// _GLIBCXX_RESOLVE_LIB_DEFECTS</span></span><br><span class="line">	    <span class="comment">// 250. splicing invalidates iterators</span></span><br><span class="line">	    <span class="keyword">this</span>-&gt;_M_transfer_from_if(__x, _Equal(__tmp));</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	_Base::splice(__position.base(), _GLIBCXX_MOVE(__x._M_base()),</span><br><span class="line">		      __first.base(), __last.base());</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p><strong>demo</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; list1;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; list2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        list1.push_back(i);</span><br><span class="line">        list2.push_front(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    list1.splice(list1.end(), list2, ++list2.begin(), --list2.end());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = list1.begin();</span><br><span class="line">    <span class="keyword">for</span> (; it != list1.end(); it++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>0 1 2 3 4 5 6 7 8 9 8 7 6 5 4 3 2 1

Process returned 0 (0x0)   execution time : 0.067 s
Press any key to continue.</code></pre>
<h2 id="size"><a href="#size" class="headerlink" title="size"></a>size</h2><p><strong>c++98</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>c++11</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  Returns the number of elements in the %list.  */</span></span><br><span class="line">      size_type</span><br><span class="line">      <span class="built_in">size</span>() <span class="keyword">const</span> _GLIBCXX_NOEXCEPT</span><br><span class="line">      &#123; <span class="keyword">return</span> std::<span class="built_in">distance</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>()); &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">distance</span>(_InputIterator __first, _InputIterator __last)     &#123;</span><br><span class="line">	<span class="keyword">return</span> std::__distance(__first, __last,         std::__iterator_category(__first));</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std _GLIBCXX_VISIBILITY(<span class="keyword">default</span>)</span><br><span class="line">&#123;</span><br><span class="line">_GLIBCXX_BEGIN_NAMESPACE_VERSION</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _InputIterator&gt;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;_InputIterator&gt;::difference_type</span><br><span class="line">    __distance(_InputIterator __first, _InputIterator __last,</span><br><span class="line">               input_iterator_tag)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// concept requirements</span></span><br><span class="line">      __glibcxx_function_requires(_InputIteratorConcept&lt;_InputIterator&gt;)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">typename</span> iterator_traits&lt;_InputIterator&gt;::difference_type __n = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (__first != __last)</span><br><span class="line">	&#123;</span><br><span class="line">	  ++__first;</span><br><span class="line">	  ++__n;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">return</span> __n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _RandomAccessIterator&gt;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIterator&gt;::difference_type</span><br><span class="line">    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,</span><br><span class="line">               random_access_iterator_tag)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// concept requirements</span></span><br><span class="line">      __glibcxx_function_requires(_RandomAccessIteratorConcept&lt;</span><br><span class="line">				  _RandomAccessIterator&gt;)</span><br><span class="line">      <span class="keyword">return</span> __last - __first;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">&#125;            </span><br></pre></td></tr></table></figure>

<p>当__distance的参数是iterator类型时，是通过遍历所有元素，统计个数的。这样写的原因见<a href="https://blog.csdn.net/russell_tao/article/details/8572000">坑爹的list容器size方法–为了splice居然把复杂度设计为O(N)</a>,貌似是为了考虑到splice函数而故意为之。splice是剪切的作用，会对size大小有影响，如果size是遍历而不是取成员变量的值,那么splice的时候就不用遍历修改大小了，各有利弊吧。</p>
<hr>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/04/21/MEX4xbmrqLiAKIP.jpg" alt="73375807_p0_master1200.jpg"></p>
]]></content>
      <tags>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title>nagle算法和延迟确认</title>
    <url>/2020-04-22-nagle%E7%AE%97%E6%B3%95%E5%92%8C%E5%BB%B6%E8%BF%9F%E7%A1%AE%E8%AE%A4/</url>
    <content><![CDATA[<table>
    <thead align="center">
        <tr>
            <th style="text-align:center">标题</th>
            <th style="text-align:center">来源</th>
            <th style="text-align:center">完成时间</th>
            <th style="text-align:center">作者</th>
            <th style="text-align:center">环境</th>
        </tr>
    </thead>
    <tbody align="center">
        <tr>
            <td>nagle算法和延迟确认</td>
            <td>书籍</td>
            <td>20200422</td>
            <td>TheRiver</td>
            <td>kernel-3.10.1</td>
        </tr>
    </tbody>
</table>

<a id="more"></a>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/wdscq1234/article/details/52432095">TCP-IP详解：Nagle算法</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1004356">Linux下TCP延迟确认(Delayed Ack)机制导致的时延问题分析</a></p>
<p><a href="https://kb.vmware.com/s/article/1002598?lang=zh_CN&queryTerm=1002598">ESX/ESXi 主机的某些存储阵列可能存在读取或写入性能问题 (1002598)</a></p>
<p><a href="">tcp/ip</a></p>
<h2 id="延时确认"><a href="#延时确认" class="headerlink" title="延时确认"></a>延时确认</h2><p>在许多情况下,TCP并不对每个到来的数据包都返回ACK,利用TCP的累积ACK字段就能实现该功能。累计确认可以允许TCP延迟一段时间发送ACK,以便将ACK和相同方向上需要传的数据结合发送。这种捎带传输的方法经常用于批量数据传输。</p>
<blockquote>
<p>主机需求RFC1122指出，TCP实现ACK延迟的时延应小于500ms,实践中时延最大取200ms</p>
</blockquote>
<p><img src="https://i.loli.net/2020/04/22/Dq8ChAyTMcX5EIR.png" alt="delay_ack.png"></p>
<p>这是一个ssh连接,客户端依次输入date \n 后抓到的报文。可以看到： <br><br>frame.number = 5 client send d to server <br><br>frame.number = 6 server send ack to client <br><br>frame.number = 7 senver send d to client(回显) <br><br>frame.number = 8 clinet send ack to server <br></p>
<p>frame.number = 18 client send t to server <br><br>frame.number = 19 server send ack and t(回显) to client <br><br>frame.number = 20 clinet send ack to server <br></p>
<p>4步是普通的报文，3步的是延迟确认。这里由于延迟很小，所以延迟确认回复比较快，体现出来只是报文数变少了。如果frame.number = 6等7号报文很久没等到，则客户端要一直等到服务端收到7号报文后才会发出ack确认(延迟确认没超时的情况下)</p>
<h2 id="Nagle算法"><a href="#Nagle算法" class="headerlink" title="Nagle算法"></a>Nagle算法</h2><p>Nagle算法要求，当一个TCP连接中有在传数据(即那些已发送但还未经确认的数据,长度小于mss)就不能被发送,直到所有的在传数据都收到ack,并且在收到ack后，将这些小包整合起来一起发送。</p>
<p>直观的说，Nagle就是在前面的<strong>小报文</strong>未被确认的时候，后面的小报文先不发送，直到收到前面小报文的ack了，把后面积累的小报文一起发送出去，这样就减少了小报文的传输。这些小报文有效负荷很低，每次都传输有点浪费带宽。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Return false, if packet can be sent now without violation Nagle&#x27;s rules:</span></span><br><span class="line"><span class="comment"> * 1. It is full sized.</span></span><br><span class="line"><span class="comment"> * 2. Or it contains FIN. (already checked by caller)</span></span><br><span class="line"><span class="comment"> * 3. Or TCP_CORK is not set, and TCP_NODELAY is set.</span></span><br><span class="line"><span class="comment"> * 4. Or TCP_CORK is not set, and all sent packets are ACKed.</span></span><br><span class="line"><span class="comment"> *    With Minshall&#x27;s modification: all sent small packets are ACKed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">tcp_nagle_check</span><span class="params">(<span class="keyword">const</span> struct tcp_sock *tp,</span></span></span><br><span class="line"><span class="function"><span class="params">				  <span class="keyword">const</span> struct sk_buff *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">				  <span class="keyword">unsigned</span> <span class="keyword">int</span> mss_now, <span class="keyword">int</span> nonagle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> skb-&gt;len &lt; mss_now &amp;&amp;</span><br><span class="line">		((nonagle &amp; TCP_NAGLE_CORK) ||</span><br><span class="line">		 (!nonagle &amp;&amp; tp-&gt;packets_out &amp;&amp; tcp_minshall_check(tp)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1: 达到mss大小直接发送 <br><br>2：是FIN报文 <br><br>3：TCP_CORK未设置，TCP_NODELAY设置 <br><br>4：TCP_CORK未设置，所有发送的<strong>小报文</strong>都收到了确认 <br></p>
<p><img src="https://i.loli.net/2020/04/22/4m2sXIiycfR15eV.png" alt="nagle.png"></p>
<p>每个小报文都要等到<code>所有发送的小报文都收到了确认</code>条件满足，才能发送。遗憾的是，这里构造实验环境没有抓包合并的小报文。</p>
<p><img src="https://i.loli.net/2020/04/23/Twf1WA2j68LMRqa.jpg" alt="nagle1_1.jpg"></p>
<p>每组报文(发送到接收)都是一个rtt时间，113-114ms</p>
<h2 id="Nagle与延迟确认"><a href="#Nagle与延迟确认" class="headerlink" title="Nagle与延迟确认"></a>Nagle与延迟确认</h2><p><img src="https://i.loli.net/2020/04/23/Bg3S9dZzLQhVFEM.jpg" alt="nale_1.jpg"></p>
<p>客户端收到2个服务端发来的报文，由于延迟确认没有即刻回复ack.服务端由于Nagle算法，要等收到前面报文的ack才继续发送，于是导致了死锁。在延迟确认超时前一直阻塞。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>linux禁用延迟确认可以setsockopt函数设置TCP_QUICKACK</li>
<li>linux禁用Nagle可以设置TCP_NODELAY</li>
<li>延迟确认和Nagle算法碰到一起可能导致死锁，需要谨慎</li>
<li>tcp.analysis.ack_rtt &gt; 0.2 and tcp.len == 0 过滤超过200ms的确认</li>
</ul>
<p>得分情况，看是别人出发晚还是路上耽搁久，服务器如果是发了一条数据，然后等了&gt;0.2s后才发的ack，这就很有可能是延迟确认导致的</p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/04/17/4NjM87RbDmLsYH3.jpg" alt="78170022_p0_lit.jpg"></p>
]]></content>
      <tags>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>常量折叠</title>
    <url>/2020-04-24-%E5%B8%B8%E9%87%8F%E6%8A%98%E5%8F%A0/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/yby4769250/article/details/7359278">C++常量折叠</a></p>
<a id="more"></a>


<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/04/24/HrUQ2K3eivA54Bg.jpg" alt="81025182_p0_lit.jpg"></p>
]]></content>
      <tags>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title>红黑树</title>
    <url>/2020-05-16-%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/31805309">漫画：什么是红黑树？</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91">wikipedia</a></p>
<p><a href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html">在线测试</a></p>
<p><a href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html">Red Black Tree</a></p>
<a id="more"></a>

<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>二叉搜索树(也叫二叉查找树，二叉排序树)利用二分法的思想，使得查找效率很高。最大查找次数是树的高度。但由于<strong>不平衡</strong>的原因，某些情况下，树的高度很高，查找近乎单链表遍历。AVL/红黑树就是为了均衡这种情况，让二叉搜索树变得稳定，可靠</p>
<p><img src="https://i.loli.net/2020/05/16/R4kBEcvs6VMLtD3.png" alt="不平衡的二叉树.png"></p>
<hr>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：</p>
<p>1 节点是红色或黑色。 <br><br>2 根是黑色 <br><br>3 所有叶子都是黑色（叶子是NIL节点） <br><br>4 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点）<br><br>5 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点</p>
<p><img src="https://i.loli.net/2020/05/16/h9kp7cIVwvKoCdW.png" alt="红黑树.png"></p>
<hr>
<h2 id="变换规则"><a href="#变换规则" class="headerlink" title="变换规则"></a>变换规则</h2><p>插入的节点是红色节点(如果设为黑色，就会导致根到叶子的路径上有一条路上，多一个额外的黑节点，这个是很难调整的。但是设为红色节点后，可能会导致出现两个连续红色节点的冲突，那么可以通过颜色调换（color flips）和树旋转来调整。)</p>
<p>1.变颜色的情况：当前节点的父节点是红色，且它的叔叔节点也是红色. <br></p>
<ul>
<li><strong>把父节点设为黑色</strong></li>
<li><strong>把叔叔节点设为黑色</strong></li>
<li><strong>把祖父节点设为红色</strong></li>
<li><strong>把当前结点指向祖父结点</strong></li>
</ul>
<p>2.左旋：当前节点的父节点是红色，叔叔节点是黑色。且当前的节点是右子树。 <br><br><strong>左旋以父节点作为左旋</strong></p>
<p><img src="https://i.loli.net/2020/05/16/sLb14Un6NWaAhmG.gif" alt="左旋.gif"></p>
<p>3.右旋：当前节点的父节点是红色，叔叔节点是黑色，且当前的节点是左子树。右旋</p>
<ul>
<li><strong>把父节点变为黑色</strong></li>
<li><strong>把祖父节点变为红色</strong></li>
<li><strong>以祖父节点旋转</strong></li>
</ul>
<p><img src="https://i.loli.net/2020/05/16/avbRdlM9jgpuT8o.gif" alt="右旋.gif"></p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p><strong>before</strong> <br></p>
<p><img src="https://i.loli.net/2020/05/17/zCbqZcK45gH1SNj.png" alt="insert_0.png"></p>
<p><strong>insert 1</strong> <br></p>
<p><img src="https://i.loli.net/2020/05/17/plSoF58aiO34HrE.gif" alt="in_1.gif"></p>
<p><strong>after</strong> <br></p>
<p><img src="https://i.loli.net/2020/05/17/BcDLYVu3US8mTKw.png" alt="in_1_new.png"></p>
<hr>
<p><strong>before</strong> <br></p>
<p><img src="https://i.loli.net/2020/05/17/l5sVYIfTqbFxo7w.png" alt="in_7_old.png"></p>
<p><strong>insert 7</strong> <br></p>
<p><img src="https://i.loli.net/2020/05/17/YQ4MWfV9Pdap12J.gif" alt="in_7.gif"></p>
<p><strong>after</strong> <br></p>
<p><img src="https://i.loli.net/2020/05/17/FbZ4frIxiRgl39G.png" alt="in_7_new.png"></p>
<hr>
<p><strong>before</strong> <br></p>
<p><img src="https://i.loli.net/2020/05/17/GtBEpW1wfjCni85.png" alt="in_6_old.png"></p>
<p><strong>insert 6 step1</strong> <br></p>
<p><img src="https://i.loli.net/2020/05/17/1LTYDIMPQfq8AWt.gif" alt="in_6_1.gif"></p>
<p><img src="https://i.loli.net/2020/05/17/KkyiOew49Qx1GAM.png" alt="in_6_step1.png"></p>
<p><strong>insert 6 step2</strong> <br></p>
<p><img src="https://i.loli.net/2020/05/17/6WZwkTFuarAE5Cx.gif" alt="in_6_2.gif"></p>
<p><img src="https://i.loli.net/2020/05/17/apA2tHTgzqSMkRo.png" alt="in_6_step2.png"></p>
<p><strong>insert 6 step3</strong> <br></p>
<p><img src="https://i.loli.net/2020/05/17/5XjgZ26dJYCrDOi.gif" alt="in_6_3.gif"></p>
<p><strong>endding</strong> <br></p>
<p><img src="https://i.loli.net/2020/05/17/L7N6tp8VICFhi5x.png" alt="in_6_step3.png"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RED 	BOOL_FLASE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLACK 	BOOL_TRUE</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> date;</span><br><span class="line">	<span class="keyword">bool</span> color;</span><br><span class="line">	Node *left;</span><br><span class="line">	Node *right;</span><br><span class="line">	Node *parent;</span><br><span class="line">	Node *root;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Node</span>(<span class="keyword">int</span> &amp;date)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;date = data;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//左旋以父节点作为左旋</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">LeftRotation</span><span class="params">(Node *e)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Node *s = e-&gt;right;		</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">if</span> (e-&gt;parent == <span class="literal">NULL</span>) <span class="comment">//e = root</span></span><br><span class="line">			root = s;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (e-&gt;parent-&gt;left = e) <span class="comment">// e is left</span></span><br><span class="line">			e-&gt;parent-&gt;left = s;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			e-&gt;parent-&gt;right = s;<span class="comment">// e is right</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (s-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">			s-&gt;left-&gt;parent = e;</span><br><span class="line">			</span><br><span class="line">		s-&gt;parent = e-&gt;parent;</span><br><span class="line">		e-&gt;parent = s;</span><br><span class="line">		</span><br><span class="line">		e-&gt;right = s-&gt;left;</span><br><span class="line">		s-&gt;left = e;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//把父节点变为黑色</span></span><br><span class="line">	<span class="comment">//把祖父节点变为红色</span></span><br><span class="line">	<span class="comment">//以祖父节点旋转</span></span><br><span class="line">	<span class="comment">//前两步在其他函数实现</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">RightRotation</span><span class="params">(Node *s)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Node *e = s-&gt;left;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (s-&gt;parent == <span class="literal">NULL</span>)</span><br><span class="line">			root = e;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (s-&gt;parent-&gt;left == s)</span><br><span class="line">			s-&gt;parent-&gt;left = e;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (s-&gt;parent-&gt;right == s)</span><br><span class="line">			s-&gt;parent-&gt;right = e;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (e-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">			e-&gt;right-&gt;parent = s;</span><br><span class="line">		</span><br><span class="line">		e-&gt;parent = s-&gt;parent;</span><br><span class="line">		s-&gt;parent = e;</span><br><span class="line">		</span><br><span class="line">		s-&gt;left = e-&gt;right;</span><br><span class="line">		e-&gt;right = s;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//红黑树插入 递归</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">InsertRBT</span><span class="params">(Node *root, <span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function">	</span>&#123;	</span><br><span class="line">		<span class="comment">//this-&gt;root 默认不为空</span></span><br><span class="line">		<span class="keyword">if</span> (data &gt; root-&gt;data)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				root-&gt;right = <span class="keyword">new</span> <span class="built_in">Node</span>(data);</span><br><span class="line">				root-&gt;right.color = RED;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">InsertRBT</span>(root-&gt;right, data);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				root-&gt;left = <span class="keyword">new</span> <span class="built_in">Node</span>(data);</span><br><span class="line">				root-&gt;right.color = RED;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">InsertRBT</span>(root-&gt;left, data);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">InsertRBTFixedUp</span>();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//红黑树插入 loop</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">InsertRBT</span><span class="params">(Node *root, <span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function">	</span>&#123;	</span><br><span class="line">		<span class="comment">//this-&gt;root 默认不为空</span></span><br><span class="line">		</span><br><span class="line">		Node *x = <span class="keyword">this</span>-&gt;root;</span><br><span class="line">		Node *y = <span class="literal">NULL</span>;</span><br><span class="line">		Node *n = <span class="keyword">new</span> <span class="built_in">Node</span>(data);</span><br><span class="line">		n.color = RED;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span> (x)</span><br><span class="line">		&#123;</span><br><span class="line">			y = x;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (data &gt; x-&gt;data)</span><br><span class="line">				x = x-&gt;right;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				x = x-&gt;left;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (!y)</span><br><span class="line">			<span class="keyword">this</span>-&gt;root = Node;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (date &gt; y-&gt;date)</span><br><span class="line">			y-&gt;right = n;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			y-&gt;left = n;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">InsertRBTFixedUp</span>();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//插入修正函数</span></span><br><span class="line">	<span class="built_in">InsertRBTFixedUp</span>(Node *c)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//parent is black, is ok</span></span><br><span class="line">		<span class="keyword">while</span> (c-&gt;parent-&gt;color == RED)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//(uncle is left, and red) or (uncle is right, and red)</span></span><br><span class="line">			<span class="keyword">if</span> (c-&gt;parent-&gt;parent-&gt;left-&gt;color == RED &amp;&amp; 				c-&gt;parent-&gt;parent-&gt;right-&gt;color == RED)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//变色</span></span><br><span class="line">				<span class="comment">//把父节点设为黑色</span></span><br><span class="line">				<span class="comment">//把叔叔节点设为黑色</span></span><br><span class="line">				<span class="comment">//把祖父节点设为红色</span></span><br><span class="line">				<span class="comment">//把当前结点指向祖父结点</span></span><br><span class="line">				c-&gt;parent-&gt;parent-&gt;right-&gt;color = BLACK;</span><br><span class="line">				c-&gt;parent-&gt;parent-&gt;left-&gt;color = BLACK;</span><br><span class="line">				c-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">				c = c-&gt;parent-&gt;parent;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (c-&gt;parent-&gt;parent-&gt;left-&gt;color == BLACK || c-&gt;parent-&gt;parent-&gt;right-&gt;color == BLACK)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//旋转</span></span><br><span class="line">				<span class="comment">//右旋</span></span><br><span class="line">				<span class="keyword">if</span> (c == c-&gt;parent-&gt;left)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//把父节点变为黑色</span></span><br><span class="line">					<span class="comment">//把祖父节点变为红色</span></span><br><span class="line">					<span class="comment">//以祖父节点旋转</span></span><br><span class="line">					c-&gt;parent-&gt;color = BLACK;</span><br><span class="line">					c-&gt;parent-&gt;parent = RED;</span><br><span class="line">					<span class="built_in">RightRotation</span>(c-&gt;parent-&gt;parent);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//左旋</span></span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//左旋以父节点作为左旋</span></span><br><span class="line">					<span class="built_in">LeftRotation</span>(c-&gt;parent);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		root-&gt;color = BLACK;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//todo: del</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DeleteRBT</span><span class="params">(Node *root, <span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/05/16/KFJa5RBmoelAiwM.jpg" alt="76887678_p0_master1200.jpg"></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树</title>
    <url>/2020-05-23-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><img src="https://i.loli.net/2020/05/23/V4wXziux3UcRtjr.jpg" alt="bst.jpg"></p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BST</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    BST *left;</span><br><span class="line">    BST *right;</span><br><span class="line">    BST *parent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>前序遍历：A,B,C <br><br>中序遍历：B,A,C <br><br>后续遍历：B,C,A <br></p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraversal</span><span class="params">(BST *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; root-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">PreOrderTraversal</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">PreOrderTraversal</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraversal</span><span class="params">(BST *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">InOrderTraversal</span>(root-&gt;left);</span><br><span class="line">    cout &lt;&lt; root-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">InOrderTraversal</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraversal</span><span class="params">(BST *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PostOrderTraversal</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">PostOrderTraversal</span>(root-&gt;right);</span><br><span class="line">    cout &lt;&lt; root-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BST* <span class="title">InsertBST</span><span class="params">(BST *root, <span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> BST *prev = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		BST *n = <span class="keyword">new</span> BST;</span><br><span class="line">		<span class="built_in">memset</span>(n, <span class="number">0</span>, <span class="keyword">sizeof</span>(BST));</span><br><span class="line">		n-&gt;data = data;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (prev == <span class="literal">NULL</span>)</span><br><span class="line">			;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (data &gt; prev-&gt;data)</span><br><span class="line">			prev-&gt;right = n;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			prev-&gt;left = n;</span><br><span class="line"></span><br><span class="line">        n-&gt;parent = prev;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	prev = root;</span><br><span class="line">	<span class="keyword">if</span> (data &gt; root-&gt;data)</span><br><span class="line">		InsertBST(root-&gt;right, data);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		InsertBST(root-&gt;left, data);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>删除有三种情况： <br></p>
<ul>
<li>删除的是叶子节点</li>
<li>删除节点包含1个孩子节点 </li>
<li>删除节点包含2个孩子节点</li>
</ul>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteBST</span><span class="params">(<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h2><h3 id="前序遍历-1"><a href="#前序遍历-1" class="headerlink" title="前序遍历"></a>前序遍历</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> PreOrderTraversal</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> InOrderTraversal</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> PostOrderTraversal</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BST* <span class="title">InsertBST</span><span class="params">(BST *root, <span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BST *n = <span class="keyword">new</span> BST;</span><br><span class="line">    <span class="built_in">memset</span>(n, <span class="number">0</span>, <span class="keyword">sizeof</span>(BST));</span><br><span class="line">    n-&gt;data = data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        root = n;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        BST *next = root;</span><br><span class="line">        BST *prev = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(next)</span><br><span class="line">        &#123;</span><br><span class="line">            prev = next;</span><br><span class="line">            <span class="keyword">if</span> (data &gt; next-&gt;data)</span><br><span class="line">                next = next-&gt;right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                next = next-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (data &gt; prev-&gt;data)</span><br><span class="line">            prev-&gt;right = n;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            prev-&gt;left = n;</span><br><span class="line"></span><br><span class="line">        n-&gt;parent = prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteBST</span><span class="params">(<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BST</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(BST *root)</span></span>;</span><br><span class="line">BST *gRoot = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BST</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	BST *left;</span><br><span class="line">	BST *right;</span><br><span class="line">	BST *parent;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">BST</span>()</span><br><span class="line">	&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">BST</span>(<span class="keyword">int</span> data)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;data = data;</span><br><span class="line">		left = <span class="literal">NULL</span>;</span><br><span class="line">		right = <span class="literal">NULL</span>;</span><br><span class="line">		parent = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">BST</span>()</span><br><span class="line">	&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="function">BST* <span class="title">InsertBST</span><span class="params">(BST *root, <span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BST *n = <span class="keyword">new</span> BST;</span><br><span class="line">	<span class="built_in">memset</span>(n, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(BST));</span><br><span class="line">	n-&gt;data = data;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">		root = n;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		BST *next = root;</span><br><span class="line">		BST *prev = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">while</span> (next)</span><br><span class="line">		&#123;</span><br><span class="line">			prev = next;</span><br><span class="line">			<span class="keyword">if</span> (data &gt; next-&gt;data)</span><br><span class="line">				next = next-&gt;right;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				next = next-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (data &gt; prev-&gt;data)</span><br><span class="line">			prev-&gt;right = n;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			prev-&gt;left = n;</span><br><span class="line"></span><br><span class="line">		n-&gt;parent = prev;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BST* <span class="title">InsertBST</span><span class="params">(BST *root, <span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> BST *prev = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		BST *n = <span class="keyword">new</span> <span class="built_in">BST</span>(data);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (prev == <span class="literal">NULL</span>)</span><br><span class="line">			;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (data &gt; prev-&gt;data)</span><br><span class="line">			prev-&gt;right = n;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			prev-&gt;left = n;</span><br><span class="line"></span><br><span class="line">		n-&gt;parent = prev;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	prev = root;</span><br><span class="line">	<span class="keyword">if</span> (data &gt; root-&gt;data)</span><br><span class="line">		<span class="built_in">InsertBST</span>(root-&gt;right, data);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">InsertBST</span>(root-&gt;left, data);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraversal</span><span class="params">(BST *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; root-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="built_in">PreOrderTraversal</span>(root-&gt;left);</span><br><span class="line">	<span class="built_in">PreOrderTraversal</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraversal</span><span class="params">(BST *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">InOrderTraversal</span>(root-&gt;left);</span><br><span class="line">	cout &lt;&lt; root-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="built_in">InOrderTraversal</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraversal</span><span class="params">(BST *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">PostOrderTraversal</span>(root-&gt;left);</span><br><span class="line">	<span class="built_in">PostOrderTraversal</span>(root-&gt;right);</span><br><span class="line">	cout &lt;&lt; root-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteBST</span><span class="params">(BST *root, <span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (data == root-&gt;data)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Delete</span>(root);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (data &gt; root-&gt;data)</span><br><span class="line">		<span class="built_in">DeleteBST</span>(root-&gt;right, data);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">DeleteBST</span>(root-&gt;left, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BST * <span class="title">RightAdjustNode</span><span class="params">(BST *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (node-&gt;left)</span><br><span class="line">		node = node-&gt;left;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(BST *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	BST *AdjustNode = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//status 1 删除叶子节点</span></span><br><span class="line">	<span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (root-&gt;parent == <span class="literal">NULL</span>)</span><br><span class="line">			;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;parent-&gt;left == root)</span><br><span class="line">			root-&gt;parent-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			root-&gt;parent-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">delete</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//status 2 有两个孩子节点 采用后驱节点</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span> &amp;&amp; root-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//查找后驱节点</span></span><br><span class="line">		AdjustNode = <span class="built_in">RightAdjustNode</span>(root-&gt;right);</span><br><span class="line">		<span class="comment">//后驱节点替换删除节点的值</span></span><br><span class="line">		<span class="keyword">if</span> (root-&gt;parent == <span class="literal">NULL</span>)</span><br><span class="line">			gRoot-&gt;data = AdjustNode-&gt;data;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;parent-&gt;left == root)</span><br><span class="line">			root-&gt;parent-&gt;left-&gt;data = AdjustNode-&gt;data;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			root-&gt;parent-&gt;right-&gt;data = AdjustNode-&gt;data;</span><br><span class="line">		<span class="comment">//删除后驱节点</span></span><br><span class="line">		<span class="built_in">Delete</span>(AdjustNode);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//status 3 有一个孩子节点</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//查找孩子节点</span></span><br><span class="line">		AdjustNode = (root-&gt;left != <span class="literal">NULL</span> ? root-&gt;left : root-&gt;right);</span><br><span class="line">		<span class="comment">//孩子节点替换删除节点</span></span><br><span class="line">		<span class="keyword">if</span> (root-&gt;parent == <span class="literal">NULL</span>)</span><br><span class="line">			gRoot = AdjustNode;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;parent-&gt;left == root)</span><br><span class="line">			root-&gt;parent-&gt;left = AdjustNode;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			root-&gt;parent-&gt;right = AdjustNode;</span><br><span class="line">		<span class="comment">//删除孩子节点</span></span><br><span class="line">		<span class="keyword">delete</span> root;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	<span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; data)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="literal">false</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			gRoot = <span class="built_in">InsertBST</span>(gRoot, data);</span><br><span class="line">			flag = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">InsertBST</span>(gRoot, data);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;PreOrder &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">PreOrderTraversal</span>(gRoot);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;InOrder &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">InOrderTraversal</span>(gRoot);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;PostOrder &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">PostOrderTraversal</span>(gRoot);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Input a data to delete:&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;delete 1&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">DeleteBST</span>(gRoot, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">InOrderTraversal</span>(gRoot);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;delete 3&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">DeleteBST</span>(gRoot, <span class="number">3</span>);</span><br><span class="line">	<span class="built_in">InOrderTraversal</span>(gRoot);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1</span></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;delete 6&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">DeleteBST</span>(gRoot, <span class="number">6</span>);</span><br><span class="line">	<span class="built_in">InOrderTraversal</span>(gRoot);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/05/23/42CiexKs7OgT6Bn.jpg" alt="bst_test1.jpg"></p>
<pre><code>1
3
5
2
6
^Z
PreOrder
1 3 2 5 6
InOrder
1 2 3 5 6
PostOrder
2 6 5 3 1</code></pre>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/05/23/YB1vaJ8MV4Clmqj.jpg" alt="76266339_p0_master1200_lit.jpg"></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希表</title>
    <url>/2020-05-24-%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2>]]></content>
      <tags>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title>c++11-delete_default</title>
    <url>/2020-07-05-c++11-delete_default/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.ibm.com/developerworks/cn/aix/library/1212_lufang_c11new/index.html">C++11 标准新特性：Defaulted 和 Deleted 函数</a></p>
<h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><p>c++的特殊成员函数：默认构造函数，默认拷贝构造函数，默认赋值操作符重载函数，默认析构函数。如果程序没有自己实现这些函数，但代码中需要用到的话，编译器会自己实现这些函数。有的时候不想要编译器自己实现，比如不希望有默认的拷贝构造和赋值操作符重载，就可以这样：</p>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myclass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> _m;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">myclass</span>();</span><br><span class="line">	~<span class="built_in">myclass</span>();</span><br><span class="line">	<span class="built_in">myclass</span>(<span class="keyword">const</span> myclass &amp; param);</span><br><span class="line">	myclass &amp; <span class="keyword">operator</span>=(myclass &amp; param);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将拷贝构造函数和赋值操作符重载函数作为private,并且只声明而不实现，这样就避免了编译器自动生成，而自己又不必去实现。而c++11引入了delete关键字，使用如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myclass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> _m;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">myclass</span>() = <span class="keyword">delete</span>;</span><br><span class="line">	~<span class="built_in">myclass</span>() = <span class="keyword">delete</span>;</span><br><span class="line">	<span class="built_in">myclass</span>(<span class="keyword">const</span> myclass &amp; param) = <span class="keyword">delete</span>;</span><br><span class="line">	myclass &amp; <span class="keyword">operator</span>=(myclass &amp; param) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样带delete关键字的函数是不能被调用的，表示该函数被禁用。</p>
<p>注意：</p>
<ul>
<li>delete关键字可以用在类内，也可以用在类外。</li>
<li>并且delete函数也可以用在普通函数上，不一定是类的成员函数：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World!\n&quot;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>错误(活动)    E1776    无法引用 函数 &quot;func()&quot; (已声明 所在行数:15) -- 它是已删除的函数    </code></pre>
<p><strong>delete也可以用于限制一些特定的函数类型参数对应的函数实现，具体如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; param &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">func</span>(<span class="literal">true</span>);	<span class="comment">//1</span></span><br><span class="line">	<span class="built_in">func</span>(<span class="number">1.2</span>);	<span class="comment">//1</span></span><br><span class="line">	<span class="built_in">func</span>(<span class="string">&#x27;a&#x27;</span>);	<span class="comment">//97</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; param &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">bool</span> param)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> param)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> param)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">func</span>(<span class="literal">true</span>);	<span class="comment">//无法引用 函数 &quot;func(bool param)&quot; (已声明 所在行数:12) -- 它是已删除的</span></span><br><span class="line">	<span class="keyword">float</span> f = <span class="number">1.2</span>;	<span class="comment">//float--&gt;double</span></span><br><span class="line">	<span class="built_in">func</span>(f);	<span class="comment">//无法引用 函数 &quot;func(double param)&quot; (已声明 所在行数:13) -- 它是已删除</span></span><br><span class="line">	<span class="built_in">func</span>(<span class="string">&#x27;a&#x27;</span>);	<span class="comment">//无法引用 函数 &quot;func(char param)&quot; (已声明 所在行数:14) -- 它是已删除的</span></span><br><span class="line">	<span class="built_in">func</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>c++98版本的策略对于类的模板函数不能生效：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myclass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T param)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; param &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//private:</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="comment">//void func&lt;int&gt;(int param);	//编译不过</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> param)</span></span>;	<span class="comment">//还是会调用模板函数，相当于没生效</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	myclass m;</span><br><span class="line">	<span class="keyword">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">	m.<span class="built_in">func</span>(c);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">	m.<span class="built_in">func</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="default"><a href="#default" class="headerlink" title="default"></a>default</h2><p>还有一种情况，默认的这几个函数，如果代码中自己实现了，则编译器不会自己再去实现了。但有些时候希望用到默认的编译器可以自己实现的函数，因为这样不用自己写起来麻烦，并且编译器自己实现的函数性能比自己实现的要高：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myclass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> _m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">myclass</span>(<span class="keyword">int</span> n):_m(n)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	myclass a;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>错误(活动)    E0291    类 “myclass” 不存在默认构造函数    ConsoleApplication6    </p>
</blockquote>
<p>自己实现了带参数的构造函数，编译器不会再去自己实现无参构造函数了，可以这样：</p>
<p><code>1 带缺省参数的构造函数</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">myclass</span>(<span class="keyword">int</span> n = <span class="number">0</span>):_m(n)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>2 另外实现无参构造函数</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myclass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> _m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">myclass</span>(<span class="keyword">int</span> n):_m(n)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">myclass</span>()</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	myclass a;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>3 什么构造函数都不实现，让编译器去实现默认的构造函数</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myclass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> _m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//myclass(int n):_m(n)</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//myclass()</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	myclass a;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>4 根据需求这个类需要另外实现其他的构造函数，还想要使用编译器自己实现的构造函数</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myclass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> _m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">myclass</span>(<span class="keyword">int</span> n):_m(n)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">myclass</span>() = <span class="keyword">default</span>;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	myclass a;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>default关键字可以让编译器去实现默认的函数</p>
<p>注意点：</p>
<ul>
<li>只针对于这几种：默认构造函数，默认析构函数，拷贝/移动构造函数，赋值/移动赋值操作符重载函数。</li>
<li>不可用于类外</li>
<li>default的函数由编译器自己实现函数体，性能比自己写的性能要高</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myclass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> _m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">myclass</span>(<span class="keyword">int</span> n):_m(n)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">myclass</span>() = <span class="keyword">default</span>;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span> </span>= <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	myclass a;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>错误(活动)    E1774    “= default”只能出现在默认构造函数、复制/移动构造函数、复制/移动赋值运算符和析构函数中</p>
</blockquote>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/07/05/8K9jPoBm5UvcQtH.jpg" alt="82747100_p0_master1200_lit.jpg"></p>
]]></content>
      <tags>
        <tag>c++11</tag>
      </tags>
  </entry>
  <entry>
    <title>copy_and_swap</title>
    <url>/2020-07-05-copy_and_swap/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>留的坑，以后填</p>
<a id="more"></a>

<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/07/05/JVorRaUSwyF6Bnx.jpg" alt="81083209_p0_master1200.jpg"></p>
]]></content>
      <tags>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title>emplace_back</title>
    <url>/2020-07-05-emplace_back/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://stackoverflow.com/questions/4303513/push-back-vs-emplace-back">push_back和emplace_back</a></p>
<p><a href="https://en.cppreference.com/w/cpp/container/vector/emplace_back">emplace_back</a></p>
<a id="more"></a>

<h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//c++11 -- c++17</span></span><br><span class="line"><span class="keyword">template</span>&lt; class... Args &gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">emplace_back</span><span class="params">( Args&amp;&amp;... args )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//since c++17</span></span><br><span class="line"><span class="keyword">template</span>&lt; class... Args &gt;</span><br><span class="line"><span class="function">reference <span class="title">emplace_back</span><span class="params">( Args&amp;&amp;... args )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">( <span class="keyword">const</span> T&amp; value )</span></span>;</span><br><span class="line"><span class="comment">//since c++11</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">( T&amp;&amp; value )</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vector::emplace</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::vector&lt;<span class="keyword">int</span>&gt; myvector = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> it = myvector.<span class="built_in">emplace</span> ( myvector.<span class="built_in">begin</span>()+<span class="number">1</span>, <span class="number">100</span> );</span><br><span class="line">  myvector.<span class="built_in">emplace</span> ( it, <span class="number">200</span> );</span><br><span class="line">  myvector.<span class="built_in">emplace</span> ( myvector.<span class="built_in">end</span>(), <span class="number">300</span> );</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;myvector contains:&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x: myvector)</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; x;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><p><code>input:</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">President</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    std::string name;</span><br><span class="line">    std::string country;</span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">President</span>(std::string p_name, std::string p_country, <span class="keyword">int</span> p_year)</span><br><span class="line">        : <span class="built_in">name</span>(std::<span class="built_in">move</span>(p_name)), <span class="built_in">country</span>(std::<span class="built_in">move</span>(p_country)), <span class="built_in">year</span>(p_year)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;I am being constructed.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">President</span>(President&amp;&amp; other)</span><br><span class="line">        : <span class="built_in">name</span>(std::<span class="built_in">move</span>(other.name)), <span class="built_in">country</span>(std::<span class="built_in">move</span>(other.country)), <span class="built_in">year</span>(other.year)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;I am being moved.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    President&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> President&amp; other) = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;President&gt; elections;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;emplace_back:\n&quot;</span>;</span><br><span class="line">    elections.<span class="built_in">emplace_back</span>(<span class="string">&quot;Nelson Mandela&quot;</span>, <span class="string">&quot;South Africa&quot;</span>, <span class="number">1994</span>);</span><br><span class="line"> </span><br><span class="line">    std::vector&lt;President&gt; reElections;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\npush_back:\n&quot;</span>;</span><br><span class="line">    reElections.<span class="built_in">push_back</span>(<span class="built_in">President</span>(<span class="string">&quot;Franklin Delano Roosevelt&quot;</span>, <span class="string">&quot;the USA&quot;</span>, <span class="number">1936</span>));</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nContents:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (President <span class="keyword">const</span>&amp; president: elections) &#123;</span><br><span class="line">        std::cout &lt;&lt; president.name &lt;&lt; <span class="string">&quot; was elected president of &quot;</span></span><br><span class="line">                  &lt;&lt; president.country &lt;&lt; <span class="string">&quot; in &quot;</span> &lt;&lt; president.year &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (President <span class="keyword">const</span>&amp; president: reElections) &#123;</span><br><span class="line">        std::cout &lt;&lt; president.name &lt;&lt; <span class="string">&quot; was re-elected president of &quot;</span></span><br><span class="line">                  &lt;&lt; president.country &lt;&lt; <span class="string">&quot; in &quot;</span> &lt;&lt; president.year &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>output</code></p>
<pre><code>emplace_back:
I am being constructed.

push_back:
I am being constructed.
I am being moved.

Contents:
Nelson Mandela was elected president of South Africa in 1994.
Franklin Delano Roosevelt was re-elected president of the USA in 1936.</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>c++11以后push_back也支持右值引用了，但和emplace_back的区别是：emplace_back支持可变参数列表的形式，可以在括号内直接赋值：</p>
<pre><code>elections.emplace_back(&quot;Nelson Mandela&quot;, &quot;South Africa&quot;, 1994);</code></pre>
<p>而push_back必须有一个具体的实现(临时对象)，看得到的参数来匹配对应的拷贝构造函数，operator=函数：</p>
<pre><code>reElections.push_back(President(&quot;Franklin Delano Roosevelt&quot;, &quot;the USA&quot;, 1936));</code></pre>
<p>push_back创建了一个临时对象President，然后通过移动构造函数把临时对象移动过来。而emplace直接通过括号的值来初始化对象。一步到位。</p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/07/05/U2qctkHWhICrlMb.jpg" alt="82157620_p0_master1200.jpg"></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>rule of three-five-zero</title>
    <url>/2020-07-05-rule%20of%20three-five-zero/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://en.cppreference.com/w/cpp/language/rule_of_three">The rule of three/five/zero</a></p>
<a id="more"></a>

<h2 id="rule-of-three"><a href="#rule-of-three" class="headerlink" title="rule of three"></a>rule of three</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">rule_of_three</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span>* cstring; <span class="comment">// raw pointer used as a handle to a dynamically-allocated memory block</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::<span class="keyword">size_t</span> n = std::<span class="built_in">strlen</span>(s) + <span class="number">1</span>;</span><br><span class="line">        cstring = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line">        std::<span class="built_in">memcpy</span>(cstring, s, n); <span class="comment">// populate</span></span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">rule_of_three</span>(<span class="keyword">const</span> <span class="keyword">char</span>* s = <span class="string">&quot;&quot;</span>) &#123; <span class="built_in">init</span>(s); &#125;</span><br><span class="line"> </span><br><span class="line">    ~<span class="built_in">rule_of_three</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] cstring;  <span class="comment">// deallocate</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">rule_of_three</span>(<span class="keyword">const</span> rule_of_three&amp; other) <span class="comment">// copy constructor</span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">init</span>(other.cstring);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    rule_of_three&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> rule_of_three&amp; other) <span class="comment">// copy assignment</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] cstring;  <span class="comment">// deallocate</span></span><br><span class="line">            <span class="built_in">init</span>(other.cstring);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>析构函数，拷贝构造函数，赋值拷贝运算符函数，如果用户实现了其中一个，则应该实现所有的三个。主要针对类内成员作为指针指向对象或者是句柄，而导致的释放关闭问题。</p>
<ul>
<li>如果只实现了析构函数，系统默认拷贝构造函数是浅拷贝，后面涉及多次析构同一地址</li>
<li>如果只实现了拷贝构造函数，析构</li>
</ul>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/07/05/wmhH31NAobMeQzR.jpg" alt="82483600_p0_master1200.jpg"></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>std::make_pair</title>
    <url>/2020-07-06-make_pair/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://stackoverflow.com/questions/9270563/what-is-the-purpose-of-stdmake-pair-vs-the-constructor-of-stdpair">What is the purpose of std::make_pair vs the constructor of std::pair?<br>Ask</a></p>
<p><a href="http://www.cplusplus.com/reference/utility/make_pair/">std::make_pair</a></p>
<p><a href="https://stackoverflow.com/questions/984394/why-not-infer-template-parameter-from-constructor">为什么不从构造函数推断模板参数？
</a></p>
<p><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0091r2.html">类模板的模板参数推导（修订版5）</a></p>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><code>c++98</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line">  pair&lt;T1,T2&gt; make_pair (T1 x, T2 y);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line">  pair&lt;T1,T2&gt; make_pair (T1 x, T2 y)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> ( pair&lt;T1,T2&gt;(x,y) );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><code>c++11</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line">  pair&lt;V1,V2&gt; make_pair (T1&amp;&amp; x, T2&amp;&amp; y);  // see below for definition of V1 and V2</span><br><span class="line">  </span><br><span class="line">The function returns:</span><br><span class="line"> </span><br><span class="line">pair&lt;V1,V2&gt;(std::forward&lt;T1&gt;(x),std::forward&lt;T2&gt;(y))</span><br><span class="line"></span><br><span class="line">Where the types V1 and V2 are the decay(衰变) equivalents(等价物) of T1 and T2, respectively(分别) (except for reference_wrapper types, for which the corresponding reference type is used instead).</span><br><span class="line"></span><br><span class="line">If T1 <span class="keyword">and</span>/<span class="keyword">or</span> T2 are rvalue references, the objects are moved <span class="keyword">and</span> x <span class="keyword">and</span>/<span class="keyword">or</span> y are left in an undefined but valid state.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// make_pair example</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span>      <span class="comment">// std::pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  std::pair &lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; foo;</span><br><span class="line">  std::pair &lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; bar;</span><br><span class="line"></span><br><span class="line">  foo = std::<span class="built_in">make_pair</span> (<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">  <span class="comment">// ok: implicit conversion from pair&lt;double,char&gt;</span></span><br><span class="line">  bar = std::<span class="built_in">make_pair</span> (<span class="number">10.5</span>,<span class="string">&#x27;A&#x27;</span>); </span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;foo: &quot;</span> &lt;&lt; foo.first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; foo.second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;bar: &quot;</span> &lt;&lt; bar.first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; bar.second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>foo: 10, 20
bar: 10, 65</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>模板类的构造函数在c++17前是不能自动推导参数类型的，所以需要手动指定类型：</p>
<pre><code>std::pair &lt;int,int&gt; p(1,2);</code></pre>
<p>而c++17后可以直接：</p>
<pre><code>std::pair p(1, &#39;a&#39;);</code></pre>
<p>具体原因我也不是很懂，可以看参考的文章。但是普通函数是支持类型推导的，所以之前c++17以前实现了make_pair：</p>
<pre><code>template &lt;class T1,class T2&gt;
pair&lt;T1,T2&gt; make_pair (T1 x, T2 y)
&#123;
  return ( pair&lt;T1,T2&gt;(x,y) );
&#125;</code></pre>
<p>这样写起来就不那么繁琐了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MyClass o1;</span><br><span class="line">MyClass o2;</span><br><span class="line"><span class="keyword">auto</span> p = std::<span class="built_in">make_pair</span>(o1, o2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> pp = std::pair&lt;MyClass, MyClass&gt; &#123; o1, o2 &#125;;</span><br></pre></td></tr></table></figure>

<p>应该是编译器会根据实际的类型去生成一个一个make_pair匹配的实现函数，转换成pare&lt;&gt;的格式。</p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/07/05/ptOwNmSl1rJ2a9s.jpg" alt="81261415_p0_master1200.jpg"></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>rvo_copy_elision</title>
    <url>/2020-07-07-rvo_copy_elision/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://community.ibm.com/community/user/browse/blogs/blogviewer?BlogKey=737659DD-8047-4BF5-B13A-003858C26C01">RVO VS std :: move</a></p>
<p><a href="http://killwing.github.io/return-value-optimization.md.html">(Named) Return Value Optimization</a></p>
<p><a href="https://stackoverflow.com/questions/11914691/copy-elision-move-constructor-not-called-when-using-ternary-expression-in-retur">move constructor not called when using ternary expression in return statement?</a></p>
<a id="more"></a>

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote>
<p>返回值优化（简称RVO）是一种编译器优化技术，它允许编译器在调用站点上构造函数的返回值。该技术也称为“清除”。C ++ 98/03标准不需要编译器提供RVO优化，但是大多数流行的C ++编译器都包含此优化技术</p>
</blockquote>
<h2 id="RVO使用"><a href="#RVO使用" class="headerlink" title="RVO使用"></a>RVO使用</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BigObject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BigObject</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;  constructor. &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">BigObject</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;  destructor.&quot;</span>&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BigObject</span>(<span class="keyword">const</span> BigObject&amp;) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;  copy constructor.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BigObject</span>(<span class="keyword">const</span> BigObject&amp;&amp;) <span class="keyword">noexcept</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;  move constructor.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">BigObject <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BigObject localObj;</span><br><span class="line">    <span class="keyword">return</span> localObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BigObject obj = <span class="built_in">foo</span>();</span><br><span class="line">    <span class="comment">//foo();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>output</strong></p>
<pre><code>//g++ xxx.cpp -std=c++11 -fno-elide-constructors
constructor.        //localObj
move constructor.   //tmp
destructor.         //~localObj
move constructor.   //obj
destructor.         //~tmp
destructor.         //~obj

0x7ffff064f99f  constructor.            //localObj
0x7ffff064f9bf  move constructor.       //tmp
0x7ffff064f99f  destructor.             //~localObj
0x7ffff064f9be  move constructor.       //obj
0x7ffff064f9bf  destructor.             //~tmp
0x7ffff064f9be  destructor.             //~obj



////g++ xxx.cpp -std=c++11
0x7fffb212e72f  constructor.    //localObj
0x7fffb212e72f  destructor.     //~localObj</code></pre>
<h2 id="RVO原理"><a href="#RVO原理" class="headerlink" title="RVO原理"></a>RVO原理</h2><p>图片来自：</p>
<p><a href="https://community.ibm.com/community/user/browse/blogs/blogviewer?BlogKey=737659DD-8047-4BF5-B13A-003858C26C01">RVO VS std :: move</a></p>
<p><code>no rvo</code></p>
<p><img src="https://i.loli.net/2020/07/07/YLRqyMAzdUO6Hf4.png" alt="7446a02d-31c5-48ec-8544-56411141f7d7.png"></p>
<p><code>rvo</code></p>
<p><img src="https://i.loli.net/2020/07/07/LUya98uKJCA5wTv.png" alt="5ce3d183-8424-4f1b-af08-cf2f0cfb3caa.png"></p>
<p>结合图示和前面的demo代码发现，rvo优化的时候函数内部并没有新建临时对象，return的就是<code>自动变量</code>。并且后面赋值的时候，main函数中的对象也用的是foo函数中<code>自动变量</code>的地址。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BigObject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BigObject</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;  constructor. &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">BigObject</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;  destructor.&quot;</span>&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BigObject</span>(<span class="keyword">const</span> BigObject&amp;) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;  copy constructor.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BigObject</span>(<span class="keyword">const</span> BigObject&amp;&amp;) <span class="keyword">noexcept</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;  move constructor.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">BigObject <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BigObject localObj;</span><br><span class="line">    localObj.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> localObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BigObject obj = <span class="built_in">foo</span>();</span><br><span class="line">    obj.<span class="built_in">print</span>();</span><br><span class="line">    <span class="comment">//foo();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>0x7ffd4772908f  constructor. 
0x7ffd4772908f
0x7ffd4772908f
0x7ffd4772908f  destructor.</code></pre>
<h2 id="RVO适用范围"><a href="#RVO适用范围" class="headerlink" title="RVO适用范围"></a>RVO适用范围</h2><p>引用自：<a href="http://killwing.github.io/return-value-optimization.md.html">(Named) Return Value Optimization</a></p>
<p><code>31.</code></p>
<p>When certain criteria are met, an implementation is allowed to omit the copy/move construction of a class object, even if the constructor selected for the copy/move operation and/or the destructor for the object have side effects. In such cases, the implementation treats the source and target of the omitted copy/move operation as simply two different ways of referring to the same object, and the destruction of that object occurs at the later of the times when the two objects would have been destroyed without the optimization. This elision of copy/move operations, called copy elision, is permitted in the following circumstances (which may be combined to eliminate multiple copies):</p>
<ul>
<li>in a return statement in a function with a class return type, when the expression is the name of a non-volatile automatic object (other than a function or catch-clause parameter) with the same cv-unqualified type as the function return type, the copy/move operation can be omitted by constructing the automatic object directly into the function’s return value</li>
<li>[…]</li>
<li>when a temporary class object that has not been bound to a reference (12.2) would be copied/moved to a class object with the same cv-unqualified type, the copy/move operation can be omitted by constructing the temporary object directly into the target of the omitted copy/move</li>
<li>[…]</li>
</ul>
<p>1 return一个局部变量（必须直接返回<code>同类型</code>的变量名或匿名，不能是<code>此函数或catch语句的参数</code>，不能是<code>条件表达式</code>），可以更改变量直接构造在返回值里（临时对象）以节省一次复制/移动。</p>
<p>2 如果一个临时对象没有绑定在引用（左值或右值）上，这个临时对象可以直接构造在同类型的目标对象里（接收变量）以节省一次复制/移动。</p>
<p>以上2点可以同时发挥作用（1 + 2），不生成临时对象以节省两次复制/移动。</p>
<p><code>32.</code></p>
<p>When the criteria for elision of a copy operation are met or would be met save for the fact that the source<br>object is a function parameter, and the object to be copied is designated by an lvalue, overload resolution to<br>select the constructor for the copy is first performed as if the object were designated by an rvalue. If overload<br>resolution fails, or if the type of the first parameter of the selected constructor is not an rvalue reference to<br>the object’s type (possibly cv-qualified), overload resolution is performed again, considering the object as an<br>lvalue. [ Note: This two-stage overload resolution must be performed regardless of whether copy elision will<br>occur. It determines the constructor to be called if elision is not performed, and the selected constructor<br>must be accessible even if the call is elided. – end note ]</p>
<p>当满足条件31的时候，即使被copy的对象是左值，也会被优先当作右值来决定选择copy还是move构造函数（不管是否会优化而不被调用到）。简单地说：当满足条件31（放宽：加上函数参数是值传递的情况）的时候，隐式的move-on-return会被调用，否则fallback为copy。<br>即使可以省去copy/move构造函数的调用，copy/move构造函数也不能是私有。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>rvo可以减少对象拷贝，不调用构造函数生成临时对象，而是直接使用原来的对象，提升性能</li>
<li>可以禁用rvo -fno-elide-constructor</li>
<li>函数内的局部变量（必须直接返回同类型的变量名或匿名，不能是此函数或catch语句的参数，不能是条件表达式），可以更改变量直接构造在返回值里（临时对象）以节省一次复制/移动</li>
<li>如果一个临时对象没有绑定在引用（左值或右值）上，这个临时对象可以直接构造在同类型的目标对象里（接收变量）以节省一次复制/移动</li>
<li>rvo是很早就出现的技术，copy elision是c++11后基于rvo提出的</li>
<li>在满足rvo的条件下，会优先考虑move函数然后才是copy函数，这并不冲突，如果加了-fno-elide-constructor导致rvo失效，那么就能看到move函数被调用而不是copy函数。在rvo成功的情况下，这一原则不容易察觉到</li>
</ul>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>代码来自：<a href="http://killwing.github.io/return-value-optimization.md.html">(Named) Return Value Optimization</a></p>
<p>仅对结果进行分析：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ctor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;dtor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">const</span> A&amp;) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;cptor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(A&amp;&amp;) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;mvtor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A g;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">A</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">f3</span><span class="params">(<span class="keyword">const</span> A&amp; a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">f4</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">f5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">A&amp;&amp; <span class="title">f55</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">f6</span><span class="params">(<span class="keyword">bool</span> b = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">return</span> b ? a : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">f66</span><span class="params">(<span class="keyword">bool</span> b = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    A aa;</span><br><span class="line">    <span class="keyword">return</span> b ? a : aa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">f7</span><span class="params">(<span class="keyword">bool</span> b = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">if</span> (b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">f8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">A&amp; <span class="title">f9</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">A&amp; <span class="title">f10</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">A&amp;&amp; <span class="title">f11</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">A x = <span class="built_in">f1</span>();     <span class="comment">//rvo</span></span><br><span class="line"></span><br><span class="line">    ctor    <span class="comment">//g</span></span><br><span class="line">    ctor    <span class="comment">//unnamed</span></span><br><span class="line">    dtor</span><br><span class="line">    dtor</span><br><span class="line"></span><br><span class="line">A x = <span class="built_in">f2</span>();     <span class="comment">//nrvo</span></span><br><span class="line"></span><br><span class="line">    ctor    <span class="comment">//g</span></span><br><span class="line">    ctor    <span class="comment">//a</span></span><br><span class="line">    dtor</span><br><span class="line">    dtor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> A&amp; x = <span class="built_in">f2</span>();  <span class="comment">//同上</span></span><br><span class="line">A&amp;&amp; x = <span class="built_in">f2</span>();       <span class="comment">//同上</span></span><br><span class="line"></span><br><span class="line">A x = <span class="built_in">f3</span>(g);</span><br><span class="line"></span><br><span class="line">    ctor    <span class="comment">//g</span></span><br><span class="line">    cptor   <span class="comment">//a-&gt;tmp </span></span><br><span class="line">            <span class="comment">//a是函数参数，不符合31</span></span><br><span class="line">            <span class="comment">//a是引用，非变量，不符合31，32</span></span><br><span class="line">            <span class="comment">//x被赋值的时候使用了rvo</span></span><br><span class="line">    dtor</span><br><span class="line">    dtor</span><br><span class="line"></span><br><span class="line">A x = <span class="built_in">f4</span>(g);</span><br><span class="line"></span><br><span class="line">    ctor    <span class="comment">//g</span></span><br><span class="line">    cptor   <span class="comment">//a </span></span><br><span class="line">            <span class="comment">//a是函数参数，不符合31</span></span><br><span class="line">            <span class="comment">//a非return值,不符合32</span></span><br><span class="line">    mvtor   <span class="comment">//tmp a不符合31，但符合32</span></span><br><span class="line">    dtor</span><br><span class="line">    dtor</span><br><span class="line">    dtor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A x = <span class="built_in">f5</span>();</span><br><span class="line"></span><br><span class="line">    ctor    <span class="comment">//g</span></span><br><span class="line">    ctor    <span class="comment">//a</span></span><br><span class="line">    mvtor   <span class="comment">//std::move后的右值--&gt;tmp</span></span><br><span class="line">    dtor</span><br><span class="line">    dtor</span><br><span class="line">    dtor</span><br><span class="line"></span><br><span class="line">A x = <span class="built_in">f55</span>();</span><br><span class="line"></span><br><span class="line">    ctor    <span class="comment">//g</span></span><br><span class="line">    ctor    <span class="comment">//a</span></span><br><span class="line">    dtor    <span class="comment">//~a</span></span><br><span class="line">    mvtor   <span class="comment">//x</span></span><br><span class="line">    dtor</span><br><span class="line">    dtor</span><br><span class="line"></span><br><span class="line">A x = <span class="built_in">f6</span>(); <span class="comment">//nrvo</span></span><br><span class="line"></span><br><span class="line">    ctor    <span class="comment">//g</span></span><br><span class="line">    ctor    <span class="comment">//a ? :的结果是确定的，符合rvo</span></span><br><span class="line">    dtor</span><br><span class="line">    dtor</span><br><span class="line"></span><br><span class="line">A x = <span class="built_in">f66</span>(); </span><br><span class="line"></span><br><span class="line">    ctor    <span class="comment">//g</span></span><br><span class="line">    ctor    <span class="comment">//a</span></span><br><span class="line">    ctor    <span class="comment">//aa</span></span><br><span class="line">    cptor   <span class="comment">//return结果不确定，不符合31,32</span></span><br><span class="line">            <span class="comment">//? : 的两个值都是左值，所以return左值。</span></span><br><span class="line">    dtor</span><br><span class="line">    dtor</span><br><span class="line">    dtor</span><br><span class="line">    dtor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A x = <span class="built_in">f7</span>(); <span class="comment">//rvo</span></span><br><span class="line"></span><br><span class="line">A x = <span class="built_in">f8</span>();</span><br><span class="line"></span><br><span class="line">    ctor    <span class="comment">//g</span></span><br><span class="line">    cptor   <span class="comment">//tmp </span></span><br><span class="line">            <span class="comment">//x执行了rvo</span></span><br><span class="line">    dtor</span><br><span class="line">    dtor</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="https://riverferry.site/2020/07/07/rvo_copy_elision/">myblog</a></p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/07/07/LbMOFXew6JyIGDg.jpg" alt="80841173_p0_master1200.jpg"></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>c++ shared_ptr weak_ptr</title>
    <url>/2020-07-09-c++%20shared_ptr%20weak_ptr/</url>
    <content><![CDATA[<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p><img src="https://i.loli.net/2020/07/10/OwoYm2aWXbVSed8.jpg" alt="071001.jpg"></p>
<p><img src="https://i.loli.net/2020/07/10/QuSUtBjdTpb1hGo.png" alt="shared_ptr.png"></p>
<a id="more"></a>

<h3 id="shared-ptr第一次创建"><a href="#shared-ptr第一次创建" class="headerlink" title="shared_ptr第一次创建"></a>shared_ptr第一次创建</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="class"><span class="keyword">class</span>&gt;</span> a = make_shard&lt;class&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp1&gt;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(_Tp1* __p)</span></span></span><br><span class="line"><span class="function">    : __shared_ptr&lt;_Tp&gt;(__p) &#123;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp1&gt;</span><br><span class="line"><span class="keyword">explicit</span> __shared_ptr(_Tp1* __p)</span><br><span class="line">    : _M_ptr(__p), _M_refcount(__p)</span><br><span class="line">&#123;</span><br><span class="line">    __glibcxx_function_requires(_ConvertibleConcept&lt;_Tp1*, _Tp*&gt;)</span><br><span class="line">    <span class="built_in"><span class="keyword">static_assert</span></span>( <span class="built_in"><span class="keyword">sizeof</span></span>(_Tp1) &gt; <span class="number">0</span>, <span class="string">&quot;incomplete type&quot;</span> );</span><br><span class="line">    __enable_shared_from_this_helper(_M_refcount, __p, __p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Ptr&gt;</span><br><span class="line">    <span class="keyword">explicit</span></span><br><span class="line">__shared_count(_Ptr __p) : _M_pi(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        _M_pi = <span class="keyword">new</span> _Sp_counted_ptr&lt;_Ptr, _Lp&gt;(__p);</span><br><span class="line">    &#125;</span><br><span class="line">    __catch(...)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> __p;</span><br><span class="line">        __throw_exception_again;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4</span></span><br><span class="line">_Sp_counted_base() <span class="keyword">noexcept</span></span><br><span class="line">    : _M_use_count(<span class="number">1</span>), _M_weak_count(<span class="number">1</span>) &#123; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="shared-ptr互相赋值"><a href="#shared-ptr互相赋值" class="headerlink" title="shared_ptr互相赋值"></a>shared_ptr互相赋值</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//拷贝构造和赋值操作符类似，举一个例子</span></span><br><span class="line"><span class="comment">//移动的就不看了，大致一样，rc和拷贝不同</span></span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;<span class="class"><span class="keyword">class</span>&gt;</span> b;</span><br><span class="line">std::shared_ptr&lt;<span class="class"><span class="keyword">class</span>&gt;</span> a = b;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="built_in">shared_ptr</span>(<span class="keyword">const</span> shared_ptr&lt;_Tp1&gt;&amp; __r) <span class="keyword">noexcept</span></span><br><span class="line">        : __shared_ptr&lt;_Tp&gt;(__r) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line">__shared_ptr(<span class="keyword">const</span> __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __r) <span class="keyword">noexcept</span></span><br><span class="line">	: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)</span><br><span class="line">	&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line">__shared_count(<span class="keyword">const</span> __shared_count&amp; __r) <span class="keyword">noexcept</span></span><br><span class="line">      : _M_pi(__r._M_pi)</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="keyword">if</span> (_M_pi != <span class="number">0</span>)</span><br><span class="line">	  _M_pi-&gt;_M_add_ref_copy();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">      _M_add_ref_copy()</span><br><span class="line">      &#123; __gnu_cxx::__atomic_add_dispatch(&amp;_M_use_count, <span class="number">1</span>); &#125;</span><br></pre></td></tr></table></figure>

<h3 id="shared-ptr析构"><a href="#shared-ptr析构" class="headerlink" title="shared_ptr析构"></a>shared_ptr析构</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line">~__shared_ptr() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">~__shared_count() <span class="keyword">noexcept</span></span><br><span class="line">      &#123;</span><br><span class="line">	<span class="keyword">if</span> (_M_pi != <span class="literal">nullptr</span>)</span><br><span class="line">	  _M_pi-&gt;_M_release();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">      _M_release() <span class="keyword">noexcept</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// Be race-detector-friendly.  For more info see bits/c++config.</span></span><br><span class="line">        _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_use_count);</span><br><span class="line">	<span class="keyword">if</span> (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_use_count, <span class="number">-1</span>) == <span class="number">1</span>)</span><br><span class="line">	  &#123;</span><br><span class="line">            _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_use_count);</span><br><span class="line">	    _M_dispose();</span><br><span class="line">	    <span class="comment">// There must be a memory barrier between dispose() and destroy()</span></span><br><span class="line">	    <span class="comment">// to ensure that the effects of dispose() are observed in the</span></span><br><span class="line">	    <span class="comment">// thread that runs destroy().</span></span><br><span class="line">	    <span class="comment">// See http://gcc.gnu.org/ml/libstdc++/2005-11/msg00136.html</span></span><br><span class="line">	    <span class="keyword">if</span> (_Mutex_base&lt;_Lp&gt;::_S_need_barriers)</span><br><span class="line">	      &#123;</span><br><span class="line">	        _GLIBCXX_READ_MEM_BARRIER;</span><br><span class="line">	        _GLIBCXX_WRITE_MEM_BARRIER;</span><br><span class="line">	      &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Be race-detector-friendly.  For more info see bits/c++config.</span></span><br><span class="line">            _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_weak_count);</span><br><span class="line">	    <span class="keyword">if</span> (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_weak_count,</span><br><span class="line">						       <span class="number">-1</span>) == <span class="number">1</span>)</span><br><span class="line">              &#123;</span><br><span class="line">                _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_weak_count);</span><br><span class="line">	        _M_destroy();</span><br><span class="line">              &#125;</span><br><span class="line">	  &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//__exchange_and_add_dispatch 取出值，然后-1</span></span><br><span class="line">    <span class="comment">//_M_use_count=1 析构模板对象的空间</span></span><br><span class="line">    <span class="comment">//_M_weak_count=1 析构管理对象的对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="keyword">virtual</span> <span class="keyword">void</span></span><br><span class="line">      _M_dispose() <span class="keyword">noexcept</span></span><br><span class="line">      &#123; <span class="keyword">delete</span> _M_ptr; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> <span class="keyword">void</span></span><br><span class="line">      _M_destroy() <span class="keyword">noexcept</span></span><br><span class="line">      &#123; <span class="keyword">delete</span> <span class="keyword">this</span>; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>其他函数之类的，记住就行了</p>
<h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;B&gt; _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">B</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::shared_ptr&lt;A&gt; _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">weak_ptr&lt;A&gt; wa;</span><br><span class="line">weak_ptr&lt;B&gt; wb;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    shared_ptr&lt;A&gt; la = make_shared&lt;A&gt;();</span><br><span class="line">    shared_ptr&lt;B&gt; lb = make_shared&lt;B&gt;();</span><br><span class="line">    wa = la;</span><br><span class="line">    wb = lb;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;A-&gt;rc = &quot;</span> &lt;&lt; la.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;B-&gt;rc = &quot;</span> &lt;&lt; lb.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    la-&gt;_a = lb;</span><br><span class="line">    lb-&gt;_b = la;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;A-&gt;rc = &quot;</span> &lt;&lt; la.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;B-&gt;rc = &quot;</span> &lt;&lt; lb.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    cout &lt;&lt; wa.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; wb.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/07/10/vYntGMwhx6f4Zsl.png" alt="循环引用.png"></p>
<pre><code>A-&gt;rc = 1
B-&gt;rc = 1
A-&gt;rc = 2
B-&gt;rc = 2
1
1</code></pre>
<p>由于weak_ptr不占用引用计数，用weak_ptr就不会存在此问题</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>shared_ptr和weak_ptr两个类各自成员占用2个指针的大小</li>
<li>给shared_ptr传入裸指针会导致在堆中new一片管理空间的大小</li>
<li>usecount=1会析构模板对象的空间</li>
<li>weakcount=1会析构管理对象的空间</li>
</ul>
<h2 id="ENDDING"><a href="#ENDDING" class="headerlink" title="ENDDING"></a>ENDDING</h2><p><img src="https://i.loli.net/2020/07/10/LzWpP5So76vcGeJ.jpg" alt="071002.jpg"></p>
]]></content>
      <tags>
        <tag>c++11</tag>
      </tags>
  </entry>
  <entry>
    <title>c++11 auto_ptr unique_ptr</title>
    <url>/2020-07-09-c++11%20auto_ptr%20unique_ptr/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>auto_ptr</strong>在c++11已经废弃，现在用<strong>unique_ptr</strong>替代</p>
<a id="more"></a>

<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>auto_ptr出现的意义就是它是一个类，可以利用析构函数来释放内存，相当于内存守卫类。主要和unique_ptr的区别在于拷贝赋值的实现：</p>
<p><code>auto_ptr</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//auto_ptr拷贝构造函数</span></span><br><span class="line"><span class="built_in">auto_ptr</span>(auto_ptr&amp; __a) <span class="keyword">throw</span>() : _M_ptr(__a.<span class="built_in">release</span>()) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//operator =</span></span><br><span class="line">auto_ptr&amp;</span><br><span class="line">      <span class="keyword">operator</span>=(auto_ptr&amp; __a) <span class="built_in"><span class="keyword">throw</span></span>()</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">reset</span>(__a.<span class="built_in">release</span>());</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//release函数</span></span><br><span class="line">element_type*</span><br><span class="line">      <span class="built_in">release</span>() <span class="keyword">throw</span>()</span><br><span class="line">      &#123;</span><br><span class="line">        element_type* __tmp = _M_ptr;</span><br><span class="line">        _M_ptr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> __tmp;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p><code>unique_ptr</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Move constructors.</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>(unique_ptr&amp;&amp; __u) <span class="keyword">noexcept</span></span><br><span class="line">    : _M_t(__u.<span class="built_in">release</span>(), std::forward&lt;deleter_type&gt;(__u.<span class="built_in">get_deleter</span>())) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Disable copy from lvalue.</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>(<span class="keyword">const</span> unique_ptr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    unique_ptr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> unique_ptr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//release</span></span><br><span class="line">      pointer</span><br><span class="line">      <span class="built_in">release</span>() <span class="keyword">noexcept</span></span><br><span class="line">      &#123;</span><br><span class="line">        pointer __p = <span class="built_in">get</span>();</span><br><span class="line">        std::get&lt;<span class="number">0</span>&gt;(_M_t) = <span class="built_in">pointer</span>();</span><br><span class="line">        <span class="keyword">return</span> __p;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>这样做的考虑是：</p>
<ul>
<li>将auto_ptr可能的运行期错误在编译期暴露出来(悬空指针)</li>
<li>unique_ptr是move-only的</li>
<li>unique_ptr支持数组元素作为模板( class unique_ptr&lt;_Tp[], _Dp&gt;)</li>
</ul>
<p>好多地方说的很多，其实主要区别就是这样，至于其他的一些东西可能是无关本身的，引入了其他新的概念。真正麻烦的是shared_ptr,以后总结</p>
<h2 id="deletor"><a href="#deletor" class="headerlink" title="deletor"></a>deletor</h2><p>todo</p>
<h2 id="ENDDING"><a href="#ENDDING" class="headerlink" title="ENDDING"></a>ENDDING</h2><p><img src="https://i.loli.net/2020/07/09/qcEvis3TUwhJ4bZ.jpg" alt="070902.jpg"></p>
]]></content>
      <tags>
        <tag>c++11</tag>
      </tags>
  </entry>
  <entry>
    <title>c++11类型推导</title>
    <url>/2020-07-09-c++11%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="">effective modern c++</a></p>
<blockquote>
<p><a href="https://medium.com/@tjsw/%E6%BD%AE-c-11-universal-reference-rvalue-reference-move-semantics-1ea29f8cabdc">https://medium.com/@tjsw/%E6%BD%AE-c-11-universal-reference-rvalue-reference-move-semantics-1ea29f8cabdc</a></p>
</blockquote>
<p><a href="https://www.devbean.net/2012/05/cpp11-decltype/">C++11 新特性：decltype</a></p>
<a id="more"></a>

<h2 id="模板类型推导"><a href="#模板类型推导" class="headerlink" title="模板类型推导"></a>模板类型推导</h2><p>函数模板可以看成是这样：</p>
<pre><code>template&lt;typename T&gt;
void f(ParamType param);
ParamType param = expr</code></pre>
<p>分三种情况：</p>
<ul>
<li>ParamType是一个指针或者引用(非通用universal reference引用)</li>
<li>ParamType是一个通用引用(universal reference)</li>
<li>ParamType既不是指针也不是引用</li>
</ul>
<p>三种情况的推导规则：(推导规则推导的是T的类型)</p>
<p><code>1</code> ParamType是一个指针或者引用(非通用universal reference引用)</p>
<ul>
<li>如果expr的类型是引用，忽略引用的部分</li>
<li>根据expr和ParamType对比来判断T的类型</li>
</ul>
<p><code>2</code> ParamType是一个通用引用(universal reference)</p>
<ul>
<li>如果expr是个左值，T和ParamType都会被推导成左值引用</li>
<li>如果expr是个右值，参考情况1</li>
</ul>
<p><code>3</code> ParamType既不是指针也不是引用</p>
<ul>
<li>如果expr的类型是引用，忽略引用的部分</li>
<li>expr是cv的，也要忽略cv类型</li>
</ul>
<p>实际测试：</p>
<h3 id="case-1"><a href="#case-1" class="headerlink" title="case 1"></a>case 1</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>; <span class="comment">// param是一个引用类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rx = x;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);   <span class="comment">//T: int             param: int &amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx);  <span class="comment">//T: const int       param: const int &amp;</span></span><br><span class="line"><span class="built_in">f</span>(rx);  <span class="comment">//T: const int       param: const int &amp;</span></span><br></pre></td></tr></table></figure>

<h3 id="case-2"><a href="#case-2" class="headerlink" title="case 2"></a>case 2</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rx = x;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);       <span class="comment">//T: int &amp;          param: int &amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx);      <span class="comment">//T: const int &amp;    param: const int &amp;</span></span><br><span class="line"><span class="built_in">f</span>(rx);      <span class="comment">//T: const int &amp;    param: const int &amp;</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">27</span>);      <span class="comment">//T: int&amp;&amp;          param: int &amp;&amp;</span></span><br></pre></td></tr></table></figure>

<h3 id="引用折叠-Reference-collapsing"><a href="#引用折叠-Reference-collapsing" class="headerlink" title="引用折叠(Reference collapsing)"></a>引用折叠(Reference collapsing)</h3><pre><code>A＆＆       --&gt; A＆
A＆&amp;&amp;       --&gt; A＆
A&amp;&amp;＆       --&gt; A＆
A&amp;&amp; &amp;&amp;      --&gt; A&amp;&amp;</code></pre>
<p>case2的param经过了引用折叠：</p>
<pre><code>int &amp; &amp;&amp;            --&gt;     int &amp;
const int &amp; &amp;&amp;      --&gt;     const int &amp;
const int &amp; &amp;&amp;      --&gt;     const int &amp;
int &amp;&amp; &amp;&amp;           --&gt;     int &amp;&amp;</code></pre>
<h3 id="case-3"><a href="#case-3" class="headerlink" title="case 3"></a>case 3</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rx = x;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);       <span class="comment">//T: int        param:int</span></span><br><span class="line"><span class="built_in">f</span>(cx);      <span class="comment">//T: int        param:int</span></span><br><span class="line"><span class="built_in">f</span>(rx);      <span class="comment">//T: int        param:int</span></span><br></pre></td></tr></table></figure>

<h3 id="数组参数"><a href="#数组参数" class="headerlink" title="数组参数"></a>数组参数</h3><p>数组会退化为指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> name[] = <span class="string">&quot;J. P. Briggs&quot;</span>; <span class="comment">// name的类型是const char[13] </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * ptrToName = name;      <span class="comment">//数组退化成指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;</span><br><span class="line"><span class="built_in">f</span>(name);        <span class="comment">//T: const char*</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>数组的引用会保留为数组形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> name[] = <span class="string">&quot;J. P. Briggs&quot;</span>; <span class="comment">// name的类型是const char[13] </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T &amp;param)</span></span>;</span><br><span class="line"><span class="built_in">f</span>(name);        <span class="comment">//T: const char[13]  param: const char (&amp;)[13]</span></span><br></pre></td></tr></table></figure>

<h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>函数类型退化成函数指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunc</span><span class="params">(<span class="keyword">int</span>， <span class="keyword">double</span>)</span></span>;    <span class="comment">//void (int, double)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(T param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f1</span>(someFunc);       <span class="comment">//T: void (*)(int, double)</span></span><br></pre></td></tr></table></figure>

<p>函数引用会保留为函数形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunc</span><span class="params">(<span class="keyword">int</span>， <span class="keyword">double</span>)</span></span>;    <span class="comment">//void (int, double)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f2</span>(someFunc);       <span class="comment">//T: void (&amp;)(int, double)</span></span><br></pre></td></tr></table></figure>

<h2 id="auto类型推导"><a href="#auto类型推导" class="headerlink" title="auto类型推导"></a>auto类型推导</h2><p><strong>auto</strong>类型推导和模板类型推导基本一致，auto相当于T,只有一个例外:{}</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> x1 = <span class="number">27</span>;       <span class="comment">//auto: int </span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">x2</span><span class="params">(<span class="number">27</span>)</span></span>;        <span class="comment">//auto: int</span></span><br><span class="line"><span class="keyword">auto</span> x3 = &#123;<span class="number">27</span>&#125;;     <span class="comment">//auto: std::initializer_list&lt;int&gt;</span></span><br><span class="line"><span class="keyword">auto</span> x4&#123; <span class="number">27</span> &#125;;      <span class="comment">//auto: std::initializer_list&lt;int&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> x5 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3.0</span> &#125;;    <span class="comment">//编译失败，类型不一致</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h2><p><strong>decltype</strong>可以表示变量或者表达式的类型</p>
<p>使用方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(expr) a;   </span><br></pre></td></tr></table></figure>

<p>注意点：</p>
<blockquote>
<p>对一个变量名使用 decltype 得到这个变量名的声明类型。变量名属于左值表达式，但这并不 影响 decltype 的行为。然而，对于一个比变量名更复杂的左值表达式， decltype 保证返回 的类型是左值引用</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x) a;      <span class="comment">//a: int</span></span><br><span class="line"><span class="keyword">decltype</span>((x)) a;    <span class="comment">//a: int &amp;</span></span><br></pre></td></tr></table></figure>

<h2 id="尾随返回值类型"><a href="#尾随返回值类型" class="headerlink" title="尾随返回值类型"></a>尾随返回值类型</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//c++11版本</span></span><br><span class="line"><span class="comment">//auto作为函数返回值，不能推导出c和i的类型，因为这时候c和i还没有声明</span></span><br><span class="line"><span class="comment">//通过--&gt; decltype(c[i])表示函数返回值类型在函数参数后声明</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">authAndAccess</span><span class="params">(Container&amp; c, Index i)</span></span></span><br><span class="line">-&gt; decltype(c[i])</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">authenticateUser</span>();</span><br><span class="line">  <span class="keyword">return</span> c[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//c++14版本</span></span><br><span class="line"><span class="comment">//c++14这样是可以编译过的，但是auto进行了类型推导并不和c[i]类型一致</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">authAndAccess</span><span class="params">(Container &amp;c, Index i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">authenticateUser</span>();</span><br><span class="line">    <span class="keyword">return</span> c[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//c++14版本</span></span><br><span class="line"><span class="comment">//返回值类型和c[i]保持一致</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;  </span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">authAndAccess</span><span class="params">(Container &amp;c, Index i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">authenticateUser</span>();</span><br><span class="line">    <span class="keyword">return</span> c[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用完美转发更好，以后总结完美转发</span></span><br></pre></td></tr></table></figure>

<h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> &amp;&amp;j = <span class="built_in"><span class="keyword">int</span></span>();</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">auto</span> &amp;&amp;b = std::<span class="built_in">move</span>(a);</span><br><span class="line">    <span class="keyword">auto</span> &amp;&amp;c = j;</span><br><span class="line">    j = <span class="number">90</span>;</span><br><span class="line">    cout &lt;&lt; &amp;j &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//dd&lt;decltype(j)&gt; s;  //dd&lt;int&amp;&amp;&gt; s</span></span><br><span class="line">    <span class="comment">//dd&lt;decltype(std::move(a))&gt; s;   //dd&lt;int&amp;&amp;&gt; s</span></span><br><span class="line">    <span class="comment">//dd&lt;decltype(b)&gt; s;  //dd&lt;int&amp;&amp;&gt; s</span></span><br><span class="line">    <span class="comment">//dd&lt;decltype(c)&gt; s;  //dd&lt;int&amp;&gt; s</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>j是左值，类似函数实参(形参是右值的，实参是左值；有名的右值引用是左值)。auto &amp;&amp;这种就是模板的perfect reference</p>
<h2 id="ENDDING"><a href="#ENDDING" class="headerlink" title="ENDDING"></a>ENDDING</h2><p><img src="https://i.loli.net/2020/07/09/RhsqPkb9vg3rKD8.jpg" alt="070901.jpg"></p>
]]></content>
      <tags>
        <tag>c++11</tag>
      </tags>
  </entry>
  <entry>
    <title>unix域套接字</title>
    <url>/2020-07-09-unix%E5%9F%9F%E5%A5%97%E6%8E%A5%E5%AD%97/</url>
    <content><![CDATA[<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="">unp v1</a></p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>wikipedia的解释：</p>
<blockquote>
<p>Unix domain socket 或者 IPC socket是一种终端，可以使同一台操作系统上的两个或多个进程进行数据通信。与管道相比，Unix domain sockets 既可以使用字节流，又可以使用数据队列，而管道通信则只能使用字节流。Unix domain sockets的接口和Internet socket很像，但它不使用网络底层协议来通信。Unix domain socket 的功能是POSIX操作系统里的一种组件。</p>
</blockquote>
<blockquote>
<p>Unix domain sockets 使用系统文件的地址来作为自己的身份。它可以被系统进程引用。所以两个进程可以同时打开一个Unix domain sockets来进行通信。不过这种通信方式是发生在系统内核里而不会在网络里传播。</p>
</blockquote>
<a id="more"></a>

<h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><p><code>server</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> listfd = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> connfd = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">socklen_t</span> clilen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">cliaddr</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">seraddr</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">	listfd = <span class="built_in">socket</span>(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">unlink</span>(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	seraddr.sun_family = AF_UNIX;</span><br><span class="line">	<span class="built_in">strncpy</span>(seraddr.sun_path, argv[<span class="number">1</span>], <span class="built_in"><span class="keyword">sizeof</span></span>(seraddr.sun_path) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">bind</span>(listfd, (sockaddr *)&amp;seraddr, <span class="built_in"><span class="keyword">sizeof</span></span>(seraddr));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">listen</span>(listfd, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">	clilen = <span class="built_in"><span class="keyword">sizeof</span></span>(cliaddr);</span><br><span class="line">	connfd = <span class="built_in">accept</span>(listfd, (sockaddr *)&amp;cliaddr, &amp;clilen);</span><br><span class="line">	<span class="keyword">if</span> (connfd &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		n = <span class="built_in">read</span>(connfd, buf, <span class="number">256</span>);</span><br><span class="line">		cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">			<span class="built_in">write</span>(connfd, buf, n);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span> &amp;&amp; errno == EINTR)</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;EINTR&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;read err!&quot;</span> &lt;&lt; endl;	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>client</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> sockfd = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">seraddr</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">	sockfd = <span class="built_in">socket</span>(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	seraddr.sun_family = AF_UNIX;</span><br><span class="line">	<span class="built_in">strncpy</span>(seraddr.sun_path, argv[<span class="number">1</span>], <span class="built_in"><span class="keyword">sizeof</span></span>(seraddr.sun_path) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ret = <span class="built_in">connect</span>(sockfd, (sockaddr *)&amp;seraddr, <span class="built_in"><span class="keyword">sizeof</span></span>(seraddr));</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; buf)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">write</span>(sockfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">		n = <span class="built_in">read</span>(sockfd, buf, <span class="number">256</span> - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;rsp: &quot;</span> &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (n &lt; <span class="number">0</span> &amp;&amp; errno == EINTR)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;read err!&quot;</span> &lt;&lt; endl;	</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<pre><code>[root@riverwang1591252165612-0 ]# ./client /tmp/unixfd 
111
rsp: 111
sss
rsp: sss
aaaaaaaa
rsp: aaaaaaaa
zzzzzzzzzzzz
rsp: zzzzzzzzzzzz</code></pre>
<h2 id="ENDDING"><a href="#ENDDING" class="headerlink" title="ENDDING"></a>ENDDING</h2><p><img src="https://i.loli.net/2020/07/09/cTyBvbJ9ZO5idWE.jpg" alt="070903.jpg"></p>
]]></content>
      <tags>
        <tag>unix</tag>
      </tags>
  </entry>
  <entry>
    <title>enum class</title>
    <url>/2020-07-12-enum%20class/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="">effective modern c++</a></p>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="区别1-限定作用域"><a href="#区别1-限定作用域" class="headerlink" title="区别1 限定作用域"></a>区别1 限定作用域</h3><p>c++98风格的enum类型的作用域：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">data</span> &#123;</span></span><br><span class="line">	one,</span><br><span class="line">	two,</span><br><span class="line">	three,</span><br><span class="line">	max</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> one;    <span class="comment">//错误	C2365	“one”: 重定义；以前的定义是“枚举数”	</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举{}内的名字的作用域是在{}外面的范围内的。也叫做不限定作用域的枚举值。</p>
<p>c++11风格的enum类型的作用域：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">data</span> &#123;</span></span><br><span class="line">	one,</span><br><span class="line">	two,</span><br><span class="line">	three,</span><br><span class="line">	max</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> one;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	::data a = data::one;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举{}内的名字的作用域是在{}内部的范围内的，也叫做限定作用域的枚举值。</p>
<h3 id="区别2-提前声明"><a href="#区别2-提前声明" class="headerlink" title="区别2 提前声明"></a>区别2 提前声明</h3><p>c++98风格的枚举没有默认的型别，会根据实际表示范围决定采用合适的容得下的类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">data</span> &#123;</span></span><br><span class="line">		one = <span class="number">0</span>,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">data2</span> &#123;</span></span><br><span class="line">		one2,</span><br><span class="line">		two2,</span><br><span class="line">		three2,</span><br><span class="line">		max2 = <span class="number">0XFFFFFFFF</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(data) &lt;&lt; endl;   <span class="comment">//4</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(data2) &lt;&lt; endl;  <span class="comment">//4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个没有复现出来，不知道是不是因为字节对齐导致的还是什么原因，98，03，11编译后的结果都是4.按照书里的意思，98版本的枚举要根据实际范围决定采用什么类型，所以不能提前声明，具体如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">data</span>;</span>  <span class="comment">//gcc：错误：使用枚举‘data’前没有给出声明</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">data</span> &#123;</span></span><br><span class="line">	one = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>c++11可以显示指定类型，并且enum class有默认的类型int</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">data</span>:</span><span class="keyword">uint8_t</span>;  <span class="comment">//声明必须显示指定类型</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">data</span>:</span><span class="keyword">uint8_t</span> &#123;</span><br><span class="line">	one = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(::data) &lt;&lt; endl; <span class="comment">//1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">data</span>;</span>    <span class="comment">//声明可以不指定类型，默认int</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">data</span>&#123;</span></span><br><span class="line">	one = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(::data) &lt;&lt; endl; <span class="comment">//4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="区别3-隐式类型转换"><a href="#区别3-隐式类型转换" class="headerlink" title="区别3 隐式类型转换"></a>区别3 隐式类型转换</h3><p>98风格的枚举会有隐式类型转换，c++11版本的不会隐式类型转换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">data98</span>&#123;</span></span><br><span class="line">	one = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">data11</span> &#123;</span></span><br><span class="line">	max = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">size_t</span> param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	data98 d98;</span><br><span class="line">	data11 d11;</span><br><span class="line">	<span class="built_in">func</span>(d98);  <span class="comment">//ok</span></span><br><span class="line">	<span class="built_in">func</span>(d11);  <span class="comment">//error </span></span><br><span class="line">    <span class="comment">//错误(活动)	E0167	&quot;data11&quot; 类型的实参与 &quot;size_t&quot; 类型的形参不兼容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/07/12/tbQPsYxE6IThNKG.jpg" alt="2020071202.jpg"></p>
]]></content>
      <tags>
        <tag>c++11</tag>
      </tags>
  </entry>
  <entry>
    <title>override final</title>
    <url>/2020-07-12-override%20final/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>函数重载有以下要求：</p>
<ul>
<li>基类中的函数必须是虚函数</li>
<li>基类和派生类中的函数名字必须完全相同(析构函数例外)、</li>
<li>基类和派生类中的函数形参型别必须完全相同</li>
<li>基类和派生类中的函数常量性必须完全相同</li>
<li>基类和派生类中的函数返回值和异常规格必须兼容</li>
</ul>
<a id="more"></a>

<p>c++11又多了一条：</p>
<ul>
<li>基类和派生类中的函数引用饰词必须完全相同</li>
</ul>
<h2 id="引用饰词"><a href="#引用饰词" class="headerlink" title="引用饰词"></a>引用饰词</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mydata</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">mydata</span>() &#123; cout &lt;&lt; <span class="string">&quot;constructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">mydata</span>() &#123; cout &lt;&lt; <span class="string">&quot;destructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="built_in">mydata</span>(mydata &amp;&amp; param) &#123; cout &lt;&lt; <span class="string">&quot;move constructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="built_in">mydata</span>(mydata &amp; param) &#123; cout &lt;&lt; <span class="string">&quot;copy constructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	mydata <span class="keyword">operator</span> =(mydata &amp;&amp; param) &#123; cout &lt;&lt; <span class="string">&quot;move operator = &quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myclass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	mydata _m;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">myclass</span>():_m()</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">mydata&amp; <span class="title">data</span><span class="params">()</span> &amp;	<span class="comment">//*this是左值才调用</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;--data() &amp;&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;_m;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">mydata <span class="title">data</span><span class="params">()</span> &amp;&amp;	<span class="comment">//*this是右值才调用</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;--data() &amp;&amp;&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> std::<span class="built_in">move</span>(<span class="keyword">this</span>-&gt;_m);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">myclass <span class="title">makemyclass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">myclass</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	myclass my;</span><br><span class="line">	<span class="keyword">auto</span> a1 = my.<span class="built_in">data</span>();</span><br><span class="line">	<span class="keyword">auto</span> a2 = <span class="built_in">makemyclass</span>().<span class="built_in">data</span>();</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="override"><a href="#override" class="headerlink" title="override"></a>override</h2><p>c++11允许在派生类的成员函数末尾添加override,表明派生类将要重写该函数，编译器会校验重写的规则，避免了一些隐晦的含义。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;base: virtual void func1() const&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;base: virtual void func2(int x)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span> &amp; </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;base: virtual void func3() &amp;&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func4</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;base: void func4() const&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span> :</span> <span class="keyword">public</span> base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;derived: virtual void func1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;derived: virtual void func2(unsigned int x)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span> &amp;&amp; </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;derived: virtual void func3() &amp;&amp;&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func4</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;derived: void func4() const&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived2</span> :</span> <span class="keyword">public</span> base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> <span class="keyword">override</span></span>;					<span class="comment">//error</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> x)</span> <span class="keyword">override</span></span>;	<span class="comment">//error</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span> &amp;&amp; <span class="keyword">override</span></span>;				<span class="comment">//error</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func4</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;					<span class="comment">//error</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived3</span> :</span> <span class="keyword">public</span> base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;	<span class="comment">//ok	</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">override</span></span>;		<span class="comment">//ok</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span> &amp; <span class="keyword">override</span></span>;		<span class="comment">//ok	</span></span><br><span class="line">	<span class="comment">//void func4() const override;	//需要修改基类				</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">derived <span class="title">makederived</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">derived</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	derived der;</span><br><span class="line">	base *bas = &amp;der;</span><br><span class="line"></span><br><span class="line">	bas-&gt;<span class="built_in">func1</span>();		<span class="comment">//base: virtual void func1() const	</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">	bas-&gt;<span class="built_in">func2</span>(x);		<span class="comment">//base : virtual void func2(int x)</span></span><br><span class="line"></span><br><span class="line">	bas-&gt;<span class="built_in">func3</span>();		<span class="comment">//base : virtual void func3() &amp;</span></span><br><span class="line"></span><br><span class="line">	bas-&gt;<span class="built_in">func4</span>();		<span class="comment">//base : void func4() const</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><ul>
<li>final跟在类定义后面，表示该类不能被继承：class test1 final </li>
<li>final不能修饰非虚函数</li>
<li>final在基类的虚函数后面，表示派生类不可以重载该函数</li>
<li>final在派生类的虚函数后面，表示派生类的其他派生类不能重载该派生类的此函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> :</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//#a</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">final</span></span>; <span class="comment">// Base::foo is overridden and A::foo is the final override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> <span class="keyword">final</span></span>; <span class="comment">// Error: bar cannot be final as it is non-virtual</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> <span class="keyword">final</span> :</span> A <span class="comment">// struct B is final</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">// Error: foo cannot be overridden as it is final in A</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span> :</span> B <span class="comment">// Error: B is final</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于上面#a的解释:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;base: foo()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> :</span> Base</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">final</span> <span class="comment">// Base::foo is overridden and A::foo is the final override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;A: foo()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//void bar() final; // Error: bar cannot be final as it is non-virtual</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	Base *p = &amp;a;</span><br><span class="line">	p-&gt;<span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>A: foo()</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>override与final都不是语言关键字（keyword），只有在特定的位置才有特别含意，其他地方仍旧可以作为一般指示字（identifier）使用。override仅出现在成员函数的末尾才有意义。其他地方使用意义就变了：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">override</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;override&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>为意在重写的函数添加override</li>
<li>成员函数引用饰词使得对于左值和右值对象(*this)的处理能够区分开来</li>
</ul>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/07/12/k9M46YErlUTFHAz.jpg" alt="2020071203_lit.jpg">      </p>
]]></content>
      <tags>
        <tag>c++11</tag>
      </tags>
  </entry>
  <entry>
    <title>typedef using</title>
    <url>/2020-07-12-typedef%20using/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://feihu.me/blog/2014/the-origin-and-usage-of-typename/">知无涯之C++ typename的起源与用法</a></p>
<p><a href="https://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-the-template-and-typename-keywords/613132#613132">为什么必须在何处以及为什么要放置“模板”和“类型名”关键字？
</a></p>
<p><a href="">effective modern c++</a></p>
<p><a href="https://zh.wikipedia.org/wiki/Typedef">wikipedia typedef</a></p>
<p><a href="https://zh.wikipedia.org/wiki/Typename">wikipedia typename</a></p>
<p><a href="https://wizardforcel.gitbooks.io/cpp-11-faq/55.html">c++11FAQ</a></p>
<a id="more"></a>

<h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2><blockquote>
<p>在C和C++编程语言中，typedef是一个关键字。它用来对一个数据类型取一个别名，目的是为了使源代码更易于阅读和理解。它通常用于简化声明复杂的类型组成的结构 ，但它也常常在各种长度的整数数据类型中看到，例如size_t和time_t。</p>
</blockquote>
<p><strong>定义数组</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> arrType[<span class="number">6</span>];    <span class="comment">// type name: arrType</span></span><br><span class="line">                            <span class="comment">// new type: char[6]</span></span><br><span class="line"></span><br><span class="line">arrType arr=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;  <span class="comment">// same as: char arr[6]=&#123;1,2,3,4,5,6&#125;</span></span><br><span class="line"></span><br><span class="line">arrType *pArr;              <span class="comment">// same as: char (*pArr)[6];</span></span><br></pre></td></tr></table></figure>

<p><strong>定义函数指针</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//old</span></span><br><span class="line"><span class="built_in"><span class="keyword">void</span></span> (*<span class="built_in">signal</span>(<span class="keyword">int</span> sig, <span class="built_in"><span class="keyword">void</span></span> (*func)(<span class="keyword">int</span>)))(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//new</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> sig, <span class="keyword">sighandler_t</span> func)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>类型转换</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//old</span></span><br><span class="line"><span class="keyword">void</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*x)(<span class="keyword">double</span>)  = (<span class="built_in"><span class="keyword">int</span></span> (*)(<span class="keyword">double</span>)) p; <span class="comment">// This is legal</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*)(<span class="keyword">double</span>) y = (<span class="built_in"><span class="keyword">int</span></span> (*)(<span class="keyword">double</span>)) p; <span class="comment">// Left-hand side is not legal</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*z)(<span class="keyword">double</span>)  = (<span class="built_in"><span class="keyword">int</span></span> (*p)(<span class="keyword">double</span>));  <span class="comment">// Right-hand side is not legal</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//new</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*funcptr)</span><span class="params">(<span class="keyword">double</span>)</span></span>;         <span class="comment">// pointer to function taking a double returning int</span></span><br><span class="line">funcptr x = (funcptr) <span class="literal">NULL</span>;             <span class="comment">// C or C++</span></span><br><span class="line">funcptr y = <span class="built_in">funcptr</span>(<span class="literal">NULL</span>);              <span class="comment">// C++ only</span></span><br><span class="line">funcptr z = <span class="keyword">static_cast</span>&lt;funcptr&gt;(<span class="literal">NULL</span>); <span class="comment">// C++ only</span></span><br></pre></td></tr></table></figure>

<h2 id="using"><a href="#using" class="headerlink" title="using"></a>using</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span>&gt;</span><br><span class="line"><span class="comment">// idea: int_exact_trait&lt;N&gt;::type用于表达含有N个bit的数值类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">int_exact_traits</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">int</span> type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">int_exact_traits</span>&lt;</span><span class="number">8</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">char</span> type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">int_exact_traits</span>&lt;</span><span class="number">16</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">char</span>[<span class="number">2</span>] type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> N&gt;</span><br><span class="line"><span class="comment">// 定义别名用以简化书写</span></span><br><span class="line"><span class="comment">// 译注：给模板的通用版本取别名，则其所有的特化版本自动获得该别名，</span></span><br><span class="line"><span class="comment">//    例如对于8bit的特化版本，现在可直接使用别名</span></span><br><span class="line">    <span class="keyword">using</span> int_exact = <span class="keyword">typename</span> int_exact_traits&lt;N&gt;::type;</span><br><span class="line">    <span class="comment">// int_exact&lt;8&gt; 是含有8个bit的数值类型</span></span><br><span class="line">int_exact&lt;<span class="number">8</span>&gt; a = <span class="number">7</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>除了在模板方面身担重任外，using语法也可作为对普通类型定义别名的另一种选择（相较于typedef更合吾意）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*PFD)</span><span class="params">(<span class="keyword">double</span>)</span></span>;    <span class="comment">// C 样式</span></span><br><span class="line"><span class="keyword">using</span> PF = <span class="built_in"><span class="keyword">void</span></span> (*)(<span class="keyword">double</span>);    <span class="comment">// using加上C样式的类型</span></span><br><span class="line"><span class="keyword">using</span> P = [](<span class="keyword">double</span>)-&gt;<span class="keyword">void</span>;  <span class="comment">// using和函数返回类型后置语法</span></span><br></pre></td></tr></table></figure>

<h2 id="typename"><a href="#typename" class="headerlink" title="typename"></a>typename</h2><p><strong>input</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> T&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 声明一个指向某个类型为T::bar的对象的指针</span></span><br><span class="line">   T::bar * p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StructWithBarAsType</span> &#123;</span></span><br><span class="line">   <span class="keyword">typedef</span> <span class="keyword">int</span> bar;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StructWithBarAsValue</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> bar;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   StructWithBarAsType x;</span><br><span class="line">   <span class="built_in">foo</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>output</strong></p>
<pre><code>错误    C3861    “p”: 找不到标识符    </code></pre>
<blockquote>
<p>A name used in a template declaration or definition and that is dependent on a template-parameter is assumed not to name a type unless the applicable name lookup finds a type name or the name is qualified by the keyword typename.</p>
</blockquote>
<p>意即出现上述歧义时(# if 0/ #if 1)，编译器将自动默认bar为一个变量名，而不是类型名</p>
<p>解决方案：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> T&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 声明一个指向某个类型为T::bar的对象的指针</span></span><br><span class="line">   <span class="keyword">typename</span> T::bar * p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显示的说明T::bar是个类型</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>1 typedef不能直接用于模板，需要具体化模板类型或者嵌套在struct里面：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;T&gt; vecint;   <span class="comment">//error	C2823	typedef 模板 非法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vec</span> &#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> vector&lt;T&gt; vecint;       <span class="comment">//ok</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="keyword">int</span>&gt; vecint;     <span class="comment">//ok</span></span><br></pre></td></tr></table></figure>

<p>2 </p>
<ul>
<li>c++带依赖型别前面加typename</li>
<li>typename仅允许在限定名称之前使用 </li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s1</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> vector&lt;T&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">//typename typedef s1&lt;T&gt;::type type2;   //ok</span></span><br><span class="line">	<span class="keyword">typedef</span> s1&lt;T&gt;::type type2;	<span class="comment">//警告	C4346	“type”: 依赖名称不是类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>::这个是罪魁祸首，因为::有好几种解释：</p>
<ul>
<li>静态成员</li>
<li>嵌套类/typedef</li>
</ul>
<p>这种定义含糊的就需要手动加typename</p>
<p>3 使用using的时候，编译器知道后面的是一个型别的名字，就相当于隐士的加了typename.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s1</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> vector&lt;T&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">//typename typedef s1&lt;T&gt;::type type2;</span></span><br><span class="line">	<span class="comment">//typedef s1&lt;T&gt;::type type2;</span></span><br><span class="line">	<span class="keyword">using</span>  type2 = <span class="keyword">typename</span> s1&lt;T&gt;::type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> t1 = vector&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> t2 = t1&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//gcc error   vs ok</span></span><br><span class="line">	<span class="keyword">using</span> t3 = <span class="keyword">typename</span> t1&lt;T&gt;;  <span class="comment">//gcc error：expected nested-name-specifier</span></span><br><span class="line">	<span class="comment">//using type3 =  t1&lt;T&gt;;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4 支持c++11以后的话，优先选择using </p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/07/12/Ri15EqtCyUveKIA.jpg" alt="2020071201.jpg"></p>
]]></content>
      <tags>
        <tag>c++11</tag>
      </tags>
  </entry>
  <entry>
    <title>constexpr</title>
    <url>/2020-07-13-constexpr/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zh.wikipedia.org/wiki/Constexpr">wiki</a></p>
<p><a href="https://www.zhihu.com/question/35614219">zhihu</a></p>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><blockquote>
<p>constexpr是C++11引入的关键字，用于编译时的常量与常量函数。</p>
</blockquote>
<blockquote>
<p>声明为constexpr函数的意义是：如果其参数均为合适的编译期常量，则对这个constexpr函数的调用就可用于期望常量表达式的场合（如模板的非类型参数，或枚举常量的值）。如果参数的值在运行期才能确定，或者虽然参数的值是编译期常量，但不匹配这个函数的要求，则对这个函数调用的求值只能在运行期进行。</p>
</blockquote>
<p>C++编译时可确定常量表达式的结果，因此可在编译时优化。C++规范在一些地方要求使用常量表达式，如声明数组的维数。但常量表达式不允许包含函数调用或者对象构造。因此下述代码无效：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// error: array bound is not an integer constant before ‘]’ token</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">get_five</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">5</span>;&#125;</span><br><span class="line"><span class="keyword">int</span> some_value[<span class="built_in">get_five</span>() + <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ok</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">get_five</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">5</span>;&#125;</span><br><span class="line"><span class="keyword">int</span> some_value[<span class="built_in">get_five</span>() + <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>constexpr的对象，必须是常量类型的，const则没要求(拷贝副本)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> s = a;    <span class="comment">//ok</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> ss = a;   <span class="comment">//error</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> ss = <span class="number">10</span>;  <span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c++11 constexpr函数必须满足下述限制：</p>
<ul>
<li>函数返回值不能是void类型</li>
<li>函数体不能声明变量或定义新的类型</li>
<li>函数体只能包含声明、null语句或者一条return语句</li>
<li>在形参实参结合后，return语句中的表达式为常量表达式</li>
</ul>
<p>C++14放松了这些限制。声明为constexpr的函数可以含有以下内容：[2]</p>
<p>任何声明，除了：</p>
<ul>
<li>static或thread_local变量。</li>
<li>没有初始化的变量声明。</li>
<li>条件分支语句if和switch。</li>
<li>所有的循环语句，包括基于范围的for循环。</li>
<li>表达式可以改变一个对象的值，只需该对象的生命期在声明为constexpr的函数内部开始。包括对有constexpr声明的任何非const非静态成员函数的调用。</li>
<li>goto仍然不允许在constexpr函数中出现。</li>
</ul>
<p>constexpr支持编译期的递归。例如，可以写一个constexpr函数计算斐波那契数列。</p>
<p>*<em>此外，C++11指出，所有被声明为constexpr的非静态成员函数也隐含声明为const（即函数不能修改</em>this的值）(函数尾部的const,只读函数)。C++14已经删除此点，非静态成员函数可以为非const。**</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _m = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x = <span class="number">0</span>)</span> <span class="keyword">const</span>   <span class="comment">//不能修改*this</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _m = <span class="number">2</span>; <span class="comment">//error: assignment of member ‘cc::_m’ in read-only object</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> x = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> ++_m ? x : x;     <span class="comment">// error: increment of member ‘cc::_m’ in read-only object</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>constexpr函数可以用在要求编译期常量的语境中。在这样的语境中，若你传给一个constexpr函数的实参值是在编译期已知的，则结果也会在编译期间计算出来。如果不能再编译期间计算得到，则编译不能通过</li>
<li>在调用constexpr函数时，若传入的值有一个或多个在编译期未知，则它的运作方式和普通函数无异，亦即它也是在运行期执行结果的计算。这意味着，如果函数执行的是同样的操作，仅仅应用的语境一个是要求在编译期常量的，一个是用于所有其他值的话，那就不用写两个函数。</li>
</ul>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/07/13/yfi7MInPUrA5jmx.png" alt="2020071301.png"></p>
]]></content>
      <tags>
        <tag>c++11</tag>
      </tags>
  </entry>
  <entry>
    <title>noexcept</title>
    <url>/2020-07-13-noexcept/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/qq_41453285/article/details/86737716">C++11：noexcept异常说明</a></p>
<p><a href="">effective modern c++</a></p>
<p><a href="https://zh.wikipedia.org/wiki/C%2B%2B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">wikipedia</a></p>
<p><a href="https://stackoverflow.com/questions/28598488/stdmove-if-noexcept-calls-copy-assignment-even-though-move-assignment-is-noexc">stackoverflow</a></p>
<a id="more"></a>

<h2 id="wiki"><a href="#wiki" class="headerlink" title="wiki"></a>wiki</h2><p>事实上，异常规格(throw这一特性在程序中很少被使用，因此在C++11中被弃用[2]。C++11定义了新的noexcept关键字。如果在函数声明后直接加上noexcept关键字，表示函数不会抛出异常。另外一种形式是noexcept关键字后跟常量表达式，其值转为布尔值，如果为真表示函数不会抛出异常，反之，则有可能抛出异常。</p>
<pre><code>returnType funcDeclaration (args) noexcept(常量表达式) ;</code></pre>
<p>如果保证不抛出异常的函数却实际上抛出异常，则会直接调用std::terminate中断程序的执行。</p>
<p>noexcept关键字还可以用作运算符，其后的操作数表达式如果有可能抛出异常，则运算符返回为false；如果操作数表达式保证不抛出异常，则运算符返回为true。这一运算符用于在定义模板函数时可以根据模板参数类型来确定是否传出异常。</p>
<p>对类析构函数，使用noexcept关键字也可以显式指明不剖出异常。类析构函数默认不抛出异常。如果声明为（或默认）不抛出异常的类析构函数在运行时抛出了异常，将导致调用std::terminate中断程序的执行。</p>
<p>以下两种等价：</p>
<pre><code>int f(x) throw();       //c++98
int f(x) noexcept();    //c++11</code></pre>
<p>性能上，noexcept可以让编译器做更多的优化，因此：</p>
<pre><code>int f(x) noexcept();    //最优化
int f(x) throw();       //优化不够
int f(x);               //优化不够</code></pre>
<h2 id="move-if-noexcept"><a href="#move-if-noexcept" class="headerlink" title="move_if_noexcept"></a>move_if_noexcept</h2><p>stl容器比如vector拥有强异常安全保证，比如vector重新调整大小的时候：</p>
<ul>
<li>分配原来两倍的大小</li>
<li>拷贝原来的数据到新的空间</li>
<li>析构原来的数据</li>
</ul>
<p>如果拷贝的过程出现异常，还可以还原到拷贝前的状态，放弃拷贝</p>
<p>c++11后有了移动操作，对于复制数据来说提升了性能，但可能导致强异常安全保证失效，因此只有在确保Move构造函数不会导致异常的情况下，容易才优先采用移动赋值函数而不是拷贝赋值函数，这里用到了move_if_noexcept</p>
<p>stackoverflow:</p>
<p>move_if_noexcept: move_if_move_ctor_is_noexcept_or_the_only_option</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">  <span class="built_in">A</span> ();</span><br><span class="line">  <span class="built_in">A</span> (A <span class="keyword">const</span>&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a1;</span><br><span class="line"><span class="function">A <span class="title">a2</span> <span class="params">(std::move_if_noexcept (a1))</span></span>; <span class="comment">// `A const&amp;` =&gt; copy-constructor</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">  <span class="built_in">B</span> ();</span><br><span class="line">  <span class="built_in">B</span> (B <span class="keyword">const</span>&amp;);</span><br><span class="line">  <span class="built_in">B</span> (B&amp;&amp;) <span class="keyword">noexcept</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">B b1;</span><br><span class="line"><span class="function">B <span class="title">b2</span> <span class="params">(std::move_if_noexcept (b1))</span></span>; <span class="comment">// `B&amp;&amp;` =&gt; move-constructor</span></span><br><span class="line">                                   <span class="comment">//          ^ it&#x27;s `noexcept`</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span> &#123;</span></span><br><span class="line">  <span class="built_in">C</span> ();</span><br><span class="line">  <span class="built_in">C</span> (C&amp;&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">C c1;</span><br><span class="line"><span class="function">C <span class="title">c2</span> <span class="params">(std::move_if_noexcept (c1))</span></span>; <span class="comment">// `C&amp;&amp;` =&gt; move-constructor</span></span><br><span class="line">                                   <span class="comment">//          ^ the only viable alternative</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> &#123;</span></span><br><span class="line">  <span class="built_in">C</span> ();</span><br><span class="line">  <span class="built_in">C</span> (C <span class="keyword">const</span>&amp;) <span class="keyword">noexcept</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">C c1;</span><br><span class="line"><span class="function">C <span class="title">c2</span> <span class="params">(std::move_if_noexcept (c1))</span></span>; <span class="comment">// C&amp;&amp; =&gt; copy-constructor</span></span><br><span class="line">                                   <span class="comment">//        ^ can be invoked with `T&amp;&amp;`</span></span><br></pre></td></tr></table></figure>

<hr>
<p>值得注意的地方是move_if_noexcept是针对于构造函数而言的，判断拷贝构造函数和移动构造函数的存在以及异常性来决定的。</p>
<p>测试下vector:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">t_no</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">t_no</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">t_no</span>(<span class="keyword">const</span> t_no &amp;)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">t_no</span>(t_no &amp;&amp;) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;move constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">t</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">t</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">t</span>(<span class="keyword">const</span> t &amp;)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">t</span>(t &amp;&amp;)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;move constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;t_no&gt; v1;</span><br><span class="line">    vector&lt;t&gt; v2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t_no a;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(a);</span><br><span class="line">        cout &lt;&lt; v1.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t a;</span><br><span class="line">        v2.<span class="built_in">push_back</span>(a);</span><br><span class="line">        cout &lt;&lt; v2.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">copy constructor</span><br><span class="line"><span class="number">1</span></span><br><span class="line">-------------------</span><br><span class="line">copy constructor</span><br><span class="line">move constructor</span><br><span class="line"><span class="number">2</span></span><br><span class="line">-------------------</span><br><span class="line">copy constructor</span><br><span class="line">move constructor</span><br><span class="line">move constructor</span><br><span class="line"><span class="number">4</span></span><br><span class="line">-------------------</span><br><span class="line">copy constructor</span><br><span class="line"><span class="number">1</span></span><br><span class="line">-------------------</span><br><span class="line">copy constructor</span><br><span class="line">copy constructor</span><br><span class="line"><span class="number">2</span></span><br><span class="line">-------------------</span><br><span class="line">copy constructor</span><br><span class="line">copy constructor</span><br><span class="line">copy constructor</span><br><span class="line"><span class="number">4</span></span><br><span class="line">-------------------</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>swap中对于底层对象noexcept的要求：</p>
<p>todo</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>析构函数，内存释放释放默认都是noexcept的，除非显示指定noexcept(false)</li>
</ul>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/07/12/1gUaSCK7wyGe2zx.jpg" alt="2020071205.jpg"></p>
]]></content>
      <tags>
        <tag>c++11</tag>
      </tags>
  </entry>
  <entry>
    <title>move forward</title>
    <url>/2020-07-14-move%20forward/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://en.cppreference.com/w/cpp/types/remove_reference">cppreference</a></p>
<a id="more"></a>

<h2 id="move"><a href="#move" class="headerlink" title="move"></a>move</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/// remove_reference</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span></span></span><br><span class="line"><span class="class">    &#123;</span> <span class="keyword">typedef</span> _Tp   type; &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&lt;</span>_Tp&amp;&gt;</span><br><span class="line">    &#123; <span class="keyword">typedef</span> _Tp   type; &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&lt;</span>_Tp&amp;&amp;&gt;</span><br><span class="line">    &#123; <span class="keyword">typedef</span> _Tp   type; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//std::move</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp;</span><br><span class="line">    <span class="built_in">move</span>(_Tp&amp;&amp; <span class="keyword">__t</span>) <span class="keyword">noexcept</span></span><br><span class="line">    &#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(<span class="keyword">__t</span>); &#125;</span><br></pre></td></tr></table></figure>

<p>std::move只保证转换成右值，并不保证一定可以移动。如下,const导致的问题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bb</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">bb</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">bb</span>(<span class="keyword">const</span> bb&amp;)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy construct&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bb</span>(bb &amp;&amp;)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;move construct&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_is_same</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::is_same&lt;T1, T2&gt;() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> bb p1;</span><br><span class="line">    bb p2 = std::<span class="built_in">move</span>(p1);  <span class="comment">//copy construct</span></span><br><span class="line">    print_is_same&lt;<span class="keyword">const</span> bb &amp;, <span class="keyword">decltype</span>(std::<span class="built_in">move</span>(p1))&gt;();   <span class="comment">//0</span></span><br><span class="line">    print_is_same&lt;bb &amp;&amp;, <span class="keyword">decltype</span>(std::<span class="built_in">move</span>(p1))&gt;();        <span class="comment">//0</span></span><br><span class="line">    print_is_same&lt;<span class="keyword">const</span> bb &amp;&amp;, <span class="keyword">decltype</span>(std::<span class="built_in">move</span>(p1))&gt;();  <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp; a = std::<span class="built_in">move</span>(b);   <span class="comment">//const左值引用可以赋值为const的右值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="forward"><a href="#forward" class="headerlink" title="forward"></a>forward</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *  @brief  Forward an lvalue.</span></span><br><span class="line"><span class="comment">  *  @return The parameter cast to the specified type.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  *  This function is used to implement &quot;perfect forwarding&quot;.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">   <span class="keyword">constexpr</span> _Tp&amp;&amp;</span><br><span class="line">   forward(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp; <span class="keyword">__t</span>) <span class="keyword">noexcept</span></span><br><span class="line">   &#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="keyword">__t</span>); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *  @brief  Forward an rvalue.</span></span><br><span class="line"><span class="comment">  *  @return The parameter cast to the specified type.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  *  This function is used to implement &quot;perfect forwarding&quot;.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">   <span class="keyword">constexpr</span> _Tp&amp;&amp;</span><br><span class="line">   forward(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp; <span class="keyword">__t</span>) <span class="keyword">noexcept</span></span><br><span class="line">   &#123;</span><br><span class="line">     <span class="built_in"><span class="keyword">static_assert</span></span>(!std::is_lvalue_reference&lt;_Tp&gt;::value, <span class="string">&quot;template argument&quot;</span></span><br><span class="line">	    <span class="string">&quot; substituting _Tp is an lvalue reference type&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="keyword">__t</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="完美转发推导"><a href="#完美转发推导" class="headerlink" title="完美转发推导"></a>完美转发推导</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">makeint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in"><span class="keyword">int</span></span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; param)</span></span>&#123;</span><br><span class="line">    <span class="comment">//test(std::forward&lt;T&gt;(param));</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按书上的说法，右值引用经由通用引用后的T是int,这样推导的话forward没有用到第二种实现</span></span><br><span class="line"><span class="comment">//网上有的地方说T是int&amp;&amp;,第二种forward的实现就用到了，做个问题留下来以后再说吧</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//rvalue</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="built_in">makeint</span>());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    <span class="comment">//makeint()返回右值： int &amp;&amp;</span></span><br><span class="line">    <span class="comment">//T推导成int</span></span><br><span class="line">    <span class="comment">//完美转发</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="keyword">int</span>&gt;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span>&amp;&amp;</span><br><span class="line">    forward(<span class="keyword">typename</span> std::remove_reference&lt;<span class="keyword">int</span>&gt;::type&amp; <span class="keyword">__t</span>) <span class="keyword">noexcept</span></span><br><span class="line">    &#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&amp;&amp;&gt;(<span class="keyword">__t</span>); &#125;</span><br><span class="line">    <span class="comment">//转换</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span>&amp;&amp;</span><br><span class="line">    forward(<span class="keyword">typename</span> <span class="keyword">int</span>&amp; <span class="keyword">__t</span>) <span class="keyword">noexcept</span></span><br><span class="line">    &#123; <span class="keyword">return</span> <span class="keyword">int</span>&amp;&amp;(<span class="keyword">__t</span>); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//lvalue</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">func</span>(a);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    <span class="comment">//a是左值</span></span><br><span class="line">    <span class="comment">//T推导成int &amp;</span></span><br><span class="line">    <span class="comment">//完美转发</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="keyword">int</span>&amp;&gt;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span>&amp;&amp;&amp;</span><br><span class="line">    forward(<span class="keyword">typename</span> std::remove_reference&lt;<span class="keyword">int</span>&amp;&gt;::type&amp; <span class="keyword">__t</span>) <span class="keyword">noexcept</span></span><br><span class="line">    &#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&amp;&amp;&amp;&gt;(<span class="keyword">__t</span>); &#125;</span><br><span class="line">    <span class="comment">//转换</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span>&amp;</span><br><span class="line">    forward(<span class="keyword">typename</span> <span class="keyword">int</span>&amp; <span class="keyword">__t</span>) <span class="keyword">noexcept</span></span><br><span class="line">    &#123; <span class="keyword">return</span> <span class="keyword">int</span>&amp;(<span class="keyword">__t</span>); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h2><p>引用折叠针对的是引用(a)的引用(b),a/b有一个是左值则结果是左值，反之是右值</p>
<h2 id="引用折叠出现的场景"><a href="#引用折叠出现的场景" class="headerlink" title="引用折叠出现的场景"></a>引用折叠出现的场景</h2><ul>
<li>模板实例化(通用引用)</li>
<li>auto型别生成</li>
<li>创建和运用typedef</li>
<li>decltype</li>
</ul>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/07/15/mODM1YSavlnAGLq.jpg" alt="2020071501.jpg"></p>
]]></content>
      <tags>
        <tag>c++11</tag>
      </tags>
  </entry>
  <entry>
    <title>特殊成员函数</title>
    <url>/2020-07-15-%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><h3 id="num-1"><a href="#num-1" class="headerlink" title="num 1"></a>num 1</h3><ul>
<li>移动构造(赋值)函数，也会调用其基类的移动构造(赋值)函数(如果有的话);</li>
</ul>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">base</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">base</span>(base &amp;)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;base: copy constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">base</span>(base &amp;&amp;) <span class="keyword">noexcept</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;base: move constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span>:</span><span class="keyword">public</span> base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">derived</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">derived</span>(derived &amp; param):<span class="built_in">base</span>(param)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;derived: copy constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">derived</span>(derived &amp;&amp; param) <span class="keyword">noexcept</span> :<span class="built_in">base</span>(std::<span class="built_in">move</span>(param))&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;derived: move constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    derived c;</span><br><span class="line">    derived d = c;</span><br><span class="line"></span><br><span class="line">    derived e = std::<span class="built_in">move</span>(c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="comment">//base: copy constructor</span></span><br><span class="line"><span class="comment">//derived: copy constructor</span></span><br><span class="line"><span class="comment">//base: move constructor</span></span><br><span class="line"><span class="comment">//derived: move constructor</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="num-2"><a href="#num-2" class="headerlink" title="num 2"></a>num 2</h3><ul>
<li>按成员移动是分两部分组成的，一部分是在支持移动操作的成员上执行的移动操作，另一部分是在不支持移动操作的成员上执行的复制操作</li>
</ul>
<hr>
<h3 id="num-3"><a href="#num-3" class="headerlink" title="num 3"></a>num 3</h3><ul>
<li>即使声明了复制构造/赋值操作符 函数的其中一个，当代码实现需要另一个的时候，编译期也会默认实现另一个(c++11称之为被废弃的行为)</li>
<li>如果声明了移动构造/赋值操作符 函数的其中一个，即使代码需要另一个的时候，编译期也不会默认实现另一个</li>
<li>如果声明了复制构造/赋值运算符函数，则不会生成默认的移动构造/移动赋值运算符函数。</li>
<li>如果声明了移动构造/移动赋值运算符函数，则不会声明默认的复制构造/赋值运算符函数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cc</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">cc</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">cc</span>(cc &amp; ) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy construct&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dd</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">dd</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">dd</span>(dd &amp;&amp;) <span class="keyword">noexcept</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;move construct&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cc data;</span><br><span class="line">    data = <span class="built_in">cc</span>();    <span class="comment">//no output</span></span><br><span class="line"></span><br><span class="line">    dd data2;</span><br><span class="line">    <span class="comment">//note: ‘dd&amp; dd::operator=(const dd&amp;)’ is implicitly declared as deleted because ‘dd’</span></span><br><span class="line">    <span class="comment">// declares a move constructor or move assignment operator</span></span><br><span class="line">    data2 = std::<span class="built_in">move</span>(<span class="built_in">dd</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="num-4"><a href="#num-4" class="headerlink" title="num 4"></a>num 4</h3><ul>
<li>如果声明了析构函数，复制构造和赋值操作符函数也会生成(c++11称之为被废弃的行为)</li>
<li>如果声明了析构函数，移动函数都不会生成</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cc</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">cc</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">cc</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dd</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">dd</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">dd</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cc data;</span><br><span class="line">    data = <span class="built_in">cc</span>();</span><br><span class="line"></span><br><span class="line">    dd data2 = std::<span class="built_in">move</span>(<span class="built_in">dd</span>()); <span class="comment">//const &amp; 拷贝构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="num-5"><a href="#num-5" class="headerlink" title="num 5"></a>num 5</h3><ul>
<li>如果声明了构造函数/赋值运算符函数 的一种实现，则不再生成默认的实现</li>
<li>如果声明了基本构造函数，不会影响默认生成其他拷贝构造函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cc</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">cc</span>(cc &amp;) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cc data;    <span class="comment">//error: no matching function for call to ‘cc::cc()’</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cc</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">cc</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cc data = std::<span class="built_in">move</span>(<span class="built_in">cc</span>());  <span class="comment">//ok</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="num-6"><a href="#num-6" class="headerlink" title="num 6"></a>num 6</h3><ul>
<li>c++11中析构函数默认都是noexcept</li>
</ul>
<hr>
<h3 id="num-7"><a href="#num-7" class="headerlink" title="num 7"></a>num 7</h3><ul>
<li>模板拷贝构造函数，赋值运算符函数，不会阻止默认函数的实现</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cc</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="built_in">cc</span>(<span class="keyword">const</span> T &amp;)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    cc&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> T &amp;)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cc data = <span class="built_in">cc</span>(); <span class="comment">//模板成员函数会阻止默认构造函数生成</span></span><br><span class="line">                    <span class="comment">//但不会阻止默认拷贝/默认赋值操作符函数的生成</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/07/15/4kXzPFMh7IUGxJi.jpg" alt="2020071502.jpg"></p>
]]></content>
      <tags>
        <tag>c++11</tag>
      </tags>
  </entry>
  <entry>
    <title>function bind</title>
    <url>/2020-07-16-function%20bind/</url>
    <content><![CDATA[<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="http://blog.bitfoc.us/p/525">http://blog.bitfoc.us/p/525</a></p>
<p><a href="https://xr1s.me/2019/01/15/stl-source-analyze-std-function-1/">STL 源码简析 – std::function</a></p>
<p><a href="https://shaharmike.com/cpp/naive-std-function/">Naive std::function implementation</a></p>
<a id="more"></a>

<h2 id="step1-匹配函数"><a href="#step1-匹配函数" class="headerlink" title="step1 匹配函数"></a>step1 匹配函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ret, <span class="keyword">typename</span> lhs, <span class="keyword">typename</span> rhs&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function</span>&lt;</span><span class="built_in">ret</span>(lhs, rhs)&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>values = <span class="number">2</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;::values &lt;&lt; endl;    <span class="comment">//2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="step2-模板匹配分析"><a href="#step2-模板匹配分析" class="headerlink" title="step2 模板匹配分析"></a>step2 模板匹配分析</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ret, <span class="keyword">typename</span> lhs, <span class="keyword">typename</span> rhs&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function</span>&lt;</span><span class="built_in">ret</span>(lhs, rhs)&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> values1 = std::is_same&lt;<span class="keyword">int</span>, ret&gt;();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> values2 = std::is_same&lt;<span class="keyword">int</span>, lhs&gt;();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> values3 = std::is_same&lt;<span class="keyword">int</span>, rhs&gt;();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;::values1 &lt;&lt; endl;   <span class="comment">//1</span></span><br><span class="line">    cout &lt;&lt; function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;::values2 &lt;&lt; endl;   <span class="comment">//1</span></span><br><span class="line">    cout &lt;&lt; function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;::values3 &lt;&lt; endl;   <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; function&lt;<span class="built_in"><span class="keyword">double</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;::values1 &lt;&lt; endl;    <span class="comment">//0</span></span><br><span class="line">    cout &lt;&lt; function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">double</span>, <span class="keyword">int</span>)&gt;::values2 &lt;&lt; endl;    <span class="comment">//0</span></span><br><span class="line">    cout &lt;&lt; function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">double</span>)&gt;::values3 &lt;&lt; endl;    <span class="comment">//0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="step3-运行函数"><a href="#step3-运行函数" class="headerlink" title="step3 运行函数"></a>step3 运行函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ret, <span class="keyword">typename</span> lhs, <span class="keyword">typename</span> rhs&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function</span>&lt;</span><span class="built_in">ret</span>(lhs, rhs)&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> functype = <span class="built_in">ret</span> (*)(lhs, rhs);</span><br><span class="line">    functype callfunc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="built_in">function</span>(T param):<span class="built_in">callfunc</span>(param)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ret <span class="title">operator</span><span class="params">()</span><span class="params">(lhs l, rhs r)</span></span>&#123;   <span class="comment">//函数调用运算符</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">callfunc</span>(l, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> lhs, <span class="keyword">int</span> rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; lhs + rhs &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; test = &amp;func;</span><br><span class="line">    <span class="built_in">test</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/07/16/UdDrIpAvucle7KR.jpg" alt="2020071603.jpg"></p>
]]></content>
      <tags>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title>完美转发失败场景</title>
    <url>/2020-07-16-%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E5%A4%B1%E8%B4%A5%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>留的坑，以后填</p>
<a id="more"></a>

<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/07/16/ZJauUNQxPWbmTnh.jpg" alt="2020071602.jpg"></p>
]]></content>
      <tags>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title>模板特化</title>
    <url>/2020-07-16-%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96%20SFINAE/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">Substitution failure is not an error</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/20029261">C++ Template的选择特化</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/21314708">C++模板进阶指南：SFINAE</a></p>
<p><a href="https://en.cppreference.com/w/cpp/types/enable_if">std::enable_if</a></p>
<p><a href="https://en.cppreference.com/w/cpp/language/sfinae">SFINAE</a></p>
<a id="more"></a>

<h2 id="SFINAE"><a href="#SFINAE" class="headerlink" title="SFINAE"></a>SFINAE</h2><blockquote>
<p>替换失败不是错误（SFINAE）是指C ++中模板参数的无效替换本身并不是错误的情况。David Vandevoorde首先引入了缩写词SFINAE来描述相关的编程技术。[1]</p>
</blockquote>
<blockquote>
<p>具体地，当创建用于重载解析的候选集时，该集合的一些（或全部）候选者可能是实例化模板的结果，该模板实例化了（可能推导的）模板参数来代替相应的模板参数。如果在将一组参数替换为任何给定模板的过程中发生错误，则编译器会从候选集中消除潜在的重载，而不会因编译错误而停止，前提是替换错误是C ++标准授予此类处理的错误。[2]如果剩下一个或多个候选并且重载解析成功，则调用格式正确</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">int</span> foo;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">typename</span> T::foo)</span> </span>&#123;&#125;  <span class="comment">// Definition #1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T)</span> </span>&#123;&#125;  <span class="comment">// Definition #2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  f&lt;Test&gt;(<span class="number">10</span>);  <span class="comment">// Call #1.</span></span><br><span class="line">  f&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);   <span class="comment">// Call #2. Without error (even though there is no int::foo)</span></span><br><span class="line">                <span class="comment">// thanks to SFINAE.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此规则在函数模板的重载解析期间适用：当用显式指定的或推导的类型代替template参数失败时，将从重载集中放弃专业化，而不会引起编译错误。</p>
<p>替代发生在:</p>
<ul>
<li>函数类型中使用的所有类型（包括返回类型和所有参数的类型）</li>
<li>模板参数声明中使用的所有类型</li>
</ul>
<p>//(自C ++ 11起）</p>
<ul>
<li>函数类型中使用的所有表达式</li>
<li>模板参数声明中使用的所有表达式</li>
</ul>
<p>//自C ++ 20起）</p>
<ul>
<li>显式说明符中使用的所有表达式</li>
</ul>
<h2 id="模板特化"><a href="#模板特化" class="headerlink" title="模板特化"></a>模板特化</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//typedef integral_constant&lt;bool,true&gt; true_type;</span></span><br><span class="line"><span class="comment">//template &lt;class T, T v&gt;</span></span><br><span class="line"><span class="comment">// struct integral_constant &#123;</span></span><br><span class="line"><span class="comment">//   static constexpr T value = v;</span></span><br><span class="line"><span class="comment">//   typedef T value_type;</span></span><br><span class="line"><span class="comment">//   typedef integral_constant&lt;T,v&gt; type;</span></span><br><span class="line"><span class="comment">//   constexpr operator T() &#123; return v; &#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mytrue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myfalse</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;    <span class="comment">// 主模板</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dd</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dd</span>&lt;</span>std::false_type&gt; : myfalse    <span class="comment">// 对 T = false_type 显式特化</span></span><br><span class="line">        &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dd</span>&lt;</span>std::true_type&gt; : mytrue    <span class="comment">// 对 T = true_type 显式特化</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; dd&lt;std::true_type&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; dd&lt;std::false_type&gt;::value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="enable-if"><a href="#enable-if" class="headerlink" title="enable_if"></a>enable_if</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Define a nested type if some predicate holds.</span></span><br><span class="line">  <span class="comment">// Primary template.</span></span><br><span class="line">  <span class="comment">/// enable_if</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">bool</span>, <span class="keyword">typename</span> _Tp = <span class="keyword">void</span>&gt;   <span class="comment">//主模板</span></span><br><span class="line">    struct enable_if </span><br><span class="line">    &#123; &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Partial specialization for true.</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;                <span class="comment">//特化模板</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">enable_if</span>&lt;</span><span class="literal">true</span>, _Tp&gt;</span><br><span class="line">    &#123; <span class="keyword">typedef</span> _Tp type; &#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span>, <span class="keyword">typename</span> T = <span class="keyword">void</span>&gt;  <span class="comment">//主模板</span></span><br><span class="line">struct my_if&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_if</span>&lt;</span><span class="literal">true</span>, T&gt;&#123;      <span class="comment">//特化模板</span></span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_if</span>&lt;</span><span class="literal">false</span>, T&gt;&#123;     <span class="comment">//特化模板</span></span><br><span class="line">    <span class="keyword">typedef</span> T* type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::is_same&lt;<span class="keyword">void</span>, my_if&lt;<span class="literal">true</span>&gt;::type&gt;() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::is_same&lt;<span class="keyword">void</span> *, my_if&lt;<span class="literal">false</span>&gt;::type&gt;() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::is_same&lt;<span class="keyword">int</span>, my_if&lt;<span class="literal">true</span>, <span class="keyword">int</span>&gt;::type&gt;() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::is_same&lt;<span class="keyword">int</span> *, my_if&lt;<span class="literal">false</span>, <span class="keyword">int</span>&gt;::type&gt;() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>模板特化和SFINAE挺复杂的，目前没有精力挖的太深，掌握大概就行了。</p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/07/16/LHF9S1zDWTfkY6y.jpg" alt="2020071601.jpg"></p>
]]></content>
      <tags>
        <tag>c++11</tag>
      </tags>
  </entry>
  <entry>
    <title>enum hack</title>
    <url>/2020-07-17-enum%20hack/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhihu.com/question/264295639">zhihu</a></p>
<a id="more"></a>

<h2 id="case1-static"><a href="#case1-static" class="headerlink" title="case1 static"></a>case1 static</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> GameTurn = <span class="number">9</span>;  <span class="comment">//ok</span></span><br><span class="line">    <span class="keyword">int</span> scores[GameTurn];           <span class="comment">//ok</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//const int Game::GameTurn = 10;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样是ok的，但有些老的编译期可能不允许在声明的时候给static变量赋值，就得做变通:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> GameTurn;  <span class="comment">//ok</span></span><br><span class="line">    <span class="keyword">int</span> scores[GameTurn];       <span class="comment">//not ok</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Game::GameTurn = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此这般scores的数组大小就取不到了。形如case2</p>
<h2 id="case2-const"><a href="#case2-const" class="headerlink" title="case2 const"></a>case2 const</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> GameTurn = <span class="number">10</span>;    <span class="comment">//ok</span></span><br><span class="line">    <span class="keyword">int</span> scores[GameTurn];       <span class="comment">//not ok</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//const int Game::GameTurn = 10;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于类没有实例化，这里数组大小还是取不到，不像static是在类外实例化的。</p>
<h2 id="case3-enum"><a href="#case3-enum" class="headerlink" title="case3 enum"></a>case3 enum</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">hack</span> &#123;</span>GameTurn = <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> scores[GameTurn];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//const int Game::GameTurn = 10;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此这般可行，甚好。enum是在编译期求值得，可用于模板元编程，见下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> data&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        result = data + test&lt;data - <span class="number">1</span>&gt;::result</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span>&lt;</span><span class="number">1</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        result = <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">10</span>;</span><br><span class="line">    std::cout &lt;&lt; test&lt;num&gt;::result &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2>]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>tuple underlying_type</title>
    <url>/2020-07-17-tuple%20underlying_type/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>留的坑，以后填</p>
<a id="more"></a>

<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2>]]></content>
      <tags>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title>成员函数指针</title>
    <url>/2020-07-20-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/hazir/p/wide-pointers.html">为什么 C++ 中成员函数指针是 16 字节？</a></p>
<a id="more"></a>

<h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">Undefined_class</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>*       _M_object;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">void</span>* _M_const_object;</span><br><span class="line"><span class="built_in"><span class="keyword">void</span></span> (*_M_function_pointer)();</span><br><span class="line"><span class="built_in"><span class="keyword">void</span></span> (_Undefined_class::*p4)();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(_M_object) &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">         &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(_M_const_object) &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">         &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(_M_function_pointer) &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">         &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(&amp;_Undefined_class::func) &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">         &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(p4) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>8
8
8
16
16</code></pre>
<p>成员函数中是可以使用this指针的，这个以前是知道的，但不够明确的是this指针的存放位置。按目前看的文章，this指针是占用成员函数指针大小的：</p>
<blockquote>
<p>A pointer to member function is a pair as follows:</p>
</blockquote>
<blockquote>
<p>ptr:</p>
</blockquote>
<blockquote>
<p>For a non-virtual function, this field is a simple function pointer. For a virtual function, it is 1 plus the virtual table offset (in bytes) of the function, represented as a ptrdiff_t. The value zero represents a NULL pointer, independent of the adjustment field value below.</p>
</blockquote>
<blockquote>
<p>adj:</p>
</blockquote>
<blockquote>
<p>The required adjustment to this, represented as a ptrdiff_t.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&#x27;s this:\t&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> pad0[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;B&#x27;s this:\t&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> pad2[<span class="number">64</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span> :</span> A, B</span><br><span class="line">&#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_by_ptr</span><span class="params">(<span class="keyword">const</span> C &amp;obj, <span class="keyword">void</span> (C::*mem_func)() <span class="keyword">const</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *data[<span class="number">2</span>];</span><br><span class="line">    std::<span class="built_in">memcpy</span>(data, &amp;mem_func, <span class="built_in"><span class="keyword">sizeof</span></span>(mem_func));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;------------------------------\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;Object ptr:\t&quot;</span> &lt;&lt; &amp;obj &lt;&lt;</span><br><span class="line">              <span class="string">&quot;\nFunction ptr:\t&quot;</span> &lt;&lt; data[<span class="number">0</span>] &lt;&lt;</span><br><span class="line">              <span class="string">&quot;\nPointer adj:\t&quot;</span> &lt;&lt; data[<span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line">    (obj.*mem_func)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C obj;</span><br><span class="line">    <span class="built_in">call_by_ptr</span>(obj, &amp;C::foo);</span><br><span class="line">    <span class="built_in">call_by_ptr</span>(obj, &amp;C::bar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>------------------------------
Object ptr:     0x7ffd3b46ec80
Function ptr:   0x400a56
Pointer adj:    0
A&#39;s this:       0x7ffd3b46ec80
------------------------------
Object ptr:     0x7ffd3b46ec80
Function ptr:   0x400a90
Pointer adj:    0x20
B&#39;s this:       0x7ffd3b46eca0</code></pre>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2>]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>training</title>
    <url>/2020-07-26-training/</url>
    <content><![CDATA[<h2 id="20200726"><a href="#20200726" class="headerlink" title="20200726"></a>20200726</h2><p>直接在leetcode做题吧，此文不再更新。</p>
<a id="more"></a>

<h2 id="源起"><a href="#源起" class="headerlink" title="源起"></a>源起</h2><p>弱点，会被看穿，会被评价，会流下血与泪</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://leetcode-cn.com/">leetcode</a></p>
<p><a href="">剑指offer</a></p>
<h2 id="001-合并两个有序链表"><a href="#001-合并两个有序链表" class="headerlink" title="001 合并两个有序链表"></a>001 合并两个有序链表</h2><table>
    <thead align="center">
        <tr>
            <th style="text-align:center">题目</th>
            <th style="text-align:center">来源</th>
            <th style="text-align:center">完成时间</th>
        </tr>
    </thead>
    <tbody align="center">
        <tr>
            <td>将两个升序链表合并为一个新的升序链表并返回</td>
            <td>剑指offer</td>
            <td>20200401</td>
        </tr>
    </tbody>
</table>

<p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists">合并两个有序链表</a></p>
<p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p>示例：</p>
<pre><code>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4 
输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</code></pre>
<p><code>my unswer</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (!l1)</span><br><span class="line">		<span class="keyword">return</span> l2;</span><br><span class="line">	<span class="keyword">if</span> (!l2)</span><br><span class="line">		<span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">	ListNode *p1 = l1;</span><br><span class="line">	ListNode *p2 = l1;</span><br><span class="line">	ListNode *p3 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (l2)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//p1 = l1 --&gt;A</span></span><br><span class="line">		p1 = l1;</span><br><span class="line">		<span class="keyword">while</span> (p1 &amp;&amp; l2-&gt;val &gt;= p1-&gt;val)</span><br><span class="line">		&#123;</span><br><span class="line">			p3 = p1;</span><br><span class="line">			p1 = p1-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!p1)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//right insert</span></span><br><span class="line">			p3-&gt;next = l2;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//mid insert</span></span><br><span class="line">			<span class="keyword">if</span> (p1 != l1)</span><br><span class="line">			&#123;</span><br><span class="line">				p3-&gt;next = l2;</span><br><span class="line">				<span class="comment">//p3 = l2 --&gt;B  </span></span><br><span class="line">                <span class="comment">//A，B保留一处</span></span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			p2 = l2-&gt;next;</span><br><span class="line">			l2-&gt;next = p1;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//left insert</span></span><br><span class="line">			<span class="keyword">if</span> (p1 == l1)</span><br><span class="line">			&#123;</span><br><span class="line">				l1 = l2;</span><br><span class="line">				p1 = l1;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		l2 = p2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="002-数组中重复的数字"><a href="#002-数组中重复的数字" class="headerlink" title="002 数组中重复的数字"></a>002 数组中重复的数字</h2><table>
    <thead align="center">
        <tr>
            <th style="text-align:center">题目</th>
            <th style="text-align:center">来源</th>
            <th style="text-align:center">完成时间</th>
        </tr>
    </thead>
    <tbody align="center">
        <tr>
            <td>找出数组中重复的数字</td>
            <td>剑指offer</td>
            <td>20200417</td>
        </tr>
    </tbody>
</table>

<p>在一个长度为n的数组里的所有数字都在0 ~ n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2,3,1,0,2,5,3},那么对应的输出是数字2或者3</p>
<p>方法1：排序，排完序遍历数组 <br><br>方法2：哈希表，插入判断是否重复  <br><br>方法3：让数组索引值和数组的元素值相等，data[0] = 0, data[1] = 1,对应不上的不管 </p>
<table>
    <thead align="center">
        <tr>
            <th style="text-align:center">方法</th>
            <th style="text-align:center">时间复杂度</th>
            <th style="text-align:center">空间复杂度</th>
        </tr>
    </thead>
    <tbody align="center">
        <tr>
            <td>排序</td>
            <td>O(nlogn)</td>
            <td>O(n)</td>
        </tr>
    </tbody>
    <tbody align="center">
        <tr>
            <td>哈希</td>
            <td>O(1)</td>
            <td>O(n)</td>
        </tr>
    </tbody>
    <tbody align="center">
        <tr>
            <td>数组索引</td>
            <td>O(1)</td>
            <td>O(1)</td>
        </tr>
    </tbody>
</table>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FuncFind</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">nullptr</span> || n &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Invalid param!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个数组元素都要&gt;=0 &amp;&amp;　&lt;n-1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (data[i] &lt; <span class="number">0</span> || data[i] &gt; n - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Invalid param!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (data[i] != i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[i] == data[data[i]])</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; data[i] &lt;&lt; endl;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(data[i], data[data[i]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FuncFind2</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">nullptr</span> || n &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Invalid param!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个数组元素都要&gt;=0 &amp;&amp;　&lt;n-1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (data[i] &lt; <span class="number">0</span> || data[i] &gt; n - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Invalid param!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (data[i] != i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[i] == data[data[i]])</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; data[i] &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(data[i], data[data[i]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in"><span class="keyword">sizeof</span></span>(data)/<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FuncFind</span>(data, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>2
3
1
3
6

Process returned 0 (0x0)   execution time : 0.011 s
Press any key to continue.</code></pre>
<h2 id="003-不修改数组找出数组中重复的数字"><a href="#003-不修改数组找出数组中重复的数字" class="headerlink" title="003 不修改数组找出数组中重复的数字"></a>003 不修改数组找出数组中重复的数字</h2><table>
    <thead align="center">
        <tr>
            <th style="text-align:center">题目</th>
            <th style="text-align:center">来源</th>
            <th style="text-align:center">完成时间</th>
        </tr>
    </thead>
    <tbody align="center">
        <tr>
            <td>不修改数组找出数组中重复的数字</td>
            <td>剑指offer</td>
            <td>20200418</td>
        </tr>
    </tbody>
</table>

<p><strong>读题：</strong> </p>
<p>在一个长度为n+1的数组里的所有数字都在<code>1~n的范围内</code>，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。</p>
<p><strong>思路：</strong> </p>
<ul>
<li>新建一个数组，复制过来，把数组值和数组索引对应上，则可以找出重复的元素</li>
<li>二分查找的方法，找出每个半区的元素个数是否刚好是半区总数，然后不断递归</li>
</ul>
<p><strong>思路2的实现：</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FuncFind</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Invalid param!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> lnum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rnum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[i] &gt; mid &amp;&amp; data[i] &lt;= right)</span><br><span class="line">                rnum++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(data[i] &lt;= mid &amp;&amp; data[i] &gt;= left)</span><br><span class="line">                lnum++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (right - mid &lt; rnum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">FuncFind</span>(data, mid + <span class="number">1</span>, right, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mid - left + <span class="number">1</span> &lt; lnum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">FuncFind</span>(data, left, mid, len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[] = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in"><span class="keyword">sizeof</span></span>(data)/<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 ~ n-1</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">FuncFind</span>(data, <span class="number">1</span>, n<span class="number">-1</span>, n) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="004-不修改数组找出数组中重复的数字"><a href="#004-不修改数组找出数组中重复的数字" class="headerlink" title="004 不修改数组找出数组中重复的数字"></a>004 不修改数组找出数组中重复的数字</h2><table>
    <thead align="center">
        <tr>
            <th style="text-align:center">题目</th>
            <th style="text-align:center">来源</th>
            <th style="text-align:center">完成时间</th>
        </tr>
    </thead>
    <tbody align="center">
        <tr>
            <td>二维数组中的查找</td>
            <td>剑指offer</td>
            <td>20200418</td>
        </tr>
    </tbody>
</table>

<p><strong>读题</strong></p>
<p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数,输入这样的一个二维数组和一个整数，判断数组中是否含有该整数</p>
<p><strong>思路</strong></p>
<p>从右上角开始找</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FuncFind</span><span class="params">(<span class="keyword">int</span> data[][<span class="number">4</span>], <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    col--;</span><br><span class="line">    <span class="keyword">int</span> line = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(line &lt; row &amp;&amp; col &gt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == data[line][col])</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;exist!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n &gt; data[line][col])</span><br><span class="line">            line++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            col--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;not exist!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[][<span class="number">4</span>] = &#123;</span><br><span class="line">        <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span>,</span><br><span class="line">        <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">12</span>,</span><br><span class="line">        <span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">13</span>,</span><br><span class="line">        <span class="number">6</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">15</span></span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">FuncFind</span>(data, <span class="number">4</span>, <span class="number">4</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="005-从尾到头打印链表"><a href="#005-从尾到头打印链表" class="headerlink" title="005 从尾到头打印链表"></a>005 从尾到头打印链表</h2><table>
    <thead align="center">
        <tr>
            <th style="text-align:center">题目</th>
            <th style="text-align:center">来源</th>
            <th style="text-align:center">完成时间</th>
        </tr>
    </thead>
    <tbody align="center">
        <tr>
            <td>从尾到头打印链表</td>
            <td>剑指offer</td>
            <td>20200418</td>
        </tr>
    </tbody>
</table>

<p><strong>读题</strong></p>
<p>输入一个链表的头节点，从头到尾反过来打印出每个节点的值。链表节点定义如下： <br></p>
<pre><code>struct ListNode
&#123;
    int m_nKey;
    ListNode* m_npNext;
&#125;;</code></pre>
<p><strong>思路：</strong></p>
<ul>
<li>栈是后进先出，可以放到栈数据结构中再取出来</li>
<li>采用函数递归，但要考虑到递归不易太深，否则会溢出</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> m_nKey;</span><br><span class="line">    ListNode* m_npNext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReversePrint</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pHead != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead-&gt;m_npNext != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">ReversePrint</span>(pHead-&gt;m_npNext);</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; pHead-&gt;m_nKey &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    ListNode *pHead = <span class="keyword">new</span> ListNode;</span><br><span class="line">    ListNode *pNode = pHead;</span><br><span class="line">    <span class="comment">//input</span></span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        pNode-&gt;m_nKey = n;</span><br><span class="line">        pNode-&gt;m_npNext = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cin.<span class="built_in">get</span>() == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        pNode-&gt;m_npNext = <span class="keyword">new</span> ListNode;</span><br><span class="line">        pNode = pNode-&gt;m_npNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//deal</span></span><br><span class="line">    stack&lt;ListNode*&gt; oStack;</span><br><span class="line">    pNode = pHead;</span><br><span class="line">    <span class="keyword">while</span>(pNode)</span><br><span class="line">    &#123;</span><br><span class="line">        oStack.<span class="built_in">push</span>(pNode);</span><br><span class="line">        pNode = pNode-&gt;m_npNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    pNode = pHead;</span><br><span class="line">    <span class="keyword">while</span>(!oStack.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        pNode = oStack.<span class="built_in">top</span>();</span><br><span class="line">        cout &lt;&lt; pNode-&gt;m_nKey &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        oStack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ReversePrint(pHead);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="006-替换空格"><a href="#006-替换空格" class="headerlink" title="006 替换空格"></a>006 替换空格</h2><table>
    <thead align="center">
        <tr>
            <th style="text-align:center">题目</th>
            <th style="text-align:center">来源</th>
            <th style="text-align:center">完成时间</th>
        </tr>
    </thead>
    <tbody align="center">
        <tr>
            <td>替换空格</td>
            <td>剑指offer</td>
            <td>20200521</td>
        </tr>
    </tbody>
</table>

<p><strong>读题</strong></p>
<p>请实现一个函数，把字符串中的每个空格替换成”%20”.例如，输入 “we are happy”, 则输出 “we%20are%20happy”</p>
<p><strong>思路：</strong></p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/04/18/FVNLQ6mIyGiwB9o.jpg" alt="74364959_p0.jpg"></p>
]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql安装</title>
    <url>/2020-07-27-mysql-%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="begin"><a href="#begin" class="headerlink" title="begin"></a>begin</h2><p>安装总体流程参考: <a href="https://blog.csdn.net/u013011879/article/details/106554289">https://blog.csdn.net/u013011879/article/details/106554289</a></p>
<a id="more"></a>

<p>遇到的问题汇总：</p>
<h3 id="case-1"><a href="#case-1" class="headerlink" title="case 1"></a>case 1</h3><p><a href="https://blog.csdn.net/yxfabcdefg/article/details/31450175">Couldn’t find MySQL server</a></p>
<h3 id="case-2"><a href="#case-2" class="headerlink" title="case 2"></a>case 2</h3><p><a href="https://blog.csdn.net/bedisdover/article/details/52567269">Can’t connect to local MySQL server</a></p>
<h3 id="case-3"><a href="#case-3" class="headerlink" title="case 3"></a>case 3</h3><p><a href="https://blog.csdn.net/yumushui/article/details/49124699">提示/etc/my.cnf 被忽略的问题处理</a></p>
<h3 id="case-4"><a href="#case-4" class="headerlink" title="case 4"></a>case 4</h3><p><a href="https://blog.51cto.com/dahui09/1775501">Your password has expired</a></p>
<h2 id="end"><a href="#end" class="headerlink" title="end"></a>end</h2>]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>golang routine</title>
    <url>/2020-07-28-golang%20routine/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>留的坑，以后填</p>
<a id="more"></a>

<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2>]]></content>
      <tags>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql 索引</title>
    <url>/2020-07-30-mysql%20%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>留的坑，以后填</p>
<a id="more"></a>

<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2>]]></content>
      <tags>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql binlog</title>
    <url>/2020-08-20-mysql%20binlog/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="">MySQL实战45讲</a></p>
<p><a href="">mysql技术内幕</a></p>
<p><a href="https://www.cnblogs.com/xinysu/p/6607658.html">关于binary log那些事</a></p>
<a id="more"></a>

<h2 id="查看配置信息"><a href="#查看配置信息" class="headerlink" title="查看配置信息"></a>查看配置信息</h2><p>查看binlog是否打开以及配置信息：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MySQL [mysql]&gt; show variables like &#x27;%log_bin%&#x27;;</span><br><span class="line">+---------------------------------+---------------------------------------+</span><br><span class="line">| Variable_name                   | Value                                 |</span><br><span class="line">+---------------------------------+---------------------------------------+</span><br><span class="line">| log_bin                         | ON                                    |</span><br><span class="line">| log_bin_basename                | /usr/local/mysql/data/mysql-bin       |</span><br><span class="line">| log_bin_index                   | /usr/local/mysql/data/mysql-bin.index |</span><br><span class="line">| log_bin_trust_function_creators | OFF                                   |</span><br><span class="line">| log_bin_use_v1_row_events       | OFF                                   |</span><br><span class="line">| sql_log_bin                     | ON                                    |</span><br><span class="line">+---------------------------------+---------------------------------------+</span><br><span class="line"><span class="number">6</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure>

<p>查看配置文件：</p>
<p>log_bin是打开binlog的开关.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[root@xxxx]<span class="meta"># mysql --help | grep cnf</span></span><br><span class="line">/etc/mysql/my.cnf /etc/my.cnf ~/.my.cnf </span><br><span class="line">                      order of preference, my.cnf, $MYSQL_TCP_PORT,</span><br><span class="line">[root@xxxx]<span class="meta"># cat /etc/my.cnf</span></span><br><span class="line">[mysqld]</span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line">log_bin = mysql-bin</span><br><span class="line">binlog-format=STATEMENT </span><br><span class="line">expire_logs_days = <span class="number">30</span></span><br></pre></td></tr></table></figure>

<p>文件列表：</p>
<p>index是binlog的索引文件，记录所有的binlog日志文件。binlog日志是可续写的，不停有新的文件产生。而redo log是循环写的，固定文件个数，满了后从头开始。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[root@xxxx]<span class="meta"># ll mysql-bin.*</span></span><br><span class="line">-rw-r----- <span class="number">1</span> mysql mysql   <span class="number">177</span> Jul <span class="number">31</span> <span class="number">17</span>:<span class="number">22</span> mysql-bin<span class="number">.000001</span></span><br><span class="line">-rw-r----- <span class="number">1</span> mysql mysql   <span class="number">177</span> Jul <span class="number">31</span> <span class="number">17</span>:<span class="number">26</span> mysql-bin<span class="number">.000002</span></span><br><span class="line">-rw-r----- <span class="number">1</span> mysql mysql  <span class="number">1321</span> Jul <span class="number">31</span> <span class="number">17</span>:<span class="number">36</span> mysql-bin<span class="number">.000003</span></span><br><span class="line">-rw-r----- <span class="number">1</span> mysql mysql <span class="number">21167</span> Aug <span class="number">20</span> <span class="number">10</span>:<span class="number">50</span> mysql-bin<span class="number">.000004</span></span><br><span class="line">-rw-r----- <span class="number">1</span> mysql mysql    <span class="number">76</span> Jul <span class="number">31</span> <span class="number">17</span>:<span class="number">36</span> mysql-bin.index</span><br><span class="line">[root@xxxx]<span class="meta"># cat mysql-bin.index</span></span><br><span class="line">./mysql-bin<span class="number">.000001</span></span><br><span class="line">./mysql-bin<span class="number">.000002</span></span><br><span class="line">./mysql-bin<span class="number">.000003</span></span><br><span class="line">./mysql-bin<span class="number">.000004</span></span><br></pre></td></tr></table></figure>

<h2 id="参数含义"><a href="#参数含义" class="headerlink" title="参数含义"></a>参数含义</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">+--------------------------------------------+---------------------------------------+</span><br><span class="line">| Variable_name                              | Value                                 |</span><br><span class="line">+--------------------------------------------+---------------------------------------+</span><br><span class="line">| binlog_cache_size                          | <span class="number">32768</span>                                 |</span><br><span class="line">| binlog_checksum                            | CRC32                                 |</span><br><span class="line">| binlog_direct_non_transactional_updates    | OFF                                   |</span><br><span class="line">| binlog_error_action                        | ABORT_SERVER                          |</span><br><span class="line">| binlog_format                              | STATEMENT                             |</span><br><span class="line">| binlog_group_commit_sync_delay             | <span class="number">0</span>                                     |</span><br><span class="line">| binlog_group_commit_sync_no_delay_count    | <span class="number">0</span>                                     |</span><br><span class="line">| binlog_gtid_simple_recovery                | ON                                    |</span><br><span class="line">| binlog_max_flush_queue_time                | <span class="number">0</span>                                     |</span><br><span class="line">| binlog_order_commits                       | ON                                    |</span><br><span class="line">| binlog_row_image                           | FULL                                  |</span><br><span class="line">| binlog_rows_query_log_events               | OFF                                   |</span><br><span class="line">| binlog_stmt_cache_size                     | <span class="number">32768</span>                                 |</span><br><span class="line">| binlog_transaction_dependency_history_size | <span class="number">25000</span>                                 |</span><br><span class="line">| binlog_transaction_dependency_tracking     | COMMIT_ORDER                          |</span><br><span class="line">| innodb_api_enable_binlog                   | OFF                                   |</span><br><span class="line">| innodb_locks_unsafe_for_binlog             | OFF                                   |</span><br><span class="line">| log_bin                                    | ON                                    |</span><br><span class="line">| log_bin_basename                           | /usr/local/mysql/data/mysql-bin       |</span><br><span class="line">| log_bin_index                              | /usr/local/mysql/data/mysql-bin.index |</span><br><span class="line">| log_bin_trust_function_creators            | OFF                                   |</span><br><span class="line">| log_bin_use_v1_row_events                  | OFF                                   |</span><br><span class="line">| log_statements_unsafe_for_binlog           | ON                                    |</span><br><span class="line">| max_binlog_cache_size                      | <span class="number">18446744073709547520</span>                  |</span><br><span class="line">| max_binlog_size                            | <span class="number">1073741824</span>                            |</span><br><span class="line">| max_binlog_stmt_cache_size                 | <span class="number">18446744073709547520</span>                  |</span><br><span class="line">| sql_log_bin                                | ON                                    |</span><br><span class="line">| sync_binlog                                | <span class="number">1</span>                                     |</span><br><span class="line">+--------------------------------------------+---------------------------------------+</span><br></pre></td></tr></table></figure>

<p><code>max_binlog_size</code>表示单个binlog日志文件的大小，默认是1g,超过后产生新文件</p>
<p><code>binlog_cache_size</code>表示binlog在内存的缓冲区大小，默认32k,这个大小是基于会话的，所以不能太大。也不能太小，因为io压力会大</p>
<p><code>sync_binlog</code>是否同步binlog到磁盘，就不写缓冲区了。高可用但是对磁盘io有压力</p>
<h3 id="binlog-format"><a href="#binlog-format" class="headerlink" title="binlog_format"></a>binlog_format</h3><p><code>binlog_format</code>mysql5.1引入的，可设置的值有：statement, row, mixed.</p>
<p>1 statement: 记录逻辑日志<br>2 row: 记录表的行更改情况<br>3 mixed: 默认采用statement格式记录日志，但是在一些情况下会使用row格式，可能的情况有</p>
<ul>
<li>表的存储引擎为ndb,这时对表的dml操作</li>
<li>使用了uuid(), user(), current_user(), found_user(), row_count()等不确定函数</li>
<li>使用了insert delay语句</li>
<li>使用了用户定义函数</li>
<li>使用了临时表</li>
</ul>
<p>对比：</p>
<p>statement: update tt set d = 4 where c = 4<br>row: update tt set d = 5 where c = 4;</p>
<p>show binlog events in ‘mysql-bin.000004’;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">| mysql-bin<span class="number">.000004</span> | <span class="number">20948</span> | Query          |         <span class="number">1</span> |       <span class="number">21029</span> | BEGIN                                                                                                                                                                                                                                                                             |</span><br><span class="line">| mysql-bin<span class="number">.000004</span> | <span class="number">21029</span> | Query          |         <span class="number">1</span> |       <span class="number">21136</span> | use `mysql`; update tt set d = <span class="number">4</span> where c = <span class="number">4</span>                                                                                                                                                                                                                                      |</span><br><span class="line">| mysql-bin<span class="number">.000004</span> | <span class="number">21136</span> | Xid            |         <span class="number">1</span> |       <span class="number">21167</span> | COMMIT <span class="comment">/* xid=645 */</span>                                                                                                                                                                                                                                                              |</span><br><span class="line">| mysql-bin.000004 | 21167 | Anonymous_Gtid |         1 |       21232 | SET @@SESSION.GTID_NEXT= &#x27;ANONYMOUS&#x27;                                                                                                                                                                                                                                              |</span><br><span class="line">| mysql-bin<span class="number">.000004</span> | <span class="number">21232</span> | Query          |         <span class="number">1</span> |       <span class="number">21305</span> | BEGIN                                                                                                                                                                                                                                                                             |</span><br><span class="line">| mysql-bin<span class="number">.000004</span> | <span class="number">21305</span> | Table_map      |         <span class="number">1</span> |       <span class="number">21353</span> | table_id: <span class="number">146</span> (mysql.tt)                                                                                                                                                                                                                                                          |</span><br><span class="line">| mysql-bin<span class="number">.000004</span> | <span class="number">21353</span> | Update_rows    |         <span class="number">1</span> |       <span class="number">21415</span> | table_id: <span class="number">146</span> flags: STMT_END_F                                                                                                                                                                                                                                                   |</span><br><span class="line">| mysql-bin<span class="number">.000004</span> | <span class="number">21415</span> | Xid            |         <span class="number">1</span> |       <span class="number">21446</span> | COMMIT <span class="comment">/* xid=662 */</span>   </span><br></pre></td></tr></table></figure>

<p>/usr/local/mysql/mysql/bin/mysqlbinlog mysql-bin.000004 -vv</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">BEGIN</span><br><span class="line"><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="meta"># at 21029</span></span><br><span class="line">#<span class="number">200820</span> <span class="number">10</span>:<span class="number">50</span>:<span class="number">40</span> server id <span class="number">1</span>  end_log_pos <span class="number">21136</span> CRC32 <span class="number">0xab574d07</span>        Query   thread_id=<span class="number">11</span>    exec_time=<span class="number">0</span>     error_code=<span class="number">0</span></span><br><span class="line">SET TIMESTAMP=<span class="number">1597891840</span><span class="comment">/*!*/</span>;</span><br><span class="line">update tt set d = <span class="number">4</span> where c = <span class="number">4</span></span><br><span class="line"><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="meta"># at 21136</span></span><br><span class="line">#<span class="number">200820</span> <span class="number">10</span>:<span class="number">50</span>:<span class="number">40</span> server id <span class="number">1</span>  end_log_pos <span class="number">21167</span> CRC32 <span class="number">0xdd08f243</span>        Xid = <span class="number">645</span></span><br><span class="line">COMMIT<span class="comment">/*!*/</span>;</span><br><span class="line"><span class="meta"># at 21167</span></span><br><span class="line">#<span class="number">200820</span> <span class="number">11</span>:<span class="number">26</span>:<span class="number">28</span> server id <span class="number">1</span>  end_log_pos <span class="number">21232</span> CRC32 <span class="number">0xe81ffc29</span>        Anonymous_GTID  last_committed=<span class="number">76</span>       sequence_number=<span class="number">77</span>      rbr_only=yes</span><br><span class="line"><span class="comment">/*!50718 SET TRANSACTION ISOLATION LEVEL READ COMMITTED*/</span><span class="comment">/*!*/</span>;</span><br><span class="line">SET @@SESSION.GTID_NEXT= &#x27;ANONYMOUS&#x27;/*!*/;</span><br><span class="line"><span class="meta"># at 21232</span></span><br><span class="line">#<span class="number">200820</span> <span class="number">11</span>:<span class="number">26</span>:<span class="number">28</span> server id <span class="number">1</span>  end_log_pos <span class="number">21305</span> CRC32 <span class="number">0x2e084ad1</span>        Query   thread_id=<span class="number">11</span>    exec_time=<span class="number">0</span>     error_code=<span class="number">0</span></span><br><span class="line">SET TIMESTAMP=<span class="number">1597893988</span><span class="comment">/*!*/</span>;</span><br><span class="line">BEGIN</span><br><span class="line"><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="meta"># at 21305</span></span><br><span class="line">#<span class="number">200820</span> <span class="number">11</span>:<span class="number">26</span>:<span class="number">28</span> server id <span class="number">1</span>  end_log_pos <span class="number">21353</span> CRC32 <span class="number">0x13267696</span>        Table_map: `mysql`.`tt` mapped to number <span class="number">146</span></span><br><span class="line"><span class="meta"># at 21353</span></span><br><span class="line">#<span class="number">200820</span> <span class="number">11</span>:<span class="number">26</span>:<span class="number">28</span> server id <span class="number">1</span>  end_log_pos <span class="number">21415</span> CRC32 <span class="number">0xf078d9cb</span>        Update_rows: table id <span class="number">146</span> flags: STMT_END_F</span><br><span class="line"></span><br><span class="line">BINLOG &#x27;</span><br><span class="line">ZO09XxMBAAAAMAAAAGlTAAAAAJIAAAAAAAEABW15c3FsAAJ0dAADAwMDAAaWdiYT</span><br><span class="line">ZO09Xx8BAAAAPgAAAKdTAAAAAJIAAAAAAAEAAgAD<span class="comment">///4FAAAAAQAAAAEAAAA+BQAAAAEAAAABQAA</span></span><br><span class="line">AMvZePA=</span><br><span class="line">&#x27;/*!*/;</span><br><span class="line">### UPDATE `mysql`.`tt`</span><br><span class="line">### WHERE</span><br><span class="line">###   @<span class="number">1</span>=<span class="number">20</span> <span class="comment">/* INT meta=0 nullable=0 is_null=0 */</span></span><br><span class="line">###   @<span class="number">2</span>=<span class="number">4</span> <span class="comment">/* INT meta=0 nullable=1 is_null=0 */</span></span><br><span class="line">###   @<span class="number">3</span>=<span class="number">4</span> <span class="comment">/* INT meta=0 nullable=1 is_null=0 */</span></span><br><span class="line">### SET</span><br><span class="line">###   @<span class="number">1</span>=<span class="number">20</span> <span class="comment">/* INT meta=0 nullable=0 is_null=0 */</span></span><br><span class="line">###   @<span class="number">2</span>=<span class="number">4</span> <span class="comment">/* INT meta=0 nullable=1 is_null=0 */</span></span><br><span class="line">###   @<span class="number">3</span>=<span class="number">5</span> <span class="comment">/* INT meta=0 nullable=1 is_null=0 */</span></span><br><span class="line"><span class="meta"># at 21415</span></span><br><span class="line">#<span class="number">200820</span> <span class="number">11</span>:<span class="number">26</span>:<span class="number">28</span> server id <span class="number">1</span>  end_log_pos <span class="number">21446</span> CRC32 <span class="number">0xfa03d621</span>        Xid = <span class="number">662</span></span><br><span class="line">COMMIT<span class="comment">/*!*/</span>;</span><br><span class="line">SET @@SESSION.GTID_NEXT= &#x27;AUTOMATIC&#x27; /* added by mysqlbinlog */ /*!*/;</span><br><span class="line">DELIMITER ;</span><br><span class="line"># End of log file</span><br><span class="line"><span class="comment">/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/</span>;</span><br><span class="line"><span class="comment">/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/</span>;</span><br></pre></td></tr></table></figure>

<h3 id="binlog-rows-query-log-events"><a href="#binlog-rows-query-log-events" class="headerlink" title="binlog_rows_query_log_events"></a>binlog_rows_query_log_events</h3><p>表示binlog日志中row格式下用不用打印执行语句，从前面的事件看，row格式下默认不打印执行语句的。这个参数默认是off:</p>
<h4 id="查看并修改binlog-rows-query-log-events"><a href="#查看并修改binlog-rows-query-log-events" class="headerlink" title="查看并修改binlog_rows_query_log_events"></a>查看并修改binlog_rows_query_log_events</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MySQL [mysql]&gt; show variables like &#x27;binlog_rows_query_log_events&#x27;;</span><br><span class="line">+------------------------------+-------+</span><br><span class="line">| Variable_name                | Value |</span><br><span class="line">+------------------------------+-------+</span><br><span class="line">| binlog_rows_query_log_events | OFF   |</span><br><span class="line">+------------------------------+-------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">MySQL [mysql]&gt; set binlog_rows_query_log_events = &#x27;ON&#x27;;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">MySQL [mysql]&gt; show variables like &#x27;binlog_rows_query_log_events&#x27;;</span><br><span class="line">+------------------------------+-------+</span><br><span class="line">| Variable_name                | Value |</span><br><span class="line">+------------------------------+-------+</span><br><span class="line">| binlog_rows_query_log_events | ON    |</span><br><span class="line">+------------------------------+-------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure>

<h4 id="dml查看binlog打印结果"><a href="#dml查看binlog打印结果" class="headerlink" title="dml查看binlog打印结果"></a>dml查看binlog打印结果</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MySQL [mysql]&gt; update tt set d = <span class="number">20</span> where id = <span class="number">2</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="function">row <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function">Rows matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">MySQL [mysql]&gt; show master status;</span></span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| mysql-bin<span class="number">.000004</span> |    <span class="number">21782</span> |              |                  |                   |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">MySQL [mysql]&gt; update tt set d = 200 where id = 2;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="function">row <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function">Rows matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">MySQL [mysql]&gt; show master status;</span></span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| mysql-bin<span class="number">.000004</span> |    <span class="number">22119</span> |              |                  |                   |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[root@xxxx ]# /usr/local/mysql/mysql/bin/mysqlbinlog mysql-bin<span class="number">.000004</span> -vv --start-position=<span class="number">21782</span> --stop-position=<span class="number">22119</span> </span><br><span class="line"><span class="comment">/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/</span>;</span><br><span class="line"><span class="comment">/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/</span>;</span><br><span class="line">DELIMITER <span class="comment">/*!*/</span>;</span><br><span class="line"><span class="meta"># at 4</span></span><br><span class="line">#<span class="number">200731</span> <span class="number">17</span>:<span class="number">36</span>:<span class="number">11</span> server id <span class="number">1</span>  end_log_pos <span class="number">123</span> CRC32 <span class="number">0xb2d914dd</span>  Start: binlog v <span class="number">4</span>, server v <span class="number">5.7</span><span class="number">.24</span>-log created <span class="number">200731</span> <span class="number">17</span>:<span class="number">36</span>:<span class="number">11</span> at startup</span><br><span class="line"># Warning: <span class="keyword">this</span> binlog is either in use <span class="keyword">or</span> was <span class="keyword">not</span> closed properly.</span><br><span class="line">ROLLBACK<span class="comment">/*!*/</span>;</span><br><span class="line">BINLOG &#x27;</span><br><span class="line">C+YjXw8BAAAAdwAAAHsAAAABAAQANS43LjI0LWxvZwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">AAAAAAAAAAAAAAAAAAAL5iNfEzgNAAgAEgAEBAQEEgAAXwAEGggAAAAICAgCAAAACgoKKioAEjQA</span><br><span class="line">Ad0U2bI=</span><br><span class="line">&#x27;/*!*/;</span><br><span class="line"><span class="meta"># at 21782</span></span><br><span class="line">#<span class="number">200820</span> <span class="number">14</span>:<span class="number">37</span>:<span class="number">40</span> server id <span class="number">1</span>  end_log_pos <span class="number">21847</span> CRC32 <span class="number">0x78241dac</span>        Anonymous_GTID  last_committed=<span class="number">78</span>       sequence_number=<span class="number">79</span>      rbr_only=yes</span><br><span class="line"><span class="comment">/*!50718 SET TRANSACTION ISOLATION LEVEL READ COMMITTED*/</span><span class="comment">/*!*/</span>;</span><br><span class="line">SET @@SESSION.GTID_NEXT= &#x27;ANONYMOUS&#x27;/*!*/;</span><br><span class="line"><span class="meta"># at 21847</span></span><br><span class="line">#<span class="number">200820</span> <span class="number">14</span>:<span class="number">37</span>:<span class="number">40</span> server id <span class="number">1</span>  end_log_pos <span class="number">21920</span> CRC32 <span class="number">0xf4915dd7</span>        Query   thread_id=<span class="number">11</span>    exec_time=<span class="number">0</span>     error_code=<span class="number">0</span></span><br><span class="line">SET TIMESTAMP=<span class="number">1597905460</span><span class="comment">/*!*/</span>;</span><br><span class="line">SET @@session.pseudo_thread_id=<span class="number">11</span><span class="comment">/*!*/</span>;</span><br><span class="line">SET @@session.foreign_key_checks=<span class="number">1</span>, @@session.sql_auto_is_null=<span class="number">0</span>, @@session.unique_checks=<span class="number">1</span>, @@session.autocommit=<span class="number">1</span><span class="comment">/*!*/</span>;</span><br><span class="line">SET @@session.sql_mode=<span class="number">1075838976</span><span class="comment">/*!*/</span>;</span><br><span class="line">SET @@session.auto_increment_increment=<span class="number">1</span>, @@session.auto_increment_offset=<span class="number">1</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="comment">/*!\C latin1 */</span><span class="comment">/*!*/</span>;</span><br><span class="line">SET @@session.character_set_client=<span class="number">8</span>,@@session.collation_connection=<span class="number">8</span>,@@session.collation_server=<span class="number">8</span><span class="comment">/*!*/</span>;</span><br><span class="line">SET @@session.lc_time_names=<span class="number">0</span><span class="comment">/*!*/</span>;</span><br><span class="line">SET @@session.collation_database=DEFAULT<span class="comment">/*!*/</span>;</span><br><span class="line">BEGIN</span><br><span class="line"><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="meta"># at 21920</span></span><br><span class="line">#<span class="number">200820</span> <span class="number">14</span>:<span class="number">37</span>:<span class="number">40</span> server id <span class="number">1</span>  end_log_pos <span class="number">21978</span> CRC32 <span class="number">0x3308d5eb</span>        Rows_query</span><br><span class="line"><span class="meta"># update tt set d = 200 where id = 2</span></span><br><span class="line"><span class="meta"># at 21978</span></span><br><span class="line">#<span class="number">200820</span> <span class="number">14</span>:<span class="number">37</span>:<span class="number">40</span> server id <span class="number">1</span>  end_log_pos <span class="number">22026</span> CRC32 <span class="number">0x06c85227</span>        Table_map: `mysql`.`tt` mapped to number <span class="number">146</span></span><br><span class="line"><span class="meta"># at 22026</span></span><br><span class="line">#<span class="number">200820</span> <span class="number">14</span>:<span class="number">37</span>:<span class="number">40</span> server id <span class="number">1</span>  end_log_pos <span class="number">22088</span> CRC32 <span class="number">0xd1e44ca1</span>        Update_rows: table id <span class="number">146</span> flags: STMT_END_F</span><br><span class="line"></span><br><span class="line">BINLOG &#x27;</span><br><span class="line">NBo+Xx0BAAAAOgAAANpVAACAACJ1cGRhdGUgdHQgc2V0IGQgPSAyMDAgd2hlcmUgaWQgPSAy69UI</span><br><span class="line">Mw==</span><br><span class="line">NBo+XxMBAAAAMAAAAApWAAAAAJIAAAAAAAEABW15c3FsAAJ0dAADAwMDAAYnUsgG</span><br><span class="line">NBo+Xx8BAAAAPgAAAEhWAAAAAJIAAAAAAAEAAgAD<span class="comment">///4AgAAAAIAAAAUAAAA+AIAAAACAAAAyAAA</span></span><br><span class="line">AKFM5NE=</span><br><span class="line">&#x27;/*!*/;</span><br><span class="line">### UPDATE `mysql`.`tt`</span><br><span class="line">### WHERE</span><br><span class="line">###   @<span class="number">1</span>=<span class="number">2</span> <span class="comment">/* INT meta=0 nullable=0 is_null=0 */</span></span><br><span class="line">###   @<span class="number">2</span>=<span class="number">2</span> <span class="comment">/* INT meta=0 nullable=1 is_null=0 */</span></span><br><span class="line">###   @<span class="number">3</span>=<span class="number">20</span> <span class="comment">/* INT meta=0 nullable=1 is_null=0 */</span></span><br><span class="line">### SET</span><br><span class="line">###   @<span class="number">1</span>=<span class="number">2</span> <span class="comment">/* INT meta=0 nullable=0 is_null=0 */</span></span><br><span class="line">###   @<span class="number">2</span>=<span class="number">2</span> <span class="comment">/* INT meta=0 nullable=1 is_null=0 */</span></span><br><span class="line">###   @<span class="number">3</span>=<span class="number">200</span> <span class="comment">/* INT meta=0 nullable=1 is_null=0 */</span></span><br><span class="line"><span class="meta"># at 22088</span></span><br><span class="line">#<span class="number">200820</span> <span class="number">14</span>:<span class="number">37</span>:<span class="number">40</span> server id <span class="number">1</span>  end_log_pos <span class="number">22119</span> CRC32 <span class="number">0x45b08113</span>        Xid = <span class="number">670</span></span><br><span class="line">COMMIT<span class="comment">/*!*/</span>;</span><br><span class="line">SET @@SESSION.GTID_NEXT= &#x27;AUTOMATIC&#x27; /* added by mysqlbinlog */ /*!*/;</span><br><span class="line">DELIMITER ;</span><br><span class="line"># End of log file</span><br><span class="line"><span class="comment">/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/</span>;</span><br><span class="line"><span class="comment">/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/</span>;</span><br></pre></td></tr></table></figure>

<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2>]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql slow log</title>
    <url>/2020-08-20-mysql%20slow%20log/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="">MySQL实战45讲</a></p>
<p><a href="">mysql技术内幕</a></p>
<a id="more"></a>

<h2 id="查看配置"><a href="#查看配置" class="headerlink" title="查看配置"></a>查看配置</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MySQL [mysql]&gt; show variables like &#x27;%slow_query%&#x27;;</span><br><span class="line">+---------------------+-------------------------------+</span><br><span class="line">| Variable_name       | Value                         |</span><br><span class="line">+---------------------+-------------------------------+</span><br><span class="line">| slow_query_log      | ON                            |</span><br><span class="line">| slow_query_log_file | /usr/local/mysql/log/slow.log |</span><br><span class="line">+---------------------+-------------------------------+</span><br><span class="line"><span class="number">2</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[root@xxxx ]<span class="meta"># cat /etc/my.cnf</span></span><br><span class="line">[mysqld]</span><br><span class="line">...</span><br><span class="line">slow_query_log=<span class="number">1</span></span><br><span class="line">slow_query_log_file=/usr/local/mysql/log/slow.log</span><br><span class="line">long_query_time=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>运行时间&gt;long_query_time的语句会被记录下来，和postgresql的日志文件有点像。</p>
<h3 id="log-queries-not-using-indexes"><a href="#log-queries-not-using-indexes" class="headerlink" title="log_queries_not_using_indexes"></a>log_queries_not_using_indexes</h3><p>该参数打开的话，没有使用索引的语句也会被打印出来。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MySQL [mysql]&gt; show variables like &#x27;%using_in%&#x27;;</span><br><span class="line">+----------------------------------------+-------+</span><br><span class="line">| Variable_name                          | Value |</span><br><span class="line">+----------------------------------------+-------+</span><br><span class="line">| log_queries_not_using_indexes          | OFF   |</span><br><span class="line">| log_throttle_queries_not_using_indexes | <span class="number">0</span>     |</span><br><span class="line">+----------------------------------------+-------+</span><br></pre></td></tr></table></figure>

<h3 id="log-throttle-queries-not-using-indexes"><a href="#log-throttle-queries-not-using-indexes" class="headerlink" title="log_throttle_queries_not_using_indexes"></a>log_throttle_queries_not_using_indexes</h3><p>该参数表示每分钟允许记录到slow log的未使用索引的语句次数，默认是0表示没限制，这个参数是mysql5.6.5版本引入的。</p>
<h2 id="mysqldumpslow"><a href="#mysqldumpslow" class="headerlink" title="mysqldumpslow"></a>mysqldumpslow</h2><p>该工具有助于分析slow log,参数如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">[root@xxxx ]# /usr/local/mysql/mysql/bin/mysqldumpslow --help</span><br><span class="line">Usage: mysqldumpslow [ OPTS... ] [ LOGS... ]</span><br><span class="line"></span><br><span class="line">Parse <span class="keyword">and</span> summarize the MySQL slow query log. Options are</span><br><span class="line"></span><br><span class="line">  --verbose    verbose</span><br><span class="line">  --debug      debug</span><br><span class="line">  --help       write <span class="keyword">this</span> text to standard output</span><br><span class="line"></span><br><span class="line">  -v           verbose</span><br><span class="line">  -d           debug</span><br><span class="line">  -s ORDER     what to sort by (al, at, ar, c, l, r, t), &#x27;at&#x27; is default</span><br><span class="line">                al: average lock time</span><br><span class="line">                ar: average rows sent</span><br><span class="line">                at: average query time</span><br><span class="line">                 c: count</span><br><span class="line">                 l: lock time</span><br><span class="line">                 r: rows sent</span><br><span class="line">                 t: query time  </span><br><span class="line">  -<span class="function">r           reverse the sort <span class="title">order</span> <span class="params">(largest last instead of first)</span></span></span><br><span class="line">  -t NUM       just show the top n queries</span><br><span class="line">  -a           don<span class="number">&#x27;</span>t abstract all numbers to N <span class="keyword">and</span> strings to <span class="string">&#x27;S&#x27;</span></span><br><span class="line">  -n NUM       abstract numbers with at least n digits within names</span><br><span class="line">  -g PATTERN   grep: only consider stmts that include <span class="keyword">this</span> string</span><br><span class="line">  -h HOSTNAME  hostname of db server for *-slow.log filename (can be wildcard),</span><br><span class="line">               <span class="keyword">default</span> is <span class="string">&#x27;*&#x27;</span>, i.e. match all</span><br><span class="line">  -<span class="function">i NAME      name of server <span class="title">instance</span> <span class="params">(<span class="keyword">if</span> <span class="keyword">using</span> mysql.server startup script)</span></span></span><br><span class="line">  -l           don&#x27;t subtract lock time from total time</span><br></pre></td></tr></table></figure>

<h2 id="table-slow-Log"><a href="#table-slow-Log" class="headerlink" title="table slow_Log"></a>table slow_Log</h2><p>打开存放满日志到table slow_log的开关：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MySQL [mysql]&gt; show variables like &#x27;log_output&#x27;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| log_output    | FILE  |</span><br><span class="line">+---------------+-------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">MySQL [mysql]&gt; set log_output = &#x27;TABLE&#x27;;</span><br><span class="line">ERROR 1229 (HY000): Variable &#x27;log_output&#x27; is a GLOBAL variable and should be set with SET GLOBAL</span><br><span class="line">MySQL [mysql]&gt; set GLOBAL log_output = &#x27;TABLE&#x27;;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">MySQL [mysql]&gt; show variables like &#x27;log_output&#x27;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| log_output    | TABLE |</span><br><span class="line">+---------------+-------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.02</span> sec)</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MySQL [mysql]&gt; select * from slow_log;</span><br><span class="line">+----------------------------+------------------------------------------------+-----------------+-----------------+-----------+---------------+-------+----------------+-----------+-----------+-----------------+-----------+</span><br><span class="line">| start_time                 | user_host                                      | query_time      | lock_time       | rows_sent | rows_examined | db    | last_insert_id | insert_id | server_id | sql_text        | thread_id |</span><br><span class="line">+----------------------------+------------------------------------------------+-----------------+-----------------+-----------+---------------+-------+----------------+-----------+-----------+-----------------+-----------+</span><br><span class="line">| 2020-07-31 16:28:22.604167 | skip-grants user[root] @ localhost [127.0.0.1] | 00:00:02.001130 | 00:00:00.000000 |         1 |             0 | mysql |              0 |         0 |         0 | select sleep(2) |         2 |</span><br><span class="line">| 2020-08-20 15:30:33.876872 | skip-grants user[root] @ localhost [127.0.0.1] | 00:00:03.000253 | 00:00:00.000000 |         1 |             0 | mysql |              0 |         0 |         1 | select sleep(3) |        12 |</span><br><span class="line">| 2020-08-20 15:30:55.647108 | skip-grants user[root] @ localhost [127.0.0.1] | 00:00:04.000252 | 00:00:00.000000 |         1 |             0 | mysql |              0 |         0 |         1 | select sleep(4) |        12 |</span><br><span class="line">+----------------------------+------------------------------------------------+-----------------+-----------------+-----------+---------------+-------+----------------+-----------+-----------+-----------------+-----------+</span><br><span class="line"><span class="number">3</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure>

<p>表结构：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MySQL [mysql]&gt; show create table slow_log;</span><br><span class="line">+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Table    | Create Table                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |</span><br><span class="line">+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| slow_log | CREATE TABLE `slow_log` (</span><br><span class="line">  `start_time` <span class="built_in">timestamp</span>(<span class="number">6</span>) NOT <span class="literal">NULL</span> DEFAULT <span class="built_in">CURRENT_TIMESTAMP</span>(<span class="number">6</span>) ON UPDATE <span class="built_in">CURRENT_TIMESTAMP</span>(<span class="number">6</span>),</span><br><span class="line">  `user_host` mediumtext NOT <span class="literal">NULL</span>,</span><br><span class="line">  `query_time` <span class="built_in">time</span>(<span class="number">6</span>) NOT <span class="literal">NULL</span>,</span><br><span class="line">  `lock_time` <span class="built_in">time</span>(<span class="number">6</span>) NOT <span class="literal">NULL</span>,</span><br><span class="line">  `rows_sent` <span class="built_in"><span class="keyword">int</span></span>(<span class="number">11</span>) NOT <span class="literal">NULL</span>,</span><br><span class="line">  `rows_examined` <span class="built_in"><span class="keyword">int</span></span>(<span class="number">11</span>) NOT <span class="literal">NULL</span>,</span><br><span class="line">  `db` <span class="built_in">varchar</span>(<span class="number">512</span>) NOT <span class="literal">NULL</span>,</span><br><span class="line">  `last_insert_id` <span class="built_in"><span class="keyword">int</span></span>(<span class="number">11</span>) NOT <span class="literal">NULL</span>,</span><br><span class="line">  `insert_id` <span class="built_in"><span class="keyword">int</span></span>(<span class="number">11</span>) NOT <span class="literal">NULL</span>,</span><br><span class="line">  `server_id` <span class="built_in"><span class="keyword">int</span></span>(<span class="number">10</span>) <span class="keyword">unsigned</span> NOT <span class="literal">NULL</span>,</span><br><span class="line">  `sql_text` mediumblob NOT <span class="literal">NULL</span>,</span><br><span class="line">  `thread_id` <span class="built_in">bigint</span>(<span class="number">21</span>) <span class="keyword">unsigned</span> NOT <span class="literal">NULL</span></span><br><span class="line">) ENGINE=CSV DEFAULT CHARSET=utf8 COMMENT=&#x27;Slow log&#x27; |</span><br><span class="line">+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure>


<p>跟pgsql的统计表很像。不过没找到命中率之类的统计信息。</p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2>]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql 锁与一致性视图</title>
    <url>/2020-08-20-mysql%20%E9%94%81%E4%B8%8E%E4%B8%80%E8%87%B4%E6%80%A7%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="">MySQL实战45讲</a></p>
<p><a href="">mysql技术内幕</a></p>
<a id="more"></a>

<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="lock-latch"><a href="#lock-latch" class="headerlink" title="lock latch"></a>lock latch</h3><p>latch是闩(shuan)锁,就是互斥量，读写锁这种控制临界资源的锁。</p>
<p>lock说的是数据库中的锁，用于锁定事物，包括表锁，行锁，意向锁。</p>
<p><img src="https://i.loli.net/2020/08/21/kwd8Vps4SLXgC5i.jpg" alt="2020082101.jpg"></p>
<h3 id="innodb的锁"><a href="#innodb的锁" class="headerlink" title="innodb的锁"></a>innodb的锁</h3><p>innodb支持行锁，有两种类型：</p>
<ul>
<li>S锁，共享锁，允许事物读</li>
<li>x锁，排他锁，允许事物删除或更新</li>
</ul>
<p>兼容性：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">                    X                   S</span><br><span class="line">X                 不兼容                不兼容</span><br><span class="line"></span><br><span class="line">S                 不兼容                兼容</span><br></pre></td></tr></table></figure>

<h3 id="监测锁"><a href="#监测锁" class="headerlink" title="监测锁"></a>监测锁</h3><h4 id="show-processlist"><a href="#show-processlist" class="headerlink" title="show processlist"></a>show processlist</h4><p>查看所有线程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MySQL [mysql]&gt; show processlist;</span><br><span class="line">+----+------+-----------+-------+---------+------+-------------+------------------+</span><br><span class="line">| Id | User | Host      | db    | Command | Time | State       | Info             |</span><br><span class="line">+----+------+-----------+-------+---------+------+-------------+------------------+</span><br><span class="line">| <span class="number">16</span> | root | localhost | mysql | Query   |    <span class="number">0</span> | System lock | show processlist |</span><br><span class="line">| <span class="number">17</span> | root | localhost | mysql | Sleep   |   <span class="number">86</span> |             | <span class="literal">NULL</span>             |</span><br><span class="line">| <span class="number">18</span> | root | localhost | mysql | Sleep   |  <span class="number">611</span> |             | <span class="literal">NULL</span>             |</span><br><span class="line">+----+------+-----------+-------+---------+------+-------------+------------------+</span><br></pre></td></tr></table></figure>

<h4 id="information-schema-innodb-trx"><a href="#information-schema-innodb-trx" class="headerlink" title="information_schema.innodb_trx"></a>information_schema.innodb_trx</h4><p>查看运行的事务</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">| INNODB_TRX | CREATE TEMPORARY TABLE `INNODB_TRX` (</span><br><span class="line">  `trx_id` varchar(18) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">  `trx_state` varchar(13) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">  `trx_started` datetime NOT NULL DEFAULT &#x27;0000-00-00 00:00:00&#x27;,</span><br><span class="line">  `trx_requested_lock_id` varchar(<span class="number">81</span>) DEFAULT <span class="literal">NULL</span>,</span><br><span class="line">  `trx_wait_started` datetime DEFAULT <span class="literal">NULL</span>,</span><br><span class="line">  `trx_weight` bigint(<span class="number">21</span>) <span class="keyword">unsigned</span> NOT <span class="literal">NULL</span> DEFAULT <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">  `trx_mysql_thread_id` bigint(<span class="number">21</span>) <span class="keyword">unsigned</span> NOT <span class="literal">NULL</span> DEFAULT <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">  `trx_query` varchar(<span class="number">1024</span>) DEFAULT <span class="literal">NULL</span>,</span><br><span class="line">  `trx_operation_state` varchar(<span class="number">64</span>) DEFAULT <span class="literal">NULL</span>,</span><br><span class="line">  `trx_tables_in_use` bigint(<span class="number">21</span>) <span class="keyword">unsigned</span> NOT <span class="literal">NULL</span> DEFAULT <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">  `trx_tables_locked` bigint(<span class="number">21</span>) <span class="keyword">unsigned</span> NOT <span class="literal">NULL</span> DEFAULT <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">  `trx_lock_structs` bigint(<span class="number">21</span>) <span class="keyword">unsigned</span> NOT <span class="literal">NULL</span> DEFAULT <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">  `trx_lock_memory_bytes` bigint(<span class="number">21</span>) <span class="keyword">unsigned</span> NOT <span class="literal">NULL</span> DEFAULT <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">  `trx_rows_locked` bigint(<span class="number">21</span>) <span class="keyword">unsigned</span> NOT <span class="literal">NULL</span> DEFAULT <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">  `trx_rows_modified` bigint(<span class="number">21</span>) <span class="keyword">unsigned</span> NOT <span class="literal">NULL</span> DEFAULT <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">  `trx_concurrency_tickets` bigint(<span class="number">21</span>) <span class="keyword">unsigned</span> NOT <span class="literal">NULL</span> DEFAULT <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">  `trx_isolation_level` varchar(16) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">  `trx_unique_checks` <span class="keyword">int</span>(<span class="number">1</span>) NOT <span class="literal">NULL</span> DEFAULT <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">  `trx_foreign_key_checks` <span class="keyword">int</span>(<span class="number">1</span>) NOT <span class="literal">NULL</span> DEFAULT <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">  `trx_last_foreign_key_error` varchar(<span class="number">256</span>) DEFAULT <span class="literal">NULL</span>,</span><br><span class="line">  `trx_adaptive_hash_latched` <span class="keyword">int</span>(<span class="number">1</span>) NOT <span class="literal">NULL</span> DEFAULT <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">  `trx_adaptive_hash_timeout` bigint(<span class="number">21</span>) <span class="keyword">unsigned</span> NOT <span class="literal">NULL</span> DEFAULT <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">  `trx_is_read_only` <span class="keyword">int</span>(<span class="number">1</span>) NOT <span class="literal">NULL</span> DEFAULT <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">  `trx_autocommit_non_locking` <span class="keyword">int</span>(<span class="number">1</span>) NOT <span class="literal">NULL</span> DEFAULT <span class="string">&#x27;0&#x27;</span></span><br><span class="line">) ENGINE=MEMORY DEFAULT CHARSET=utf8 |</span><br><span class="line"></span><br><span class="line">MySQL [mysql]&gt; select trx_id,trx_state,trx_query from information_schema.innodb_trx;</span><br><span class="line">+-----------------+-----------+-----------+</span><br><span class="line">| trx_id          | trx_state | trx_query |</span><br><span class="line">+-----------------+-----------+-----------+</span><br><span class="line">| <span class="number">421346370501344</span> | RUNNING   | <span class="literal">NULL</span>      |</span><br><span class="line">+-----------------+-----------+-----------+</span><br></pre></td></tr></table></figure>

<h4 id="information-schema-innodb-locks"><a href="#information-schema-innodb-locks" class="headerlink" title="information_schema.innodb_locks"></a>information_schema.innodb_locks</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MySQL [mysql]&gt; select * from information_schema.innodb_locks;</span><br><span class="line">+--------------+-------------+-----------+-----------+--------------+------------+------------+-----------+----------+-----------+</span><br><span class="line">| lock_id      | lock_trx_id | lock_mode | lock_type | lock_table   | lock_index | lock_space | lock_page | lock_rec | lock_data |</span><br><span class="line">+--------------+-------------+-----------+-----------+--------------+------------+------------+-----------+----------+-----------+</span><br><span class="line">| <span class="number">18651</span>:<span class="number">76</span>:<span class="number">4</span>:<span class="number">5</span> | <span class="number">18651</span>       | X         | RECORD    | `mysql`.`tt` | c          |         <span class="number">76</span> |         <span class="number">4</span> |        <span class="number">5</span> | <span class="number">4</span>         |</span><br><span class="line">| <span class="number">18650</span>:<span class="number">76</span>:<span class="number">4</span>:<span class="number">5</span> | <span class="number">18650</span>       | X         | RECORD    | `mysql`.`tt` | c          |         <span class="number">76</span> |         <span class="number">4</span> |        <span class="number">5</span> | <span class="number">4</span>         |</span><br><span class="line">+--------------+-------------+-----------+-----------+--------------+------------+------------+-----------+----------+-----------+</span><br><span class="line"><span class="number">2</span> rows in <span class="built_in">set</span>, <span class="number">1</span> warning (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<h4 id="information-schema-innodb-lock-waits"><a href="#information-schema-innodb-lock-waits" class="headerlink" title="information_schema.innodb_lock_waits"></a>information_schema.innodb_lock_waits</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MySQL [mysql]&gt; select * from information_schema.innodb_lock_waits;</span><br><span class="line">+-------------------+-------------------+-----------------+------------------+</span><br><span class="line">| requesting_trx_id | requested_lock_id | blocking_trx_id | blocking_lock_id |</span><br><span class="line">+-------------------+-------------------+-----------------+------------------+</span><br><span class="line">| <span class="number">18651</span>             | <span class="number">18651</span>:<span class="number">76</span>:<span class="number">4</span>:<span class="number">5</span>      | <span class="number">18650</span>           | <span class="number">18650</span>:<span class="number">76</span>:<span class="number">4</span>:<span class="number">5</span>     |</span><br><span class="line">+-------------------+-------------------+-----------------+------------------+</span><br><span class="line"><span class="number">1</span> row in <span class="built_in">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h3><p>一致性非锁定读是innodb根据mvcc的方式来读取数据库中的数据。读取不需要等待对应行上的x锁的释放。读取是按照快照的形式，快照是通过undo日志实现的。</p>
<p><img src="https://i.loli.net/2020/08/21/ItPxE9KiQvAl4nC.png" alt="2020082102.png"></p>
<p>图中u1,u2,u3记录的是undo日志，v1,v2,v3,v4是根据undo日志反推出来的结果。trx_id是事务id,是事务系统维护的一个递增的值，可以用来判断版本和事务之间的关系。</p>
<blockquote>
<p>在实现上， InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指的就是，启动了但还没提交。</p>
</blockquote>
<p>在隔离级别read committed, repeatable read下，innodb使用一致性非锁定读。两种隔离级别选择快照的时间点是不一样的。</p>
<ul>
<li>RC下，在每条语句执行前，记录快照/视图</li>
<li>RR下，在事物启动后，第一条查询语句执行后(或者start transaction with consistent snapshot),记录快照/视图</li>
</ul>
<p>测试下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MySQL [mysql]&gt; select * from tt;</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line">| id | c    | d    | field | f2   | f3   |</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line">|  <span class="number">1</span> |    <span class="number">1</span> |    <span class="number">1</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">|  <span class="number">2</span> |    <span class="number">2</span> |  <span class="number">200</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">|  <span class="number">3</span> |    <span class="number">3</span> |   <span class="number">30</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">| <span class="number">20</span> |    <span class="number">4</span> |  <span class="number">500</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">+----+------+------+-------+------+------+</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">        sessionA                        sessionB</span><br><span class="line">start transaction with </span><br><span class="line">consistent snapshot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                        update tt <span class="built_in">set</span> d = <span class="number">0</span> where c = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">select * from tt where c = <span class="number">4</span>;</span><br><span class="line"><span class="comment">//d=500 isolation=RR</span></span><br><span class="line"><span class="comment">//d=0   isolation=RC</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//REPEATABLE-READ</span></span><br><span class="line">MySQL [mysql]&gt; select @@tx_isolation;</span><br><span class="line">+-----------------+</span><br><span class="line">| @@tx_isolation  |</span><br><span class="line">+-----------------+</span><br><span class="line">| REPEATABLE-READ |</span><br><span class="line">+-----------------+</span><br><span class="line"><span class="number">1</span> row in <span class="built_in">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">MySQL [mysql]&gt; select * from tt where c = <span class="number">4</span>;</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line">| id | c    | d    | field | f2   | f3   |</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line">| <span class="number">20</span> |    <span class="number">4</span> |  <span class="number">500</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//READ-COMMITTED </span></span></span><br><span class="line">MySQL [mysql]&gt; set session transaction isolation level READ COMMITTED;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">MySQL [mysql]&gt; select @@tx_isolation;</span><br><span class="line">+----------------+</span><br><span class="line">| @@tx_isolation |</span><br><span class="line">+----------------+</span><br><span class="line">| READ-COMMITTED |</span><br><span class="line">+----------------+</span><br><span class="line"><span class="number">1</span> row in <span class="built_in">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">MySQL [mysql]&gt; begin;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//sessionB MySQL [mysql]&gt; update tt set d = 20 where c = 4;</span></span></span><br><span class="line">MySQL [mysql]&gt; select * from tt where c = 4;</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line">| id | c    | d    | field | f2   | f3   |</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line">| <span class="number">20</span> |    <span class="number">4</span> |   <span class="number">20</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="一致性锁定读"><a href="#一致性锁定读" class="headerlink" title="一致性锁定读"></a>一致性锁定读</h3><p>一致性非锁定读基于mvcc，利用快照去找对应版本的行记录，不需要等待x锁的释放。而一致性锁定读需要加锁，来取最新版本的数据。有两种形式：</p>
<ul>
<li>select … for update</li>
<li>select … lock in share mode</li>
</ul>
<h3 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h3><blockquote>
<p>两阶段锁（two-phase locking，2PL）是数据库事务处理时的并发控制方法，以保证可串行化。[1][2]</p>
</blockquote>
<p>这种方法使用数据库锁在两个阶段：</p>
<ul>
<li>扩张阶段：不断上锁，没有锁被释放</li>
<li>收缩阶段：锁被陆续释放，没有新的加锁</li>
</ul>
<p>2PL可能会导致死锁。</p>
<p>证明如下，太麻烦了，贴个链接不看了</p>
<p><a href="https://www.cnblogs.com/gatsby123/p/10800089.html">CMU-15445 LAB3:事务隔离，two-phase locking，锁管理器</a></p>
<h3 id="gap-lock"><a href="#gap-lock" class="headerlink" title="gap lock"></a>gap lock</h3><p>放在幻读的文章总结了。</p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2>]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>c++ 虚析构</title>
    <url>/2020-08-24-c++%20%E8%99%9A%E6%9E%90%E6%9E%84/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一个非常基础又常见的问题，总感觉隔一段时间突然遇到这个问题的时候会有点”不安全“的感觉。不能很确定完整的讲述出来，所以做一个简单的总结，加深记忆。</p>
<a id="more"></a>

<h2 id="case1"><a href="#case1" class="headerlink" title="case1"></a>case1</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">base</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;cons -&gt; base&quot;</span> &lt;&lt; endl;     <span class="comment">//step 2</span></span><br><span class="line">    &#125;       <span class="comment">//step 3</span></span><br><span class="line">    ~<span class="built_in">base</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;dest -&gt; base&quot;</span> &lt;&lt; endl;     <span class="comment">//s 3</span></span><br><span class="line">    &#125;       <span class="comment">//s 4</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">drive</span>:</span> <span class="keyword">public</span> base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">drive</span>()</span><br><span class="line">    &#123;       <span class="comment">//step 1</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;cons -&gt; drive&quot;</span> &lt;&lt; endl;    <span class="comment">//step 4</span></span><br><span class="line">    &#125;       <span class="comment">//step 5</span></span><br><span class="line">    ~<span class="built_in">drive</span>()</span><br><span class="line">    &#123;       <span class="comment">//s 2</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;dest -&gt; drive&quot;</span> &lt;&lt; endl;    <span class="comment">//s 1</span></span><br><span class="line">    &#125;       <span class="comment">//s 5</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    drive *d = <span class="keyword">new</span> drive;</span><br><span class="line">    <span class="keyword">delete</span> d;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>output</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cons -&gt; base</span><br><span class="line">cons -&gt; drive</span><br><span class="line">dest -&gt; drive</span><br><span class="line">dest -&gt; base</span><br></pre></td></tr></table></figure>

<p><code>gdb</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">看注释</span><br><span class="line">构造函数：先基类，后派生类</span><br><span class="line">析构函数：先派生类，后基类</span><br></pre></td></tr></table></figure>

<h2 id="case-2"><a href="#case-2" class="headerlink" title="case 2"></a>case 2</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">base</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;cons -&gt; base&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">base</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;dest -&gt; base&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">drive</span>:</span> <span class="keyword">public</span> base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">drive</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;cons -&gt; drive&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">drive</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;dest -&gt; drive&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    base *b = <span class="keyword">new</span> drive;</span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>output</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cons -&gt; base</span><br><span class="line">cons -&gt; drive</span><br><span class="line">dest -&gt; drive</span><br><span class="line">dest -&gt; base</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>利用多态的时候</p>
<ul>
<li>如果析构函数不是虚函数，则delete基类指针，就只执行基类的析构函数。</li>
<li>如果析构函数是虚函数，则根据多态，执行实际指向类的析构函数</li>
</ul>
<p>对于基类指针指向派生类的情况，delete基类指针可以调用派生类的析构函数，派生类的析构函数自己执行完再调用基类的析构函数，保证都得到了释放，仅此而已。</p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2>]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql mvcc</title>
    <url>/2020-08-24-mysql%20mvcc/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/cb97f76a92fd">数据库事务、隔离级别和锁</a></p>
<p><a href="">高性能mysql第三版</a></p>
<p><a href="">mysql技术内幕</a></p>
<p><a href="">mysql实战45讲</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6">wikipedia</a></p>
<a id="more"></a>

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote>
<p>多版本并发控制(Multiversion concurrency control， MCC 或 MVCC)，是数据库管理系统常用的一种并发控制，也用于程序设计语言实现事务内存。[1]</p>
</blockquote>
<blockquote>
<p>MVCC意图解决读写锁造成的多个、长时间的读操作饿死写操作问题。每个事务读到的数据项都是一个历史快照（snapshot)并依赖于实现的隔离级别。写操作不覆盖已有数据项，而是创建一个新的版本，直至所在操作提交时才变为可见。快照隔离使得事物看到它启动时的数据状态。</p>
</blockquote>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>主要针对读操作，减少加锁的负担</li>
<li>写操作不覆盖历史版本</li>
</ul>
<h2 id="innodb的实现"><a href="#innodb的实现" class="headerlink" title="innodb的实现"></a>innodb的实现</h2><p>Innodb的mvcc，是通过在每行记录后面保存两个隐藏的列来实现的，增加了一定的存储空间。两个列：</p>
<ul>
<li>创建事务的trx_id      //create_trx_id</li>
<li>删除事物的trx_id      //del_trx_id</li>
</ul>
<p>dml操作如何操纵，利用这两个值(mvcc只对repeatable read/read committed两种隔离级别有效)：</p>
<p><code>select</code></p>
<p>select取的是snapshot的结果：</p>
<p>更新点：</p>
<ul>
<li>对于repeatale read,在begin select或者start transaction with consistent  snapshot的时候更新快照</li>
<li>对于read committed,在每条语句执行的时候更新快照</li>
</ul>
<p>快照通过当前事务的trx_id和对应行记录现存的所有版本的create_trx_id,del_trx_id对比得到。不同版本的行记录是通过链表保存的。链表中所有记录的trx_id不是递增的，老得事务可能后提交，链表是根据版本递增的。</p>
<p>如果是rc,在更新点，取已提交的最新版本(&lt; current_trx_id或者 &gt; current_trx_id),每条语句都更新结果.并且del_trx_id为空才可查到<br>如果是rr,在更新点，取已提交的最新版本(&lt; current_trx_id),当前事务后续进行的修改会更新结果。并且del_trx_id为空才可查到</p>
<p><code>insert</code></p>
<blockquote>
<p>将create_trx_id更新为当前事务的trx_id</p>
</blockquote>
<p><code>delete</code></p>
<blockquote>
<p>将del_trx_id更新为当前事物的trx_id</p>
</blockquote>
<p><code>update</code></p>
<blockquote>
<p>如果不是主键列，则记录反向的日志，如果执行delete,则undo记录insert,可以反推出更改前的值</p>
</blockquote>
<blockquote>
<p>如果是主键列，新增一条行记录，也就是多了一个版本，将老得行记录版本的del_trx_id更新为当前事务的trx_id,将新的行记录版本的create_trx_id更新为当前事务的trx_id</p>
</blockquote>
<p>对于innodb,mvcc只适用于repeatable read, read committed两种隔离级别，对于read uncommitted,直接读最新版本即可不需要历史版本的参考，而serializable的每次读都是select … lock in share mode,都是加锁读</p>
<p>innodb的purse线程会清除部分历史版本的row记录，当链表中的版本中的create_trx_id小于当前活跃的事务的最小id的时候，这个版本的记录就可能被清楚。</p>
<h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><p>pgsql中mvcc的实现，是把所有版本都存在b+树中，这样查询很快，删除比较麻烦 <br><br>innodb通过undo log来保存mvcc的多版本，b+树只保存最新提交的版本，老版本保存在undolog中，通过链表串起来</p>
<p>undo log也会持久化的，默认存在共享表空间</p>
<p>undo log也可用于事务回滚，保证事务的一致性，undo log记录的是逻辑日志。</p>
<h2 id="mvcc的作用"><a href="#mvcc的作用" class="headerlink" title="mvcc的作用"></a>mvcc的作用</h2><p>如果有人这样问，总得有个差不多的听起来是对的回答：</p>
<p>降低多版本并发时候的读负担(相对加锁)，以牺牲一点存储空间为代价</p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2>]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql 事务</title>
    <url>/2020-08-25-mysql%20%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/cb97f76a92fd">数据库事务、隔离级别和锁</a></p>
<p><a href="">mysql技术内幕</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1">wikipedia</a></p>
<p><a href="">mysql实战45讲</a></p>
<a id="more"></a>

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote>
<p>数据库事务（简称：事务）是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成</p>
</blockquote>
<h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><h3 id="atomicity-原子性"><a href="#atomicity-原子性" class="headerlink" title="atomicity   原子性"></a>atomicity   原子性</h3><blockquote>
<p>事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行</p>
</blockquote>
<p>就像atm取款一样，出账和入账不能部分完成。</p>
<h3 id="consistency-一致性"><a href="#consistency-一致性" class="headerlink" title="consistency 一致性"></a>consistency 一致性</h3><blockquote>
<p>事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束</p>
</blockquote>
<p>比如唯一键约束，外键约束</p>
<h3 id="isolation-隔离性"><a href="#isolation-隔离性" class="headerlink" title="isolation   隔离性"></a>isolation   隔离性</h3><blockquote>
<p>多个事务并发执行时，一个事务的执行不应影响其他事务的执行</p>
</blockquote>
<p>通常通过锁，或者mvcc等实现</p>
<h3 id="durability-持久性"><a href="#durability-持久性" class="headerlink" title="durability  持久性"></a>durability  持久性</h3><blockquote>
<p>已被提交的事务对数据库的修改应该永久保存在数据库中</p>
</blockquote>
<p>事务提交的时候，redo log, binlog会刷盘(也可根据配置参数调整)，总之，在数据库层面是可以保证事务提交后的持久性的，但外部比如硬件导致的异常不可控</p>
<h2 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h2><ul>
<li>隔离性通过锁或者mvcc实现</li>
<li>原子性，持久性通过redo log</li>
<li>一致性通过undo log</li>
</ul>
<h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><h4 id="innodb-flush-log-at-trx-commit"><a href="#innodb-flush-log-at-trx-commit" class="headerlink" title="innodb_flush_log_at_trx_commit"></a>innodb_flush_log_at_trx_commit</h4><p>事务提交时候，redo log会把redo log buffer的数据写入系统文件缓存，并同步到磁盘(可以根据参数innodb_flush_log_at_trx_commit控制写入的时机)。</p>
<p><img src="https://i.loli.net/2020/08/25/CHPLZbE8y9t1XAU.png" alt="2020082502.png"></p>
<p>图片来源：<a href="">mysql实战45讲</a></p>
<p>innodb_flush_log_at_trx_commit的取值情况：</p>
<ul>
<li>0:    事务提交时不写重做日志(redo log和undo log),只是留在redo log buffer,master thread会每隔1s进行fsync的</li>
<li>1:    默认值，每次提交进行fsync</li>
<li>2:    提交时候，写入系统文件缓存</li>
</ul>
<p>除了后台线程刷盘，还有两种情况导致redo log持久化的：</p>
<ul>
<li>redo log buffer大小达到innodb_log_buffer_size一半的时候</li>
<li>其他事物提交的时候如果设置的要刷盘，由于redo log buffer对于事务是公用的，事务会把别的事务的redo log连带fsync</li>
</ul>
<h4 id="sync-binlog"><a href="#sync-binlog" class="headerlink" title="sync_binlog"></a>sync_binlog</h4><p><img src="https://i.loli.net/2020/08/25/b4o5zDtPL6iulQ7.png" alt="2020082503.png"></p>
<p>图片来源：<a href="">mysql实战45讲</a></p>
<p>binlog也有刷盘策略可以控制的：</p>
<p>sync_binlog的取值：</p>
<ul>
<li>0:    每次事务提交，只write写文件缓存，不fsync</li>
<li>1:    每次提交都fsync</li>
<li>N&gt;1:   每次提交都write,积累N个事务后，fsync</li>
</ul>
<h4 id="双1"><a href="#双1" class="headerlink" title="双1"></a>双1</h4><p>sync_binlog=1,innodb_flush_log_at_trx_commit=1</p>
<p>这样设置可以保证每次提交事务，binlog和redo log都刷盘，高可用，但是io压力大</p>
<h4 id="非双1"><a href="#非双1" class="headerlink" title="非双1"></a>非双1</h4><p>业务高峰期，备库延迟，批量导入这样的场景可以设置非双1，提高数据库性能，牺牲一点可靠性的代价。mysql实战45讲给的参考是：innodb_flush_logs_at_trx_commit=2、sync_binlog=1000。</p>
<h4 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h4><p>redo log的写入是基于<code>两阶段提交</code>的：</p>
<blockquote>
<p>二阶段提交（英语：Two-phase Commit）是指在计算机网络以及数据库领域内，为了使基于分布式系统架构下的所有节点在进行事务提交时保持一致性而设计的一种算法。通常，二阶段提交也被称为是一种协议（Protocol）。在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为协调者的组件来统一掌控所有节点（称作参与者）的操作结果并最终指示这些节点是否要把操作结果进行真正的提交（比如将更新后的数据写入磁盘等等）。因此，二阶段提交的算法思路可以概括为： 参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。</p>
</blockquote>
<p>概念中的两阶段提交主要针对分布式事务，这里讲的是内部事务的两阶段提交，大同小异。</p>
<p><img src="https://i.loli.net/2020/08/25/mJXokeNMhwstWU6.jpg" alt="2020082501.jpg"></p>
<h3 id="LSN"><a href="#LSN" class="headerlink" title="LSN"></a>LSN</h3><p>log sequence number,日志序列号。在innodb中，占用8字节，单调递增</p>
<p>含义：</p>
<ul>
<li>重做日志写入的总量          //1</li>
<li>checkpoint的位置          //2</li>
<li>页的版本                  //3</li>
</ul>
<p>1: lsn表示了重做日志的字节的总量，加入原来lsn=1000,重做日志写入1000字节，则lsn=1100</p>
<p>2:可用于checkpoint的记录</p>
<p><img src="https://i.loli.net/2020/08/25/r5QekZoFTL4lAzx.jpg" alt="2020082504.jpg"></p>
<p>redo log组的第一个日志文件的文件头会保存checkpoint位置，checkpoint表示已经刷新到磁盘的lsn号</p>
<p>3:每个页的头部，FIL_PAGE_LSN记录这个页的lsn号，表示该页最后刷新时的lsn号，通过对比redo log中的lsn号，可用于恢复页</p>
<h3 id="group-commit"><a href="#group-commit" class="headerlink" title="group commit"></a>group commit</h3><p>fsync的效率是很慢的，组提交可以一次将多个fsync同时进行，提高效率。</p>
<p>两阶段提交过程：</p>
<p>1: innodb存储引擎进行prepare <br><br>2: mysql写入binlog日志  <br><br>3: innodb写入重做日志文件 <br></p>
<ul>
<li>3.1 将日志写入日志缓冲</li>
<li>3.2 调用fsync</li>
</ul>
<p>3.1步可以并发执行的时候，到3.2就可能一次把多个事务的日志刷盘。但是mysql老得版本不支持，因为老得版本两阶段提交会加锁prepare_commit_mutex,这个锁会导致3.2执行的时候，其他事物不能执行3.1.导致group commit不可用。不过mysql5.6通过BLGC解决了该问题：</p>
<h4 id="BLGC"><a href="#BLGC" class="headerlink" title="BLGC"></a>BLGC</h4><p><img src="https://i.loli.net/2020/08/25/8X35jnyWDv6acz1.jpg" alt="2020082505.jpg"></p>
<p>binlog group comit，mysql server层提交时，按顺序将其放入一个队列，队列中的第一个事务成为leader,其他事务成为follower,leader控制follower,分3个阶段：</p>
<ul>
<li>flush阶段，二进制日志写入内存</li>
<li>sync阶段，二进制日志刷盘，将队列中所有事物刷盘</li>
<li>commit阶段，leader根据顺序调用存储引擎层的事务的提交。innodb本来就支持组提交。</li>
</ul>
<p>blgc实现没有用到prepare_commit_mutex锁，所以innodb层group commmit可以发挥出来，并且server层的binlog也变成了group commit,性能很好。</p>
<p>原来server层的binlog是每个线程单独一个binlog cache的，不像redo log是公用的redo log buffer,通过队列将binlog cache串起来组提交。并且leader可以根据顺序控制引擎层按照顺序提交，不需要加锁。    </p>
<h3 id="purge"><a href="#purge" class="headerlink" title="purge"></a>purge</h3><p><img src="https://i.loli.net/2020/08/25/r9NvOXoRm5HKWg1.jpg" alt="2020082506.jpg"></p>
<p>由于mvcc的缘故，删除操作并不直接删除数据，因为这个版本的记录可能被其他事务引用，所以update/delete的时候如果是删除数据，只是把删除标记置为真(不确定这个标记是不是就是del_trx_id),真正删除是purge线程判断然后处理的。</p>
<p>undo log允许在一个页上保存多个undo log记录，之前也总结过undo log是通过链表串起来的，结合这两点，再看上面的图：</p>
<p>从链表第一个节点开始，trx1找到undo page1,清除trx1的undo log,然后继续在这个页中找其他的事务，清除trx3,然后找到trx5,trx5被其他事务引用了，不能删除，回到链表，找到trx2,然后trx6,trx4,整个undo page2就清除完了，该页可以被其他地方使用了。</p>
<p>以上就是purge的大概流程，优先清除一个页上的undo log,避免了过多的随机写操作。</p>
<p>purge还涉及一些配置参数，感觉不是很重要，就不记录了。</p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2>]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql 幻读</title>
    <url>/2020-08-25-mysql%20%E5%B9%BB%E8%AF%BB/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="">mysql实战45讲</a></p>
<a id="more"></a>

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote>
<p>phantom problem是指在同一事务下，连续执行两次的sql语句可能导致不同的结果，第二次的sql语句可能会返回之前不存在的行</p>
</blockquote>
<p>一定记住是之前<strong>不存在的行</strong>，这点很重要。</p>
<h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MySQL [mysql]&gt; select * from tt;</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line">| id | c    | d    | field | f2   | f3   |</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line">|  <span class="number">1</span> |    <span class="number">1</span> |  <span class="number">777</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">|  <span class="number">2</span> |    <span class="number">2</span> |  <span class="number">200</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">|  <span class="number">3</span> |    <span class="number">3</span> |   <span class="number">30</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">|  <span class="number">9</span> |    <span class="number">5</span> |   <span class="number">50</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">| <span class="number">20</span> |    <span class="number">4</span> |   <span class="number">90</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line"><span class="number">5</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure>

<p>设置场景：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">        sessionA                        sessionB</span><br><span class="line">    begin;</span><br><span class="line"></span><br><span class="line">T1  select * from tt where c &gt; <span class="number">2</span>; </span><br><span class="line">    <span class="comment">//select * from tt where c &gt; 2 for update;  </span></span><br><span class="line">    update tt <span class="built_in">set</span> d = <span class="number">0</span> where c &gt; <span class="number">2</span>;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">T2                                       insert tt select null,<span class="number">6</span>,<span class="number">60</span>,null,null,null;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">T3  select * from tt where c &gt; <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//select * from tt where c &gt; 2 for update;   </span></span><br><span class="line"></span><br><span class="line">    commit;</span><br></pre></td></tr></table></figure>

<p>预期结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">T1 select:</span><br><span class="line">|  <span class="number">3</span> |    <span class="number">3</span> |   <span class="number">30</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">|  <span class="number">9</span> |    <span class="number">5</span> |   <span class="number">50</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">| <span class="number">20</span> |    <span class="number">4</span> |   <span class="number">90</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line"></span><br><span class="line">--------------------------------------------------</span><br><span class="line"></span><br><span class="line">T1 update:</span><br><span class="line">|  <span class="number">3</span> |    <span class="number">3</span> |   <span class="number">0</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">|  <span class="number">9</span> |    <span class="number">5</span> |   <span class="number">0</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">| <span class="number">20</span> |    <span class="number">4</span> |   <span class="number">0</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line"></span><br><span class="line">--------------------------------------------------</span><br><span class="line"></span><br><span class="line">T2 insert:</span><br><span class="line">|  <span class="number">3</span> |    <span class="number">3</span> |   <span class="number">0</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">|  <span class="number">9</span> |    <span class="number">5</span> |   <span class="number">0</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">| <span class="number">20</span> |    <span class="number">4</span> |   <span class="number">0</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">| <span class="number">21</span> |    <span class="number">6</span> |  <span class="number">60</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line"></span><br><span class="line">--------------------------------------------------</span><br><span class="line"></span><br><span class="line">T3 select:</span><br><span class="line"></span><br><span class="line">可能<span class="number">1</span>:</span><br><span class="line">|  <span class="number">3</span> |    <span class="number">3</span> |   <span class="number">0</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">|  <span class="number">9</span> |    <span class="number">5</span> |   <span class="number">0</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">| <span class="number">20</span> |    <span class="number">4</span> |   <span class="number">0</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">| <span class="number">21</span> |    <span class="number">6</span> |  <span class="number">60</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line"></span><br><span class="line">可能<span class="number">2</span>:</span><br><span class="line">|  <span class="number">3</span> |    <span class="number">3</span> |   <span class="number">0</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">|  <span class="number">9</span> |    <span class="number">5</span> |   <span class="number">0</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">| <span class="number">20</span> |    <span class="number">4</span> |   <span class="number">0</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br></pre></td></tr></table></figure>


<h3 id="读提交场景"><a href="#读提交场景" class="headerlink" title="读提交场景"></a>读提交场景</h3><p>sessionB:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MySQL [mysql]&gt;  <span class="built_in">set</span> session tx_isolation=<span class="string">&quot;read-committed&quot;</span>;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">MySQL [mysql]&gt; select @@tx_isolation;</span><br><span class="line">+----------------+</span><br><span class="line">| @@tx_isolation |</span><br><span class="line">+----------------+</span><br><span class="line">| READ-COMMITTED |</span><br><span class="line">+----------------+</span><br><span class="line"><span class="number">1</span> row in <span class="built_in">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">MySQL [mysql]&gt; begin;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">MySQL [mysql]&gt; insert tt select null,6,60,null,null,null;</span><br><span class="line">ERROR <span class="number">1665</span> (HY000): Cannot execute statement: impossible to write to binary <span class="built_in">log</span> since BINLOG_FORMAT = STATEMENT <span class="keyword">and</span> at least one table uses a storage engine limited to row-based logging. InnoDB is limited to row-logging when transaction isolation level is READ COMMITTED <span class="keyword">or</span> READ UNCOMMITTED.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ERROR 1665 (HY000): Cannot execute statement: impossible to write to binary log since BINLOG_FORMAT = STATEMENT and at least one table uses a storage engine limited to row-based logging. InnoDB is limited to row-logging when transaction isolation level is READ COMMITTED or READ UNCOMMITTED.</p>
</blockquote>
<p>这里报错，因为binlog现在是statement,innodb认为在rc/ru下，binlog应该设置为row.</p>
<p>ok,改成row,继续：</p>
<p>sessionA</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MySQL [mysql]&gt; select @@tx_isolation;</span><br><span class="line">+----------------+</span><br><span class="line">| @@tx_isolation |</span><br><span class="line">+----------------+</span><br><span class="line">| READ-COMMITTED |</span><br><span class="line">+----------------+</span><br><span class="line"><span class="number">1</span> row in <span class="built_in">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">MySQL [mysql]&gt; select * from tt where c &gt; <span class="number">2</span>; </span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line">| id | c    | d    | field | f2   | f3   |</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line">|  <span class="number">3</span> |    <span class="number">3</span> |   <span class="number">30</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">|  <span class="number">9</span> |    <span class="number">5</span> |   <span class="number">50</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">| <span class="number">20</span> |    <span class="number">4</span> |   <span class="number">90</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line"><span class="number">3</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">MySQL [mysql]&gt; update tt set d = 0 where c &gt; 2; </span><br><span class="line">Query OK, <span class="number">3</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br><span class="line"><span class="function">Rows matched: 3  Changed: 3  Warnings: 0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line">MySQL [mysql]&gt; select * from tt where c &gt; 2;</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line">| id | c    | d    | field | f2   | f3   |</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line">|  <span class="number">3</span> |    <span class="number">3</span> |    <span class="number">0</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">|  <span class="number">9</span> |    <span class="number">5</span> |    <span class="number">0</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">| <span class="number">12</span> |    <span class="number">6</span> |   <span class="number">60</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">| <span class="number">20</span> |    <span class="number">4</span> |    <span class="number">0</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line"><span class="number">4</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br></pre></td></tr></table></figure>

<p>sessionB</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MySQL [mysql]&gt; select @@tx_isolation;</span><br><span class="line">+----------------+</span><br><span class="line">| @@tx_isolation |</span><br><span class="line">+----------------+</span><br><span class="line">| READ-COMMITTED |</span><br><span class="line">+----------------+</span><br><span class="line"><span class="number">1</span> row in <span class="built_in">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">MySQL [mysql]&gt; insert tt select null,<span class="number">6</span>,<span class="number">60</span>,null,null,null;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="function">row <span class="title">affected</span> <span class="params">(<span class="number">0.03</span> sec)</span></span></span><br><span class="line"><span class="function">Records: 1  Duplicates: 0  Warnings: 0</span></span><br></pre></td></tr></table></figure>

<p>按照幻读的定义，rc级别下，是会产生幻读的，同理，ru也是一样的。隔离级别：ru &lt; rc &lt; rr &lt; se.序列化读，每次都会加锁，不会产生幻读，是最高的隔离级别。读提交，从定义来看，就是要能读到其他事务提交的结果，本身隔离性就比较低，幻读也比较能理解。主要读提交下，innodb要求binlog是row格式，所以即使幻读，binlog日志恢复的数据起码是一致的。注意，rc只会持有行锁。</p>
<p>可重复读作为默认的隔离级别，再来看看这种情况。</p>
<h3 id="可重复读场景"><a href="#可重复读场景" class="headerlink" title="可重复读场景"></a>可重复读场景</h3><p>sessionA</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MySQL [mysql]&gt; select @@tx_isolation;</span><br><span class="line">+-----------------+</span><br><span class="line">| @@tx_isolation  |</span><br><span class="line">+-----------------+</span><br><span class="line">| REPEATABLE-READ |</span><br><span class="line">+-----------------+</span><br><span class="line"><span class="number">1</span> row in <span class="built_in">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">MySQL [mysql]&gt; begin;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">MySQL [mysql]&gt; select * from tt where c &gt; 2 for update;  </span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line">| id | c    | d    | field | f2   | f3   |</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line">|  <span class="number">3</span> |    <span class="number">3</span> |   <span class="number">30</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">|  <span class="number">9</span> |    <span class="number">5</span> |   <span class="number">50</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">| <span class="number">20</span> |    <span class="number">4</span> |   <span class="number">90</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line"><span class="number">3</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">MySQL [mysql]&gt; update tt set d = 0 where c &gt; 2;  </span><br><span class="line">Query OK, <span class="number">3</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function">Rows matched: 3  Changed: 3  Warnings: 0</span></span><br></pre></td></tr></table></figure>

<p>sessionB</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MySQL [mysql]&gt; select @@tx_isolation;</span><br><span class="line">+-----------------+</span><br><span class="line">| @@tx_isolation  |</span><br><span class="line">+-----------------+</span><br><span class="line">| REPEATABLE-READ |</span><br><span class="line">+-----------------+</span><br><span class="line"><span class="number">1</span> row in <span class="built_in">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">MySQL [mysql]&gt; insert tt select null,<span class="number">6</span>,<span class="number">60</span>,null,null,null;</span><br><span class="line">ERROR <span class="number">1205</span> (HY000): Lock wait timeout exceeded; <span class="keyword">try</span> restarting transaction</span><br></pre></td></tr></table></figure>

<p>可重复读，由于快照的原因，普通的读是不会有幻读的。所以这里用锁定一致性视图读，即加锁的当前读。</p>
<p>但是这里sessionB被阻塞了，因为锁的原因：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MySQL [mysql]&gt; select * from information_schema.innodb_locks;</span><br><span class="line">+--------------+-------------+-----------+-----------+--------------+------------+------------+-----------+----------+-----------+</span><br><span class="line">| lock_id      | lock_trx_id | lock_mode | lock_type | lock_table   | lock_index | lock_space | lock_page | lock_rec | lock_data |</span><br><span class="line">+--------------+-------------+-----------+-----------+--------------+------------+------------+-----------+----------+-----------+</span><br><span class="line">| <span class="number">18687</span>:<span class="number">76</span>:<span class="number">3</span>:<span class="number">5</span> | <span class="number">18687</span>       | X,GAP     | RECORD    | `mysql`.`tt` | PRIMARY    |         <span class="number">76</span> |         <span class="number">3</span> |        <span class="number">5</span> | <span class="number">20</span>        |</span><br><span class="line">| <span class="number">18685</span>:<span class="number">76</span>:<span class="number">3</span>:<span class="number">5</span> | <span class="number">18685</span>       | X         | RECORD    | `mysql`.`tt` | PRIMARY    |         <span class="number">76</span> |         <span class="number">3</span> |        <span class="number">5</span> | <span class="number">20</span>        |</span><br><span class="line">+--------------+-------------+-----------+-----------+--------------+------------+------------+-----------+----------+-----------+</span><br><span class="line"><span class="number">2</span> rows in <span class="built_in">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>可以看到sessionA持有了X锁和gap锁。X锁属于行锁，而行锁加上间隙锁合称为next-key lock.实际应该没有实现的next-key lock,其只是对于实现的行锁+间隙锁的统称。</p>
<p>由于间隙锁的存在，rr级别下，可以解决幻读的问题。select不加锁的话，根据快照不会产生幻读。select加锁读，通过间隙锁解决幻读问题。</p>
<h4 id="幻读对binlog的影响"><a href="#幻读对binlog的影响" class="headerlink" title="幻读对binlog的影响"></a>幻读对binlog的影响</h4><p>如果rr下，没有gap lock机制的话，幻读对binlog也会有影响，如果binlog=statement,回想前面，rc,ru下强制要求binlog=row是有原因的。现在分析下，rr下，binlog=statement的情况：</p>
<p>关闭间隙锁的方式：</p>
<ul>
<li>隔离级别设置为rc</li>
<li>innodb_locks_unsafe_for_binlog=1</li>
</ul>
<p>sessionA:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">MySQL [mysql]&gt; show variables like &#x27;innodb_locks_unsafe_for_binlog&#x27;;</span><br><span class="line">+--------------------------------+-------+</span><br><span class="line">| Variable_name                  | Value |</span><br><span class="line">+--------------------------------+-------+</span><br><span class="line">| innodb_locks_unsafe_for_binlog | ON    |</span><br><span class="line">+--------------------------------+-------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">MySQL [mysql]&gt; begin;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">MySQL [mysql]&gt; select * from tt where c &gt; 2 for update;  </span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line">| id | c    | d    | field | f2   | f3   |</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line">|  <span class="number">3</span> |    <span class="number">3</span> |   <span class="number">30</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">|  <span class="number">9</span> |    <span class="number">5</span> |   <span class="number">50</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">| <span class="number">20</span> |    <span class="number">4</span> |   <span class="number">90</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line"><span class="number">3</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">MySQL [mysql]&gt; update tt set d = 0 where c &gt; 2;   </span><br><span class="line">Query OK, <span class="number">3</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function">Rows matched: 3  Changed: 3  Warnings: 0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line">MySQL [mysql]&gt; select * from tt where c &gt; 2;</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line">| id | c    | d    | field | f2   | f3   |</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line">|  <span class="number">3</span> |    <span class="number">3</span> |    <span class="number">0</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">|  <span class="number">9</span> |    <span class="number">5</span> |    <span class="number">0</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">| <span class="number">20</span> |    <span class="number">4</span> |    <span class="number">0</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">| <span class="number">25</span> |    <span class="number">6</span> |   <span class="number">60</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line"><span class="number">4</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">MySQL [mysql]&gt; commit;</span><br></pre></td></tr></table></figure>

<p>sessionB:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MySQL [(none)]&gt; use mysql;</span><br><span class="line">Reading table information <span class="keyword">for</span> completion of table <span class="keyword">and</span> column names</span><br><span class="line">You can turn off <span class="keyword">this</span> feature to get a quicker startup with -A</span><br><span class="line"></span><br><span class="line">Database changed</span><br><span class="line">MySQL [mysql]&gt; insert tt select null,<span class="number">6</span>,<span class="number">60</span>,null,null,null;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="function">row <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br><span class="line"><span class="function">Records: 1  Duplicates: 0  Warnings: 0</span></span><br></pre></td></tr></table></figure>

<p>binlog:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SET TIMESTAMP=<span class="number">1598347030</span><span class="comment">/*!*/</span>;</span><br><span class="line">BEGIN</span><br><span class="line"><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="meta"># at 1708</span></span><br><span class="line"><span class="meta"># at 1740</span></span><br><span class="line">#<span class="number">200825</span> <span class="number">17</span>:<span class="number">17</span>:<span class="number">10</span> server id <span class="number">1</span>  end_log_pos <span class="number">1740</span> CRC32 <span class="number">0xe0159005</span>         Intvar</span><br><span class="line">SET INSERT_ID=<span class="number">25</span><span class="comment">/*!*/</span>;</span><br><span class="line">#<span class="number">200825</span> <span class="number">17</span>:<span class="number">17</span>:<span class="number">10</span> server id <span class="number">1</span>  end_log_pos <span class="number">1857</span> CRC32 <span class="number">0xc851009c</span>         Query   thread_id=<span class="number">4</span>     exec_time=<span class="number">0</span>     error_code=<span class="number">0</span></span><br><span class="line">SET TIMESTAMP=<span class="number">1598347030</span><span class="comment">/*!*/</span>;</span><br><span class="line">insert tt select null,<span class="number">6</span>,<span class="number">60</span>,null,null,null</span><br><span class="line"><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="meta"># at 1857</span></span><br><span class="line">#<span class="number">200825</span> <span class="number">17</span>:<span class="number">17</span>:<span class="number">10</span> server id <span class="number">1</span>  end_log_pos <span class="number">1888</span> CRC32 <span class="number">0x9f72707d</span>         Xid = <span class="number">142</span></span><br><span class="line">COMMIT<span class="comment">/*!*/</span>;</span><br><span class="line"><span class="meta"># at 1888</span></span><br><span class="line">#<span class="number">200825</span> <span class="number">17</span>:<span class="number">17</span>:<span class="number">54</span> server id <span class="number">1</span>  end_log_pos <span class="number">1953</span> CRC32 <span class="number">0x1b7f81f5</span>         Anonymous_GTID  last_committed=<span class="number">5</span>        sequence_number=<span class="number">7</span>       rbr_only=no</span><br><span class="line">SET @@SESSION.GTID_NEXT= &#x27;ANONYMOUS&#x27;/*!*/;</span><br><span class="line"><span class="meta"># at 1953</span></span><br><span class="line">#<span class="number">200825</span> <span class="number">17</span>:<span class="number">16</span>:<span class="number">39</span> server id <span class="number">1</span>  end_log_pos <span class="number">2034</span> CRC32 <span class="number">0xc51fd871</span>         Query   thread_id=<span class="number">2</span>     exec_time=<span class="number">0</span>     error_code=<span class="number">0</span></span><br><span class="line">SET TIMESTAMP=<span class="number">1598346999</span><span class="comment">/*!*/</span>;</span><br><span class="line">BEGIN</span><br><span class="line"><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="meta"># at 2034</span></span><br><span class="line">#<span class="number">200825</span> <span class="number">17</span>:<span class="number">16</span>:<span class="number">39</span> server id <span class="number">1</span>  end_log_pos <span class="number">2141</span> CRC32 <span class="number">0xa64310b0</span>         Query   thread_id=<span class="number">2</span>     exec_time=<span class="number">0</span>     error_code=<span class="number">0</span></span><br><span class="line">SET TIMESTAMP=<span class="number">1598346999</span><span class="comment">/*!*/</span>;</span><br><span class="line">update tt <span class="built_in">set</span> d = <span class="number">0</span> where c &gt; <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>sessionA后提交的，如果根据binlog恢复数据或者从库更新：</p>
<p>1 insert tt select null,6,60,null,null,null <br><br>2 update tt set d = 0 where c &gt; 2</p>
<p>就得不到主库的结果了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MySQL [mysql]&gt; select * from tt where c &gt; <span class="number">2</span>;</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line">| id | c    | d    | field | f2   | f3   |</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line">|  <span class="number">3</span> |    <span class="number">3</span> |    <span class="number">0</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">|  <span class="number">9</span> |    <span class="number">5</span> |    <span class="number">0</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">| <span class="number">20</span> |    <span class="number">4</span> |    <span class="number">0</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">| <span class="number">25</span> |    <span class="number">6</span> |   <span class="number">60</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">+----+------+------+-------+------+------+</span><br></pre></td></tr></table></figure>

<p>这是幻读在rr模式下，binlog=statement可能造成的问题，但是gap lock没让这种情况发生。</p>
<h2 id="gap-lock"><a href="#gap-lock" class="headerlink" title="gap lock"></a>gap lock</h2><p>前面碰到了间隙锁，这里再深化一下：</p>
<p>sessionA:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MySQL [mysql]&gt; select * from tt;</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line">| id | c    | d    | field | f2   | f3   |</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line">|  <span class="number">1</span> |    <span class="number">1</span> |  <span class="number">777</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">|  <span class="number">2</span> |    <span class="number">2</span> |  <span class="number">200</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">|  <span class="number">3</span> |    <span class="number">3</span> |   <span class="number">30</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">|  <span class="number">9</span> |    <span class="number">5</span> |   <span class="number">50</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">| <span class="number">20</span> |    <span class="number">4</span> |   <span class="number">90</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line"><span class="number">5</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">MySQL [mysql]&gt; begin;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">MySQL [mysql]&gt; select * from tt where d = 90 for update;</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line">| id | c    | d    | field | f2   | f3   |</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line">| <span class="number">20</span> |    <span class="number">4</span> |   <span class="number">90</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure>

<p>select * from tt where d = 90 for update;这条语句加了2个锁，一个x锁，一个gap锁。</p>
<ul>
<li>间隙锁锁住了d=90的间隙,(50-90),(90-200).</li>
<li>x锁锁住了d=90</li>
<li>next-key lock锁的是(50-200)</li>
</ul>
<p>所以，添加数据：</p>
<p>sessionB:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MySQL [mysql]&gt;  insert tt select null,<span class="number">6</span>,<span class="number">60</span>,null,null,null;</span><br><span class="line">ERROR <span class="number">1205</span> (HY000): Lock wait timeout exceeded; <span class="keyword">try</span> restarting transaction</span><br><span class="line"></span><br><span class="line">MySQL [mysql]&gt;  insert tt select null,<span class="number">6</span>,<span class="number">100</span>,null,null,null;</span><br><span class="line">ERROR <span class="number">1205</span> (HY000): Lock wait timeout exceeded; <span class="keyword">try</span> restarting transaction</span><br><span class="line"></span><br><span class="line">MySQL [mysql]&gt; insert tt select null,<span class="number">6</span>,<span class="number">45</span>,null,null,null;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="function">row <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br><span class="line"><span class="function">Records: 1  Duplicates: 0  Warnings: 0</span></span><br></pre></td></tr></table></figure>

<h4 id="间隙锁的降级"><a href="#间隙锁的降级" class="headerlink" title="间隙锁的降级"></a>间隙锁的降级</h4><p>当条件语句是唯一索引，则gap锁降级为行锁，只锁定索引记录。</p>
<p>sessionA:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MySQL [mysql]&gt; begin;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">MySQL [mysql]&gt; select * from tt where id = 20 for update;</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line">| id | c    | d    | field | f2   | f3   |</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line">| <span class="number">20</span> |    <span class="number">4</span> |   <span class="number">90</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br></pre></td></tr></table></figure>

<p>sessionB:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MySQL [mysql]&gt;  insert tt select null,<span class="number">7</span>,<span class="number">110</span>,null,null,null;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="function">row <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br><span class="line"><span class="function">Records: 1  Duplicates: 0  Warnings: 0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line">MySQL [mysql]&gt;  insert tt select 21,8,92,null,null,null;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="function">row <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br><span class="line"><span class="function">Records: 1  Duplicates: 0  Warnings: 0</span></span><br></pre></td></tr></table></figure>

<h3 id="gap-lock导致的死锁"><a href="#gap-lock导致的死锁" class="headerlink" title="gap lock导致的死锁"></a>gap lock导致的死锁</h3><p>间隙锁和间隙锁之前是兼容的，间隙锁和insert插入间隙的操作是不兼容的，所以：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MySQL [mysql]&gt; select * from tt;</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line">| id | c    | d    | field | f2   | f3   |</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line">|  <span class="number">1</span> |    <span class="number">1</span> |  <span class="number">777</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">|  <span class="number">2</span> |    <span class="number">2</span> |  <span class="number">200</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">|  <span class="number">3</span> |    <span class="number">3</span> |    <span class="number">0</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">|  <span class="number">9</span> |    <span class="number">5</span> |    <span class="number">0</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">| <span class="number">20</span> |    <span class="number">4</span> |    <span class="number">0</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">| <span class="number">25</span> |    <span class="number">6</span> |   <span class="number">60</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line"><span class="number">6</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">            sessionA                    sessinB</span><br><span class="line"></span><br><span class="line">T1 begin;</span><br><span class="line">select * from tt where d = <span class="number">300</span> <span class="keyword">for</span> update;</span><br><span class="line"></span><br><span class="line">T2                                      begin;</span><br><span class="line">                                        select * from tt where d = <span class="number">300</span> <span class="keyword">for</span> update;</span><br><span class="line"></span><br><span class="line">T3 insert tt select null,<span class="number">7</span>,<span class="number">400</span>,null,null,null;</span><br><span class="line"></span><br><span class="line">T4                                      insert tt select null,<span class="number">8</span>,<span class="number">500</span>,null,null,null;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p>T3 成功插入；</p>
<p>T4死锁；</p>
<p>又一个事务可以成功提交，其他死锁的报错：</p>
<blockquote>
<p>ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</p>
</blockquote>
<p>也还好吧。</p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2>]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql change buffer</title>
    <url>/2020-08-26-mysql%20change%20buffer/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h2 id="innodb-buffer-poll"><a href="#innodb-buffer-poll" class="headerlink" title="innodb buffer poll"></a>innodb buffer poll</h2><p><img src="https://i.loli.net/2020/08/25/Rs1czFSpCY84yfE.jpg" alt="2020082601.jpg"></p>
<h2 id="inser-buffer"><a href="#inser-buffer" class="headerlink" title="inser buffer"></a>inser buffer</h2><p>innodb的索引是B+树，主键索引也叫聚簇索引，是自增的一个非空的键值。所以顺序插入的效率是很高的。但是对于非聚簇索引(第二索引)，则往往是离散插入的，效率很低。经常会碰到字符串，或者非递增的数据作为第二索引。</p>
<a id="more"></a>

<p>为了减少离散插入造成的效率损失，innodb引入了insert buffer缓冲区，对于第二索引的插入，先放到缓冲区中，然后merge，如果merge的时候，一次可以处理多个，就提升了性能。</p>
<p>insert buffer使用要满足：</p>
<ul>
<li>索引是辅助索引(第二索引)</li>
<li>索引不是唯一的</li>
</ul>
<p>因为唯一索引要判断唯一性，就不能直接放到缓冲区不管。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">show engine innodb status;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-------------------------------------</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX</span><br><span class="line">-------------------------------------</span><br><span class="line">Ibuf: size <span class="number">1</span>, <span class="built_in">free</span> <span class="built_in">list</span> len <span class="number">0</span>, seg size <span class="number">2</span>, <span class="number">0</span> merges</span><br><span class="line">merged operations:</span><br><span class="line"> insert <span class="number">0</span>, <span class="keyword">delete</span> mark <span class="number">0</span>, <span class="keyword">delete</span> <span class="number">0</span></span><br><span class="line">discarded operations:</span><br><span class="line"> insert <span class="number">0</span>, <span class="keyword">delete</span> mark <span class="number">0</span>, <span class="keyword">delete</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>segsize表示insert buffer大小：2*16kb</p>
<p>free list代表空闲列表长度</p>
<p>size表示已经合并数据页的长度</p>
<h2 id="change-buffer"><a href="#change-buffer" class="headerlink" title="change buffer"></a>change buffer</h2><p>innodb从1.0.x版本引入change buffer,是insert buffer的加强版，不仅支持insert,还支持其他dml操作(insert buffer, delete buffer, purge buffer)。所以，insert buffer也是个老古董了。</p>
<p>delete操作可能的过程：</p>
<ul>
<li>将记录标记为已删除</li>
<li>真正删除记录</li>
</ul>
<p>第一步就是delete buffer,第二步是purge buffer.</p>
<h3 id="innodb-change-buffering"><a href="#innodb-change-buffering" class="headerlink" title="innodb_change_buffering"></a>innodb_change_buffering</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MySQL [mysql]&gt; show variables like &#x27;innodb_change_buffering&#x27;;</span><br><span class="line">+-------------------------+-------+</span><br><span class="line">| Variable_name           | Value |</span><br><span class="line">+-------------------------+-------+</span><br><span class="line">| innodb_change_buffering | all   |</span><br><span class="line">+-------------------------+-------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure>

<p>innodb_change_buffering可选的值：</p>
<ul>
<li>inserts</li>
<li>deletes</li>
<li>purges</li>
<li>changes</li>
<li>all</li>
<li>none</li>
</ul>
<p>changes = inserts + deletes</p>
<p>all = 所有</p>
<p>none表示不启用</p>
<h3 id="innodb-change-buffer-max-size"><a href="#innodb-change-buffer-max-size" class="headerlink" title="innodb_change_buffer_max_size"></a>innodb_change_buffer_max_size</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MySQL [mysql]&gt; show variables like &#x27;innodb_change_buffer_max_size&#x27;;</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line">| Variable_name                 | Value |</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line">| innodb_change_buffer_max_size | <span class="number">25</span>    |</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure>

<p>innodb_change_buffer_max_size表示change buffer的最大大小，25表示最多使用1/4的缓冲池空间。</p>
<p>change buffer内部也是B+树，具体不研究了。</p>
<h2 id="question"><a href="#question" class="headerlink" title="question"></a>question</h2><p>如果binlog=row,需要旧的数据，会影响change buffer吗？</p>
<p>这个mysql实战45讲下面的问题，之前自己也没搞懂，这篇文章写完似乎明白了。</p>
<p>聚簇索引和第二索引都是B+树，不管是新增数据还是删除数据，聚簇索引和第二索引都是要同步的。所以change buffer必要性在这里。同步聚簇索引效率高，同步第二索引效率低，所以先缓存，并不真的落盘同步。等下次查询的时候，在从磁盘读取第二索引的值，将之前的buffer数据读入merge.或者后台线程merge.</p>
<p>然后查老得数据是从聚簇索引查的，不影响。我理解聚簇索引是肯定要持久化到磁盘的，第二索引应该也会持久化到磁盘。所以对于查老得数据，如果内存不存在，直接将磁盘的聚簇索引的记录查出来就是完整的行记录，不用查磁盘的第二索引的值，所以change buffer还是起效果的。</p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2>]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql 脏读 不可重复读</title>
    <url>/2020-08-26-mysql%20%E8%84%8F%E8%AF%BB%20%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="">mysql技术内幕</a></p>
<h2 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h2><p>先看下脏页和脏数据的区别</p>
<a id="more"></a>

<h3 id="脏页"><a href="#脏页" class="headerlink" title="脏页"></a>脏页</h3><blockquote>
<p>脏页是缓冲区中的已经提交的数据，但还没刷到磁盘持久化，不过重做日志会刷盘的。</p>
</blockquote>
<h3 id="脏数据"><a href="#脏数据" class="headerlink" title="脏数据"></a>脏数据</h3><blockquote>
<p>脏数据是事务还未提交，进行修改后的数据</p>
</blockquote>
<p>那么脏读，就是读到了脏数据，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//read uncommitted</span></span><br><span class="line">        sessionA                    sessionB</span><br><span class="line"></span><br><span class="line">T1     begin;                       begin;</span><br><span class="line">                                    select * from tt where c = <span class="number">3</span>;<span class="comment">//d = 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">T2     update tt <span class="built_in">set</span> d = <span class="number">999</span> where c = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">T3                                  select * from tt where c = <span class="number">3</span>;<span class="comment">//d = 999</span></span><br></pre></td></tr></table></figure>

<p><code>sessionB</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MySQL [mysql]&gt; show variables like &#x27;%binlog_format%&#x27;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| binlog_format | ROW   |</span><br><span class="line">+---------------+-------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">MySQL [mysql]&gt; set session tx_isolation = &#x27;read-uncommitted&#x27;;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">MySQL [mysql]&gt; select * from tt where c = <span class="number">3</span>;</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line">| id | c    | d    | field | f2   | f3   |</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line">|  <span class="number">3</span> |    <span class="number">3</span> |    <span class="number">0</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">MySQL [mysql]&gt; select * from tt where c = 3;</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line">| id | c    | d    | field | f2   | f3   |</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line">|  <span class="number">3</span> |    <span class="number">3</span> |  <span class="number">999</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure>

<p><code>sessionA</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MySQL [mysql]&gt; show variables like &#x27;%binlog_format%&#x27;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| binlog_format | ROW   |</span><br><span class="line">+---------------+-------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">MySQL [mysql]&gt; set session tx_isolation = &#x27;read-uncommitted&#x27;;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">MySQL [mysql]&gt; select * from tt where c = <span class="number">3</span>;</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line">| id | c    | d    | field | f2   | f3   |</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line">|  <span class="number">3</span> |    <span class="number">3</span> |    <span class="number">0</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">MySQL [mysql]&gt; update tt set d = 999 where c = 3;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="function">row <span class="title">affected</span> <span class="params">(<span class="number">0.04</span> sec)</span></span></span><br><span class="line"><span class="function">Rows matched: 1  Changed: 1  Warnings: 0</span></span><br></pre></td></tr></table></figure>

<p>sessionB读到了d=999,即sessionA修改的未提交的数据，也就是脏数据，发生了脏读。脏读只在read uncommitted隔离级别下发生，其破坏了事务的隔离性，基本没啥用。pgsql都没有实现ru这个级别。</p>
<p>书中讲，这种情况下可以使用脏读：replication环境的slave节点，并且在该slave上的查询并不需要特别精确的返回值。</p>
<h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><ul>
<li>幻读是读到了别的事务未提交的数据，导致两次读结果不一致</li>
<li>不可重复读是读到了别的事务已提交的数据，导致两次读结果不一致</li>
</ul>
<p>这个已经很常见了，模拟一种：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//read committed</span></span><br><span class="line">            sessionA                        sessionB</span><br><span class="line"></span><br><span class="line">T1          begin;</span><br><span class="line">            select * from tt where c = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">T2                                          update tt <span class="built_in">set</span> d = <span class="number">999</span> where c = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">T3          select * from tt where c = <span class="number">3</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>sessionA</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MySQL [mysql]&gt; select @@tx_isolation;</span><br><span class="line">+----------------+</span><br><span class="line">| @@tx_isolation |</span><br><span class="line">+----------------+</span><br><span class="line">| READ-COMMITTED |</span><br><span class="line">+----------------+</span><br><span class="line"><span class="number">1</span> row in <span class="built_in">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">MySQL [mysql]&gt; begin;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">MySQL [mysql]&gt; select * from tt where c = 3;</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line">| id | c    | d    | field | f2   | f3   |</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line">|  <span class="number">3</span> |    <span class="number">3</span> |    <span class="number">0</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">MySQL [mysql]&gt; select * from tt where c = 3;</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line">| id | c    | d    | field | f2   | f3   |</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line">|  <span class="number">3</span> |    <span class="number">3</span> |  <span class="number">999</span> |  <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line">+----+------+------+-------+------+------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure>

<p><code>sessionB</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MySQL [mysql]&gt; select @@tx_isolation;</span><br><span class="line">+----------------+</span><br><span class="line">| @@tx_isolation |</span><br><span class="line">+----------------+</span><br><span class="line">| READ-COMMITTED |</span><br><span class="line">+----------------+</span><br><span class="line"><span class="number">1</span> row in <span class="built_in">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">MySQL [mysql]&gt; update tt <span class="built_in">set</span> d = <span class="number">999</span> where c = <span class="number">3</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="function">row <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br><span class="line"><span class="function">Rows matched: 1  Changed: 1  Warnings: 0</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<p>不可重复读是可接受的，读到别的事务一提交的结果，还好吧，根据实际情况选择就好。</p>
<p>不可重复读发生在read committed隔离级别下，当前更低的ru也会发生。rr下通过next-key lock解决不可重复读问题(如果是普通读，读快照，是不存在不可重复读的；如果是加锁读，因为next-key lock，也不存在不可重复读).</p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2>]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库 范式</title>
    <url>/2020-08-29-%E6%95%B0%E6%8D%AE%E5%BA%93%20%E8%8C%83%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhihu.com/question/24696366">如何理解关系型数据库的常见设计范式？</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>留的坑，以后填</p>
<a id="more"></a>


<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2>]]></content>
      <tags>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql 索引</title>
    <url>/2020-09-01-mysql%20%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>留的坑，以后填</p>
<a id="more"></a>

<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>聚簇索引和非聚簇索引的区别，实现原理。</p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2>]]></content>
      <tags>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title>网络 https原理</title>
    <url>/2020-09-01-%E7%BD%91%E7%BB%9C%20https%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>留的坑，以后填</p>
<a id="more"></a>

<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2>]]></content>
      <tags>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title>redis 安装</title>
    <url>/2020-09-02-redis%20%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://redis.io/download">下载地址</a>,我下的5.0的版本，然后make即可。</p>
<a id="more"></a>

<p>测试：</p>
<p><code>server</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[root@**** ]# ./src/redis-server </span><br><span class="line"><span class="number">27306</span>:C <span class="number">02</span> Sep <span class="number">2020</span> <span class="number">17</span>:<span class="number">51</span>:<span class="number">42.050</span> # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line"><span class="number">27306</span>:C <span class="number">02</span> Sep <span class="number">2020</span> <span class="number">17</span>:<span class="number">51</span>:<span class="number">42.051</span> # Redis version=<span class="number">5.0</span><span class="number">.9</span>, bits=<span class="number">64</span>, commit=<span class="number">00000000</span>, modified=<span class="number">0</span>, pid=<span class="number">27306</span>, just started</span><br><span class="line"><span class="number">27306</span>:C <span class="number">02</span> Sep <span class="number">2020</span> <span class="number">17</span>:<span class="number">51</span>:<span class="number">42.051</span> # Warning: no config file specified, <span class="keyword">using</span> the <span class="keyword">default</span> config. In order to specify a config file use ./src/redis-server /path/to/redis.conf</span><br><span class="line">                _._                                                  </span><br><span class="line">           _.-``__ &#x27;&#x27;-._                                             </span><br><span class="line">      _.-``    `.  `_.  &#x27;&#x27;-._           Redis 5.0.9 (00000000/0) 64 bit</span><br><span class="line">  .-`` .-```.  ```\/    _.,_ &#x27;&#x27;-._                                   </span><br><span class="line"> (    &#x27;      ,       .-`  | `,    )     Running in standalone mode</span><br><span class="line"> |`-._`-...-` __...-.``-._|&#x27;` _.-&#x27;|     Port: 6379</span><br><span class="line"> |    `-._   `._    /     _.-&#x27;    |     PID: 27306</span><br><span class="line">  `-._    `-._  `-./  _.-&#x27;    _.-&#x27;                                   </span><br><span class="line"> |`-._`-._    `-.__.-&#x27;    _.-&#x27;_.-&#x27;|                                  </span><br><span class="line"> |    `-._`-._        _.-&#x27;_.-&#x27;    |           http://redis.io        </span><br><span class="line">  `-._    `-._`-.__.-&#x27;_.-&#x27;    _.-&#x27;                                   </span><br><span class="line"> |`-._`-._    `-.__.-&#x27;    _.-&#x27;_.-&#x27;|                                  </span><br><span class="line"> |    `-._`-._        _.-&#x27;_.-&#x27;    |                                  </span><br><span class="line">  `-._    `-._`-.__.-&#x27;_.-&#x27;    _.-&#x27;                                   </span><br><span class="line">      `-._    `-.__.-&#x27;    _.-&#x27;                                       </span><br><span class="line">          `-._        _.-&#x27;                                           </span><br><span class="line">              `-.__.-&#x27;                                               </span><br><span class="line"></span><br><span class="line"><span class="number">27306</span>:M <span class="number">02</span> Sep <span class="number">2020</span> <span class="number">17</span>:<span class="number">51</span>:<span class="number">42.052</span> # WARNING: The TCP backlog setting of <span class="number">511</span> cannot be enforced because /proc/sys/net/core/somaxconn is <span class="built_in">set</span> to the lower value of <span class="number">128.</span></span><br><span class="line"><span class="number">27306</span>:M <span class="number">02</span> Sep <span class="number">2020</span> <span class="number">17</span>:<span class="number">51</span>:<span class="number">42.052</span> # Server initialized</span><br><span class="line"><span class="number">27306</span>:M <span class="number">02</span> Sep <span class="number">2020</span> <span class="number">17</span>:<span class="number">51</span>:<span class="number">42.052</span> * Ready to accept connections</span><br></pre></td></tr></table></figure>

<p><code>client</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[root@**** ]# ./src/redis-cli </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> key value</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get key</span><br><span class="line"><span class="string">&quot;value&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; </span><br></pre></td></tr></table></figure>

<p>前台运行是这样的，后台运行需要配合配置文件。</p>
<p>修改redis.conf</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#daemonize no</span></span><br><span class="line">daemonize yes</span><br></pre></td></tr></table></figure>

<p>运行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[root@**** ]# ./src/redis-server  ./redis.conf </span><br><span class="line"><span class="number">27989</span>:C <span class="number">02</span> Sep <span class="number">2020</span> <span class="number">17</span>:<span class="number">58</span>:<span class="number">47.478</span> # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line"><span class="number">27989</span>:C <span class="number">02</span> Sep <span class="number">2020</span> <span class="number">17</span>:<span class="number">58</span>:<span class="number">47.478</span> # Redis version=<span class="number">5.0</span><span class="number">.9</span>, bits=<span class="number">64</span>, commit=<span class="number">00000000</span>, modified=<span class="number">0</span>, pid=<span class="number">27989</span>, just started</span><br><span class="line"><span class="number">27989</span>:C <span class="number">02</span> Sep <span class="number">2020</span> <span class="number">17</span>:<span class="number">58</span>:<span class="number">47.478</span> # Configuration loaded</span><br></pre></td></tr></table></figure>

<h2 id="开机启动"><a href="#开机启动" class="headerlink" title="开机启动"></a>开机启动</h2><p>参考: <a href="https://blog.csdn.net/liulihui1988/article/details/78087495">redis开机自动启动服务设置</a></p>
<h3 id="step-1"><a href="#step-1" class="headerlink" title="step 1"></a>step 1</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cp /usr/local/redis/redis<span class="number">-5.0</span><span class="number">.9</span>/utils/redis_init_script /etc/init.d/redis</span><br></pre></td></tr></table></figure>

<h3 id="step-2"><a href="#step-2" class="headerlink" title="step 2"></a>step 2</h3><p>修改配置文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">REDISPORT=<span class="number">6379</span></span><br><span class="line">#EXEC=/usr/local/bin/redis-server</span><br><span class="line">#CLIEXEC=/usr/local/bin/redis-cli</span><br><span class="line">EXEC=/usr/local/redis/redis<span class="number">-5.0</span><span class="number">.9</span>/src/redis-server</span><br><span class="line">CLIEXEC=/usr/local/redis/redis<span class="number">-5.0</span><span class="number">.9</span>/src/redis-cli</span><br><span class="line"></span><br><span class="line">PIDFILE=/var/run/redis_$&#123;REDISPORT&#125;.pid</span><br><span class="line">#CONF=<span class="string">&quot;/etc/redis/$&#123;REDISPORT&#125;.conf&quot;</span></span><br><span class="line">CONF=<span class="string">&quot;/usr/local/redis/redis-5.0.9/redis.conf&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="step-3"><a href="#step-3" class="headerlink" title="step 3"></a>step 3</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加入chkconfig</span></span><br><span class="line">[root@**** ]<span class="meta"># chkconfig --add redis</span></span><br><span class="line"><span class="comment">//开机启动</span></span><br><span class="line">[root@**** ]<span class="meta"># chkconfig redis on</span></span><br><span class="line">[root@**** ]<span class="meta"># ps aux | grep redis</span></span><br><span class="line">root     <span class="number">27990</span>  <span class="number">0.0</span>  <span class="number">0.0</span>  <span class="number">51304</span>  <span class="number">2880</span> ?        Ssl  <span class="number">17</span>:<span class="number">58</span>   <span class="number">0</span>:<span class="number">00</span> ./src/redis-server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span></span><br><span class="line">root     <span class="number">28960</span>  <span class="number">0.0</span>  <span class="number">0.0</span>  <span class="number">12148</span>   <span class="number">688</span> pts/<span class="number">1</span>    S+   <span class="number">18</span>:<span class="number">09</span>   <span class="number">0</span>:<span class="number">00</span> grep --color=<span class="keyword">auto</span> redis</span><br><span class="line"><span class="comment">//stop redis</span></span><br><span class="line">[root@**** ]<span class="meta"># service redis stop</span></span><br><span class="line">Stopping ...</span><br><span class="line">Redis stopped</span><br><span class="line">[root@**** ]<span class="meta"># ps aux | grep redis</span></span><br><span class="line">root     <span class="number">29107</span>  <span class="number">0.0</span>  <span class="number">0.0</span>  <span class="number">12148</span>   <span class="number">684</span> pts/<span class="number">1</span>    S+   <span class="number">18</span>:<span class="number">10</span>   <span class="number">0</span>:<span class="number">00</span> grep --color=<span class="keyword">auto</span> redis</span><br><span class="line"><span class="comment">//start redis</span></span><br><span class="line">[root@**** ]<span class="meta"># service redis start</span></span><br><span class="line">Starting Redis server...</span><br><span class="line"><span class="number">29120</span>:C <span class="number">02</span> Sep <span class="number">2020</span> <span class="number">18</span>:<span class="number">10</span>:<span class="number">16.256</span> # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line"><span class="number">29120</span>:C <span class="number">02</span> Sep <span class="number">2020</span> <span class="number">18</span>:<span class="number">10</span>:<span class="number">16.256</span> # Redis version=<span class="number">5.0</span><span class="number">.9</span>, bits=<span class="number">64</span>, commit=<span class="number">00000000</span>, modified=<span class="number">0</span>, pid=<span class="number">29120</span>, just started</span><br><span class="line"><span class="number">29120</span>:C <span class="number">02</span> Sep <span class="number">2020</span> <span class="number">18</span>:<span class="number">10</span>:<span class="number">16.256</span> # Configuration loaded</span><br><span class="line">[root@**** ]<span class="meta"># ps aux | grep redis</span></span><br><span class="line">root     <span class="number">29121</span>  <span class="number">0.0</span>  <span class="number">0.0</span>  <span class="number">51304</span>  <span class="number">2744</span> ?        Ssl  <span class="number">18</span>:<span class="number">10</span>   <span class="number">0</span>:<span class="number">00</span> /usr/local/redis/redis<span class="number">-5.0</span><span class="number">.9</span>/src/redis-server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span></span><br><span class="line">root     <span class="number">29126</span>  <span class="number">0.0</span>  <span class="number">0.0</span>  <span class="number">12148</span>   <span class="number">688</span> pts/<span class="number">1</span>    S+   <span class="number">18</span>:<span class="number">10</span>   <span class="number">0</span>:<span class="number">00</span> grep --color=<span class="keyword">auto</span> redis</span><br></pre></td></tr></table></figure>


<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2>]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis-数据结构</title>
    <url>/2020-09-25-redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="">REDIS-5.0.9</a></p>
<a id="more"></a>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>对于不需要修改的字符串，沿用C语言的格式。对于像键值这种可能修改的，采用SDS，内部实现的数据结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class="line"><span class="comment"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class="line"> <span class="comment">//lsb:低3位</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_5  0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_8  1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_16 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_32 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_64 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_MASK 7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_BITS 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)));</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_5_LEN(f) ((f)&gt;&gt;SDS_TYPE_BITS)</span></span><br></pre></td></tr></table></figure>

<p>sdshdr*中flags的低3位表示类型(eg:SDS_TYPE_5)，sdshdr5中的flags的高5位表示string的长度，其他长度结果体的len表示长度，alloc表示总的大小。</p>
<hr>
<h3 id="sdsnewlen"><a href="#sdsnewlen" class="headerlink" title="sdsnewlen"></a>sdsnewlen</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Create a new sds string with the content specified by the &#x27;init&#x27; pointer</span></span><br><span class="line"><span class="comment"> * and &#x27;initlen&#x27;.</span></span><br><span class="line"><span class="comment"> * If NULL is used for &#x27;init&#x27; the string is initialized with zero bytes.</span></span><br><span class="line"><span class="comment"> * If SDS_NOINIT is used, the buffer is left uninitialized;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The string is always null-termined (all the sds strings are, always) so</span></span><br><span class="line"><span class="comment"> * even if you create an sds string with:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * mystring = sdsnewlen(&quot;abc&quot;,3);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * You can print the string with printf() as there is an implicit \0 at the</span></span><br><span class="line"><span class="comment"> * end of the string. However the string is binary safe and can contain</span></span><br><span class="line"><span class="comment"> * \0 characters in the middle, as the length is stored in the sds header. */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh;</span><br><span class="line">    sds s;</span><br><span class="line">    <span class="comment">//根据长度选择合适的数据结构sdshdr</span></span><br><span class="line">    <span class="keyword">char</span> type = sdsReqType(initlen);</span><br><span class="line">    <span class="comment">/* Empty strings are usually created in order to append. Use type 8</span></span><br><span class="line"><span class="comment">     * since type 5 is not good at this. */</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5 &amp;&amp; initlen == <span class="number">0</span>) type = SDS_TYPE_8;</span><br><span class="line">    <span class="comment">//对应数据结构体sdshdr的大小</span></span><br><span class="line">    <span class="keyword">int</span> hdrlen = sdsHdrSize(type);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *fp; <span class="comment">/* flags pointer. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//malloc,结构体大小+字符串长度+1个结束符</span></span><br><span class="line">    sh = s_malloc(hdrlen+initlen+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (init==SDS_NOINIT)</span><br><span class="line">        init = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!init)</span><br><span class="line">        <span class="built_in">memset</span>(sh, <span class="number">0</span>, hdrlen+initlen+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//s是结构体后面柔性数组的位置</span></span><br><span class="line">    s = (<span class="keyword">char</span>*)sh+hdrlen;</span><br><span class="line">    fp = ((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)s)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5: &#123;</span><br><span class="line">            <span class="comment">//高5位存长度，低3位存类型</span></span><br><span class="line">            *fp = type | (initlen &lt;&lt; SDS_TYPE_BITS);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8: &#123;</span><br><span class="line">            <span class="comment">//sh从void*转成对应结构体的指针</span></span><br><span class="line">            SDS_HDR_VAR(<span class="number">8</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">16</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">32</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">64</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝数据</span></span><br><span class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</span><br><span class="line">        <span class="built_in">memcpy</span>(s, init, initlen);</span><br><span class="line">    s[initlen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="sdscatlen"><a href="#sdscatlen" class="headerlink" title="sdscatlen"></a>sdscatlen</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Append the specified binary-safe string pointed by &#x27;t&#x27; of &#x27;len&#x27; bytes to the</span></span><br><span class="line"><span class="comment"> * end of the specified sds string &#x27;s&#x27;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * After the call, the passed sds string is no longer valid and all the</span></span><br><span class="line"><span class="comment"> * references must be substituted with the new pointer returned by the call. */</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> curlen = sdslen(s);</span><br><span class="line"></span><br><span class="line">    s = sdsMakeRoomFor(s,len);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(s+curlen, t, len);</span><br><span class="line">    sdssetlen(s, curlen+len);</span><br><span class="line">    s[curlen+len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字符串拼接函数，主要是sdsMakeRoomFor，如果空余长度够用直接拷贝，不够的话sdsMakeRoomFor函数重新申请内存并返回新的地址，进行拷贝。拷贝完更新结构体的值。</p>
<hr>
<h3 id="sdsMakeRoomFor"><a href="#sdsMakeRoomFor" class="headerlink" title="sdsMakeRoomFor"></a>sdsMakeRoomFor</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Enlarge the free space at the end of the sds string so that the caller</span></span><br><span class="line"><span class="comment"> * is sure that after calling this function can overwrite up to addlen</span></span><br><span class="line"><span class="comment"> * bytes after the end of the string, plus one more byte for nul term.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note: this does not change the *length* of the sds string as returned</span></span><br><span class="line"><span class="comment"> * by sdslen(), but only the free buffer space we have. */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh, *newsh;</span><br><span class="line">    <span class="keyword">size_t</span> avail = sdsavail(s);</span><br><span class="line">    <span class="keyword">size_t</span> len, newlen;</span><br><span class="line">    <span class="comment">//[-1]在c语言是允许的，c++尽量不要这么来，参考https://www.zhihu.com/question/34790951</span></span><br><span class="line">    <span class="comment">//s[-1]是flag的地址</span></span><br><span class="line">    <span class="keyword">char</span> type, oldtype = s[<span class="number">-1</span>] &amp; SDS_TYPE_MASK;</span><br><span class="line">    <span class="keyword">int</span> hdrlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return ASAP if there is enough space left. */</span></span><br><span class="line">    <span class="keyword">if</span> (avail &gt;= addlen) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//len是字符串的长度</span></span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    <span class="comment">//sh结构体的地址</span></span><br><span class="line">    sh = (<span class="keyword">char</span>*)s-sdsHdrSize(oldtype);</span><br><span class="line">    newlen = (len+addlen);</span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        newlen += SDS_MAX_PREALLOC;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重新计算新的长度需要的结构体类型</span></span><br><span class="line">    type = sdsReqType(newlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don&#x27;t use type 5: the user is appending to the string and type 5 is</span></span><br><span class="line"><span class="comment">     * not able to remember empty space, so sdsMakeRoomFor() must be called</span></span><br><span class="line"><span class="comment">     * at every appending operation. */</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5) type = SDS_TYPE_8;</span><br><span class="line"></span><br><span class="line">    hdrlen = sdsHdrSize(type);</span><br><span class="line">    <span class="keyword">if</span> (oldtype==type) &#123;</span><br><span class="line">        <span class="comment">//结构体类型不变的，直接realloc</span></span><br><span class="line">        newsh = s_realloc(sh, hdrlen+newlen+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Since the header size changes, need to move the string forward,</span></span><br><span class="line"><span class="comment">         * and can&#x27;t use realloc */</span></span><br><span class="line">         <span class="comment">//结构体类型变化的，申请新的空间，拷贝老的过来，释放来的空间</span></span><br><span class="line">        newsh = s_malloc(hdrlen+newlen+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">char</span>*)newsh+hdrlen, s, len+<span class="number">1</span>);</span><br><span class="line">        s_free(sh);</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;</span><br><span class="line">        s[<span class="number">-1</span>] = type;</span><br><span class="line">        sdssetlen(s, len);</span><br><span class="line">    &#125;</span><br><span class="line">    sdssetalloc(s, newlen);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2>]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>golang 方法和嵌入</title>
    <url>/2020-09-29-golang%20%E6%96%B9%E6%B3%95%E5%92%8C%E5%B5%8C%E5%85%A5/</url>
    <content><![CDATA[<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>函数名和func之间添加指定类型作为receiver,只要底层数据类型不是指针和接口的类型都可以。绑定方法的时候，既可以绑定到对象本身，也可以绑定到对象的指针</p>
<a id="more"></a>

<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> i <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i)</span> <span class="title">f</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;f()&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> test i</span><br><span class="line">	test.f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="底层类型不能是pointer和interface"><a href="#底层类型不能是pointer和interface" class="headerlink" title="底层类型不能是pointer和interface"></a>底层类型不能是pointer和interface</h2><h3 id="pointer"><a href="#pointer" class="headerlink" title="pointer"></a>pointer</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i)</span> <span class="title">f</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	fmt.Print(<span class="string">&quot;f()&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>invalid receiver type i (i is an interface type)</p>
<hr>
<h3 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> i *<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i)</span> <span class="title">f</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	fmt.Print(<span class="string">&quot;f()&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>invalid receiver type i (i is a pointer type)</p>
<hr>
<h2 id="指针和对象"><a href="#指针和对象" class="headerlink" title="指针和对象"></a>指针和对象</h2><p>如果方法中绑定的对象是值类型，则会造成拷贝，副本。如果结构很大，会影响性能，所以可以用指针。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> i <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//case1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*i)</span> <span class="title">f</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;*i&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//case2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i)</span> <span class="title">f</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;i&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>case1和case2两种写法都是正确的，但只能存在一种，否则会认为是重定义。调用的时候只要i.f()即可，编译器会<strong>自动引用</strong>或者<strong>解引用</strong>。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> i <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i)</span> <span class="title">f</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;i&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> test i</span><br><span class="line">	ptest := &amp;test</span><br><span class="line">	ptest.f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul>
<li>不管method的receiver是指针类型还是非指针类型，都是可以通过指针/非指针类型进行调用的，编译器会帮你做类型转换。</li>
<li>大对象可以考虑指针，指针需要考虑浅拷贝。</li>
</ul>
<h2 id="嵌入"><a href="#嵌入" class="headerlink" title="嵌入"></a>嵌入</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> small_has_func <span class="keyword">struct</span>&#123;</span><br><span class="line">	a <span class="keyword">int</span></span><br><span class="line">	b <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(small_has_func)</span> <span class="title">f</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;small&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> small_no_func <span class="keyword">struct</span>&#123;</span><br><span class="line">	a <span class="keyword">int</span></span><br><span class="line">	b <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@1 value has name</span></span><br><span class="line"><span class="keyword">type</span> big_hasName_bs_hasFunc <span class="keyword">struct</span> &#123;</span><br><span class="line">	s small_has_func</span><br><span class="line">	cc <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> big_hasName_b_hasFunc <span class="keyword">struct</span> &#123;</span><br><span class="line">	s small_no_func</span><br><span class="line">	cc <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> big_hasName_s_hasFunc <span class="keyword">struct</span> &#123;</span><br><span class="line">	s small_has_func</span><br><span class="line">	cc <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(big_hasName_bs_hasFunc)</span> <span class="title">f</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;big_hasName_bs_hasFunc&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(big_hasName_b_hasFunc)</span> <span class="title">f</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;big_hasName_b_hasFunc&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//@2 value no name</span></span><br><span class="line"><span class="keyword">type</span> big_noName_bs_hasFunc <span class="keyword">struct</span> &#123;</span><br><span class="line">	small_has_func</span><br><span class="line">	cc <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> big_noName_b_hasFunc <span class="keyword">struct</span> &#123;</span><br><span class="line">	small_no_func</span><br><span class="line">	cc <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> big_noName_s_hasFunc <span class="keyword">struct</span> &#123;</span><br><span class="line">	small_has_func</span><br><span class="line">	cc <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(big_noName_bs_hasFunc)</span> <span class="title">f</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;big_noName_bs_hasFunc&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(big_noName_b_hasFunc)</span> <span class="title">f</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;big_noName_b_hasFunc&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@3 pvalue has name</span></span><br><span class="line"><span class="keyword">type</span> pbig_hasName_bs_hasFunc <span class="keyword">struct</span> &#123;</span><br><span class="line">	ps *small_has_func</span><br><span class="line">	cc <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> pbig_hasName_b_hasFunc <span class="keyword">struct</span> &#123;</span><br><span class="line">	ps *small_no_func</span><br><span class="line">	cc <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> pbig_hasName_s_hasFunc <span class="keyword">struct</span> &#123;</span><br><span class="line">	ps *small_has_func</span><br><span class="line">	cc <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pbig_hasName_bs_hasFunc)</span> <span class="title">f</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;pbig_hasName_bs_hasFunc&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pbig_hasName_b_hasFunc)</span> <span class="title">f</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;pbig_hasName_b_hasFunc&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@4 pvalue no name</span></span><br><span class="line"><span class="keyword">type</span> pbig_noName_bs_hasFunc <span class="keyword">struct</span> &#123;</span><br><span class="line">	*small_has_func</span><br><span class="line">	cc <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> pbig_noName_b_hasFunc <span class="keyword">struct</span> &#123;</span><br><span class="line">	*small_no_func</span><br><span class="line">	cc <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> pbig_noName_s_hasFunc <span class="keyword">struct</span> &#123;</span><br><span class="line">	*small_has_func</span><br><span class="line">	cc <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pbig_noName_bs_hasFunc)</span> <span class="title">f</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;pbig_noName_bs_hasFunc&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pbig_noName_b_hasFunc)</span> <span class="title">f</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;pbig_noName_b_hasFunc&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> t1 big_hasName_bs_hasFunc</span><br><span class="line">	t1.f()							<span class="comment">//big_hasName_bs_hasFunc</span></span><br><span class="line">	t1.s.f()						<span class="comment">//small</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> t2 big_hasName_b_hasFunc</span><br><span class="line">	t2.f()							<span class="comment">//big_hasName_b_hasFunc</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> t3 big_hasName_s_hasFunc</span><br><span class="line">	<span class="comment">//t3.f()	//error</span></span><br><span class="line">	t3.s.f()						<span class="comment">//small</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> t4 big_noName_bs_hasFunc</span><br><span class="line">	t4.f()							<span class="comment">//big_noName_bs_hasFunc</span></span><br><span class="line">	t4.small_has_func.f()			<span class="comment">//small</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> t5 big_noName_b_hasFunc</span><br><span class="line">	t5.f()							<span class="comment">//big_noName_b_hasFunc</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> t6 big_noName_s_hasFunc</span><br><span class="line">	t6.f()							<span class="comment">//small</span></span><br><span class="line">	t6.small_has_func.f()			<span class="comment">//small</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//var t7 pbig_hasName_bs_hasFunc</span></span><br><span class="line">	<span class="comment">//t7.f()</span></span><br><span class="line">	<span class="comment">//t7.ps.f()	//error</span></span><br><span class="line"></span><br><span class="line">	t7_1 := pbig_hasName_bs_hasFunc&#123;&amp;small_has_func&#123;a:<span class="number">1</span>, b:<span class="number">2</span>&#125;,<span class="number">2</span>&#125;</span><br><span class="line">	t7_1.f()						<span class="comment">//pbig_hasName_bs_hasFunc</span></span><br><span class="line">	t7_1.ps.f()						<span class="comment">//small</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> t8 pbig_hasName_b_hasFunc</span><br><span class="line">	t8.f()							<span class="comment">//pbig_hasName_b_hasFunc</span></span><br><span class="line"></span><br><span class="line">	t9 := pbig_hasName_s_hasFunc&#123;&amp;small_has_func&#123;a:<span class="number">1</span>, b:<span class="number">2</span>&#125;,<span class="number">2</span>&#125;</span><br><span class="line">	t9.ps.f()						<span class="comment">//small</span></span><br><span class="line"></span><br><span class="line">	t10 := pbig_noName_bs_hasFunc&#123;&amp;small_has_func&#123;a:<span class="number">1</span>, b:<span class="number">2</span>&#125;,<span class="number">2</span>&#125;</span><br><span class="line">	t10.f()							<span class="comment">//pbig_noName_bs_hasFunc</span></span><br><span class="line">	t10.small_has_func.f()			<span class="comment">//small</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> t11 pbig_noName_b_hasFunc</span><br><span class="line">	t11.f()							<span class="comment">//pbig_noName_b_hasFunc</span></span><br><span class="line"></span><br><span class="line">	t12 := pbig_noName_s_hasFunc&#123;&amp;small_has_func&#123;a:<span class="number">1</span>, b:<span class="number">2</span>&#125;,<span class="number">2</span>&#125;</span><br><span class="line">	t12.f()							<span class="comment">//small</span></span><br><span class="line">	t12.small_has_func.f()			<span class="comment">//small</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>匿名的嵌入对象，可以用<strong>外部类型</strong>作为选择器，调用匿名对象的方法或者值。也可以用<strong>外部对象.内部对象的类型</strong>来作为选择器调用</li>
<li>同一层次不能存在相同的函数名，不同层次可以。优先级是先外层再内层递归</li>
<li>对于指针类型的嵌入，指针类型的对象一定要存在才可以，不然编译报错</li>
</ul>
<h2 id="方法值和方法表达式"><a href="#方法值和方法表达式" class="headerlink" title="方法值和方法表达式"></a>方法值和方法表达式</h2><h3 id="方法值"><a href="#方法值" class="headerlink" title="方法值"></a>方法值</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> i <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i)</span> <span class="title">f</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;f()&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//ok</span></span><br><span class="line">	<span class="keyword">var</span> data i = <span class="number">100</span></span><br><span class="line">	test := data.f</span><br><span class="line">	test()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//not ok</span></span><br><span class="line">	test := i.f</span><br><span class="line">	test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法表达式"><a href="#方法表达式" class="headerlink" title="方法表达式"></a>方法表达式</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> i <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i)</span> <span class="title">f</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;f()&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//ok</span></span><br><span class="line">	test := i.f</span><br><span class="line">	<span class="keyword">var</span> data i = <span class="number">100</span></span><br><span class="line">	test(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接收器类型是nil"><a href="#接收器类型是nil" class="headerlink" title="接收器类型是nil"></a>接收器类型是nil</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> i <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pi *i)</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> pi == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;nil&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;not nil&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m *i = <span class="literal">nil</span>	<span class="comment">//nil</span></span><br><span class="line">	m.test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2>]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang 接口</title>
    <url>/2020-09-30-golang%20%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>简单整理go的接口相关知识</p>
<a id="more"></a>

<h2 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> i <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i)</span> <span class="title">print</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;int&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> f <span class="keyword">float32</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f)</span> <span class="title">print</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;float&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> d data</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> in i</span><br><span class="line">	d = in</span><br><span class="line">	d.<span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> flo f</span><br><span class="line">	d = flo</span><br><span class="line">	d.<span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个类型实现了接口的所有方法，则这个类型就是实现了接口的类型，可以赋值给接口类型的值。具有面向对象的特征。</p>
<h2 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> nul <span class="keyword">interface</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">	<span class="keyword">var</span> f <span class="keyword">float32</span> = <span class="number">10.10</span></span><br><span class="line">	<span class="keyword">var</span> s <span class="keyword">string</span> = <span class="string">&quot;10&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> data nul</span><br><span class="line">	data = i</span><br><span class="line">	fmt.Println(data)</span><br><span class="line">	data = f</span><br><span class="line">	fmt.Println(data)</span><br><span class="line">	data = s</span><br><span class="line">	fmt.Println(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空接口可以接受任意类型的值</p>
<h2 id="flag-value"><a href="#flag-value" class="headerlink" title="flag.value"></a>flag.value</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = change(<span class="string">&quot;number&quot;</span>, <span class="number">0</span>, <span class="string">&quot;input a number, output num*2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag.Parse()</span><br><span class="line">	fmt.Println(num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">//num.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">	number <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *data)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;output is  %d&quot;</span>, d.number)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *data)</span> <span class="title">Set</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	out, err := strconv.ParseInt(s, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;error!&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	d.number = out * <span class="number">2</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(name <span class="keyword">string</span>, value <span class="keyword">int64</span>, usage <span class="keyword">string</span>)</span> *<span class="title">data</span></span> &#123;</span><br><span class="line">	f := data&#123;value&#125;</span><br><span class="line">	flag.CommandLine.Var(&amp;f, name, usage)</span><br><span class="line">	<span class="keyword">return</span> &amp;f</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[*** ]$ ./main -number <span class="number">100</span></span><br><span class="line">output is  <span class="number">200</span></span><br><span class="line">[*** ]$ ./main -number <span class="number">1000</span></span><br><span class="line">output is  <span class="number">2000</span></span><br></pre></td></tr></table></figure>

<h2 id="nil接口"><a href="#nil接口" class="headerlink" title="nil接口"></a>nil接口</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> test1 <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> test2 <span class="keyword">struct</span> &#123;</span><br><span class="line">	i <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(test2)</span> <span class="title">print</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(in test1)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> in == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;nil&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;not nil&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a test1</span><br><span class="line">	check(a)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> b test2</span><br><span class="line">    check(b)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<pre><code>nil
not nil </code></pre>
<p>一个包含nil指针/值的接口不是nil接口，test2实现了print函数，是test1的一个实现类型。但b不是nil</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">|-----------------|</span><br><span class="line">|     test2       |</span><br><span class="line">|_________________|     <span class="comment">//type</span></span><br><span class="line">|      nil        |</span><br><span class="line">|-----------------|     <span class="comment">//value</span></span><br></pre></td></tr></table></figure>

<h2 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h2><h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2>]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>sql 窗口函数</title>
    <url>/2020-10-09-sql%20%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/92654574">通俗易懂的学会：SQL窗口函数</a></p>
<a id="more"></a>

<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2>]]></content>
      <tags>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title>golang连接mysql</title>
    <url>/2020-10-10-golang%E8%BF%9E%E6%8E%A5mysql/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://go-database-sql.org/retrieving.html">http://go-database-sql.org/</a></p>
<a id="more"></a>

<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> CREATE TABLE `tt` (</span><br><span class="line">  `id` <span class="keyword">int</span>(<span class="number">11</span>) NOT <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `c` <span class="keyword">int</span>(<span class="number">11</span>) DEFAULT <span class="literal">NULL</span>,</span><br><span class="line">  `d` <span class="keyword">int</span>(<span class="number">11</span>) DEFAULT <span class="literal">NULL</span>,</span><br><span class="line">  `field` varchar(64) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `c` (`c`),</span><br><span class="line">  KEY `index_d` (`d`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=<span class="number">26</span> DEFAULT CHARSET=latin1</span><br></pre></td></tr></table></figure>

<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;database/sql&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line"></span><br><span class="line">	_ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//go get github.com/go-sql-driver/mysql</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mysql_open</span><span class="params">()</span> <span class="params">(*sql.DB, error)</span></span> &#123;</span><br><span class="line">	db, err := sql.Open(<span class="string">&quot;mysql&quot;</span>,</span><br><span class="line">		<span class="string">&quot;root:123456@tcp(127.0.0.1:3306)/mysql&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> db, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">MySQL [mysql]&gt; select * from tt;</span></span><br><span class="line"><span class="comment">+----+------+------+-------+</span></span><br><span class="line"><span class="comment">| id | c    | d    | field |</span></span><br><span class="line"><span class="comment">+----+------+------+-------+</span></span><br><span class="line"><span class="comment">|  1 |    1 |  777 | hello |</span></span><br><span class="line"><span class="comment">|  2 |    2 |  200 |       |</span></span><br><span class="line"><span class="comment">|  3 |    3 |  999 |       |</span></span><br><span class="line"><span class="comment">|  9 |    5 |    0 |       |</span></span><br><span class="line"><span class="comment">| 20 |    4 |    0 |       |</span></span><br><span class="line"><span class="comment">| 25 |    6 |  600 |       |</span></span><br><span class="line"><span class="comment">+----+------+------+-------+</span></span><br><span class="line"><span class="comment">6 rows in set (0.00 sec)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> tt <span class="keyword">struct</span> &#123;</span><br><span class="line">	id    <span class="keyword">int</span></span><br><span class="line">	c     <span class="keyword">int</span></span><br><span class="line">	d     <span class="keyword">int</span></span><br><span class="line">	field <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">queryAll</span><span class="params">(db *sql.DB)</span> []*<span class="title">tt</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ret []*tt</span><br><span class="line">	<span class="comment">//query all</span></span><br><span class="line">	rows, err := db.Query(<span class="string">&quot;select id, c, d, field from tt where 1 = ?&quot;</span>, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">defer</span> rows.Close()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;id\tc\td\tfield&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">		data := &amp;tt&#123;&#125;</span><br><span class="line">		err = rows.Scan(&amp;data.id,</span><br><span class="line">			&amp;data.c,</span><br><span class="line">			&amp;data.d,</span><br><span class="line">			&amp;data.field)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(err)</span><br><span class="line">		&#125;</span><br><span class="line">		ret = <span class="built_in">append</span>(ret, data)</span><br><span class="line">		<span class="comment">//log.Println(data.id, &quot;\t&quot;, data.c, &quot;\t&quot;, data.d, &quot;\t&quot;, data.field)</span></span><br><span class="line">		fmt.Println(data.id, <span class="string">&quot;\t&quot;</span>, data.c, <span class="string">&quot;\t&quot;</span>, data.d, <span class="string">&quot;\t&quot;</span>, data.field)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = rows.Err()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">querySingle</span><span class="params">(db *sql.DB)</span> *<span class="title">tt</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> data tt</span><br><span class="line">	<span class="comment">//query single-row</span></span><br><span class="line">	err := db.QueryRow(<span class="string">&quot;select id, c, d, field from tt where id = ?&quot;</span>, <span class="number">1</span>).Scan(&amp;data.id,</span><br><span class="line">		&amp;data.c,</span><br><span class="line">		&amp;data.d,</span><br><span class="line">		&amp;data.field)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">	fmt.Println(<span class="string">&quot;id\tc\td\tfield&quot;</span>)</span><br><span class="line">	fmt.Println(data.id, <span class="string">&quot;\t&quot;</span>, data.c, <span class="string">&quot;\t&quot;</span>, data.d, <span class="string">&quot;\t&quot;</span>, data.field)</span><br><span class="line">	<span class="keyword">return</span> &amp;data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifybyTx</span><span class="params">(db *sql.DB, data []*tt)</span></span> &#123;</span><br><span class="line">	tx, err := db.Begin()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;begin tx err!&quot;</span>)</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">			_ = tx.Commit()</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			_ = tx.Rollback()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	param := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> _, row := <span class="keyword">range</span> data &#123;</span><br><span class="line">		param = <span class="built_in">append</span>(param, row.id)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sql := strings.Builder&#123;&#125;</span><br><span class="line">	sql.WriteString(fmt.Sprintf(<span class="string">&quot;update tt set field = unix_timestamp(NOW()) where id in (?%s)&quot;</span>,</span><br><span class="line">		strings.Repeat(<span class="string">&quot;, ?&quot;</span>, <span class="built_in">len</span>(data)<span class="number">-1</span>)))</span><br><span class="line"></span><br><span class="line">	_, err = tx.Exec(sql.String(), param...)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	db, err := mysql_open()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;open mysql error!&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> data []*tt</span><br><span class="line">	data = queryAll(db)</span><br><span class="line">	fmt.Println(<span class="string">&quot;-------------------------&quot;</span>)</span><br><span class="line">	querySingle(db)</span><br><span class="line">	fmt.Println(<span class="string">&quot;-------------------------&quot;</span>)</span><br><span class="line">	modifybyTx(db, data)</span><br><span class="line">	queryAll(db)</span><br><span class="line">	fmt.Println(<span class="string">&quot;-------------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		db.Close()</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="error"><a href="#error" class="headerlink" title="error"></a>error</h2><h3 id="next循环异常结束"><a href="#next循环异常结束" class="headerlink" title="next循环异常结束"></a>next循环异常结束</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err = rows.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="comment">// handle the error here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>The error from rows.Err() could be the result of a variety of errors in the rows.Next() loop. The loop might exit for some reason other than finishing the loop normally, so you always need to check whether the loop terminated normally or not. An abnormal termination automatically calls rows.Close(), although it’s harmless to call it multiple times.</p>
</blockquote>
<h3 id="查询结果为空"><a href="#查询结果为空" class="headerlink" title="查询结果为空"></a>查询结果为空</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line">err = db.QueryRow(<span class="string">&quot;select name from users where id = ?&quot;</span>, <span class="number">1</span>).Scan(&amp;name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err == sql.ErrNoRows &#123;</span><br><span class="line">		<span class="comment">// there were no rows, but otherwise no error occurred</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(name)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="未知列"><a href="#未知列" class="headerlink" title="未知列"></a>未知列</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unknown</span><span class="params">(db *sql.DB)</span></span> &#123;</span><br><span class="line">	<span class="comment">//query all</span></span><br><span class="line">	rows, err := db.Query(<span class="string">&quot;select * from tt&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> rows.Close()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cols, err := rows.Columns() <span class="comment">// Remember to check err afterwards</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(cols))</span><br><span class="line">	<span class="comment">// if len(cols) == 11 &#123;</span></span><br><span class="line">	<span class="comment">// 	// Percona Server</span></span><br><span class="line">	<span class="comment">// &#125; else if len(cols) &gt; 8 &#123;</span></span><br><span class="line">	<span class="comment">// 	// Handle this case</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">	vals := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(cols))</span><br><span class="line">	<span class="keyword">for</span> i, _ := <span class="keyword">range</span> cols &#123;</span><br><span class="line">		vals[i] = <span class="built_in">new</span>(sql.RawBytes)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">		err = rows.Scan(vals...)</span><br><span class="line">		<span class="comment">// Now you can check each element of vals for nil-ness,</span></span><br><span class="line">		<span class="comment">// and you can use type introspection and type assertions</span></span><br><span class="line">		<span class="comment">// to fetch the column into a typed variable.</span></span><br><span class="line">		fmt.Println(vals)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2>]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang连接redis</title>
    <url>/2020-10-10-golang%E8%BF%9E%E6%8E%A5redis/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通过redigo连接redis,以后有时间的话搞搞go-redis.</p>
<a id="more"></a>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/go-redis/redis">https://github.com/go-redis/redis</a></p>
<p><a href="https://github.com/gomodule/redigo">https://github.com/gomodule/redigo</a></p>
<p><a href="http://doc.redisfans.com/transaction/multi.html">redis命令</a></p>
<h2 id="func"><a href="#func" class="headerlink" title="func"></a>func</h2><h3 id="func-Dial"><a href="#func-Dial" class="headerlink" title="func Dial"></a>func Dial</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">func <span class="title">Dial</span><span class="params">(network, address <span class="built_in">string</span>, options ...DialOption)</span> <span class="params">(Conn, error)</span></span></span><br></pre></td></tr></table></figure>
<p>Dial connects to the Redis server at the given network and address using the specified options.</p>
<p>Connect to local instance of Redis running on the default port.</p>
<p>Code:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">c, err := redis.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:6379&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != nil &#123;</span><br><span class="line">    <span class="comment">// handle error</span></span><br><span class="line">&#125;</span><br><span class="line">defer c.Close()</span><br></pre></td></tr></table></figure>

<p>Connect to an Redis instance using the Redis ACL system</p>
<p>Code:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">c, err := redis.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:6379&quot;</span>,</span><br><span class="line">    redis.DialUsername(<span class="string">&quot;username&quot;</span>),</span><br><span class="line">    redis.DialPassword(<span class="string">&quot;password&quot;</span>),</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != nil &#123;</span><br><span class="line">    <span class="comment">// handle error</span></span><br><span class="line">&#125;</span><br><span class="line">defer c.Close()</span><br></pre></td></tr></table></figure>

<h3 id="func-DialTimeout"><a href="#func-DialTimeout" class="headerlink" title="func DialTimeout"></a>func DialTimeout</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">func <span class="title">DialTimeout</span><span class="params">(network, address <span class="built_in">string</span>, connectTimeout, readTimeout, writeTimeout time.Duration)</span> <span class="params">(Conn, error)</span></span></span><br></pre></td></tr></table></figure>

<p>DialTimeout acts like Dial but takes timeouts for establishing the connection to the server, writing a command and reading a reply.</p>
<p>Deprecated: Use Dial with options instead.</p>
<h3 id="func-NewConn"><a href="#func-NewConn" class="headerlink" title="func NewConn"></a>func NewConn</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">func <span class="title">NewConn</span><span class="params">(netConn net.Conn, readTimeout, writeTimeout time.Duration)</span> Conn</span></span><br></pre></td></tr></table></figure>

<p>NewConn returns a new Redigo connection for the given net connection.</p>
<h3 id="func-do"><a href="#func-do" class="headerlink" title="func do"></a>func do</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Do(commandName <span class="built_in">string</span>, args ...interface&#123;&#125;) (reply interface&#123;&#125;, err error)</span><br></pre></td></tr></table></figure>

<p>The Do method converts command arguments to bulk strings for transmission to the server as follows:</p>
<pre><code>Go Type                 Conversion
[]byte                  Sent as is
string                  Sent as is
int, int64              strconv.FormatInt(v)
float64                 strconv.FormatFloat(v, &#39;g&#39;, -1, 64)
bool                    true -&gt; &quot;1&quot;, false -&gt; &quot;0&quot;
nil                     &quot;&quot;
all other types         fmt.Fprint(w, v)</code></pre>
<p>Redis command reply types are represented using the following Go types:</p>
<pre><code>Redis type              Go type
error                   redis.Error
integer                 int64
simple string           string
bulk string             []byte or nil if value not present.
array                   []interface&#123;&#125; or nil if value not present.</code></pre>
<h3 id="func-bytes"><a href="#func-bytes" class="headerlink" title="func bytes"></a>func bytes</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">func <span class="title">Bytes</span><span class="params">(reply interface&#123;&#125;, err error)</span> <span class="params">([]byte, error)</span></span></span><br></pre></td></tr></table></figure>

<p>Bytes is a helper that converts a command reply to a slice of bytes. If err is not equal to nil, then Bytes returns nil, err. Otherwise Bytes converts the reply to a slice of bytes as follows:</p>
<pre><code>Reply type      Result
bulk string     reply, nil
simple string   []byte(reply), nil
nil             nil, ErrNil
other           nil, error</code></pre>
<h3 id="func-ByteSlices"><a href="#func-ByteSlices" class="headerlink" title="func ByteSlices"></a>func ByteSlices</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">func <span class="title">ByteSlices</span><span class="params">(reply interface&#123;&#125;, err error)</span> <span class="params">([][]byte, error)</span></span></span><br></pre></td></tr></table></figure>

<p>ByteSlices is a helper that converts an array command reply to a [][]byte. If err is not equal to nil, then ByteSlices returns nil, err. Nil array items are stay nil. ByteSlices returns an error if an array item is not a bulk string or nil.</p>
<h3 id="func-Bool"><a href="#func-Bool" class="headerlink" title="func Bool"></a>func Bool</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">func <span class="title">Bool</span><span class="params">(reply interface&#123;&#125;, err error)</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span></span><br></pre></td></tr></table></figure>

<p>Bool is a helper that converts a command reply to a boolean. If err is not equal to nil, then Bool returns false, err. Otherwise Bool converts the reply to boolean as follows:</p>
<p>Reply type      Result<br>integer         value != 0, nil<br>bulk string     strconv.ParseBool(reply)<br>nil             false, ErrNil<br>other           false, error</p>
<h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/gomodule/redigo/redis&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//go get -u &quot;github.com/gomodule/redigo/redis&quot;</span></span><br><span class="line"><span class="comment">//go get -u &quot;github.com/gogf/gf/net/gtcp&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">redis_open</span><span class="params">()</span> <span class="params">(redis.Conn, error)</span></span> &#123;</span><br><span class="line">	connectTimeout := <span class="number">10</span> * time.Second</span><br><span class="line">	readTimeout := <span class="number">10</span> * time.Second</span><br><span class="line">	writeTimeout := <span class="number">10</span> * time.Second</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		c1, err := redis.Dial(&quot;tcp&quot;, &quot;127.0.0.1:6379&quot;,</span></span><br><span class="line"><span class="comment">			redis.DialPassword(&quot;123456&quot;),</span></span><br><span class="line"><span class="comment">			redis.DialConnectTimeout(connectTimeout),</span></span><br><span class="line"><span class="comment">			redis.DialReadTimeout(readTimeout),</span></span><br><span class="line"><span class="comment">			redis.DialWriteTimeout(writeTimeout))</span></span><br><span class="line"><span class="comment">		defer c1.Close()</span></span><br><span class="line"><span class="comment">		if err != nil &#123;</span></span><br><span class="line"><span class="comment">			// handle error</span></span><br><span class="line"><span class="comment">			return nil, err</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		conn, err := net.Dial(&quot;tcp&quot;, &quot;127.0.0.1:6379&quot;)</span></span><br><span class="line"><span class="comment">		if err != nil &#123;</span></span><br><span class="line"><span class="comment">			log.Fatal(err)</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		c2 := redis.NewConn(conn, readTimeout, writeTimeout)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	c3, err := redis.DialTimeout(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:6379&quot;</span>,</span><br><span class="line">		connectTimeout,</span><br><span class="line">		readTimeout,</span><br><span class="line">		writeTimeout)</span><br><span class="line">	<span class="comment">//defer c3.Close()</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// handle error</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _, err = c3.Do(<span class="string">&quot;AUTH&quot;</span>, <span class="string">&quot;123456&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> c3, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cache, err := redis_open()</span><br><span class="line">	<span class="keyword">defer</span> cache.Close()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _, err = cache.Do(<span class="string">&quot;SET&quot;</span>, <span class="string">&quot;key1&quot;</span>, <span class="string">&quot;values1&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bytes, err := redis.Bytes(cache.Do(<span class="string">&quot;Get&quot;</span>, <span class="string">&quot;key1&quot;</span>))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(bytes))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> _, err = cache.Do(<span class="string">&quot;SET&quot;</span>, <span class="string">&quot;key2&quot;</span>, <span class="number">1</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	cache.Send(<span class="string">&quot;INCR&quot;</span>, <span class="string">&quot;key2&quot;</span>)</span><br><span class="line">	cache.Send(<span class="string">&quot;INCR&quot;</span>, <span class="string">&quot;key2&quot;</span>)</span><br><span class="line">	cache.Send(<span class="string">&quot;INCR&quot;</span>, <span class="string">&quot;key2&quot;</span>)</span><br><span class="line">	bytes, err := redis.Bytes(cache.Do(<span class="string">&quot;Get&quot;</span>, <span class="string">&quot;key2&quot;</span>))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	n, _ := strconv.Atoi(<span class="keyword">string</span>(bytes))</span><br><span class="line">	fmt.Println(n) <span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _, err = cache.Do(<span class="string">&quot;SET&quot;</span>, <span class="string">&quot;key3&quot;</span>, <span class="number">1</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	cache.Send(<span class="string">&quot;INCR&quot;</span>, <span class="string">&quot;key3&quot;</span>)</span><br><span class="line">	cache.Send(<span class="string">&quot;INCR&quot;</span>, <span class="string">&quot;key3&quot;</span>)</span><br><span class="line">	cache.Send(<span class="string">&quot;INCR&quot;</span>, <span class="string">&quot;key3&quot;</span>)</span><br><span class="line">	cache.Flush()</span><br><span class="line"></span><br><span class="line">	n1, err := cache.Receive()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(n1) <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">	n2, err := cache.Receive()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(n2) <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">	n3, err := cache.Receive()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(n3) <span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<p>通过Do的get返回的interface{}需要转换成切片再转成数字，receive返回的直接就是interface{}-&gt;int64了，这个后面再看下原因。</p>
<p>这里主要的点是连续作业，send+flush+receive或者send+do,do相当于flush+receive了。也可以DO(“”)来flush然后取上一条命令的结果。</p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2>]]></content>
      <tags>
        <tag>redis</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>grpc hello</title>
    <url>/2020-10-13-grpc%20hello/</url>
    <content><![CDATA[<p>用golang+grpc生成一个简单的hello world程序。代码地址：<a href="https://github.com/RiverFerry/grpc">https://github.com/RiverFerry/grpc</a>。</p>
<a id="more"></a>

<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><pre><code>brew install protobuf
brew install golang
brew install grpc

go get -u github.com/golang/protobuf/&#123;proto,protoc-gen-go&#125;
go get -u google.golang.org/grpc</code></pre>
<h3 id="proto文件"><a href="#proto文件" class="headerlink" title="proto文件"></a>proto文件</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">    <span class="keyword">string</span> name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message HelloReply &#123;</span><br><span class="line">    <span class="keyword">string</span> message = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service Greeter &#123;</span><br><span class="line">    rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line"></span><br><span class="line">	pb <span class="string">&quot;grpc/hello&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	port = <span class="string">&quot;:10000&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// server is used to implement helloworld.GreeterServer.</span></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;</span><br><span class="line">	pb.UnimplementedGreeterServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SayHello implements helloworld.GreeterServer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span> <span class="title">SayHello</span><span class="params">(ctx context.Context, in *pb.HelloRequest)</span> <span class="params">(*pb.HelloReply, error)</span></span> &#123;</span><br><span class="line">	log.Printf(<span class="string">&quot;Received: %v&quot;</span>, in.GetName())</span><br><span class="line">	<span class="keyword">return</span> &amp;pb.HelloReply&#123;Message: <span class="string">&quot;Hello &quot;</span> + in.GetName()&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, port)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;failed to listen: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	s := grpc.NewServer()</span><br><span class="line">	pb.RegisterGreeterServer(s, &amp;server&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> err := s.Serve(lis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;failed to serve: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="client"><a href="#client" class="headerlink" title="client"></a>client</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">	pb <span class="string">&quot;grpc/hello&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	address     = <span class="string">&quot;localhost:10000&quot;</span></span><br><span class="line">	defaultName = <span class="string">&quot;23333333&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Set up a connection to the server.</span></span><br><span class="line">	conn, err := grpc.Dial(address, grpc.WithInsecure(), grpc.WithBlock())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;did not connect: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	c := pb.NewGreeterClient(conn)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Contact the server and print out its response.</span></span><br><span class="line">	name := defaultName</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &gt; <span class="number">1</span> &#123;</span><br><span class="line">		name = os.Args[<span class="number">1</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line">	r, err := c.SayHello(ctx, &amp;pb.HelloRequest&#123;Name: name&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;could not greet: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Printf(<span class="string">&quot;Greeting: %s&quot;</span>, r.GetMessage())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><pre><code>protoc -I=../grpc/hello --go_out=plugins=grpc:./hello/ hello.proto --experimental_allow_proto3_optional</code></pre>
<ul>
<li>-I是–proto_path的简写，表示proto文件所在路径</li>
<li>–go_out后面./hello表示生成文件所在路径</li>
<li>experimental_allow_proto3_optional是proto3版本要带的参数</li>
<li>把项目代码放在GOPATH/src下面，import的时候<code>pb &quot;grpc/hello&quot;</code>路径到hello.pb.go文件所在的文件夹就行了</li>
<li>proto文件的message添加optional后go文件中的struct的name/message就变成string*,这里需要注意下</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>main的代码基本是拷贝官方的example,这里主要是编译和设置的问题比较多。其他细节的东西后面其他文章再研究，然后补充。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://doc.oschina.net/grpc?t=58008">gRPC 官方文档中文版V1.0</a></p>
<p><a href="https://stackoverflow.com/questions/57700860/protoc-gen-go-program-not-found-or-is-not-executable">protoc-gen-go: program not found or is not executable
</a></p>
<p><a href="https://stackoverflow.com/questions/34708207/command-not-found-go-on-mac-after-installing-go">Command not found go — on Mac after installing Go</a></p>
<p><a href="https://stackoverflow.com/questions/61188567/could-not-make-proto-path-relative-and-no-such-file-or-directory">Could not make proto path relative and No such file or directory</a></p>
<p><a href="https://stackoverflow.com/questions/61666805/correct-format-of-protoc-go-package">Correct format of protoc go_package?</a></p>
<p><a href="https://juejin.im/post/6844903957672755214">用Golang构建gRPC服务</a></p>
]]></content>
      <tags>
        <tag>grpc</tag>
      </tags>
  </entry>
  <entry>
    <title>gitlab+github+hexo</title>
    <url>/2020-10-14-gitlab+github+hexo/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>以前的blog是基于github page + jekyll实现的，参考别人的模板修修改改。存在一些痛点：</p>
<ul>
<li>代码段不能显示行号</li>
<li>文章没有分页功能</li>
<li>没有搜索功能</li>
<li>没有评论系统(其实是可以实现，但是因为参考别人的模板，之前参考文章失效了，也不知道怎么修改了)</li>
<li>不够流畅，并且缺乏定制化的东西</li>
</ul>
<p>后面选择的方案是hexo+github+gitlab.通过hexo生成静态网页，依赖next的强大可用资源，然后用gitlab实现ci/cd,整个流程还是比较满意的。也考虑过hugo框架，但是资源太少，放弃了</p>
<a id="more"></a>

<h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><h3 id="step-1-安装nodejs"><a href="#step-1-安装nodejs" class="headerlink" title="step 1 安装nodejs"></a>step 1 安装nodejs</h3><p>我之前安装过，就跳过这步了，安装步骤网上很好找</p>
<h3 id="step-2-安装hexo"><a href="#step-2-安装hexo" class="headerlink" title="step 2  安装hexo"></a>step 2  安装hexo</h3><pre><code>npm i hexo-cli -g
npm install
hexo init   //初始化，生成必要的文件
hexo g //hexo generate 生成静态网页
hexo s //hexo server   本地部署
hexo clean </code></pre>
<h3 id="step-3-配置github"><a href="#step-3-配置github" class="headerlink" title="step 3 配置github"></a>step 3 配置github</h3><pre><code>git config --global user.name
git config --global user.email
ssh-keygen -t rsa -C
//添加ssh pub key 到github setting中的ssh key配置中
ssh -T git@github.com
//修改项目路径下的_config.yml repository:填入github仓库地址</code></pre>
<h3 id="step-4-写文章"><a href="#step-4-写文章" class="headerlink" title="step 4 写文章"></a>step 4 写文章</h3><pre><code>hexo new post
//会在source/_post下面生成md文章</code></pre>
<h3 id="step-5-ci-cd"><a href="#step-5-ci-cd" class="headerlink" title="step 5 ci/cd"></a>step 5 ci/cd</h3><p>本地部署hexo的话，直接hexo g -d就行了，会把静态网页传到github下。</p>
<p>gitlab部署的话，需要在gitlab新增一个private的仓库，把hexo下面的文件传进去，把github的rsa也放在仓库中。然后写.gitlab-ci.yml文件，就是脚本配置文件，然后以后push/merge会触发ci/cd.从gitlab配置的share running的docker中执行脚本，部署到github.</p>
<p>我的文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">image: node:<span class="number">14.11</span><span class="number">.0</span></span><br><span class="line">cache:</span><br><span class="line">  paths:</span><br><span class="line">    - node_modules/</span><br><span class="line"></span><br><span class="line">before_script:</span><br><span class="line">  - npm install hexo-cli -g</span><br><span class="line">  - npm install</span><br><span class="line">  - npm audit fix</span><br><span class="line">  - npm install hexo-deployer-git --save</span><br><span class="line">#  - npm install hexo-symbols-count-time --save</span><br><span class="line">#  - npm install --save hexo-helper-live2d</span><br><span class="line">#  - npm install hexo-generator-searchdb --save</span><br><span class="line">#  - npm install live2d-widget-model-tororo</span><br><span class="line">#  - npm i hexo-generator-json-content@<span class="number">2.2</span><span class="number">.0</span> -S</span><br><span class="line">#  - npm install hexo-wordcount --save</span><br><span class="line">#  - npm install hexo-generator-sitemap --save</span><br><span class="line">#  - npm uninstall hexo-generator-baidu-sitemap --save</span><br><span class="line">#  - npm uninstall hexo-baidu-url-submit --save</span><br><span class="line"></span><br><span class="line">pages:</span><br><span class="line">  script:</span><br><span class="line">    - eval $(ssh-agent -s)</span><br><span class="line">    - chmod <span class="number">700</span> github-rsa</span><br><span class="line">    - ssh-add github-rsa</span><br><span class="line">    - git config --global user.email <span class="string">&quot;wang84819762@gmail.com&quot;</span></span><br><span class="line">    - git config --global user.name <span class="string">&quot;RiverFerry&quot;</span></span><br><span class="line">    - echo StrictHostKeyChecking no &gt;&gt; /etc/ssh/ssh_config</span><br><span class="line">#    - ssh -T git@github.com</span><br><span class="line">    - hexo clean</span><br><span class="line">    - hexo g -d</span><br><span class="line">    - echo <span class="string">&quot;Deploy succeed!&quot;</span></span><br><span class="line">  artifacts:</span><br><span class="line">    paths:</span><br><span class="line">      - <span class="keyword">public</span></span><br><span class="line">  only:</span><br><span class="line">    - master</span><br></pre></td></tr></table></figure>

<h2 id="谷歌收录"><a href="#谷歌收录" class="headerlink" title="谷歌收录"></a>谷歌收录</h2><p>百度收录比较麻烦，并且被github屏蔽了，双线部署觉得没必要。就只搞了谷歌收录：</p>
<p>登陆<a href="https://www.google.com/webmasters/">谷歌站长</a>，添加你的站点，新版本有不带前缀的选项，我用的这一个，然后dns验证</p>
<p><img src="https://i.loli.net/2020/10/16/oFebBi4KIJjLHdW.jpg" alt="99a8104b-bc6a-43a4-88d6-1849cc5b5229.jpg"></p>
<p>然后生成sitemap：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure>

<p>修改项目的config:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url: https:&#x2F;&#x2F;riverferry.site</span><br><span class="line"></span><br><span class="line">sitemap:</span><br><span class="line">path: sitemap.xml</span><br></pre></td></tr></table></figure>

<p>source目录下新增robots.txt：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># hexo robots.txt</span><br><span class="line">User-agent: *</span><br><span class="line">Allow: &#x2F;</span><br><span class="line">Allow: &#x2F;archives&#x2F;</span><br><span class="line">Allow: &#x2F;categories&#x2F;</span><br><span class="line">Allow: &#x2F;tags&#x2F;</span><br><span class="line">Disallow: &#x2F;vendors&#x2F;</span><br><span class="line">Disallow: &#x2F;js&#x2F;</span><br><span class="line">Disallow: &#x2F;css&#x2F;</span><br><span class="line">Disallow: &#x2F;fonts&#x2F;</span><br><span class="line">Disallow: &#x2F;vendors&#x2F;</span><br><span class="line">Disallow: &#x2F;fancybox&#x2F;</span><br><span class="line">Sitemap: https:&#x2F;&#x2F;riverferry.site&#x2F;sitemap.xml</span><br></pre></td></tr></table></figure>

<p>在google的search console添加sitemap即可。</p>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><div class="note info">
            <p>色表:<a href="https://flatuicolors.com/palette/fr">https://flatuicolors.com/palette/fr</a><br>图：腾讯cos</p>
          </div>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>报错可以参考下面的文章寻找解决方案。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://hexo.io/zh-cn/docs/gitlab-pages.html">将 Hexo 部署到 GitLab Pages</a></p>
<p><a href="https://damoshushu.github.io/2018/11/18/UseGitLabDeployHexo2GitHub/">使用GitLab Ci 自动部署Hexo到GitHub</a></p>
<p><a href="http://yearito.cn/posts/hexo-theme-beautify.html">Hexo 搭建个人博客系列：主题美化篇</a></p>
<p><a href="https://segmentfault.com/a/1190000017986794">超详细Hexo+Github Page搭建技术博客教程【持续更新】</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/35668237">超详细Hexo+Github博客搭建小白教程</a></p>
<p><a href="https://cuiqingcai.com/7625.html">利用 GitHub + Hexo + Next 从零搭建一个博客</a></p>
]]></content>
      <tags>
        <tag>gitlab</tag>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>git 工作流</title>
    <url>/2020-10-20-git-%E5%B7%A5%E4%BD%9C%E6%B5%81/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.ruanyifeng.com/blog/2015/12/git-workflow.html">Git 工作流程</a></p>
<p><a href="https://github.com/RiverFerry/my-git">forked from xirong/my-git</a></p>
<p><a href="https://www.endoflineblog.com/gitflow-considered-harmful">GitFlow considered harmful</a></p>
]]></content>
  </entry>
  <entry>
    <title>golang channel</title>
    <url>/2020-10-21-golang-channel/</url>
    <content><![CDATA[<p>channel数据结构使用了有锁队列(mutex+双向链表)，区别于runtime sema的mutex+[]treap,主要差异是对于锁和等待队列的实现。睡眠和唤醒都是goready和gppark来实现的，代码版本<code>go version go1.15.2 darwin/amd64</code></p>
<a id="more"></a>

<h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">		<span class="built_in">close</span>(ch)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-ch:</span><br><span class="line">		fmt.Println(<span class="string">&quot;recv!&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>close后会触发读。</p>
<h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">	qcount   <span class="keyword">uint</span>           <span class="comment">// total data in the queue </span></span><br><span class="line">	dataqsiz <span class="keyword">uint</span>           <span class="comment">// size of the circular queue</span></span><br><span class="line">	buf      unsafe.Pointer <span class="comment">// points to an array of dataqsiz elements</span></span><br><span class="line">	elemsize <span class="keyword">uint16</span></span><br><span class="line">	closed   <span class="keyword">uint32</span></span><br><span class="line">	elemtype *_type <span class="comment">// element type</span></span><br><span class="line">	sendx    <span class="keyword">uint</span>   <span class="comment">// send index</span></span><br><span class="line">	recvx    <span class="keyword">uint</span>   <span class="comment">// receive index</span></span><br><span class="line">	recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">	sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">	<span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Do not change another G&#x27;s status while holding this lock</span></span><br><span class="line">	<span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">	<span class="comment">// with stack shrinking.</span></span><br><span class="line">	lock mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">	first *sudog</span><br><span class="line">	last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="chansend"><a href="#chansend" class="headerlink" title="chansend"></a>chansend</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * generic single channel send/recv</span></span><br><span class="line"><span class="comment"> * If block is not nil,</span></span><br><span class="line"><span class="comment"> * then the protocol will not</span></span><br><span class="line"><span class="comment"> * sleep but return if it could</span></span><br><span class="line"><span class="comment"> * not complete.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * sleep can wake up with g.param == nil</span></span><br><span class="line"><span class="comment"> * when a channel involved in the sleep has</span></span><br><span class="line"><span class="comment"> * been closed.  it is easiest to loop and re-run</span></span><br><span class="line"><span class="comment"> * the operation; we&#x27;ll see that it&#x27;s now closed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !block &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">		throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> debugChan &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;chansend: chan=&quot;</span>, c, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		racereadpc(c.raceaddr(), callerpc, funcPC(chansend))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fast path: check for failed non-blocking operation without acquiring the lock.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// After observing that the channel is not closed, we observe that the channel is</span></span><br><span class="line">	<span class="comment">// not ready for sending. Each of these observations is a single word-sized read</span></span><br><span class="line">	<span class="comment">// (first c.closed and second full()).</span></span><br><span class="line">	<span class="comment">// Because a closed channel cannot transition from &#x27;ready for sending&#x27; to</span></span><br><span class="line">	<span class="comment">// &#x27;not ready for sending&#x27;, even if the channel is closed between the two observations,</span></span><br><span class="line">	<span class="comment">// they imply a moment between the two when the channel was both not yet closed</span></span><br><span class="line">	<span class="comment">// and not ready for sending. We behave as if we observed the channel at that moment,</span></span><br><span class="line">	<span class="comment">// and report that the send cannot proceed.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// It is okay if the reads are reordered here: if we observe that the channel is not</span></span><br><span class="line">	<span class="comment">// ready for sending and then observe that it is not closed, that implies that the</span></span><br><span class="line">	<span class="comment">// channel wasn&#x27;t closed during the first observation. However, nothing here</span></span><br><span class="line">	<span class="comment">// guarantees forward progress. We rely on the side effects of lock release in</span></span><br><span class="line">	<span class="comment">// chanrecv() and closechan() to update this thread&#x27;s view of c.closed and full().</span></span><br><span class="line">	<span class="keyword">if</span> !block &amp;&amp; c.closed == <span class="number">0</span> &amp;&amp; full(c) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> t0 <span class="keyword">int64</span></span><br><span class="line">	<span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">		t0 = cputicks()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//有锁队列</span></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//case1: 有等待者，则唤醒</span></span><br><span class="line">	<span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Found a waiting receiver. We pass the value we want to send</span></span><br><span class="line">		<span class="comment">// directly to the receiver, bypassing the channel buffer (if any).</span></span><br><span class="line">		send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//case2: 没有等待者并且缓冲区未满，则写缓冲区</span></span><br><span class="line">	<span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">		<span class="comment">// Space is available in the channel buffer. Enqueue the element to send.</span></span><br><span class="line">		qp := chanbuf(c, c.sendx)</span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquire(qp)</span><br><span class="line">			racerelease(qp)</span><br><span class="line">		&#125;</span><br><span class="line">		typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">		c.sendx++</span><br><span class="line">		<span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">			c.sendx = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		c.qcount++</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !block &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//case3: 没有等待者，缓冲区已满 则gopark挂起</span></span><br><span class="line">	<span class="comment">// Block on the channel. Some receiver will complete our operation for us.</span></span><br><span class="line">	gp := getg()</span><br><span class="line">	mysg := acquireSudog()</span><br><span class="line">	mysg.releasetime = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">		mysg.releasetime = <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line">	<span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">	mysg.elem = ep</span><br><span class="line">	mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">	mysg.g = gp</span><br><span class="line">	mysg.isSelect = <span class="literal">false</span></span><br><span class="line">	mysg.c = c</span><br><span class="line">	gp.waiting = mysg</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	c.sendq.enqueue(mysg)</span><br><span class="line">	gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, <span class="number">2</span>)</span><br><span class="line">	<span class="comment">// Ensure the value being sent is kept alive until the</span></span><br><span class="line">	<span class="comment">// receiver copies it out. The sudog has a pointer to the</span></span><br><span class="line">	<span class="comment">// stack object, but sudogs aren&#x27;t considered as roots of the</span></span><br><span class="line">	<span class="comment">// stack tracer.</span></span><br><span class="line">	KeepAlive(ep)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// someone woke us up.</span></span><br><span class="line">	<span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">		throw(<span class="string">&quot;G waiting list is corrupted&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	gp.waiting = <span class="literal">nil</span></span><br><span class="line">	gp.activeStackChans = <span class="literal">false</span></span><br><span class="line">	<span class="keyword">if</span> gp.param == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> c.closed == <span class="number">0</span> &#123;</span><br><span class="line">			throw(<span class="string">&quot;chansend: spurious wakeup&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">		blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	mysg.c = <span class="literal">nil</span></span><br><span class="line">	releaseSudog(mysg)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="chanrecv"><a href="#chanrecv" class="headerlink" title="chanrecv"></a>chanrecv</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// chanrecv receives on channel c and writes the received data to ep.</span></span><br><span class="line"><span class="comment">// ep may be nil, in which case received data is ignored.</span></span><br><span class="line"><span class="comment">// If block == false and no elements are available, returns (false, false).</span></span><br><span class="line"><span class="comment">// Otherwise, if c is closed, zeros *ep and returns (true, false).</span></span><br><span class="line"><span class="comment">// Otherwise, fills in *ep with an element and returns (true, true).</span></span><br><span class="line"><span class="comment">// A non-nil ep must point to the heap or the caller&#x27;s stack.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>)</span> <span class="params">(selected, received <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// raceenabled: don&#x27;t need to check ep, as it is always on the stack</span></span><br><span class="line">	<span class="comment">// or is new memory allocated by reflect.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> debugChan &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;chanrecv: chan=&quot;</span>, c, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !block &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">		throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fast path: check for failed non-blocking operation without acquiring the lock.</span></span><br><span class="line">	<span class="keyword">if</span> !block &amp;&amp; empty(c) &#123;</span><br><span class="line">		<span class="comment">// After observing that the channel is not ready for receiving, we observe whether the</span></span><br><span class="line">		<span class="comment">// channel is closed.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// Reordering of these checks could lead to incorrect behavior when racing with a close.</span></span><br><span class="line">		<span class="comment">// For example, if the channel was open and not empty, was closed, and then drained,</span></span><br><span class="line">		<span class="comment">// reordered reads could incorrectly indicate &quot;open and empty&quot;. To prevent reordering,</span></span><br><span class="line">		<span class="comment">// we use atomic loads for both checks, and rely on emptying and closing to happen in</span></span><br><span class="line">		<span class="comment">// separate critical sections under the same lock.  This assumption fails when closing</span></span><br><span class="line">		<span class="comment">// an unbuffered channel with a blocked send, but that is an error condition anyway.</span></span><br><span class="line">		<span class="keyword">if</span> atomic.Load(&amp;c.closed) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// Because a channel cannot be reopened, the later observation of the channel</span></span><br><span class="line">			<span class="comment">// being not closed implies that it was also not closed at the moment of the</span></span><br><span class="line">			<span class="comment">// first observation. We behave as if we observed the channel at that moment</span></span><br><span class="line">			<span class="comment">// and report that the receive cannot proceed.</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// The channel is irreversibly closed. Re-check whether the channel has any pending data</span></span><br><span class="line">		<span class="comment">// to receive, which could have arrived between the empty and closed checks above.</span></span><br><span class="line">		<span class="comment">// Sequential consistency is also required here, when racing with such a send.</span></span><br><span class="line">		<span class="keyword">if</span> empty(c) &#123;</span><br><span class="line">			<span class="comment">// The channel is irreversibly closed and empty.</span></span><br><span class="line">			<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">				raceacquire(c.raceaddr())</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">				typedmemclr(c.elemtype, ep)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> t0 <span class="keyword">int64</span></span><br><span class="line">	<span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">		t0 = cputicks()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquire(c.raceaddr())</span><br><span class="line">		&#125;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">			typedmemclr(c.elemtype, ep)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//case1: 有发送者阻塞，直接接受</span></span><br><span class="line">	<span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Found a waiting sender. If buffer is size 0, receive value</span></span><br><span class="line">		<span class="comment">// directly from sender. Otherwise, receive from head of queue</span></span><br><span class="line">		<span class="comment">// and add sender&#x27;s value to the tail of the queue (both map to</span></span><br><span class="line">		<span class="comment">// the same buffer slot because the queue is full).</span></span><br><span class="line">		recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//case2: 没有发送者阻塞，但缓冲区有内容</span></span><br><span class="line">	<span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Receive directly from queue</span></span><br><span class="line">		qp := chanbuf(c, c.recvx)</span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquire(qp)</span><br><span class="line">			racerelease(qp)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">			typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">		&#125;</span><br><span class="line">		typedmemclr(c.elemtype, qp)</span><br><span class="line">		c.recvx++</span><br><span class="line">		<span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">			c.recvx = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		c.qcount--</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !block &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//case3: 没有发送者阻塞，缓冲区为空 gopark挂起</span></span><br><span class="line">	<span class="comment">// no sender available: block on this channel.</span></span><br><span class="line">	gp := getg()</span><br><span class="line">	mysg := acquireSudog()</span><br><span class="line">	mysg.releasetime = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">		mysg.releasetime = <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line">	<span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">	mysg.elem = ep</span><br><span class="line">	mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">	gp.waiting = mysg</span><br><span class="line">	mysg.g = gp</span><br><span class="line">	mysg.isSelect = <span class="literal">false</span></span><br><span class="line">	mysg.c = c</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	c.recvq.enqueue(mysg)</span><br><span class="line">	gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanReceive, traceEvGoBlockRecv, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// someone woke us up</span></span><br><span class="line">	<span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">		throw(<span class="string">&quot;G waiting list is corrupted&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	gp.waiting = <span class="literal">nil</span></span><br><span class="line">	gp.activeStackChans = <span class="literal">false</span></span><br><span class="line">	<span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">		blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	closed := gp.param == <span class="literal">nil</span></span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	mysg.c = <span class="literal">nil</span></span><br><span class="line">	releaseSudog(mysg)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>, !closed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang context</title>
    <url>/2020-10-21-golang-context/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">author</th>
<th align="center">title</th>
<th align="center">version</th>
</tr>
</thead>
<tbody><tr>
<td align="center">TheRiver</td>
<td align="center">golang reflect</td>
<td align="center">go version go1.15.2 darwin/amd64</td>
</tr>
</tbody></table>
<a id="more"></a>

<h3 id="context-Context"><a href="#context-Context" class="headerlink" title="context.Context"></a>context.Context</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A Context carries a deadline, a cancellation signal, and other values across</span></span><br><span class="line"><span class="comment">// API boundaries.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Context&#x27;s methods may be called by multiple goroutines simultaneously.</span></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">	Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line">	Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	Err() error</span><br><span class="line">	Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	background = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">	todo       = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> emptyCtx <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Deadline</span><span class="params">()</span> <span class="params">(deadline time.Time, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Done</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Err</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Background"><a href="#Background" class="headerlink" title="Background()"></a>Background()</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span> <span class="title">Context</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> background</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO()"></a>TODO()</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TODO</span><span class="params">()</span> <span class="title">Context</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>Background()和TODO()都返回一个实现了context.Context接口的类型emptyCtx,通常作为parent的context节点使用。一般都是用Background(),TODO if you are unsure about which Context to use.</p>
<h3 id="WithValue"><a href="#WithValue" class="headerlink" title="WithValue()"></a>WithValue()</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WithValue returns a copy of parent in which the value associated with key is</span></span><br><span class="line"><span class="comment">// val.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Use context Values only for request-scoped data that transits processes and</span></span><br><span class="line"><span class="comment">// APIs, not for passing optional parameters to functions.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The provided key must be comparable and should not be of type</span></span><br><span class="line"><span class="comment">// string or any other built-in type to avoid collisions between</span></span><br><span class="line"><span class="comment">// packages using context. Users of WithValue should define their own</span></span><br><span class="line"><span class="comment">// types for keys. To avoid allocating when assigning to an</span></span><br><span class="line"><span class="comment">// interface&#123;&#125;, context keys often have concrete type</span></span><br><span class="line"><span class="comment">// struct&#123;&#125;. Alternatively, exported context key variables&#x27; static</span></span><br><span class="line"><span class="comment">// type should be a pointer or interface.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Context</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> key == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;nil key&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !reflectlite.TypeOf(key).Comparable() &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;key is not comparable&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	Context</span><br><span class="line">	key, val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Value"><a href="#Value" class="headerlink" title="Value()"></a>Value()</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">if</span> c.key == key &#123;</span><br><span class="line">		<span class="keyword">return</span> c.val</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c.Context.Value(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>key必须是可比较的类型，并且不能是string或者其他内置类型，通常定义为type xxx struct{}.valueCtx通过嵌入接口来继承接口的方法，也即是实现了该接口，并在此基础上新增了几个方法(Value()…)</p>
<h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> k <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx := context.Background()</span><br><span class="line">	valueCtx := context.WithValue(ctx, k&#123;&#125;, <span class="string">&quot;parent&quot;</span>)</span><br><span class="line">	fmt.Println(valueCtx.Value(k&#123;&#125;)) <span class="comment">//parent</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="WithCancel"><a href="#WithCancel" class="headerlink" title="WithCancel"></a>WithCancel</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WithCancel returns a copy of parent with a new Done channel. The returned</span></span><br><span class="line"><span class="comment">// context&#x27;s Done channel is closed when the returned cancel function is called</span></span><br><span class="line"><span class="comment">// or when the parent context&#x27;s Done channel is closed, whichever happens first.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Canceling this context releases resources associated with it, so code should</span></span><br><span class="line"><span class="comment">// call cancel as soon as the operations running in this Context complete.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	c := newCancelCtx(parent)</span><br><span class="line">    propagateCancel(parent, &amp;c)</span><br><span class="line">    <span class="comment">//var Canceled = errors.New(&quot;context canceled&quot;)</span></span><br><span class="line">	<span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="newCancelCtx"><a href="#newCancelCtx" class="headerlink" title="newCancelCtx"></a>newCancelCtx</h4><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// newCancelCtx returns an initialized cancelCtx.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCancelCtx</span><span class="params">(parent Context)</span> <span class="title">cancelCtx</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> cancelCtx&#123;Context: parent&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A cancelCtx can be canceled. When canceled, it also cancels any children</span></span><br><span class="line"><span class="comment">// that implement canceler.</span></span><br><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	Context</span><br><span class="line"></span><br><span class="line">	mu       sync.Mutex            <span class="comment">// protects following fields</span></span><br><span class="line">	done     <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;         <span class="comment">// created lazily, closed by first cancel call</span></span><br><span class="line">	children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125; <span class="comment">// set to nil by the first cancel call</span></span><br><span class="line">	err      error                 <span class="comment">// set to non-nil by the first cancel call</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">Done</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	d := c.done</span><br><span class="line">	c.mu.Unlock()</span><br><span class="line">	<span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A canceler is a context type that can be canceled directly. The</span></span><br><span class="line"><span class="comment">// implementations are *cancelCtx and *timerCtx.</span></span><br><span class="line"><span class="keyword">type</span> canceler <span class="keyword">interface</span> &#123;</span><br><span class="line">	cancel(removeFromParent <span class="keyword">bool</span>, err error)</span><br><span class="line">	Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="propagateCancel"><a href="#propagateCancel" class="headerlink" title="propagateCancel"></a>propagateCancel</h4><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cancel closes c.done, cancels each of c&#x27;s children, and, if</span></span><br><span class="line"><span class="comment">// removeFromParent is true, removes c from its parent&#x27;s children.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">cancel</span><span class="params">(removeFromParent <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;context: internal error: missing cancel error&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> c.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.mu.Unlock()</span><br><span class="line">		<span class="keyword">return</span> <span class="comment">// already canceled</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.err = err</span><br><span class="line">	<span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">//var closedchan = make(chan struct&#123;&#125;)</span></span><br><span class="line">		c.done = closedchan</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">close</span>(c.done)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> child := <span class="keyword">range</span> c.children &#123;</span><br><span class="line">		<span class="comment">// <span class="doctag">NOTE:</span> acquiring the child&#x27;s lock while holding parent&#x27;s lock.</span></span><br><span class="line">		child.cancel(<span class="literal">false</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	c.children = <span class="literal">nil</span></span><br><span class="line">	c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">		removeChild(c.Context, c)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// removeChild removes a context from its parent.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeChild</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">    p, ok := parentCancelCtx(parent)</span><br><span class="line">    <span class="comment">//第2层以下的为真</span></span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	p.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> p.children != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">delete</span>(p.children, child)</span><br><span class="line">	&#125;</span><br><span class="line">	p.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// parentCancelCtx returns the underlying *cancelCtx for parent.</span></span><br><span class="line"><span class="comment">// It does this by looking up parent.Value(&amp;cancelCtxKey) to find</span></span><br><span class="line"><span class="comment">// the innermost enclosing *cancelCtx and then checking whether</span></span><br><span class="line"><span class="comment">// parent.Done() matches that *cancelCtx. (If not, the *cancelCtx</span></span><br><span class="line"><span class="comment">// has been wrapped in a custom implementation providing a</span></span><br><span class="line"><span class="comment">// different done channel, in which case we should not bypass it.)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parentCancelCtx</span><span class="params">(parent Context)</span> <span class="params">(*cancelCtx, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	done := parent.Done()</span><br><span class="line">	<span class="keyword">if</span> done == closedchan || done == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里value返回parent,转换成cancelCtx,按说本来就是cancelCtx。</span></span><br><span class="line">    <span class="comment">//对于root的ctx这里类型转换会panic,不过前面if已经拒绝了root的ctx</span></span><br><span class="line">    <span class="comment">//也就是说这里是第2层以下的parent的ctx</span></span><br><span class="line">	p, ok := parent.Value(&amp;cancelCtxKey).(*cancelCtx)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	p.mu.Lock()</span><br><span class="line">	ok = p.done == done</span><br><span class="line">	p.mu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line">		<span class="keyword">return</span> c</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c.Context.Value(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// propagateCancel arranges for child to be canceled when parent is.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">propagateCancel</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">	done := parent.Done()</span><br><span class="line">	<span class="keyword">if</span> done == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="comment">// parent is never canceled</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-done:</span><br><span class="line">		<span class="comment">// parent is already canceled</span></span><br><span class="line">		child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">		p.mu.Lock()</span><br><span class="line">		<span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// parent has already been canceled</span></span><br><span class="line">			child.cancel(<span class="literal">false</span>, p.err)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> p.children == <span class="literal">nil</span> &#123;</span><br><span class="line">				p.children = <span class="built_in">make</span>(<span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">			p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		p.mu.Unlock()</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		atomic.AddInt32(&amp;goroutines, +<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">				child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line">			<span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>newCancelCtx返回cancelCtx，cancelCtx实现了5个方法：</p>
<ul>
<li>func (c *cancelCtx) Value(key interface{}) interface{}</li>
<li>func (c *cancelCtx) Done() &lt;-chan struct{}    //生成channel</li>
<li>func (c *cancelCtx) Err() error</li>
<li>func (c *cancelCtx) String() string</li>
<li>func (c *cancelCtx) cancel(removeFromParent bool, err error) //关闭</li>
</ul>
<p>最重要的是<code>Done()</code>,<code>Value</code>和<code>cancel</code>函数。</p>
<ul>
<li>Done生成一个channel</li>
<li>Vaule返回自身的ctx或者调用parent.Value()</li>
<li>cancle关闭自身和children的channel</li>
</ul>
<p>propagateCancel会把children存入map.</p>
<p>由于context可以无限的向下扩展，层级可能很复杂，这里的函数看起来挺绕的，不深究了。</p>
<h3 id="WithTimeout"><a href="#WithTimeout" class="headerlink" title="WithTimeout"></a>WithTimeout</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span> <span class="params">(Context, CancelFunc)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="WithDeadline"><a href="#WithDeadline" class="headerlink" title="WithDeadline"></a>WithDeadline</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WithDeadline returns a copy of the parent context with the deadline adjusted</span></span><br><span class="line"><span class="comment">// to be no later than d. If the parent&#x27;s deadline is already earlier than d,</span></span><br><span class="line"><span class="comment">// WithDeadline(parent, d) is semantically equivalent to parent. The returned</span></span><br><span class="line"><span class="comment">// context&#x27;s Done channel is closed when the deadline expires, when the returned</span></span><br><span class="line"><span class="comment">// cancel function is called, or when the parent context&#x27;s Done channel is</span></span><br><span class="line"><span class="comment">// closed, whichever happens first.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Canceling this context releases resources associated with it, so code should</span></span><br><span class="line"><span class="comment">// call cancel as soon as the operations running in this Context complete.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span> <span class="params">(Context, CancelFunc)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;</span><br><span class="line">		<span class="comment">// The current deadline is already sooner than the new one.</span></span><br><span class="line">		<span class="keyword">return</span> WithCancel(parent)</span><br><span class="line">	&#125;</span><br><span class="line">	c := &amp;timerCtx&#123;</span><br><span class="line">		cancelCtx: newCancelCtx(parent),</span><br><span class="line">		deadline:  d,</span><br><span class="line">	&#125;</span><br><span class="line">	propagateCancel(parent, c)</span><br><span class="line">	dur := time.Until(d)</span><br><span class="line">	<span class="keyword">if</span> dur &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		c.cancel(<span class="literal">true</span>, DeadlineExceeded) <span class="comment">// deadline has already passed</span></span><br><span class="line">		<span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">false</span>, Canceled) &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> c.err == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.timer = time.AfterFunc(dur, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			c.cancel(<span class="literal">true</span>, DeadlineExceeded)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A timerCtx carries a timer and a deadline. It embeds a cancelCtx to</span></span><br><span class="line"><span class="comment">// implement Done and Err. It implements cancel by stopping its timer then</span></span><br><span class="line"><span class="comment">// delegating to cancelCtx.cancel.</span></span><br><span class="line"><span class="keyword">type</span> timerCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	cancelCtx</span><br><span class="line">	timer *time.Timer <span class="comment">// Under cancelCtx.mu.</span></span><br><span class="line"></span><br><span class="line">	deadline time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span> <span class="title">Deadline</span><span class="params">()</span> <span class="params">(deadline time.Time, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.deadline, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><p>和withcancle差别不大，就是多了计时功能。WithDeadline生成的ctx才有Deadline()函数。</p>
<p>WithDeadline在time.Time时间后异步的关闭channel</p>
<h3 id="CancelFunc"><a href="#CancelFunc" class="headerlink" title="CancelFunc"></a>CancelFunc</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> CancelFunc <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>在database/sql中有遇到context的使用，但只有一层，没看出多大用。以后遇到有意义的场景再补充。</p>
<p>层层生成的新的层级的ctx和一个ctx层层传递的区别？</p>
<p>关闭当前的ctx也会把底层的ctx关闭，这就是区别吧？？？</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ctx2</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ctx3</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	ctx2(ctx)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx, cancle := context.WithCancel(context.Background())</span><br><span class="line">	ctx2, cancle2 := context.WithCancel(ctx)</span><br><span class="line">	_, cancle3 := context.WithCancel(ctx2)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		cancle()</span><br><span class="line">		cancle2()</span><br><span class="line">		cancle3()</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><p>[1]<a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/">https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/</a></p>
<p>[2]<a href="https://golang.org/pkg/context/">https://golang.org/pkg/context/</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang mutex</title>
    <url>/2020-10-22-golang-mutex/</url>
    <content><![CDATA[<p>下面这段注释很重要。简单翻一下：</p>
<blockquote>
<p>Mutex有2种模式：normal/starvation 。</p>
</blockquote>
<blockquote>
<p>正常模式下的waiter是排成fifo的队列，但是被唤醒的waiter遇到刚运行的goroutine(有更高的优先级)是竞争不过mutex的所有权的。这时候这个waiter就在queue的head等待。如果超过1ms还没拿到锁，就切换成饥饿模式。其实就是做补偿处理，防止饿死</p>
</blockquote>
<blockquote>
<p>在饥饿模式下，mutex的所有权从未加锁的goroutine直接传递给queue头部的那个饥饿模式下的waiter.新的goroutine不会尝试获取锁，不会自旋。而是将自己放到了queue的tail.所以这里是挂起了自己？</p>
</blockquote>
<blockquote>
<p>对于一个拿到mutex所有权的waiter,有两种情况：1&gt;这个waiter是queue的最后一个 2&gt;这个waiter获取所有权不超过1ms,满足其一则将模式切换回Normal</p>
</blockquote>
<blockquote>
<p>普通模式下应该考虑到一个goroutine可能一直尝试获取mutext很多次，即使已经有很多被阻塞的waiters.</p>
</blockquote>
<blockquote>
<p>starvation对于饿死情况有很好的的补偿处理</p>
</blockquote>
<a id="more"></a>

<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	mutexLocked = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// mutex is locked</span></span><br><span class="line">	mutexWoken</span><br><span class="line">	mutexStarving</span><br><span class="line">	mutexWaiterShift = <span class="literal">iota</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Mutex fairness.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Mutex can be in 2 modes of operations: normal and starvation.</span></span><br><span class="line">	<span class="comment">// In normal mode waiters are queued in FIFO order, but a woken up waiter</span></span><br><span class="line">	<span class="comment">// does not own the mutex and competes with new arriving goroutines over</span></span><br><span class="line">	<span class="comment">// the ownership. New arriving goroutines have an advantage -- they are</span></span><br><span class="line">	<span class="comment">// already running on CPU and there can be lots of them, so a woken up</span></span><br><span class="line">	<span class="comment">// waiter has good chances of losing. In such case it is queued at front</span></span><br><span class="line">	<span class="comment">// of the wait queue. If a waiter fails to acquire the mutex for more than 1ms,</span></span><br><span class="line">	<span class="comment">// it switches mutex to the starvation mode.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// In starvation mode ownership of the mutex is directly handed off from</span></span><br><span class="line">	<span class="comment">// the unlocking goroutine to the waiter at the front of the queue.</span></span><br><span class="line">	<span class="comment">// New arriving goroutines don&#x27;t try to acquire the mutex even if it appears</span></span><br><span class="line">	<span class="comment">// to be unlocked, and don&#x27;t try to spin. Instead they queue themselves at</span></span><br><span class="line">	<span class="comment">// the tail of the wait queue.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// If a waiter receives ownership of the mutex and sees that either</span></span><br><span class="line">	<span class="comment">// (1) it is the last waiter in the queue, or (2) it waited for less than 1 ms,</span></span><br><span class="line">	<span class="comment">// it switches mutex back to normal operation mode.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Normal mode has considerably better performance as a goroutine can acquire</span></span><br><span class="line">	<span class="comment">// a mutex several times in a row even if there are blocked waiters.</span></span><br><span class="line">	<span class="comment">// Starvation mode is important to prevent pathological cases of tail latency.</span></span><br><span class="line">	starvationThresholdNs = <span class="number">1e6</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock()"></a>Lock()</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Lock locks m.</span></span><br><span class="line"><span class="comment">// If the lock is already in use, the calling goroutine</span></span><br><span class="line"><span class="comment">// blocks until the mutex is available.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Fast path: grab unlocked mutex.</span></span><br><span class="line">    <span class="comment">// CompareAndSwapInt32 executes the compare-and-swap operation for an int32 value.</span></span><br><span class="line">    <span class="comment">//如果m未加锁，则加锁</span></span><br><span class="line">	<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line">		<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">            <span class="comment">//race是做竞争检测的</span></span><br><span class="line">			race.Acquire(unsafe.Pointer(m))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Slow path (outlined so that the fast path can be inlined)</span></span><br><span class="line">	m.lockSlow()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A Mutex is a mutual exclusion lock.</span></span><br><span class="line"><span class="comment">// The zero value for a Mutex is an unlocked mutex.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A Mutex must not be copied after first use.</span></span><br><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	state <span class="keyword">int32</span> <span class="comment">//0:unlock 1:lock</span></span><br><span class="line">	sema  <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="cas"><a href="#cas" class="headerlink" title="cas"></a>cas</h2><p>compare-and-swap是原子操作的一种，可用于在多线程编程中实现不被打断的数据交换操作，从而避免多线程同时改写某一数据时由于执行顺序不确定性以及中断的不可预知性产生的数据不一致问题。 该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值。</p>
<p>wiki上的一个伪代码例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cas</span><span class="params">(<span class="keyword">long</span> *addr, <span class="keyword">long</span> old, <span class="keyword">long</span> <span class="keyword">new</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Executes atomically. */</span></span><br><span class="line">    <span class="keyword">if</span>(*addr != old)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    *addr = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cas的底层实现是cmpxchg,类似的指令还有xchg,xadd等。cas的原理是判断内存地址的值和存的旧值是否相等，如果相等就认为没有被修改过，是原子安全的。就把新值set进去。但这里有个问题，即旧值被修改了&gt;=2次，最终和原来的值保持一致，就造成了误判，也就是ABA问题，参考wiki.所以使用的时候，cmpxchg在多cpu下需要加lock前缀，锁住内存总线或者对应的内存地址，具体的处理方法细节太底层不捉摸了。(unicore下就不用加lock了？在单核下，只有中断会打断进程的执行，但不会打断一条指令的执行，所以单个cmpxchg指令是原子的。)</p>
<blockquote>
<p>On a single-CPU system, cmpxchg is atomic with respect to other threads, or any other code running on the same CPU core. (But not to “system” observers like a memory-mapped I/O device, or a device doing DMA reads of normal memory, so lock cmpxchg was relevant even on uniprocessor CPU designs).</p>
</blockquote>
<blockquote>
<p>Context switches can only happen on interrupts, and interrupts happen before or after an instruction, not in the middle. Any code running on the same CPU will see the cmpxchg as either fully executed or not at all.</p>
</blockquote>
<p><a href="https://stackoverflow.com/questions/27837731/is-x86-cmpxchg-atomic-if-so-why-does-it-need-lock/44273130#44273130">https://stackoverflow.com/questions/27837731/is-x86-cmpxchg-atomic-if-so-why-does-it-need-lock/44273130#44273130</a></p>
<p>需要注意的是，xchg是inter x86底层的一个实现了tsl的指令。其包含了一个隐含的lock指令，而不像cmpxchg是需要手动在必要情况下添加lock的。这两个的性能好像也没啥区别，参考:<a href="https://software.intel.com/content/www/us/en/develop/articles/implementing-scalable-atomic-locks-for-multi-core-intel-em64t-and-ia32-architectures.html">https://software.intel.com/content/www/us/en/develop/articles/implementing-scalable-atomic-locks-for-multi-core-intel-em64t-and-ia32-architectures.html</a></p>
<p><img src="https://i.loli.net/2020/10/22/9DeHGZNPUz3oVlm.gif" alt="333943-333943-142885.gif"></p>
<p>CompareAndSwapInt32实现的源代码在<a href="https://github.com/golang/go/blob/master/src/runtime/internal/atomic/asm_amd64.s">https://github.com/golang/go/blob/master/src/runtime/internal/atomic/asm_amd64.s</a>,就是通过lock+cmpxchg实现的。</p>
<h2 id="lockSlow"><a href="#lockSlow" class="headerlink" title="lockSlow"></a>lockSlow</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">lockSlow</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> waitStartTime <span class="keyword">int64</span></span><br><span class="line">	starving := <span class="literal">false</span></span><br><span class="line">	awoke := <span class="literal">false</span></span><br><span class="line">	iter := <span class="number">0</span></span><br><span class="line">	old := m.state</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// Don&#x27;t spin in starvation mode, ownership is handed off to waiters</span></span><br><span class="line">        <span class="comment">// so we won&#x27;t be able to acquire the mutex anyway.</span></span><br><span class="line">        <span class="comment">//前面说过了饥饿模式下是通过其他goroutine把mutex转交过来的，所以饥饿模式下不用再去申请锁了</span></span><br><span class="line">        <span class="comment">//这里判断是普通模式下，处于锁定状态，然后runtime_canSpin判断能否进入自旋</span></span><br><span class="line">        <span class="comment">//old&amp;mutexStarving=0</span></span><br><span class="line">        <span class="comment">//old&amp;mutexLocked=1</span></span><br><span class="line">        <span class="comment">//old:0*1      --&gt; old &amp; 101 = 001</span></span><br><span class="line">		<span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;</span><br><span class="line">			<span class="comment">// Active spinning makes sense.</span></span><br><span class="line">			<span class="comment">// Try to set mutexWoken flag to inform Unlock</span></span><br><span class="line">			<span class="comment">// to not wake other blocked goroutines.</span></span><br><span class="line">			<span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp;</span><br><span class="line">				atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;</span><br><span class="line">				awoke = <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">			runtime_doSpin()</span><br><span class="line">			iter++</span><br><span class="line">			old = m.state</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//走到这有3个case</span></span><br><span class="line">        <span class="comment">//1: old=0*0 普通模式，unlock</span></span><br><span class="line">        <span class="comment">//2: old=1*1 饥饿模式，lock</span></span><br><span class="line">        <span class="comment">//3: old=1*0 饥饿模式，unlock</span></span><br><span class="line">		<span class="built_in">new</span> := old</span><br><span class="line">        <span class="comment">// Don&#x27;t try to acquire starving mutex, new arriving goroutines must queue.</span></span><br><span class="line">        <span class="comment">//old=0*0,不是饥饿模式，说明mutex是unlock,则吧mutexLocked加锁标记加上,-&gt;0*1</span></span><br><span class="line">		<span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="built_in">new</span> |= mutexLocked</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//old &amp; 101 != 000 , old = 0*0不进入if，不给mutexWaiterShift置位</span></span><br><span class="line">		<span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">//new += (1&lt;&lt;3)</span></span><br><span class="line">            <span class="comment">//等待队列+1</span></span><br><span class="line">			<span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// The current goroutine switches mutex to starvation mode.</span></span><br><span class="line">		<span class="comment">// But if the mutex is currently unlocked, don&#x27;t do the switch.</span></span><br><span class="line">		<span class="comment">// Unlock expects that starving mutex has waiters, which will not</span></span><br><span class="line">        <span class="comment">// be true in this case.</span></span><br><span class="line">        <span class="comment">//第一次循环starving=false</span></span><br><span class="line">        <span class="comment">//上一次被唤醒等待超过1m，starving为true了。这一次自旋获取锁失败，则进入饥饿模式</span></span><br><span class="line">		<span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="built_in">new</span> |= mutexStarving</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> awoke &#123;</span><br><span class="line">			<span class="comment">// The goroutine has been woken from sleep,</span></span><br><span class="line">			<span class="comment">// so we need to reset the flag in either case.</span></span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexWoken == <span class="number">0</span> &#123;</span><br><span class="line">				throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//已经被唤醒了，置mutexWoken=0</span></span><br><span class="line">			<span class="built_in">new</span> &amp;^= mutexWoken</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新m.state</span></span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">            <span class="comment">//old=000</span></span><br><span class="line">            <span class="comment">//普通模式，前面new已经加了上锁标记了，所以cas后退出循环，拿锁成功</span></span><br><span class="line">			<span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">break</span> <span class="comment">// locked the mutex with CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//走到这里只能是饥饿模式</span></span><br><span class="line">			<span class="comment">// If we were already waiting before, queue at the front of the queue.</span></span><br><span class="line">            queueLifo := waitStartTime != <span class="number">0</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">			<span class="keyword">if</span> waitStartTime == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">//设置为当前时间</span></span><br><span class="line">				waitStartTime = runtime_nanotime()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取信号量</span></span><br><span class="line">            <span class="comment">//queueLifo=false,g是新执行的,加入队列tail</span></span><br><span class="line">            <span class="comment">//queueLifo=true,g是被唤醒的,加入队列head</span></span><br><span class="line">            runtime_SemacquireMutex(&amp;m.sema, queueLifo, <span class="number">1</span>)</span><br><span class="line">            <span class="comment">//等待超过1秒,设置为饥饿模式，给下一次循环用的</span></span><br><span class="line">			starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line">            old = m.state</span><br><span class="line">            <span class="comment">//饥饿模式下</span></span><br><span class="line">			<span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// If this goroutine was woken and mutex is in starvation mode,</span></span><br><span class="line">				<span class="comment">// ownership was handed off to us but mutex is in somewhat</span></span><br><span class="line">				<span class="comment">// inconsistent state: mutexLocked is not set and we are still</span></span><br><span class="line">                <span class="comment">// accounted as waiter. Fix that.</span></span><br><span class="line">                <span class="comment">//case1&gt;    old(1**) &amp; 011 != 0, old ！= 100为真 </span></span><br><span class="line">                <span class="comment">//case2&gt;    old&gt;&gt;mutexWaiterShift == 0,表示old=0*0</span></span><br><span class="line">                <span class="comment">//old = 100 &amp;&amp; old != 0*0,才不抛异常;等待队列为空</span></span><br><span class="line">				<span class="keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="number">0</span> &#123;</span><br><span class="line">					throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//old = 100</span></span><br><span class="line">                <span class="comment">//等待队列-1并获取锁</span></span><br><span class="line">                delta := <span class="keyword">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class="line">                <span class="comment">//已经不是饥饿模式了，或者waiter queue只剩下一个了</span></span><br><span class="line">				<span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123;</span><br><span class="line">					<span class="comment">// Exit starvation mode.</span></span><br><span class="line">					<span class="comment">// Critical to do it here and consider wait time.</span></span><br><span class="line">					<span class="comment">// Starvation mode is so inefficient, that two goroutines</span></span><br><span class="line">					<span class="comment">// can go lock-step infinitely once they switch mutex</span></span><br><span class="line">                    <span class="comment">// to starvation mode.</span></span><br><span class="line">                    <span class="comment">//退出starving</span></span><br><span class="line">					delta -= mutexStarving</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//原子add操作</span></span><br><span class="line">				atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			awoke = <span class="literal">true</span></span><br><span class="line">			iter = <span class="number">0</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			old = m.state</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Acquire(unsafe.Pointer(m))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="unlock"><a href="#unlock" class="headerlink" title="unlock"></a>unlock</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Unlock unlocks m.</span></span><br><span class="line"><span class="comment">// It is a run-time error if m is not locked on entry to Unlock.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A locked Mutex is not associated with a particular goroutine.</span></span><br><span class="line"><span class="comment">// It is allowed for one goroutine to lock a Mutex and then</span></span><br><span class="line"><span class="comment">// arrange for another goroutine to unlock it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		_ = m.state</span><br><span class="line">		race.Release(unsafe.Pointer(m))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fast path: drop lock bit.</span></span><br><span class="line">	<span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">new</span> != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Outlined slow path to allow inlining the fast path.</span></span><br><span class="line">		<span class="comment">// To hide unlockSlow during tracing we skip one extra frame when tracing GoUnblock.</span></span><br><span class="line">		m.unlockSlow(<span class="built_in">new</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">unlockSlow</span><span class="params">(<span class="built_in">new</span> <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;sync: unlock of unlocked mutex&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//普通模式</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">		old := <span class="built_in">new</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="comment">// If there are no waiters or a goroutine has already</span></span><br><span class="line">			<span class="comment">// been woken or grabbed the lock, no need to wake anyone.</span></span><br><span class="line">			<span class="comment">// In starvation mode ownership is directly handed off from unlocking</span></span><br><span class="line">			<span class="comment">// goroutine to the next waiter. We are not part of this chain,</span></span><br><span class="line">			<span class="comment">// since we did not observe mutexStarving when we unlocked the mutex above.</span></span><br><span class="line">			<span class="comment">// So get off the way.</span></span><br><span class="line">			<span class="comment">//等待队列为空或者 old &amp; 111 != 0即old != 000,至少1位是1，抢到锁/被唤醒/饥饿模式下不用唤醒</span></span><br><span class="line">			<span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Grab the right to wake someone.</span></span><br><span class="line">			<span class="comment">//等待队列-1，置位mutexWoken</span></span><br><span class="line">			<span class="comment">//先更新m.state，再唤醒</span></span><br><span class="line">			<span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken</span><br><span class="line">			<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">				runtime_Semrelease(&amp;m.sema, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			old = m.state</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="comment">//饥饿模式</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Starving mode: handoff mutex ownership to the next waiter, and yield</span></span><br><span class="line">		<span class="comment">// our time slice so that the next waiter can start to run immediately.</span></span><br><span class="line">		<span class="comment">// Note: mutexLocked is not set, the waiter will set it after wakeup.</span></span><br><span class="line">		<span class="comment">// But mutex is still considered locked if mutexStarving is set,</span></span><br><span class="line">		<span class="comment">// so new coming goroutines won&#x27;t acquire it.</span></span><br><span class="line">		<span class="comment">//饥饿模式下，将所有权交给head的waiter，waiter置位mutexlock</span></span><br><span class="line">		<span class="comment">//不用更新m.state,直接唤醒</span></span><br><span class="line">		runtime_Semrelease(&amp;m.sema, <span class="literal">true</span>, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1]<a href="https://studygolang.com/articles/17017">https://studygolang.com/articles/17017</a></p>
<p>[2]<a href="https://studygolang.com/articles/25155">https://studygolang.com/articles/25155</a></p>
<p>[3]<a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/">https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>bloom filter</title>
    <url>/2020-10-24-bloom-filter/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1]<a href="https://www.wmyskxz.com/2020/03/11/redis-5-yi-ji-shu-ju-guo-lu-he-bu-long-guo-lu-qi/">https://www.wmyskxz.com/2020/03/11/redis-5-yi-ji-shu-ju-guo-lu-he-bu-long-guo-lu-qi/</a></p>
<p>[2]<a href="https://github.com/willf/bloom/blob/master/bloom.go">https://github.com/willf/bloom/blob/master/bloom.go</a></p>
<p>[3]<a href="https://blog.huoding.com/2020/06/22/825">https://blog.huoding.com/2020/06/22/825</a></p>
<p>[4]<a href="https://zhuanlan.zhihu.com/p/43263751">https://zhuanlan.zhihu.com/p/43263751</a></p>
<p>[5]<a href="http://oserror.com/backend/bloomfilter/">http://oserror.com/backend/bloomfilter/</a></p>
]]></content>
  </entry>
  <entry>
    <title>golang sync map</title>
    <url>/2020-10-26-golang-sync%20map/</url>
    <content><![CDATA[<h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Map is like a Go map[interface&#123;&#125;]interface&#123;&#125; but is safe for concurrent use</span></span><br><span class="line"><span class="comment">// by multiple goroutines without additional locking or coordination.</span></span><br><span class="line"><span class="comment">// Loads, stores, and deletes run in amortized constant time.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The Map type is specialized. Most code should use a plain Go map instead,</span></span><br><span class="line"><span class="comment">// with separate locking or coordination, for better type safety and to make it</span></span><br><span class="line"><span class="comment">// easier to maintain other invariants along with the map content.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The Map type is optimized for two common use cases: (1) when the entry for a given</span></span><br><span class="line"><span class="comment">// key is only ever written once but read many times, as in caches that only grow,</span></span><br><span class="line"><span class="comment">// or (2) when multiple goroutines read, write, and overwrite entries for disjoint</span></span><br><span class="line"><span class="comment">// sets of keys. In these two cases, use of a Map may significantly reduce lock</span></span><br><span class="line"><span class="comment">// contention compared to a Go map paired with a separate Mutex or RWMutex.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The zero Map is empty and ready for use. A Map must not be copied after first use.</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu Mutex</span><br><span class="line"></span><br><span class="line">	<span class="comment">// read contains the portion of the map&#x27;s contents that are safe for</span></span><br><span class="line">	<span class="comment">// concurrent access (with or without mu held).</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// The read field itself is always safe to load, but must only be stored with</span></span><br><span class="line">	<span class="comment">// mu held.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Entries stored in read may be updated concurrently without mu, but updating</span></span><br><span class="line">	<span class="comment">// a previously-expunged entry requires that the entry be copied to the dirty</span></span><br><span class="line">	<span class="comment">// map and unexpunged with mu held.</span></span><br><span class="line">	read atomic.Value <span class="comment">// readOnly</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// dirty contains the portion of the map&#x27;s contents that require mu to be</span></span><br><span class="line">	<span class="comment">// held. To ensure that the dirty map can be promoted to the read map quickly,</span></span><br><span class="line">	<span class="comment">// it also includes all of the non-expunged entries in the read map.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Expunged entries are not stored in the dirty map. An expunged entry in the</span></span><br><span class="line">	<span class="comment">// clean map must be unexpunged and added to the dirty map before a new value</span></span><br><span class="line">	<span class="comment">// can be stored to it.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// If the dirty map is nil, the next write to the map will initialize it by</span></span><br><span class="line">	<span class="comment">// making a shallow copy of the clean map, omitting stale entries.</span></span><br><span class="line">	dirty <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry</span><br><span class="line"></span><br><span class="line">	<span class="comment">// misses counts the number of loads since the read map was last updated that</span></span><br><span class="line">	<span class="comment">// needed to lock mu to determine whether the key was present.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Once enough misses have occurred to cover the cost of copying the dirty</span></span><br><span class="line">	<span class="comment">// map, the dirty map will be promoted to the read map (in the unamended</span></span><br><span class="line">	<span class="comment">// state) and the next store to the map will make a new dirty copy.</span></span><br><span class="line">	misses <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><h3 id="Load"><a href="#Load" class="headerlink" title="Load()"></a>Load()</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Load returns the value stored in the map for a key, or nil if no</span></span><br><span class="line"><span class="comment">// value is present.</span></span><br><span class="line"><span class="comment">// The ok result indicates whether value was found in the map.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Load</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	read, _ := m.read.Load().(readOnly)</span><br><span class="line">	e, ok := read.m[key]</span><br><span class="line">	<span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">		m.mu.Lock()</span><br><span class="line">		<span class="comment">// Avoid reporting a spurious miss if m.dirty got promoted while we were</span></span><br><span class="line">		<span class="comment">// blocked on m.mu. (If further loads of the same key will not miss, it&#x27;s</span></span><br><span class="line">		<span class="comment">// not worth copying the dirty map for this key.)</span></span><br><span class="line">		read, _ = m.read.Load().(readOnly)</span><br><span class="line">		e, ok = read.m[key]</span><br><span class="line">		<span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">			e, ok = m.dirty[key]</span><br><span class="line">			<span class="comment">// Regardless of whether the entry was present, record a miss: this key</span></span><br><span class="line">			<span class="comment">// will take the slow path until the dirty map is promoted to the read</span></span><br><span class="line">			<span class="comment">// map.</span></span><br><span class="line">			m.missLocked()</span><br><span class="line">		&#125;</span><br><span class="line">		m.mu.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> e.load()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="note"><a href="#note" class="headerlink" title="note"></a>note</h4><ul>
<li>先从read查，查到就直接返回。查不到并且<code>read.amended=true(dirty!=read)</code>再去dirty中查，查dirty要加互斥锁。</li>
<li>这里用到了两次查询，参考单例的设计。</li>
<li>read是<code>atomic.value</code>类型的，atomic.value的<code>Load/Store</code>是线程安全的，所以不用加锁，读性能比较好。但是其实也用到了<code>cas</code>,所以也用到了lock指令，不是完全无锁定的。</li>
</ul>
<h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu     sync.Mutex</span><br><span class="line">	read   atomic.Value <span class="comment">// readOnly</span></span><br><span class="line">	dirty  <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*<span class="keyword">int</span></span><br><span class="line">	misses <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> readOnly <span class="keyword">struct</span> &#123;</span><br><span class="line">	m       <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*<span class="keyword">int</span></span><br><span class="line">	amended <span class="keyword">bool</span> <span class="comment">// true if the dirty map contains some key not in m.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := Map&#123;&#125;</span><br><span class="line">	<span class="comment">//fmt.Println(m.read.Load().(readOnly))		//panic</span></span><br><span class="line">	fmt.Println(m.read.Load()) <span class="comment">//&lt;nil&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> v <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	read, _ := (v).(readOnly)</span><br><span class="line">	fmt.Println(read)	<span class="comment">//&#123;map[] false&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Store"><a href="#Store" class="headerlink" title="Store()"></a>Store()</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Store sets the value for a key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Store</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	read, _ := m.read.Load().(readOnly)</span><br><span class="line">	<span class="comment">//先从read读，读成功再尝试store更新</span></span><br><span class="line">	<span class="comment">//tryStore先load,如果标记为expunged则ret false, ow store</span></span><br><span class="line">	<span class="keyword">if</span> e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//read读不到则store到dirty，要加锁</span></span><br><span class="line">	m.mu.Lock()</span><br><span class="line">	read, _ = m.read.Load().(readOnly)</span><br><span class="line">	<span class="comment">//两次读，第2次读到了</span></span><br><span class="line">	<span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">		<span class="comment">//unexpungeLocked：如果e.p=expunged，则set e.p=nil</span></span><br><span class="line">		<span class="keyword">if</span> e.unexpungeLocked() &#123;</span><br><span class="line">			<span class="comment">// The entry was previously expunged, which implies that there is a</span></span><br><span class="line">			<span class="comment">// non-nil dirty map and this entry is not in it.</span></span><br><span class="line">			m.dirty[key] = e</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//atomic.StorePointer 更新entry</span></span><br><span class="line">		e.storeLocked(&amp;value)</span><br><span class="line">	<span class="comment">//dirty中有，则更新</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123;</span><br><span class="line">		e.storeLocked(&amp;value)</span><br><span class="line">	<span class="comment">//read/dirty都没有</span></span><br><span class="line">	<span class="comment">//新增数据</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//并且read.amended=0</span></span><br><span class="line">		<span class="keyword">if</span> !read.amended &#123;</span><br><span class="line">			<span class="comment">// We&#x27;re adding the first new key to the dirty map.</span></span><br><span class="line">			<span class="comment">// Make sure it is allocated and mark the read-only map as incomplete.</span></span><br><span class="line">			<span class="comment">//如果dirty=nil,则把read(未删除的)拷贝给dirty</span></span><br><span class="line">			<span class="comment">//初始化后第一次store会进入这里，或者misscount&gt;=len(dirty)也会进来重新刷新dirty.</span></span><br><span class="line">			m.dirtyLocked()</span><br><span class="line">			<span class="comment">//更新了amended</span></span><br><span class="line">			m.read.Store(readOnly&#123;m: read.m, amended: <span class="literal">true</span>&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//新增entry并加到dirty</span></span><br><span class="line">		m.dirty[key] = newEntry(value)</span><br><span class="line">	&#125;</span><br><span class="line">	m.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="note-1"><a href="#note-1" class="headerlink" title="note"></a>note</h4><ul>
<li>任何值可以赋值给空接口的值，空接口的值也可以赋值给任何值</li>
<li>第一次新增和misscount达到限制都会刷新dirty(吧read赋值给dirty,如果read为空，这一步就提前ret)</li>
<li>store包含了更新和新增</li>
<li>这里加锁是给m.dirty加锁，加锁是内核的调度器执行的主要用于大的复合对象/临界区，原子操作是硬件指令主要针对单个值</li>
<li>(新增元素或者刷新dirty的时候)tryExpungeLocked将nil的标记为已删除expunged，新增entry的时候read如果能读到，unexpungeLocked对于expunged又改为nil并更新dirty</li>
</ul>
<h4 id="demo-1"><a href="#demo-1" class="headerlink" title="demo"></a>demo</h4><h3 id="missLocked"><a href="#missLocked" class="headerlink" title="missLocked"></a>missLocked</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">missLocked</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m.misses++</span><br><span class="line">	<span class="keyword">if</span> m.misses &lt; <span class="built_in">len</span>(m.dirty) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	m.read.Store(readOnly&#123;m: m.dirty&#125;)</span><br><span class="line">	m.dirty = <span class="literal">nil</span></span><br><span class="line">	m.misses = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LoadOrStore"><a href="#LoadOrStore" class="headerlink" title="LoadOrStore"></a>LoadOrStore</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// LoadOrStore returns the existing value for the key if present.</span></span><br><span class="line"><span class="comment">// Otherwise, it stores and returns the given value.</span></span><br><span class="line"><span class="comment">// The loaded result is true if the value was loaded, false if stored.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">LoadOrStore</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(actual <span class="keyword">interface</span>&#123;&#125;, loaded <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Avoid locking if it&#x27;s a clean hit.</span></span><br><span class="line">	read, _ := m.read.Load().(readOnly)</span><br><span class="line">	<span class="comment">//如果read里面有</span></span><br><span class="line">	<span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">		<span class="comment">//tryLoadOrStore逻辑：</span></span><br><span class="line">		<span class="comment">//tryLoadOrStore:先load</span></span><br><span class="line">		<span class="comment">//if e.p=expunged, ret nil, false, false</span></span><br><span class="line">		<span class="comment">//if e.p=nil, 返回原来的值，true, true</span></span><br><span class="line">		<span class="comment">//else store，return value, false, true</span></span><br><span class="line">		actual, loaded, ok := e.tryLoadOrStore(value)</span><br><span class="line">		<span class="keyword">if</span> ok &#123;</span><br><span class="line">			<span class="keyword">return</span> actual, loaded</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果read读到了，并且e.p=expunged,则往下执行，走dirty</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m.mu.Lock()</span><br><span class="line">	read, _ = m.read.Load().(readOnly)</span><br><span class="line">	<span class="comment">//如果从read读到</span></span><br><span class="line">	<span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">		<span class="comment">//unexpungeLocked: return atomic.CompareAndSwapPointer(&amp;e.p, expunged, nil)</span></span><br><span class="line">		<span class="keyword">if</span> e.unexpungeLocked() &#123;</span><br><span class="line">		<span class="comment">//If the entry was previously expunged, it must be added to the dirty map</span></span><br><span class="line">		<span class="comment">//before m.mu is unlocked.</span></span><br><span class="line">			m.dirty[key] = e</span><br><span class="line">		&#125;</span><br><span class="line">		actual, loaded, _ = e.tryLoadOrStore(value)</span><br><span class="line">	<span class="comment">//如果从dirty读到</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123;</span><br><span class="line">		actual, loaded, _ = e.tryLoadOrStore(value)</span><br><span class="line">		m.missLocked()</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !read.amended &#123;</span><br><span class="line">			<span class="comment">// We&#x27;re adding the first new key to the dirty map.</span></span><br><span class="line">			<span class="comment">// Make sure it is allocated and mark the read-only map as incomplete.</span></span><br><span class="line">			m.dirtyLocked()</span><br><span class="line">			m.read.Store(readOnly&#123;m: read.m, amended: <span class="literal">true</span>&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">		m.dirty[key] = newEntry(value)</span><br><span class="line">		actual, loaded = value, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	m.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> actual, loaded</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="note-2"><a href="#note-2" class="headerlink" title="note"></a>note</h4><p>load和store的结合体，不赘述</p>
<h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Delete deletes the value for a key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Delete</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	m.LoadAndDelete(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="LoadAndDelete"><a href="#LoadAndDelete" class="headerlink" title="LoadAndDelete"></a>LoadAndDelete</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LoadAndDelete deletes the value for a key, returning the previous value if any.</span></span><br><span class="line"><span class="comment">// The loaded result reports whether the key was present.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">LoadAndDelete</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, loaded <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	read, _ := m.read.Load().(readOnly)</span><br><span class="line">	e, ok := read.m[key]</span><br><span class="line">	<span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">		m.mu.Lock()</span><br><span class="line">		read, _ = m.read.Load().(readOnly)</span><br><span class="line">		e, ok = read.m[key]</span><br><span class="line">		<span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">			e, ok = m.dirty[key]</span><br><span class="line">			<span class="built_in">delete</span>(m.dirty, key)</span><br><span class="line">			<span class="comment">// Regardless of whether the entry was present, record a miss: this key</span></span><br><span class="line">			<span class="comment">// will take the slow path until the dirty map is promoted to the read</span></span><br><span class="line">			<span class="comment">// map.</span></span><br><span class="line">			m.missLocked()</span><br><span class="line">		&#125;</span><br><span class="line">		m.mu.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		<span class="comment">//if e.p=nil/expunged,ret</span></span><br><span class="line">		<span class="comment">//else set e.p = nil</span></span><br><span class="line">		<span class="keyword">return</span> e.<span class="built_in">delete</span>()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="note-3"><a href="#note-3" class="headerlink" title="note"></a>note</h4><ul>
<li>如果read中找到了，直接在read标记删除，否则才去找dirty</li>
<li>read的删除，对于nil/expunged直接ret,不然标记为nil</li>
<li>dirty的删除，才是真的删除</li>
<li>删除dirty也会使misscount+1</li>
</ul>
<h3 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Range calls f sequentially for each key and value present in the map.</span></span><br><span class="line"><span class="comment">// If f returns false, range stops the iteration.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Range does not necessarily correspond to any consistent snapshot of the Map&#x27;s</span></span><br><span class="line"><span class="comment">// contents: no key will be visited more than once, but if the value for any key</span></span><br><span class="line"><span class="comment">// is stored or deleted concurrently, Range may reflect any mapping for that key</span></span><br><span class="line"><span class="comment">// from any point during the Range call.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Range may be O(N) with the number of elements in the map even if f returns</span></span><br><span class="line"><span class="comment">// false after a constant number of calls.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Range</span><span class="params">(f <span class="keyword">func</span>(key, value <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// We need to be able to iterate over all of the keys that were already</span></span><br><span class="line">	<span class="comment">// present at the start of the call to Range.</span></span><br><span class="line">	<span class="comment">// If read.amended is false, then read.m satisfies that property without</span></span><br><span class="line">	<span class="comment">// requiring us to hold m.mu for a long time.</span></span><br><span class="line">	read, _ := m.read.Load().(readOnly)</span><br><span class="line">	<span class="keyword">if</span> read.amended &#123;</span><br><span class="line">		<span class="comment">// m.dirty contains keys not in read.m. Fortunately, Range is already O(N)</span></span><br><span class="line">		<span class="comment">// (assuming the caller does not break out early), so a call to Range</span></span><br><span class="line">		<span class="comment">// amortizes an entire copy of the map: we can promote the dirty copy</span></span><br><span class="line">		<span class="comment">// immediately!</span></span><br><span class="line">		m.mu.Lock()</span><br><span class="line">		read, _ = m.read.Load().(readOnly)</span><br><span class="line">		<span class="keyword">if</span> read.amended &#123;</span><br><span class="line">			<span class="comment">//如果dirty有新数据，则先同步到read在range</span></span><br><span class="line">			read = readOnly&#123;m: m.dirty&#125;</span><br><span class="line">			m.read.Store(read)</span><br><span class="line">			m.dirty = <span class="literal">nil</span></span><br><span class="line">			m.misses = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		m.mu.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line">		v, ok := e.load()</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !f(k, v) &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dirtyLocked"><a href="#dirtyLocked" class="headerlink" title="dirtyLocked"></a>dirtyLocked</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">dirtyLocked</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> m.dirty != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	read, _ := m.read.Load().(readOnly)</span><br><span class="line">	m.dirty = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry, <span class="built_in">len</span>(read.m))</span><br><span class="line">	<span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line">		<span class="keyword">if</span> !e.tryExpungeLocked() &#123;</span><br><span class="line">			m.dirty[k] = e</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// An entry is a slot in the map corresponding to a particular key.</span></span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// p points to the interface&#123;&#125; value stored for the entry.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// If p == nil, the entry has been deleted and m.dirty == nil.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// If p == expunged, the entry has been deleted, m.dirty != nil, and the entry</span></span><br><span class="line">	<span class="comment">// is missing from m.dirty.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Otherwise, the entry is valid and recorded in m.read.m[key] and, if m.dirty</span></span><br><span class="line">	<span class="comment">// != nil, in m.dirty[key].</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// An entry can be deleted by atomic replacement with nil: when m.dirty is</span></span><br><span class="line">	<span class="comment">// next created, it will atomically replace nil with expunged and leave</span></span><br><span class="line">	<span class="comment">// m.dirty[key] unset.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// An entry&#x27;s associated value can be updated by atomic replacement, provided</span></span><br><span class="line">	<span class="comment">// p != expunged. If p == expunged, an entry&#x27;s associated value can be updated</span></span><br><span class="line">	<span class="comment">// only after first setting m.dirty[key] = e so that lookups using the dirty</span></span><br><span class="line">	<span class="comment">// map find the entry.</span></span><br><span class="line">	p unsafe.Pointer <span class="comment">// *interface&#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tryStore"><a href="#tryStore" class="headerlink" title="tryStore"></a>tryStore</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tryStore stores a value if the entry has not been expunged.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If the entry is expunged, tryStore returns false and leaves the entry</span></span><br><span class="line"><span class="comment">// unchanged.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">tryStore</span><span class="params">(i *<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">		<span class="keyword">if</span> p == expunged &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, p, unsafe.Pointer(i)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unexpungeLocked"><a href="#unexpungeLocked" class="headerlink" title="unexpungeLocked"></a>unexpungeLocked</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// unexpungeLocked ensures that the entry is not marked as expunged.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If the entry was previously expunged, it must be added to the dirty map</span></span><br><span class="line"><span class="comment">// before m.mu is unlocked.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">unexpungeLocked</span><span class="params">()</span> <span class="params">(wasExpunged <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> atomic.CompareAndSwapPointer(&amp;e.p, expunged, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="storeLocked"><a href="#storeLocked" class="headerlink" title="storeLocked"></a>storeLocked</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// storeLocked unconditionally stores a value to the entry.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The entry must be known not to be expunged.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">storeLocked</span><span class="params">(i *<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	atomic.StorePointer(&amp;e.p, unsafe.Pointer(i))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tryLoadOrStore"><a href="#tryLoadOrStore" class="headerlink" title="tryLoadOrStore"></a>tryLoadOrStore</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tryLoadOrStore atomically loads or stores a value if the entry is not</span></span><br><span class="line"><span class="comment">// expunged.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If the entry is expunged, tryLoadOrStore leaves the entry unchanged and</span></span><br><span class="line"><span class="comment">// returns with ok==false.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">tryLoadOrStore</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(actual <span class="keyword">interface</span>&#123;&#125;, loaded, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">	<span class="keyword">if</span> p == expunged &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> *(*<span class="keyword">interface</span>&#123;&#125;)(p), <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Copy the interface after the first load to make this method more amenable</span></span><br><span class="line">	<span class="comment">// to escape analysis: if we hit the &quot;load&quot; path or the entry is expunged, we</span></span><br><span class="line">	<span class="comment">// shouldn&#x27;t bother heap-allocating.</span></span><br><span class="line">	ic := i</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, <span class="literal">nil</span>, unsafe.Pointer(&amp;ic)) &#123;</span><br><span class="line">			<span class="keyword">return</span> i, <span class="literal">false</span>, <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		p = atomic.LoadPointer(&amp;e.p)</span><br><span class="line">		<span class="keyword">if</span> p == expunged &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> *(*<span class="keyword">interface</span>&#123;&#125;)(p), <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">delete</span><span class="params">()</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">		<span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, p, <span class="literal">nil</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> *(*<span class="keyword">interface</span>&#123;&#125;)(p), <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tryExpungeLocked"><a href="#tryExpungeLocked" class="headerlink" title="tryExpungeLocked"></a>tryExpungeLocked</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">tryExpungeLocked</span><span class="params">()</span> <span class="params">(isExpunged <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">	<span class="keyword">for</span> p == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, <span class="literal">nil</span>, expunged) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		p = atomic.LoadPointer(&amp;e.p)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p == expunged</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>misscount达到阈值，将dirty刷回read,set dirty=nil</li>
<li>新增元素的时候(区别与修改)，如果amend=false,则将read刷回dirty</li>
</ul>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1]<a href="https://colobu.com/2017/07/11/dive-into-sync-Map/">https://colobu.com/2017/07/11/dive-into-sync-Map/</a></p>
<p>[2]<a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/">https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/</a></p>
<p>[3]<a href="https://juejin.im/post/6844903895227957262">https://juejin.im/post/6844903895227957262</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang concurrent map</title>
    <url>/2020-10-27-golang%20concurrent-map/</url>
    <content><![CDATA[<p>本文是对github上<a href="https://github.com/orcaman/concurrent-map">https://github.com/orcaman/concurrent-map</a>此rep的一点学习记录。</p>
<a id="more"></a>

<h2 id="官方demo"><a href="#官方demo" class="headerlink" title="官方demo"></a>官方demo</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">	cmap <span class="string">&quot;github.com/orcaman/concurrent-map&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Create a new map.</span></span><br><span class="line">	m := cmap.New()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Sets item within map, sets &quot;bar&quot; under key &quot;foo&quot;</span></span><br><span class="line">	m.Set(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Retrieve item from map.</span></span><br><span class="line">	<span class="keyword">if</span> tmp, ok := m.Get(<span class="string">&quot;foo&quot;</span>); ok &#123;</span><br><span class="line">		fmt.Println(tmp)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Removes item under key &quot;foo&quot;</span></span><br><span class="line">	m.Remove(<span class="string">&quot;foo&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> SHARD_COUNT = <span class="number">32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A &quot;thread&quot; safe map of type string:Anything.</span></span><br><span class="line"><span class="comment">// To avoid lock bottlenecks this map is dived to several (SHARD_COUNT) map shards.</span></span><br><span class="line"><span class="keyword">type</span> ConcurrentMap []*ConcurrentMapShared</span><br><span class="line"></span><br><span class="line"><span class="comment">// A &quot;thread&quot; safe string to anything map.</span></span><br><span class="line"><span class="keyword">type</span> ConcurrentMapShared <span class="keyword">struct</span> &#123;</span><br><span class="line">	items        <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	sync.RWMutex <span class="comment">// Read Write mutex, guards access to internal map.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="New"><a href="#New" class="headerlink" title="New"></a>New</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Creates a new concurrent map.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="title">ConcurrentMap</span></span> &#123;</span><br><span class="line">	m := <span class="built_in">make</span>(ConcurrentMap, SHARD_COUNT)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; SHARD_COUNT; i++ &#123;</span><br><span class="line">		m[i] = &amp;ConcurrentMapShared&#123;items: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GetShard"><a href="#GetShard" class="headerlink" title="GetShard"></a>GetShard</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; GetShard returns shard under given key</span><br><span class="line">func (m ConcurrentMap) GetShard(key string) *ConcurrentMapShared &#123;</span><br><span class="line">	return m[uint(fnv32(key))%uint(SHARD_COUNT)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sets the given value under the specified key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m ConcurrentMap)</span> <span class="title">Set</span><span class="params">(key <span class="keyword">string</span>, value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Get map shard.</span></span><br><span class="line">	shard := m.GetShard(key)</span><br><span class="line">	shard.Lock()</span><br><span class="line">	shard.items[key] = value</span><br><span class="line">	shard.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Get retrieves an element from map under given key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m ConcurrentMap)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Get shard</span></span><br><span class="line">	shard := m.GetShard(key)</span><br><span class="line">	shard.RLock()</span><br><span class="line">	<span class="comment">// Get item from shard.</span></span><br><span class="line">	val, ok := shard.items[key]</span><br><span class="line">	shard.RUnlock()</span><br><span class="line">	<span class="keyword">return</span> val, ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>就是原生map+rwmutex的细化，这里分了32个map,通过hash落在一个map加锁，锁的粒度更小了，从而提升并发性能</li>
<li>主要函数就这几个，其他函数基本基于这个原则</li>
<li>sync.map主要针对读多写少的场景，写的时候会加mutex，并且可能刷新dirty，读的时候因为是atomic.value性能会好</li>
<li>concurrent map比较综合吧，更细粒度的锁对缓存数据库更友好</li>
</ul>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang atomic.value</title>
    <url>/2020-10-27-golang-atomic-value/</url>
    <content><![CDATA[<p>Package atomic provides low-level atomic memory primitives useful for implementing synchronization algorithms.</p>
<p>These functions require great care to be used correctly. Except for special, low-level applications, synchronization is better done with channels or the facilities of the sync package. Share memory by communicating; don’t communicate by sharing memory.</p>
<a id="more"></a>

<h2 id="atomic-value"><a href="#atomic-value" class="headerlink" title="atomic.value"></a>atomic.value</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// A Value provides an atomic load and store of a consistently typed value.</span></span><br><span class="line"><span class="comment">// The zero value for a Value returns nil from Load.</span></span><br><span class="line"><span class="comment">// Once Store has been called, a Value must not be copied.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A Value must not be copied after first use.</span></span><br><span class="line"><span class="keyword">type</span> Value <span class="keyword">struct</span> &#123;</span><br><span class="line">	v <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Load returns the value set by the most recent Store.</span></span><br><span class="line"><span class="comment">// It returns nil if there has been no call to Store for this Value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Value)</span> <span class="title">Load</span><span class="params">()</span> <span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	vp := (*ifaceWords)(unsafe.Pointer(v))</span><br><span class="line">	typ := LoadPointer(&amp;vp.typ)</span><br><span class="line">	<span class="keyword">if</span> typ == <span class="literal">nil</span> || <span class="keyword">uintptr</span>(typ) == ^<span class="keyword">uintptr</span>(<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// First store not yet completed.</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	data := LoadPointer(&amp;vp.data)</span><br><span class="line">	xp := (*ifaceWords)(unsafe.Pointer(&amp;x))</span><br><span class="line">	xp.typ = typ</span><br><span class="line">	xp.data = data</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ifaceWords is interface&#123;&#125; internal representation.</span></span><br><span class="line"><span class="keyword">type</span> ifaceWords <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ  unsafe.Pointer</span><br><span class="line">	data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Store sets the value of the Value to x.</span></span><br><span class="line"><span class="comment">// All calls to Store for a given Value must use values of the same concrete type.</span></span><br><span class="line"><span class="comment">// Store of an inconsistent type panics, as does Store(nil).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Value)</span> <span class="title">Store</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;sync/atomic: store of nil value into Value&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	vp := (*ifaceWords)(unsafe.Pointer(v))  <span class="comment">//old value,类型一致，只改data</span></span><br><span class="line">	xp := (*ifaceWords)(unsafe.Pointer(&amp;x)) <span class="comment">//new value</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">//原子读</span></span><br><span class="line">        typ := LoadPointer(&amp;vp.typ)</span><br><span class="line">        <span class="comment">//case1 nil</span></span><br><span class="line">		<span class="keyword">if</span> typ == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// Attempt to start first store.</span></span><br><span class="line">			<span class="comment">// Disable preemption so that other goroutines can use</span></span><br><span class="line">			<span class="comment">// active spin wait to wait for completion; and so that</span></span><br><span class="line">			<span class="comment">// GC does not see the fake type accidentally.</span></span><br><span class="line">            runtime_procPin()</span><br><span class="line">            <span class="comment">//set 中间值</span></span><br><span class="line">			<span class="keyword">if</span> !CompareAndSwapPointer(&amp;vp.typ, <span class="literal">nil</span>, unsafe.Pointer(^<span class="keyword">uintptr</span>(<span class="number">0</span>))) &#123;</span><br><span class="line">				runtime_procUnpin()</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">// Complete first store.</span></span><br><span class="line">            <span class="comment">//第一次存储，既要更新data,还要更新type，这里的type作为实际的类型</span></span><br><span class="line">			StorePointer(&amp;vp.data, xp.data)</span><br><span class="line">			StorePointer(&amp;vp.typ, xp.typ)</span><br><span class="line">			runtime_procUnpin()</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//case2 ^uintptr(0)</span></span><br><span class="line">        <span class="comment">//第一阶段未完成,typ作为是否完成的标记</span></span><br><span class="line">        <span class="comment">//第一阶段未完成，为什么会走下来？是异步的还是并发情况？</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">uintptr</span>(typ) == ^<span class="keyword">uintptr</span>(<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">// First store in progress. Wait.</span></span><br><span class="line">			<span class="comment">// Since we disable preemption around the first store,</span></span><br><span class="line">			<span class="comment">// we can wait with active spinning.</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// First store completed. Check type and overwrite data.</span></span><br><span class="line">        <span class="comment">//case3 类型不符</span></span><br><span class="line">		<span class="keyword">if</span> typ != xp.typ &#123;</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">&quot;sync/atomic: store of inconsistently typed value into Value&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		StorePointer(&amp;vp.data, xp.data)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>ifaceWords是interface的抽象，函数参数就是interface</li>
<li>^uintptr(0)作为一个中间值，用来保证原子性，读和写都会判断</li>
<li>Load()只是将value转换成ifaceWords类型并返回</li>
<li>runtime_procPin涉及调度，作为todo以后看到调度的部分了再补充</li>
<li>atomic是原子的，针对小的操作，保证不可中断。mutex是操作系统实现，通过原子性的判断锁标记来隔离其他进程/线程访问大的临界区，临界区内可中断。</li>
</ul>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1]<a href="https://blog.betacat.io/post/golang-atomic-value-exploration/">https://blog.betacat.io/post/golang-atomic-value-exploration/</a></p>
<p>[2]<a href="https://mp.weixin.qq.com/s/re_9CmGm3xEbY7xCr5CYbQ">https://mp.weixin.qq.com/s/re_9CmGm3xEbY7xCr5CYbQ</a></p>
<p>[3]<a href="https://www.quora.com/What-is-the-difference-between-Mutex-and-Atomic-Operation">https://www.quora.com/What-is-the-difference-between-Mutex-and-Atomic-Operation</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang sync WaitGroup</title>
    <url>/2020-10-28-golang%20sync-WaitGroup/</url>
    <content><![CDATA[<p>官方的demo演示如下，做了点小改动</p>
<a id="more"></a>

<h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> httpPkg <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(httpPkg)</span> <span class="title">Get</span><span class="params">(url <span class="keyword">string</span>, i <span class="keyword">int</span>)</span></span> &#123; fmt.Println(i) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> http httpPkg</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">var</span> urls = []<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;http://www.golang.org/&quot;</span>,</span><br><span class="line">		<span class="string">&quot;http://www.google.com/&quot;</span>,</span><br><span class="line">		<span class="string">&quot;http://www.somestupidname.com/&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, url := <span class="keyword">range</span> urls &#123;</span><br><span class="line">		<span class="comment">// Increment the WaitGroup counter.</span></span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="comment">// Launch a goroutine to fetch the URL.</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(url <span class="keyword">string</span>, i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="comment">// Decrement the counter when the goroutine completes.</span></span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			<span class="comment">// Fetch the URL.</span></span><br><span class="line">			http.Get(url, i)</span><br><span class="line">		&#125;(url, i)</span><br><span class="line">		i += <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Wait for all HTTP fetches to complete.</span></span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>output:</p>
<pre><code>2
0
1</code></pre>
<hr>
<h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A WaitGroup waits for a collection of goroutines to finish.</span></span><br><span class="line"><span class="comment">// The main goroutine calls Add to set the number of</span></span><br><span class="line"><span class="comment">// goroutines to wait for. Then each of the goroutines</span></span><br><span class="line"><span class="comment">// runs and calls Done when finished. At the same time,</span></span><br><span class="line"><span class="comment">// Wait can be used to block until all goroutines have finished.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A WaitGroup must not be copied after first use.</span></span><br><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">	noCopy noCopy</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 64-bit value: high 32 bits are counter, low 32 bits are waiter count.</span></span><br><span class="line">	<span class="comment">// 64-bit atomic operations require 64-bit alignment, but 32-bit</span></span><br><span class="line">	<span class="comment">// compilers do not ensure it. So we allocate 12 bytes and then use</span></span><br><span class="line">	<span class="comment">// the aligned 8 bytes in them as state, and the other 4 as storage</span></span><br><span class="line">	<span class="comment">// for the sema.</span></span><br><span class="line">	state1 [<span class="number">3</span>]<span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用[3]uint32保证在32/64位系统下都是12字节，然后4位保存计数，4位保存等待计数，4位保存sema.64位系统的原子操作是保证8个字节对齐的，32位不能保证。所以用此判断区别32/64位系统。</p>
<h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// state returns pointers to the state and sema fields stored within wg.state1.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">state</span><span class="params">()</span> <span class="params">(statep *<span class="keyword">uint64</span>, semap *<span class="keyword">uint32</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//64 bit state1[0]=count, state1[1]=wait, state1[2]=sema</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;wg.state1))%<span class="number">8</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (*<span class="keyword">uint64</span>)(unsafe.Pointer(&amp;wg.state1)), &amp;wg.state1[<span class="number">2</span>]</span><br><span class="line">    <span class="comment">//32 bit state1[0]=sema, state1[1]=count, state1[2]=wait</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (*<span class="keyword">uint64</span>)(unsafe.Pointer(&amp;wg.state1[<span class="number">1</span>])), &amp;wg.state1[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回32/64位系统中count和sema的地址</p>
<h3 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Add adds delta, which may be negative, to the WaitGroup counter.</span></span><br><span class="line"><span class="comment">// If the counter becomes zero, all goroutines blocked on Wait are released.</span></span><br><span class="line"><span class="comment">// If the counter goes negative, Add panics.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Note that calls with a positive delta that occur when the counter is zero</span></span><br><span class="line"><span class="comment">// must happen before a Wait. Calls with a negative delta, or calls with a</span></span><br><span class="line"><span class="comment">// positive delta that start when the counter is greater than zero, may happen</span></span><br><span class="line"><span class="comment">// at any time.</span></span><br><span class="line"><span class="comment">// Typically this means the calls to Add should execute before the statement</span></span><br><span class="line"><span class="comment">// creating the goroutine or other event to be waited for.</span></span><br><span class="line"><span class="comment">// If a WaitGroup is reused to wait for several independent sets of events,</span></span><br><span class="line"><span class="comment">// new Add calls must happen after all previous Wait calls have returned.</span></span><br><span class="line"><span class="comment">// See the WaitGroup example.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Add</span><span class="params">(delta <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	statep, semap := wg.state()</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		_ = *statep <span class="comment">// trigger nil deref early</span></span><br><span class="line">		<span class="keyword">if</span> delta &lt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// Synchronize decrements with Wait.</span></span><br><span class="line">			race.ReleaseMerge(unsafe.Pointer(wg))</span><br><span class="line">		&#125;</span><br><span class="line">		race.Disable()</span><br><span class="line">		<span class="keyword">defer</span> race.Enable()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计数器是4字节的，这里用uint64存的数也只能是4字节大小，然后左移32位加给计数器</span></span><br><span class="line">    state := atomic.AddUint64(statep, <span class="keyword">uint64</span>(delta)&lt;&lt;<span class="number">32</span>)</span><br><span class="line">    <span class="comment">//算出计数器的实际值</span></span><br><span class="line">    v := <span class="keyword">int32</span>(state &gt;&gt; <span class="number">32</span>)</span><br><span class="line">    <span class="comment">//截断成32位，表示waiter</span></span><br><span class="line">	w := <span class="keyword">uint32</span>(state)</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &amp;&amp; delta &gt; <span class="number">0</span> &amp;&amp; v == <span class="keyword">int32</span>(delta) &#123;</span><br><span class="line">		<span class="comment">// The first increment must be synchronized with Wait.</span></span><br><span class="line">		<span class="comment">// Need to model this as a read, because there can be</span></span><br><span class="line">		<span class="comment">// several concurrent wg.counter transitions from 0.</span></span><br><span class="line">		race.Read(unsafe.Pointer(semap))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计数器小于0报错</span></span><br><span class="line">	<span class="keyword">if</span> v &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;sync: negative WaitGroup counter&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//已经有goroutine在wait,且计数器等于0，就不能再add一个正数</span></span><br><span class="line">    <span class="comment">//应该是计数器=0，正要唤醒wait的g,这时候就不要再add了，并发安全</span></span><br><span class="line">	<span class="keyword">if</span> w != <span class="number">0</span> &amp;&amp; delta &gt; <span class="number">0</span> &amp;&amp; v == <span class="keyword">int32</span>(delta) &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;sync: WaitGroup misuse: Add called concurrently with Wait&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> v &gt; <span class="number">0</span> || w == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//说明 v =0 &amp;&amp; w &gt; 0,需要唤醒所有waiter</span></span><br><span class="line">	<span class="comment">// This goroutine has set counter to 0 when waiters &gt; 0.</span></span><br><span class="line">	<span class="comment">// Now there can&#x27;t be concurrent mutations(变动) of state:</span></span><br><span class="line">	<span class="comment">// - Adds must not happen concurrently with Wait,</span></span><br><span class="line">	<span class="comment">// - Wait does not increment waiters if it sees counter == 0.</span></span><br><span class="line">	<span class="comment">// Still do a cheap sanity(合理) check to detect WaitGroup misuse(滥用).</span></span><br><span class="line">	<span class="keyword">if</span> *statep != state &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;sync: WaitGroup misuse: Add called concurrently with Wait&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Reset waiters count to 0.</span></span><br><span class="line">	*statep = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> ; w != <span class="number">0</span>; w-- &#123;</span><br><span class="line">        <span class="comment">//逐个唤醒</span></span><br><span class="line">		runtime_Semrelease(semap, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Done"><a href="#Done" class="headerlink" title="Done"></a>Done</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Done decrements the WaitGroup counter by one.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Done</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg.Add(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Wait"><a href="#Wait" class="headerlink" title="Wait"></a>Wait</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Wait blocks until the WaitGroup counter is zero.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Wait</span><span class="params">()</span></span> &#123;</span><br><span class="line">	statep, semap := wg.state()</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		_ = *statep <span class="comment">// trigger nil deref early</span></span><br><span class="line">		race.Disable()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">//同上</span></span><br><span class="line">		state := atomic.LoadUint64(statep)</span><br><span class="line">		v := <span class="keyword">int32</span>(state &gt;&gt; <span class="number">32</span>)</span><br><span class="line">		w := <span class="keyword">uint32</span>(state)</span><br><span class="line">		<span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// Counter is 0, no need to wait.</span></span><br><span class="line">			<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">				race.Enable()</span><br><span class="line">				race.Acquire(unsafe.Pointer(wg))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//=0就不用阻塞了</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Increment waiters count.</span></span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapUint64(statep, state, state+<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> race.Enabled &amp;&amp; w == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// Wait must be synchronized with the first Add.</span></span><br><span class="line">				<span class="comment">// Need to model this is as a write to race with the read in Add.</span></span><br><span class="line">				<span class="comment">// As a consequence, can do the write only for the first waiter,</span></span><br><span class="line">				<span class="comment">// otherwise concurrent Waits will race with each other.</span></span><br><span class="line">				race.Write(unsafe.Pointer(semap))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//阻塞</span></span><br><span class="line">			runtime_Semacquire(semap)</span><br><span class="line">			<span class="keyword">if</span> *statep != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="built_in">panic</span>(<span class="string">&quot;sync: WaitGroup is reused before previous Wait has returned&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">				race.Enable()</span><br><span class="line">				race.Acquire(unsafe.Pointer(wg))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>waitegroup主要用来做wait,等待一组goroutine结束。手动通过channel也能实现。这是抽象好的易用的形式，而且是用Semacquire实现的(另行总结)</li>
<li>add用来给计数器做增减，done就是add(-1).wait给waiter+1然后阻塞，计数器=0的时候唤醒所有waiter.</li>
<li>实现上有特色的就是位操作，虽然能看懂。但是这样搞的实际价值以及动机还是有点模糊。</li>
<li>go语言函数参数都是值传递，所以waitgroup作为参数的时候要传递地址，不然就出问题了，来个demo测下</li>
</ul>
<h3 id="WaitGroup值传递"><a href="#WaitGroup值传递" class="headerlink" title="WaitGroup值传递"></a>WaitGroup值传递</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> httpPkg <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(httpPkg)</span> <span class="title">Get</span><span class="params">(url <span class="keyword">string</span>, i <span class="keyword">int</span>)</span></span> &#123; fmt.Println(i) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> http httpPkg</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(wg sync.WaitGroup, url <span class="keyword">string</span>, i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	http.Get(url, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">var</span> urls = []<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;http://www.golang.org/&quot;</span>,</span><br><span class="line">		<span class="string">&quot;http://www.google.com/&quot;</span>,</span><br><span class="line">		<span class="string">&quot;http://www.somestupidname.com/&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, url := <span class="keyword">range</span> urls &#123;</span><br><span class="line">		<span class="comment">// Increment the WaitGroup counter.</span></span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="comment">// Launch a goroutine to fetch the URL.</span></span><br><span class="line">		<span class="comment">// go func(url string, i int) &#123;</span></span><br><span class="line">		<span class="comment">// 	// Decrement the counter when the goroutine completes.</span></span><br><span class="line">		<span class="comment">// 	defer wg.Done()</span></span><br><span class="line">		<span class="comment">// 	// Fetch the URL.</span></span><br><span class="line">		<span class="comment">// 	http.Get(url, i)</span></span><br><span class="line">		<span class="comment">// &#125;(url, i)</span></span><br><span class="line">		<span class="keyword">go</span> test(wg, url, i)</span><br><span class="line">		i += <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Wait for all HTTP fetches to complete.</span></span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>output:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [semacquire]:</span><br><span class="line">sync.runtime_Semacquire(<span class="number">0xc000016088</span>)</span><br><span class="line">        /usr/local/Cellar/<span class="keyword">go</span>/<span class="number">1.15</span><span class="number">.2</span>/libexec/src/runtime/sema.<span class="keyword">go</span>:<span class="number">56</span> +<span class="number">0x45</span></span><br><span class="line">sync.(*WaitGroup).Wait(<span class="number">0xc000016080</span>)</span><br><span class="line">        /usr/local/Cellar/<span class="keyword">go</span>/<span class="number">1.15</span><span class="number">.2</span>/libexec/src/sync/waitgroup.<span class="keyword">go</span>:<span class="number">130</span> +<span class="number">0x65</span></span><br><span class="line">main.main()</span><br><span class="line">        /Users/river/<span class="keyword">go</span>/src/grpc/test/main.<span class="keyword">go</span>:<span class="number">41</span> +<span class="number">0x178</span></span><br><span class="line">exit status <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>值传递导致是一个新的WaitGroup对象,原来的Done就没生效。死锁了.这里需要注意的是nocopy的实现，就是定义了一空结构体，然后一个Lock方法。这种类型如果复制,go vet可以检测出来，vscode上也会直观提示的。</p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1]<a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#waitgroup">https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#waitgroup</a></p>
<p>[2]<a href="https://golang.design/under-the-hood/zh-cn/part4lib/ch15sync/waitgroup/">https://golang.design/under-the-hood/zh-cn/part4lib/ch15sync/waitgroup/</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang semaphore</title>
    <url>/2020-10-28-golang-semaphore/</url>
    <content><![CDATA[<p>golang.org/x下面的包是区别于标椎库的，具有实验性质的辅助包，一些功能日趋完善后也可能添加到标准库中。</p>
<a id="more"></a>

<h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;golang.org/x/sync/semaphore&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// collatzSteps computes the number of steps to reach 1 under the Collatz</span></span><br><span class="line"><span class="comment">// conjecture. (See https://en.wikipedia.org/wiki/Collatz_conjecture.)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">collatzSteps</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">(steps <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;nonpositive input&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> ; n &gt; <span class="number">1</span>; steps++ &#123;</span><br><span class="line">		<span class="comment">//time.Sleep(1 * time.Second)</span></span><br><span class="line">		<span class="keyword">if</span> steps &lt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">&quot;too many steps&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> n%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">			n /= <span class="number">2</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">const</span> maxInt = <span class="keyword">int</span>(^<span class="keyword">uint</span>(<span class="number">0</span>) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span> n &gt; (maxInt<span class="number">-1</span>)/<span class="number">3</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">&quot;overflow&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		n = <span class="number">3</span>*n + <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> steps</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx := context.TODO()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		maxWorkers = runtime.GOMAXPROCS(<span class="number">0</span>) <span class="comment">//12</span></span><br><span class="line">		sem        = semaphore.NewWeighted(<span class="keyword">int64</span>(maxWorkers))</span><br><span class="line">		out        = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">32</span>)</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Compute the output using up to maxWorkers goroutines at a time.</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> out &#123;</span><br><span class="line">		<span class="comment">// When maxWorkers goroutines are in flight, Acquire blocks until one of the</span></span><br><span class="line">		<span class="comment">// workers finishes.</span></span><br><span class="line">		<span class="keyword">if</span> err := sem.Acquire(ctx, <span class="number">1</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;Failed to acquire semaphore: %v&quot;</span>, err)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(i)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> sem.Release(<span class="number">1</span>)</span><br><span class="line">			out[i] = collatzSteps(i + <span class="number">1</span>)</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Acquire all of the tokens to wait for any remaining workers to finish.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// If you are already waiting for the workers by some other means (such as an</span></span><br><span class="line">	<span class="comment">// errgroup.Group), you can omit this final Acquire call.</span></span><br><span class="line">	<span class="keyword">if</span> err := sem.Acquire(ctx, <span class="keyword">int64</span>(maxWorkers)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">&quot;Failed to acquire semaphore: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一个官方的demo<a href="https://godoc.org/golang.org/x/sync/semaphore">https://godoc.org/golang.org/x/sync/semaphore</a>.out大小是32，我这里maxWorkers是12，一开始很快打开12个goroutine,然后后面的开始等待，因为channel满了。for循环外面的sem.Acquire保证所有gouritine都执行结束，像是多线程的wait函数。</p>
<p>NewWeighted传入权重也就是信号量的计数器，然后Acquire就是P操作(wait,-1),Release是V操作(post,+1)</p>
<hr>
<h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Weighted provides a way to bound concurrent access to a resource.</span></span><br><span class="line"><span class="comment">// The callers can request access with a given weight.</span></span><br><span class="line"><span class="keyword">type</span> Weighted <span class="keyword">struct</span> &#123;</span><br><span class="line">	size    <span class="keyword">int64</span>   <span class="comment">//权重，信号量个数</span></span><br><span class="line">	cur     <span class="keyword">int64</span>   <span class="comment">//使用的信号量个数</span></span><br><span class="line">	mu      sync.Mutex</span><br><span class="line">	waiters list.List   <span class="comment">//等待的goroutine</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> waiter <span class="keyword">struct</span> &#123;</span><br><span class="line">	n     <span class="keyword">int64</span></span><br><span class="line">	ready <span class="keyword">chan</span>&lt;- <span class="keyword">struct</span>&#123;&#125; <span class="comment">// Closed when semaphore acquired.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Acquire"><a href="#Acquire" class="headerlink" title="Acquire"></a>Acquire</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Acquire acquires the semaphore with a weight of n, blocking until resources</span></span><br><span class="line"><span class="comment">// are available or ctx is done. On success, returns nil. On failure, returns</span></span><br><span class="line"><span class="comment">// ctx.Err() and leaves the semaphore unchanged.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If ctx is already done, Acquire may still succeed without blocking.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Weighted)</span> <span class="title">Acquire</span><span class="params">(ctx context.Context, n <span class="keyword">int64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    s.mu.Lock()</span><br><span class="line">    <span class="comment">//信号量够用，并且没有goroutine在排队，cur增加，返回成功</span></span><br><span class="line">	<span class="keyword">if</span> s.size-s.cur &gt;= n &amp;&amp; s.waiters.Len() == <span class="number">0</span> &#123;</span><br><span class="line">		s.cur += n</span><br><span class="line">		s.mu.Unlock()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求的大于容量的值，关闭context</span></span><br><span class="line">	<span class="keyword">if</span> n &gt; s.size &#123;</span><br><span class="line">		<span class="comment">// Don&#x27;t make other Acquire calls block on one that&#x27;s doomed to fail.</span></span><br><span class="line">		s.mu.Unlock()</span><br><span class="line">		&lt;-ctx.Done()</span><br><span class="line">		<span class="keyword">return</span> ctx.Err()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//要排队的情况</span></span><br><span class="line">    ready := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="comment">//转换成只能发送的channel</span></span><br><span class="line">    w := waiter&#123;n: n, ready: ready&#125;</span><br><span class="line">    <span class="comment">//加入等待队列</span></span><br><span class="line">	elem := s.waiters.PushBack(w)</span><br><span class="line">	s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="comment">//context结束的话，做错误处理</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">		err := ctx.Err()</span><br><span class="line">		s.mu.Lock()</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ready:</span><br><span class="line">			<span class="comment">// Acquired the semaphore after we were canceled.  Rather than trying to</span></span><br><span class="line">			<span class="comment">// fix up the queue, just pretend we didn&#x27;t notice the cancelation.</span></span><br><span class="line">			err = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			isFront := s.waiters.Front() == elem</span><br><span class="line">			s.waiters.Remove(elem)</span><br><span class="line">			<span class="comment">// If we&#x27;re at the front and there&#x27;re extra tokens left, notify other waiters.</span></span><br><span class="line">			<span class="keyword">if</span> isFront &amp;&amp; s.size &gt; s.cur &#123;</span><br><span class="line">				s.notifyWaiters()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		s.mu.Unlock()</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line"></span><br><span class="line">    <span class="comment">//阻塞到channel可读了</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-ready:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TryAcquire"><a href="#TryAcquire" class="headerlink" title="TryAcquire"></a>TryAcquire</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TryAcquire acquires the semaphore with a weight of n without blocking.</span></span><br><span class="line"><span class="comment">// On success, returns true. On failure, returns false and leaves the semaphore unchanged.</span></span><br><span class="line"><span class="comment">//非阻塞式的，只判断能否成功</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Weighted)</span> <span class="title">TryAcquire</span><span class="params">(n <span class="keyword">int64</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	s.mu.Lock()</span><br><span class="line">	success := s.size-s.cur &gt;= n &amp;&amp; s.waiters.Len() == <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> success &#123;</span><br><span class="line">		s.cur += n</span><br><span class="line">	&#125;</span><br><span class="line">	s.mu.Unlock()</span><br><span class="line">	<span class="keyword">return</span> success</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Release"><a href="#Release" class="headerlink" title="Release"></a>Release</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Release releases the semaphore with a weight of n.</span></span><br><span class="line"><span class="comment">//很直观，信号量-n,并唤醒</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Weighted)</span> <span class="title">Release</span><span class="params">(n <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">	s.mu.Lock()</span><br><span class="line">	s.cur -= n</span><br><span class="line">	<span class="keyword">if</span> s.cur &lt; <span class="number">0</span> &#123;</span><br><span class="line">		s.mu.Unlock()</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;semaphore: released more than held&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	s.notifyWaiters()</span><br><span class="line">	s.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="notifyWaiters"><a href="#notifyWaiters" class="headerlink" title="notifyWaiters"></a>notifyWaiters</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//广播操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Weighted)</span> <span class="title">notifyWaiters</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		next := s.waiters.Front()</span><br><span class="line">		<span class="keyword">if</span> next == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span> <span class="comment">// No more waiters blocked.</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        w := next.Value.(waiter)</span><br><span class="line">        <span class="comment">//不够唤醒，退出</span></span><br><span class="line">		<span class="keyword">if</span> s.size-s.cur &lt; w.n &#123;</span><br><span class="line">			<span class="comment">// Not enough tokens for the next waiter.  We could keep going (to try to</span></span><br><span class="line">			<span class="comment">// find a waiter with a smaller request), but under load that could cause</span></span><br><span class="line">			<span class="comment">// starvation for large requests; instead, we leave all remaining waiters</span></span><br><span class="line">			<span class="comment">// blocked.</span></span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">			<span class="comment">// Consider a semaphore used as a read-write lock, with N tokens, N</span></span><br><span class="line">			<span class="comment">// readers, and one writer.  Each reader can Acquire(1) to obtain a read</span></span><br><span class="line">			<span class="comment">// lock.  The writer can Acquire(N) to obtain a write lock, excluding all</span></span><br><span class="line">			<span class="comment">// of the readers.  If we allow the readers to jump ahead in the queue,</span></span><br><span class="line">			<span class="comment">// the writer will starve — there is always one token available for every</span></span><br><span class="line">			<span class="comment">// reader.</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		s.cur += w.n</span><br><span class="line">        s.waiters.Remove(next)</span><br><span class="line">        <span class="comment">//close唤醒阻塞的goroutine</span></span><br><span class="line">		<span class="built_in">close</span>(w.ready)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>通过头遍历双向链表实现了fifo唤醒等待队列</li>
<li>通过channel实现semaphore,数据结构设计很有意思，引入了权重的概念，从而多了cur,mutex,waiter(waiter内置了channel,并且支持一个goroutine可以递增技术量&gt;=1的值，也就是权重的概念)，所以这里不仅是实现了多元信号量，并且区别posix那种实现(每个线程只占用1个计数量)</li>
</ul>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1]<a href="https://www.codeleading.com/article/44422188264/">https://www.codeleading.com/article/44422188264/</a></p>
<p>[2]<a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#semaphore">https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#semaphore</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>grpc 实现</title>
    <url>/2020-10-28-grpc%20%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><a id="more"></a>

<h2 id="RegisterName"><a href="#RegisterName" class="headerlink" title="RegisterName"></a>RegisterName</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">rpc.RegisterName(<span class="string">&quot;hello&quot;</span>, <span class="built_in">new</span>(hello.Hello))</span><br><span class="line"></span><br><span class="line"><span class="comment">// RegisterName is like Register but uses the provided name for the type</span></span><br><span class="line"><span class="comment">// instead of the receiver&#x27;s concrete type.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterName</span><span class="params">(name <span class="keyword">string</span>, rcvr <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> DefaultServer.RegisterName(name, rcvr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultServer is the default instance of *Server.</span></span><br><span class="line"><span class="keyword">var</span> DefaultServer = NewServer()</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewServer returns a new Server.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">()</span> *<span class="title">Server</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Server&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Server represents an RPC Server.</span></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">	serviceMap sync.Map   <span class="comment">// map[string]*service</span></span><br><span class="line">	reqLock    sync.Mutex <span class="comment">// protects freeReq</span></span><br><span class="line">	freeReq    *Request</span><br><span class="line">	respLock   sync.Mutex <span class="comment">// protects freeResp</span></span><br><span class="line">	freeResp   *Response</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RegisterName is like Register but uses the provided name for the type</span></span><br><span class="line"><span class="comment">// instead of the receiver&#x27;s concrete type.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span> <span class="title">RegisterName</span><span class="params">(name <span class="keyword">string</span>, rcvr <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> server.register(rcvr, name, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> service <span class="keyword">struct</span> &#123;</span><br><span class="line">	name   <span class="keyword">string</span>                 <span class="comment">// name of service</span></span><br><span class="line">	rcvr   reflect.Value          <span class="comment">// receiver of methods for the service</span></span><br><span class="line">	typ    reflect.Type           <span class="comment">// type of the receiver</span></span><br><span class="line">	method <span class="keyword">map</span>[<span class="keyword">string</span>]*methodType <span class="comment">// registered methods</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span> <span class="title">register</span><span class="params">(rcvr <span class="keyword">interface</span>&#123;&#125;, name <span class="keyword">string</span>, useName <span class="keyword">bool</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	s := <span class="built_in">new</span>(service)</span><br><span class="line">	s.typ = reflect.TypeOf(rcvr)</span><br><span class="line">	s.rcvr = reflect.ValueOf(rcvr)</span><br><span class="line">	sname := reflect.Indirect(s.rcvr).Type().Name()</span><br><span class="line">	<span class="keyword">if</span> useName &#123;</span><br><span class="line">		sname = name</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> sname == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		s := <span class="string">&quot;rpc.Register: no service name for type &quot;</span> + s.typ.String()</span><br><span class="line">		log.Print(s)</span><br><span class="line">		<span class="keyword">return</span> errors.New(s)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !token.IsExported(sname) &amp;&amp; !useName &#123;</span><br><span class="line">		s := <span class="string">&quot;rpc.Register: type &quot;</span> + sname + <span class="string">&quot; is not exported&quot;</span></span><br><span class="line">		log.Print(s)</span><br><span class="line">		<span class="keyword">return</span> errors.New(s)</span><br><span class="line">	&#125;</span><br><span class="line">	s.name = sname</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Install the methods</span></span><br><span class="line">	s.method = suitableMethods(s.typ, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(s.method) == <span class="number">0</span> &#123;</span><br><span class="line">		str := <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// To help the user, see if a pointer receiver would work.</span></span><br><span class="line">		<span class="comment">//转换成指针类型再试试</span></span><br><span class="line">		method := suitableMethods(reflect.PtrTo(s.typ), <span class="literal">false</span>)</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(method) != <span class="number">0</span> &#123;</span><br><span class="line">			str = <span class="string">&quot;rpc.Register: type &quot;</span> + sname + <span class="string">&quot; has no exported methods of suitable type (hint: pass a pointer to value of that type)&quot;</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			str = <span class="string">&quot;rpc.Register: type &quot;</span> + sname + <span class="string">&quot; has no exported methods of suitable type&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line">		log.Print(str)</span><br><span class="line">		<span class="keyword">return</span> errors.New(str)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _, dup := server.serviceMap.LoadOrStore(sname, s); dup &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;rpc: service already defined: &quot;</span> + sname)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="suitableMethods"><a href="#suitableMethods" class="headerlink" title="suitableMethods"></a>suitableMethods</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// suitableMethods returns suitable Rpc methods of typ, it will report</span></span><br><span class="line"><span class="comment">// error using log if reportErr is true.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">suitableMethods</span><span class="params">(typ reflect.Type, reportErr <span class="keyword">bool</span>)</span> <span class="title">map</span>[<span class="title">string</span>]*<span class="title">methodType</span></span> &#123;</span><br><span class="line">	methods := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*methodType)</span><br><span class="line">	<span class="keyword">for</span> m := <span class="number">0</span>; m &lt; typ.NumMethod(); m++ &#123;</span><br><span class="line">		method := typ.Method(m)</span><br><span class="line">		mtype := method.Type</span><br><span class="line">		mname := method.Name</span><br><span class="line">		<span class="comment">// Method must be exported.</span></span><br><span class="line">		<span class="keyword">if</span> method.PkgPath != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Method needs three ins: receiver, *args, *reply.</span></span><br><span class="line">		<span class="comment">//func (h *Hello) Hello(req string, rep *string) error </span></span><br><span class="line">		<span class="keyword">if</span> mtype.NumIn() != <span class="number">3</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> reportErr &#123;</span><br><span class="line">				log.Printf(<span class="string">&quot;rpc.Register: method %q has %d input parameters; needs exactly three\n&quot;</span>, mname, mtype.NumIn())</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// First arg need not be a pointer.</span></span><br><span class="line">		argType := mtype.In(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span> !isExportedOrBuiltinType(argType) &#123;</span><br><span class="line">			<span class="keyword">if</span> reportErr &#123;</span><br><span class="line">				log.Printf(<span class="string">&quot;rpc.Register: argument type of method %q is not exported: %q\n&quot;</span>, mname, argType)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Second arg must be a pointer.</span></span><br><span class="line">		replyType := mtype.In(<span class="number">2</span>)</span><br><span class="line">		<span class="keyword">if</span> replyType.Kind() != reflect.Ptr &#123;</span><br><span class="line">			<span class="keyword">if</span> reportErr &#123;</span><br><span class="line">				log.Printf(<span class="string">&quot;rpc.Register: reply type of method %q is not a pointer: %q\n&quot;</span>, mname, replyType)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Reply type must be exported.</span></span><br><span class="line">		<span class="keyword">if</span> !isExportedOrBuiltinType(replyType) &#123;</span><br><span class="line">			<span class="keyword">if</span> reportErr &#123;</span><br><span class="line">				log.Printf(<span class="string">&quot;rpc.Register: reply type of method %q is not exported: %q\n&quot;</span>, mname, replyType)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Method needs one out.</span></span><br><span class="line">		<span class="keyword">if</span> mtype.NumOut() != <span class="number">1</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> reportErr &#123;</span><br><span class="line">				log.Printf(<span class="string">&quot;rpc.Register: method %q has %d output parameters; needs exactly one\n&quot;</span>, mname, mtype.NumOut())</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// The return type of the method must be error.</span></span><br><span class="line">		<span class="keyword">if</span> returnType := mtype.Out(<span class="number">0</span>); returnType != typeOfError &#123;</span><br><span class="line">			<span class="keyword">if</span> reportErr &#123;</span><br><span class="line">				log.Printf(<span class="string">&quot;rpc.Register: return type of method %q is %q, must be error\n&quot;</span>, mname, returnType)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		methods[mname] = &amp;methodType&#123;method: method, ArgType: argType, ReplyType: replyType&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> methods</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="note"><a href="#note" class="headerlink" title="note"></a>note</h3><p>RegisterName其实就是通过reflect把数据结构的所有方法存到sync.map中</p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang sync.cond</title>
    <url>/2020-10-29-golang-sync-cond/</url>
    <content><![CDATA[<p>Cond implements a condition variable, a rendezvous(会和) point for goroutines waiting for or announcing(宣布，公告) the occurrence(发生) of an event.</p>
<p>Each Cond has an associated(关联) Locker L (often a *Mutex or *RWMutex), which must be held when changing the condition and when calling the Wait method.</p>
<p>A Cond must not be copied after first use.</p>
<p>函数以及用法和unix的条件变量很相似。代码路径<code>/usr/local/Cellar/go/1.15.2/libexec/src/sync/cond.go</code></p>
<a id="more"></a>

<h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">	noCopy noCopy   <span class="comment">//禁止拷贝</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// L is held while observing or changing the condition</span></span><br><span class="line">	L Locker</span><br><span class="line"></span><br><span class="line">	notify  notifyList</span><br><span class="line">	checker copyChecker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Approximation of notifyList in runtime/sema.go. Size and alignment must</span></span><br><span class="line"><span class="comment">// agree.</span></span><br><span class="line"><span class="keyword">type</span> notifyList <span class="keyword">struct</span> &#123;</span><br><span class="line">	wait   <span class="keyword">uint32</span></span><br><span class="line">	notify <span class="keyword">uint32</span></span><br><span class="line">	lock   <span class="keyword">uintptr</span> <span class="comment">// key field of the mutex</span></span><br><span class="line">	head   unsafe.Pointer</span><br><span class="line">	tail   unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NewCond"><a href="#NewCond" class="headerlink" title="NewCond"></a>NewCond</h2><p>NewCond returns a new Cond with Locker l.</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NewCond returns a new Cond with Locker l.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCond</span><span class="params">(l Locker)</span> *<span class="title">Cond</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Cond&#123;L: l&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Wait"><a href="#Wait" class="headerlink" title="Wait"></a>Wait</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Wait atomically unlocks c.L and suspends execution</span></span><br><span class="line"><span class="comment">// of the calling goroutine. After later resuming execution,</span></span><br><span class="line"><span class="comment">// Wait locks c.L before returning. Unlike in other systems,</span></span><br><span class="line"><span class="comment">// Wait cannot return unless awoken by Broadcast or Signal.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Because c.L is not locked when Wait first resumes, the caller</span></span><br><span class="line"><span class="comment">// typically cannot assume that the condition is true when</span></span><br><span class="line"><span class="comment">// Wait returns. Instead, the caller should Wait in a loop:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    c.L.Lock()</span></span><br><span class="line"><span class="comment">//    for !condition() &#123;</span></span><br><span class="line"><span class="comment">//        c.Wait()</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    ... make use of condition ...</span></span><br><span class="line"><span class="comment">//    c.L.Unlock()</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Wait</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c.checker.check()   <span class="comment">//检查有没有被copy</span></span><br><span class="line">	t := runtime_notifyListAdd(&amp;c.notify)</span><br><span class="line">	c.L.Unlock()</span><br><span class="line">	runtime_notifyListWait(&amp;c.notify, t)</span><br><span class="line">	c.L.Lock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="check"><a href="#check" class="headerlink" title="check"></a>check</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// copyChecker holds back pointer to itself to detect object copying.</span></span><br><span class="line"><span class="keyword">type</span> copyChecker <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *copyChecker)</span> <span class="title">check</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">uintptr</span>(*c) != <span class="keyword">uintptr</span>(unsafe.Pointer(c)) &amp;&amp;</span><br><span class="line">		!atomic.CompareAndSwapUintptr((*<span class="keyword">uintptr</span>)(c), <span class="number">0</span>, <span class="keyword">uintptr</span>(unsafe.Pointer(c))) &amp;&amp;</span><br><span class="line">		<span class="keyword">uintptr</span>(*c) != <span class="keyword">uintptr</span>(unsafe.Pointer(c)) &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;sync.Cond is copied&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Signal"><a href="#Signal" class="headerlink" title="Signal"></a>Signal</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Signal wakes one goroutine waiting on c, if there is any.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// It is allowed but not required for the caller to hold c.L</span></span><br><span class="line"><span class="comment">// during the call.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Signal</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c.checker.check()</span><br><span class="line">	runtime_notifyListNotifyOne(&amp;c.notify)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Broadcast"><a href="#Broadcast" class="headerlink" title="Broadcast"></a>Broadcast</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Broadcast wakes all goroutines waiting on c.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// It is allowed but not required for the caller to hold c.L</span></span><br><span class="line"><span class="comment">// during the call.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Broadcast</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c.checker.check()</span><br><span class="line">	runtime_notifyListNotifyAll(&amp;c.notify)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基本比较简单，麻烦的是runtime系列函数，我在别的文章单独整理吧"><a href="#基本比较简单，麻烦的是runtime系列函数，我在别的文章单独整理吧" class="headerlink" title="基本比较简单，麻烦的是runtime系列函数，我在别的文章单独整理吧."></a>基本比较简单，麻烦的是runtime系列函数，我在别的文章单独整理吧.</h2><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1]<a href="https://golang.org/pkg/sync/#Cond">https://golang.org/pkg/sync/#Cond</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang sync.once</title>
    <url>/2020-10-29-golang-sync-once/</url>
    <content><![CDATA[<p>Once is an object that will perform exactly one action.类似c++的单例模式。代码路径<code>/usr/local/Cellar/go/1.15.2/libexec/src/sync/once.go</code>。代码很少，实现起来也比较简单。</p>
<a id="more"></a>

<h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> once sync.Once</span><br><span class="line">	onceBody := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Only once&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			once.Do(onceBody)</span><br><span class="line">			done &lt;- <span class="literal">true</span></span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		&lt;-done</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;all done!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>output:</p>
<pre><code>Only once
all done!</code></pre>
<h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Once is an object that will perform exactly one action.</span></span><br><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// done indicates whether the action has been performed.</span></span><br><span class="line">	<span class="comment">// It is first in the struct because it is used in the hot path.</span></span><br><span class="line">	<span class="comment">// The hot path is inlined at every call site.</span></span><br><span class="line">	<span class="comment">// Placing done first allows more compact instructions on some architectures (amd64/x86),</span></span><br><span class="line">    <span class="comment">// and fewer instructions (to calculate offset) on other architectures.</span></span><br><span class="line">    <span class="comment">//0表示第一次执行</span></span><br><span class="line">	done <span class="keyword">uint32</span></span><br><span class="line">	m    Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Do"><a href="#Do" class="headerlink" title="Do"></a>Do</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Do calls the function f if and only if Do is being called for the</span></span><br><span class="line"><span class="comment">// first time for this instance of Once. In other words, given</span></span><br><span class="line"><span class="comment">// 	var once Once</span></span><br><span class="line"><span class="comment">// if once.Do(f) is called multiple times, only the first call will invoke f,</span></span><br><span class="line"><span class="comment">// even if f has a different value in each invocation. A new instance of</span></span><br><span class="line"><span class="comment">// Once is required for each function to execute.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Do is intended for initialization that must be run exactly once. Since f</span></span><br><span class="line"><span class="comment">// is niladic, it may be necessary to use a function literal to capture the</span></span><br><span class="line"><span class="comment">// arguments to a function to be invoked by Do:</span></span><br><span class="line"><span class="comment">// 	config.once.Do(func() &#123; config.init(filename) &#125;)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Because no call to Do returns until the one call to f returns, if f causes</span></span><br><span class="line"><span class="comment">// Do to be called, it will deadlock.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If f panics, Do considers it to have returned; future calls of Do return</span></span><br><span class="line"><span class="comment">// without calling f.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// Note: Here is an incorrect implementation of Do:</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//	if atomic.CompareAndSwapUint32(&amp;o.done, 0, 1) &#123;</span></span><br><span class="line">	<span class="comment">//		f()</span></span><br><span class="line">	<span class="comment">//	&#125;</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Do guarantees that when it returns, f has finished.</span></span><br><span class="line">	<span class="comment">// This implementation would not implement that guarantee:</span></span><br><span class="line">	<span class="comment">// given two simultaneous calls, the winner of the cas would</span></span><br><span class="line">	<span class="comment">// call f, and the second would return immediately, without</span></span><br><span class="line">	<span class="comment">// waiting for the first&#x27;s call to f to complete.</span></span><br><span class="line">	<span class="comment">// This is why the slow path falls back to a mutex, and why</span></span><br><span class="line">	<span class="comment">// the atomic.StoreUint32 must be delayed until after f returns.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Outlined slow-path to allow inlining of the fast-path.</span></span><br><span class="line">		o.doSlow(f)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="doSlow"><a href="#doSlow" class="headerlink" title="doSlow"></a>doSlow</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">doSlow</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">	o.m.Lock()</span><br><span class="line">    <span class="keyword">defer</span> o.m.Unlock()</span><br><span class="line">    <span class="comment">//两次判断</span></span><br><span class="line">	<span class="keyword">if</span> o.done == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="number">1</span>)</span><br><span class="line">		f()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总体比较简单，需要注意的就是2次加锁。然后2次defer,defer有如析构是先构造后析构的，所以先修改值再释放锁</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;111&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;222&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>output:</p>
<pre><code>222
111</code></pre>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1]<a href="https://golang.org/pkg/sync/#Once">https://golang.org/pkg/sync/#Once</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang runtime sema</title>
    <url>/2020-11-03-golang-runtime-sema/</url>
    <content><![CDATA[<p>go实现的sleep和wakeup，底层是gopark和goready，需要结合调度来看。其他同步手段基本都与这里有关。版本<code>go/1.15.2/libexec/src/runtime/sema.go</code></p>
<a id="more"></a>

<h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">//go:linkname sync_runtime_Semacquire sync.runtime_Semacquire</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_Semacquire</span><span class="params">(addr *<span class="keyword">uint32</span>)</span></span> &#123;</span><br><span class="line">	semacquire1(addr, <span class="literal">false</span>, semaBlockProfile, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:linkname poll_runtime_Semacquire internal/poll.runtime_Semacquire</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_Semacquire</span><span class="params">(addr *<span class="keyword">uint32</span>)</span></span> &#123;</span><br><span class="line">	semacquire1(addr, <span class="literal">false</span>, semaBlockProfile, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:linkname sync_runtime_Semrelease sync.runtime_Semrelease</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_Semrelease</span><span class="params">(addr *<span class="keyword">uint32</span>, handoff <span class="keyword">bool</span>, skipframes <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	semrelease1(addr, handoff, skipframes)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:linkname sync_runtime_SemacquireMutex sync.runtime_SemacquireMutex</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_SemacquireMutex</span><span class="params">(addr *<span class="keyword">uint32</span>, lifo <span class="keyword">bool</span>, skipframes <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	semacquire1(addr, lifo, semaBlockProfile|semaMutexProfile, skipframes)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prime to not correlate(相关) with any user patterns.</span></span><br><span class="line"><span class="keyword">const</span> semTabSize = <span class="number">251</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> semtable [semTabSize]<span class="keyword">struct</span> &#123;</span><br><span class="line">	root semaRoot</span><br><span class="line">	pad  [cpu.CacheLinePadSize - unsafe.Sizeof(semaRoot&#123;&#125;)]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> semaRoot <span class="keyword">struct</span> &#123;</span><br><span class="line">	lock  mutex</span><br><span class="line">	treap *sudog <span class="comment">// root of balanced tree of unique waiters.</span></span><br><span class="line">	nwait <span class="keyword">uint32</span> <span class="comment">// Number of waiters. Read w/o the lock.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// The following fields are protected by the hchan.lock of the</span></span><br><span class="line">	<span class="comment">// channel this sudog is blocking on. shrinkstack depends on</span></span><br><span class="line">	<span class="comment">// this for sudogs involved in channel ops.</span></span><br><span class="line"></span><br><span class="line">	g *g</span><br><span class="line"></span><br><span class="line">	next *sudog</span><br><span class="line">	prev *sudog</span><br><span class="line">	elem unsafe.Pointer <span class="comment">// data element (may point to stack)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// The following fields are never accessed concurrently.</span></span><br><span class="line">	<span class="comment">// For channels, waitlink is only accessed by g.</span></span><br><span class="line">	<span class="comment">// For semaphores, all fields (including the ones above)</span></span><br><span class="line">	<span class="comment">// are only accessed when holding a semaRoot lock.</span></span><br><span class="line"></span><br><span class="line">	acquiretime <span class="keyword">int64</span></span><br><span class="line">	releasetime <span class="keyword">int64</span></span><br><span class="line">	ticket      <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// isSelect indicates g is participating in a select, so</span></span><br><span class="line">	<span class="comment">// g.selectDone must be CAS&#x27;d to win the wake-up race.</span></span><br><span class="line">	isSelect <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	parent   *sudog <span class="comment">// semaRoot binary tree</span></span><br><span class="line">	waitlink *sudog <span class="comment">// g.waiting list or semaRoot</span></span><br><span class="line">	waittail *sudog <span class="comment">// semaRoot</span></span><br><span class="line">	c        *hchan <span class="comment">// channel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>semtable是大小251的数组，数组元素存放了semaRoot,每个semaRoot都是一个树堆，key是锁的地址elem，优先级是生成的一个随机数ticket.并且相同地址的elem不是存在树堆里面的，而是通过和树堆里相同的key组成单向链表串起来的(waitlink指向链表下一个元素，waittail指向链表最后的一个元素)。sudog.g保存了阻塞在锁上面的g,即goroutine的信息，在唤醒的时候会用到。</p>
<hr>
<h2 id="cansemacquire"><a href="#cansemacquire" class="headerlink" title="cansemacquire"></a>cansemacquire</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cansemacquire</span><span class="params">(addr *<span class="keyword">uint32</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		v := atomic.Load(addr)</span><br><span class="line">		<span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> atomic.Cas(addr, v, v<span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>treap是存放等待队列的，所以如果能直接取到锁的值可以修改的话，就不用阻塞也就不用入队了，这里是easy case.</p>
<hr>
<h2 id="semacquire1"><a href="#semacquire1" class="headerlink" title="semacquire1"></a>semacquire1</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">semacquire1</span><span class="params">(addr *<span class="keyword">uint32</span>, lifo <span class="keyword">bool</span>, profile semaProfileFlags, skipframes <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	gp := getg()    <span class="comment">//记录当前的G信息</span></span><br><span class="line">	<span class="keyword">if</span> gp != gp.m.curg &#123;</span><br><span class="line">		throw(<span class="string">&quot;semacquire not on the G stack&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Easy case.</span></span><br><span class="line">    <span class="comment">//尝试原子操作-1</span></span><br><span class="line">	<span class="keyword">if</span> cansemacquire(addr) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Harder case:</span></span><br><span class="line">	<span class="comment">//	increment waiter count</span></span><br><span class="line">	<span class="comment">//	try cansemacquire one more time, return if succeeded</span></span><br><span class="line">	<span class="comment">//	enqueue itself as a waiter</span></span><br><span class="line">	<span class="comment">//	sleep</span></span><br><span class="line">	<span class="comment">//	(waiter descriptor is dequeued by signaler)</span></span><br><span class="line">	s := acquireSudog()</span><br><span class="line">	root := semroot(addr)</span><br><span class="line">	t0 := <span class="keyword">int64</span>(<span class="number">0</span>)</span><br><span class="line">	s.releasetime = <span class="number">0</span></span><br><span class="line">	s.acquiretime = <span class="number">0</span></span><br><span class="line">	s.ticket = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> profile&amp;semaBlockProfile != <span class="number">0</span> &amp;&amp; blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">		t0 = cputicks()</span><br><span class="line">		s.releasetime = <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> profile&amp;semaMutexProfile != <span class="number">0</span> &amp;&amp; mutexprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> t0 == <span class="number">0</span> &#123;</span><br><span class="line">			t0 = cputicks()</span><br><span class="line">		&#125;</span><br><span class="line">		s.acquiretime = t0</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		lockWithRank(&amp;root.lock, lockRankRoot)</span><br><span class="line">        <span class="comment">// Add ourselves to nwait to disable &quot;easy case&quot; in semrelease.</span></span><br><span class="line">        <span class="comment">//nwaiter+1,让其他cas失效</span></span><br><span class="line">		atomic.Xadd(&amp;root.nwait, <span class="number">1</span>)</span><br><span class="line">		<span class="comment">// Check cansemacquire to avoid missed wakeup.</span></span><br><span class="line">		<span class="keyword">if</span> cansemacquire(addr) &#123;</span><br><span class="line">			atomic.Xadd(&amp;root.nwait, <span class="number">-1</span>)</span><br><span class="line">			unlock(&amp;root.lock)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Any semrelease after the cansemacquire knows we&#x27;re waiting</span></span><br><span class="line">        <span class="comment">// (we set nwait above), so go to sleep.</span></span><br><span class="line">        <span class="comment">//s加到treap里面，然后gopark睡眠</span></span><br><span class="line">		root.queue(addr, s, lifo)</span><br><span class="line">		goparkunlock(&amp;root.lock, waitReasonSemacquire, traceEvGoBlockSync, <span class="number">4</span>+skipframes)</span><br><span class="line">		<span class="keyword">if</span> s.ticket != <span class="number">0</span> || cansemacquire(addr) &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> s.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">		blockevent(s.releasetime-t0, <span class="number">3</span>+skipframes)</span><br><span class="line">	&#125;</span><br><span class="line">	releaseSudog(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="semrelease1"><a href="#semrelease1" class="headerlink" title="semrelease1"></a>semrelease1</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">semrelease1</span><span class="params">(addr *<span class="keyword">uint32</span>, handoff <span class="keyword">bool</span>, skipframes <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    root := semroot(addr)</span><br><span class="line">    <span class="comment">//+1</span></span><br><span class="line">	atomic.Xadd(addr, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Easy case: no waiters?</span></span><br><span class="line">	<span class="comment">// This check must happen after the xadd, to avoid a missed wakeup</span></span><br><span class="line">    <span class="comment">// (see loop in semacquire).</span></span><br><span class="line">    <span class="comment">//再次检查，刚add的看样子已经被其他g给acquire了</span></span><br><span class="line">	<span class="keyword">if</span> atomic.Load(&amp;root.nwait) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Harder case: search for a waiter and wake it.</span></span><br><span class="line">	lockWithRank(&amp;root.lock, lockRankRoot)</span><br><span class="line">	<span class="keyword">if</span> atomic.Load(&amp;root.nwait) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// The count is already consumed by another goroutine,</span></span><br><span class="line">		<span class="comment">// so no need to wake up another goroutine.</span></span><br><span class="line">		unlock(&amp;root.lock)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出队，从treap/sudog链表删除</span></span><br><span class="line">	s, t0 := root.dequeue(addr)</span><br><span class="line">	<span class="keyword">if</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">		atomic.Xadd(&amp;root.nwait, <span class="number">-1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	unlock(&amp;root.lock)</span><br><span class="line">	<span class="keyword">if</span> s != <span class="literal">nil</span> &#123; <span class="comment">// May be slow or even yield, so unlock first</span></span><br><span class="line">		acquiretime := s.acquiretime</span><br><span class="line">		<span class="keyword">if</span> acquiretime != <span class="number">0</span> &#123;</span><br><span class="line">			mutexevent(t0-acquiretime, <span class="number">3</span>+skipframes)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> s.ticket != <span class="number">0</span> &#123;</span><br><span class="line">			throw(<span class="string">&quot;corrupted semaphore ticket&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> handoff &amp;&amp; cansemacquire(addr) &#123;</span><br><span class="line">			s.ticket = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//goready唤醒</span></span><br><span class="line">		readyWithTime(s, <span class="number">5</span>+skipframes)</span><br><span class="line">		<span class="keyword">if</span> s.ticket == <span class="number">1</span> &amp;&amp; getg().m.locks == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// Direct G handoff</span></span><br><span class="line">			<span class="comment">// readyWithTime has added the waiter G as runnext in the</span></span><br><span class="line">			<span class="comment">// current P; we now call the scheduler so that we start running</span></span><br><span class="line">			<span class="comment">// the waiter G immediately.</span></span><br><span class="line">			<span class="comment">// Note that waiter inherits our time slice: this is desirable</span></span><br><span class="line">			<span class="comment">// to avoid having a highly contended semaphore hog the P</span></span><br><span class="line">			<span class="comment">// indefinitely. goyield is like Gosched, but it emits a</span></span><br><span class="line">			<span class="comment">// &quot;preempted&quot; trace event instead and, more importantly, puts</span></span><br><span class="line">			<span class="comment">// the current G on the local runq instead of the global one.</span></span><br><span class="line">			<span class="comment">// We only do this in the starving regime (handoff=true), as in</span></span><br><span class="line">			<span class="comment">// the non-starving case it is possible for a different waiter</span></span><br><span class="line">			<span class="comment">// to acquire the semaphore while we are yielding/scheduling,</span></span><br><span class="line">			<span class="comment">// and this would be wasteful. We wait instead to enter starving</span></span><br><span class="line">			<span class="comment">// regime, and then we start to do direct handoffs of ticket and</span></span><br><span class="line">			<span class="comment">// P.</span></span><br><span class="line">            <span class="comment">// See issue 33747 for discussion.</span></span><br><span class="line">            <span class="comment">//将当前g放到P的可运行队列，而不是全局的可运行队列</span></span><br><span class="line">			goyield()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1]<a href="https://github.com/cch123/golang-notes/blob/master/semaphore.md">https://github.com/cch123/golang-notes/blob/master/semaphore.md</a></p>
<p>[2]<a href="https://github.com/thinkboy/go-notes/blob/master/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E7%9C%8BGolang%E7%9A%84%E8%B0%83%E5%BA%A6.md">https://github.com/thinkboy/go-notes/blob/master/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E7%9C%8BGolang%E7%9A%84%E8%B0%83%E5%BA%A6.md</a></p>
<p>[3]<a href="">数据结构与算法之美</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang sema treap</title>
    <url>/2020-11-04-golang%20sema%20treap/</url>
    <content><![CDATA[<p>接着runtime sema的部分，梳理wait的队列实现细节。</p>
<a id="more"></a>

<h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// queue adds s to the blocked goroutines in semaRoot.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(root *semaRoot)</span> <span class="title">queue</span><span class="params">(addr *<span class="keyword">uint32</span>, s *sudog, lifo <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	s.g = getg()    <span class="comment">//当前的G</span></span><br><span class="line">	s.elem = unsafe.Pointer(addr)</span><br><span class="line">	s.next = <span class="literal">nil</span></span><br><span class="line">	s.prev = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> last *sudog</span><br><span class="line">	pt := &amp;root.treap</span><br><span class="line">	<span class="keyword">for</span> t := *pt; t != <span class="literal">nil</span>; t = *pt &#123;</span><br><span class="line">        <span class="comment">//bst搜索</span></span><br><span class="line">		<span class="keyword">if</span> t.elem == unsafe.Pointer(addr) &#123;</span><br><span class="line">            <span class="comment">// Already have addr in list. </span></span><br><span class="line">            <span class="comment">//lifo:插到head</span></span><br><span class="line">			<span class="keyword">if</span> lifo &#123;</span><br><span class="line">                <span class="comment">// Substitute s in t&#x27;s place in treap.</span></span><br><span class="line">                <span class="comment">//old: t-&gt;t1-&gt;t2</span></span><br><span class="line">                <span class="comment">//new s-&gt;t-&gt;t1</span></span><br><span class="line">				*pt = s</span><br><span class="line">				s.ticket = t.ticket</span><br><span class="line">				s.acquiretime = t.acquiretime</span><br><span class="line">				s.parent = t.parent</span><br><span class="line">				s.prev = t.prev</span><br><span class="line">				s.next = t.next</span><br><span class="line">				<span class="keyword">if</span> s.prev != <span class="literal">nil</span> &#123;</span><br><span class="line">					s.prev.parent = s</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> s.next != <span class="literal">nil</span> &#123;</span><br><span class="line">					s.next.parent = s</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// Add t first in s&#x27;s wait list.</span></span><br><span class="line">				s.waitlink = t</span><br><span class="line">				s.waittail = t.waittail</span><br><span class="line">				<span class="keyword">if</span> s.waittail == <span class="literal">nil</span> &#123;</span><br><span class="line">					s.waittail = t</span><br><span class="line">				&#125;</span><br><span class="line">				t.parent = <span class="literal">nil</span></span><br><span class="line">				t.prev = <span class="literal">nil</span></span><br><span class="line">				t.next = <span class="literal">nil</span></span><br><span class="line">                t.waittail = <span class="literal">nil</span></span><br><span class="line">            <span class="comment">//fifo:插到tail</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// Add s to end of t&#x27;s wait list.</span></span><br><span class="line">				<span class="keyword">if</span> t.waittail == <span class="literal">nil</span> &#123;</span><br><span class="line">					t.waitlink = s</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					t.waittail.waitlink = s</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//只更新了链表第一个元素指向的tail,其他元素的tail指针好像没有同步</span></span><br><span class="line">				t.waittail = s</span><br><span class="line">				s.waitlink = <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		last = t</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">uintptr</span>(unsafe.Pointer(addr)) &lt; <span class="keyword">uintptr</span>(t.elem) &#123;</span><br><span class="line">			pt = &amp;t.prev</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			pt = &amp;t.next</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Add s as new leaf in tree of unique addrs.</span></span><br><span class="line">	<span class="comment">// The balanced tree is a treap using ticket as the random heap priority.</span></span><br><span class="line">	<span class="comment">// That is, it is a binary tree ordered according to the elem addresses,</span></span><br><span class="line">	<span class="comment">// but then among the space of possible binary trees respecting those</span></span><br><span class="line">	<span class="comment">// addresses, it is kept balanced on average by maintaining a heap ordering</span></span><br><span class="line">	<span class="comment">// on the ticket: s.ticket &lt;= both s.prev.ticket and s.next.ticket.</span></span><br><span class="line">	<span class="comment">// https://en.wikipedia.org/wiki/Treap</span></span><br><span class="line">	<span class="comment">// https://faculty.washington.edu/aragon/pubs/rst89.pdf</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// s.ticket compared with zero in couple of places, therefore set lowest bit.</span></span><br><span class="line">    <span class="comment">// It will not affect treap&#x27;s quality noticeably.</span></span><br><span class="line">    <span class="comment">//更新s的优先级，平衡整棵树</span></span><br><span class="line">	s.ticket = fastrand() | <span class="number">1</span></span><br><span class="line">	s.parent = last</span><br><span class="line">	*pt = s</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Rotate up into tree according to ticket (priority).</span></span><br><span class="line">	<span class="keyword">for</span> s.parent != <span class="literal">nil</span> &amp;&amp; s.parent.ticket &gt; s.ticket &#123;</span><br><span class="line">        <span class="comment">//当前节点是左节点就右旋，右节点则左旋</span></span><br><span class="line">        <span class="comment">//这里看样子用的是小顶堆</span></span><br><span class="line">		<span class="keyword">if</span> s.parent.prev == s &#123;</span><br><span class="line">			root.rotateRight(s.parent)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> s.parent.next != s &#123;</span><br><span class="line">				<span class="built_in">panic</span>(<span class="string">&quot;semaRoot queue&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			root.rotateLeft(s.parent)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="dequeue"><a href="#dequeue" class="headerlink" title="dequeue"></a>dequeue</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// dequeue searches for and finds the first goroutine</span></span><br><span class="line"><span class="comment">// in semaRoot blocked on addr.</span></span><br><span class="line"><span class="comment">// If the sudog was being profiled, dequeue returns the time</span></span><br><span class="line"><span class="comment">// at which it was woken up as now. Otherwise now is 0.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(root *semaRoot)</span> <span class="title">dequeue</span><span class="params">(addr *<span class="keyword">uint32</span>)</span> <span class="params">(found *sudog, now <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">	ps := &amp;root.treap</span><br><span class="line">	s := *ps</span><br><span class="line">	<span class="keyword">for</span> ; s != <span class="literal">nil</span>; s = *ps &#123;</span><br><span class="line">		<span class="keyword">if</span> s.elem == unsafe.Pointer(addr) &#123;</span><br><span class="line">			<span class="keyword">goto</span> Found</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//bst搜索</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">uintptr</span>(unsafe.Pointer(addr)) &lt; <span class="keyword">uintptr</span>(s.elem) &#123;</span><br><span class="line">			ps = &amp;s.prev</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			ps = &amp;s.next</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Found:</span><br><span class="line">    <span class="comment">//s:对应addr的节点</span></span><br><span class="line">	now = <span class="keyword">int64</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> s.acquiretime != <span class="number">0</span> &#123;</span><br><span class="line">		now = cputicks()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> t := s.waitlink; t != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// Substitute t, also waiting on addr, for s in root tree of unique addrs.</span></span><br><span class="line">        <span class="comment">//链表有2个以上元素，把第2个元素挪到treap下，删掉s</span></span><br><span class="line">		*ps = t</span><br><span class="line">		t.ticket = s.ticket</span><br><span class="line">		t.parent = s.parent</span><br><span class="line">		t.prev = s.prev</span><br><span class="line">		<span class="keyword">if</span> t.prev != <span class="literal">nil</span> &#123;</span><br><span class="line">			t.prev.parent = t</span><br><span class="line">		&#125;</span><br><span class="line">		t.next = s.next</span><br><span class="line">		<span class="keyword">if</span> t.next != <span class="literal">nil</span> &#123;</span><br><span class="line">			t.next.parent = t</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> t.waitlink != <span class="literal">nil</span> &#123;</span><br><span class="line">			t.waittail = s.waittail</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			t.waittail = <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		t.acquiretime = now</span><br><span class="line">		s.waitlink = <span class="literal">nil</span></span><br><span class="line">		s.waittail = <span class="literal">nil</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//链表只有1个元素，这个元素s有子节点才考虑旋转，将这个元素删掉</span></span><br><span class="line">		<span class="comment">// Rotate s down to be leaf of tree for removal, respecting priorities.</span></span><br><span class="line">		<span class="keyword">for</span> s.next != <span class="literal">nil</span> || s.prev != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">//只有右节点，或者有2个节点但是右节点大于左节点，都右旋</span></span><br><span class="line">			<span class="keyword">if</span> s.next == <span class="literal">nil</span> || s.prev != <span class="literal">nil</span> &amp;&amp; s.prev.ticket &lt; s.next.ticket &#123;</span><br><span class="line">				root.rotateRight(s)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				root.rotateLeft(s)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Remove s, now a leaf.</span></span><br><span class="line">		<span class="keyword">if</span> s.parent != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> s.parent.prev == s &#123;</span><br><span class="line">				s.parent.prev = <span class="literal">nil</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				s.parent.next = <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			root.treap = <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	s.parent = <span class="literal">nil</span></span><br><span class="line">	s.elem = <span class="literal">nil</span></span><br><span class="line">	s.next = <span class="literal">nil</span></span><br><span class="line">	s.prev = <span class="literal">nil</span></span><br><span class="line">	s.ticket = <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> s, now</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="rotateLeft"><a href="#rotateLeft" class="headerlink" title="rotateLeft"></a>rotateLeft</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// rotateLeft rotates the tree rooted at node x.</span></span><br><span class="line"><span class="comment">// turning (x a (y b c)) into (y (x a b) c).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(root *semaRoot)</span> <span class="title">rotateLeft</span><span class="params">(x *sudog)</span></span> &#123;</span><br><span class="line">	<span class="comment">// p -&gt; (x a (y b c))</span></span><br><span class="line">	p := x.parent</span><br><span class="line">	y := x.next</span><br><span class="line">	b := y.prev</span><br><span class="line"></span><br><span class="line">	y.prev = x</span><br><span class="line">	x.parent = y</span><br><span class="line">	x.next = b</span><br><span class="line">	<span class="keyword">if</span> b != <span class="literal">nil</span> &#123;</span><br><span class="line">		b.parent = x</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	y.parent = p</span><br><span class="line">	<span class="keyword">if</span> p == <span class="literal">nil</span> &#123;</span><br><span class="line">		root.treap = y</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> p.prev == x &#123;</span><br><span class="line">		p.prev = y</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> p.next != x &#123;</span><br><span class="line">			throw(<span class="string">&quot;semaRoot rotateLeft&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		p.next = y</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/11/04/i6WFbVlfmUOT2p9.png" alt="未命名文件 _1_.png"></p>
<hr>
<h2 id="rotateRight"><a href="#rotateRight" class="headerlink" title="rotateRight"></a>rotateRight</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// rotateRight rotates the tree rooted at node y.</span></span><br><span class="line"><span class="comment">// turning (y (x a b) c) into (x a (y b c)).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(root *semaRoot)</span> <span class="title">rotateRight</span><span class="params">(y *sudog)</span></span> &#123;</span><br><span class="line">	<span class="comment">// p -&gt; (y (x a b) c)</span></span><br><span class="line">	p := y.parent</span><br><span class="line">	x := y.prev</span><br><span class="line">	b := x.next</span><br><span class="line"></span><br><span class="line">	x.next = y</span><br><span class="line">	y.parent = x</span><br><span class="line">	y.prev = b</span><br><span class="line">	<span class="keyword">if</span> b != <span class="literal">nil</span> &#123;</span><br><span class="line">		b.parent = y</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	x.parent = p</span><br><span class="line">	<span class="keyword">if</span> p == <span class="literal">nil</span> &#123;</span><br><span class="line">		root.treap = x</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> p.prev == y &#123;</span><br><span class="line">		p.prev = x</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> p.next != y &#123;</span><br><span class="line">			throw(<span class="string">&quot;semaRoot rotateRight&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		p.next = x</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/11/04/CHzJr5Z8IXsPFQc.png" alt="未命名文件 _2_.png"></p>
<h2 id="note"><a href="#note" class="headerlink" title="note"></a>note</h2><p>之前看红黑树的时候没有注意这一点：选择左旋还是右旋，是考虑到了旋转后还是bst树。这样就都清晰了。</p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1]<a href="https://byvoid.com/zhs/blog/treap-analysis-and-application/">https://byvoid.com/zhs/blog/treap-analysis-and-application/</a></p>
]]></content>
  </entry>
  <entry>
    <title>golang RWmutex</title>
    <url>/2020-11-04-golang-RWmutex/</url>
    <content><![CDATA[<p>读和读不隔离，写和写通过mutex隔离，写和读通过sema互相配合。</p>
<a id="more"></a>

<h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rw := <span class="built_in">new</span>(sync.RWMutex)</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	<span class="comment">//写锁</span></span><br><span class="line">	rw.Lock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="comment">//读锁</span></span><br><span class="line">			<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				wg.Done()</span><br><span class="line">				rw.RUnlock()</span><br><span class="line">			&#125;()</span><br><span class="line">			rw.RLock()</span><br><span class="line">			fmt.Println(i)</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;print:&quot;</span>)</span><br><span class="line">	rw.Unlock()</span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// There is a modified copy of this file in runtime/rwmutex.go.</span></span><br><span class="line"><span class="comment">// If you make any changes here, see if you should make them there.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A RWMutex is a reader/writer mutual exclusion lock.</span></span><br><span class="line"><span class="comment">// The lock can be held by an arbitrary number of readers or a single writer.</span></span><br><span class="line"><span class="comment">// The zero value for a RWMutex is an unlocked mutex.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A RWMutex must not be copied after first use.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If a goroutine holds a RWMutex for reading and another goroutine might</span></span><br><span class="line"><span class="comment">// call Lock, no goroutine should expect to be able to acquire a read lock</span></span><br><span class="line"><span class="comment">// until the initial read lock is released. In particular, this prohibits</span></span><br><span class="line"><span class="comment">// recursive read locking. This is to ensure that the lock eventually becomes</span></span><br><span class="line"><span class="comment">// available; a blocked Lock call excludes new readers from acquiring the</span></span><br><span class="line"><span class="comment">// lock.</span></span><br><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	w           Mutex  <span class="comment">// held if there are pending writers</span></span><br><span class="line">	writerSem   <span class="keyword">uint32</span> <span class="comment">// semaphore for writers to wait for completing readers</span></span><br><span class="line">    readerSem   <span class="keyword">uint32</span> <span class="comment">// semaphore for readers to wait for completing writers</span></span><br><span class="line">    <span class="comment">//当前读操作的个数</span></span><br><span class="line">    readerCount <span class="keyword">int32</span>  <span class="comment">// number of pending readers</span></span><br><span class="line">    <span class="comment">//被写阻塞的读g的个数</span></span><br><span class="line">	readerWait  <span class="keyword">int32</span>  <span class="comment">// number of departing readers</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rwmutexMaxReaders = <span class="number">1</span> &lt;&lt; <span class="number">30</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="RLock"><a href="#RLock" class="headerlink" title="RLock"></a>RLock</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RLock locks rw for reading.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// It should not be used for recursive read locking; a blocked Lock</span></span><br><span class="line"><span class="comment">// call excludes new readers from acquiring the lock. See the</span></span><br><span class="line"><span class="comment">// documentation on the RWMutex type.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		_ = rw.w.state</span><br><span class="line">		race.Disable()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="number">1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// A writer is pending, wait for it.</span></span><br><span class="line">		runtime_SemacquireMutex(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">		race.Acquire(unsafe.Pointer(&amp;rw.readerSem))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>RLock给readerCount加1</li>
<li>readerCount为负数，表示有写在进行，这里就阻塞了</li>
</ul>
<hr>
<h2 id="RUnlock"><a href="#RUnlock" class="headerlink" title="RUnlock"></a>RUnlock</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RUnlock undoes a single RLock call;</span></span><br><span class="line"><span class="comment">// it does not affect other simultaneous readers.</span></span><br><span class="line"><span class="comment">// It is a run-time error if rw is not locked for reading</span></span><br><span class="line"><span class="comment">// on entry to RUnlock.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RUnlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		_ = rw.w.state</span><br><span class="line">		race.ReleaseMerge(unsafe.Pointer(&amp;rw.writerSem))</span><br><span class="line">		race.Disable()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> r := atomic.AddInt32(&amp;rw.readerCount, <span class="number">-1</span>); r &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Outlined slow-path to allow the fast-path to be inlined</span></span><br><span class="line">		rw.rUnlockSlow(r)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">rUnlockSlow</span><span class="params">(r <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r+<span class="number">1</span> == <span class="number">0</span> || r+<span class="number">1</span> == -rwmutexMaxReaders &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">		throw(<span class="string">&quot;sync: RUnlock of unlocked RWMutex&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// A writer is pending.</span></span><br><span class="line">	<span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerWait, <span class="number">-1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// The last reader unblocks the writer.</span></span><br><span class="line">        <span class="comment">//读读是可以并行的，这里只需要唤醒阻塞的写</span></span><br><span class="line">		runtime_Semrelease(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>RUnlock给readerCount减1</li>
<li>r &lt; 0表示写锁已经加上了还没释放，那么现在的读g就是被阻塞的，所以readerWait要减1，等减到0的时候就可以唤醒写了(阻塞在Lock下的写)</li>
<li>readerWait=0的时候写才会被唤醒</li>
</ul>
<hr>
<h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Lock locks rw for writing.</span></span><br><span class="line"><span class="comment">// If the lock is already locked for reading or writing,</span></span><br><span class="line"><span class="comment">// Lock blocks until the lock is available.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		_ = rw.w.state</span><br><span class="line">		race.Disable()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// First, resolve competition with other writers.</span></span><br><span class="line">	rw.w.Lock()</span><br><span class="line">    <span class="comment">// Announce to readers there is a pending writer.</span></span><br><span class="line">    <span class="comment">//readerCount为负数，阻塞其他的新的读</span></span><br><span class="line">	r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders</span><br><span class="line">    <span class="comment">// Wait for active readers.</span></span><br><span class="line">    <span class="comment">//r就是原来的readerCount，这些读都被写操作阻塞了，记录在readerWait</span></span><br><span class="line">    <span class="comment">//等待被读锁唤醒，每唤醒一个读，readerWait-1</span></span><br><span class="line">    <span class="comment">//这里说明当前有读在进行中，所以写只能阻塞等待被读唤醒。</span></span><br><span class="line">	<span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != <span class="number">0</span> &#123;</span><br><span class="line">		runtime_SemacquireMutex(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">		race.Acquire(unsafe.Pointer(&amp;rw.readerSem))</span><br><span class="line">		race.Acquire(unsafe.Pointer(&amp;rw.writerSem))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>写和写通过rw.w.Lock()隔离，写和读通过sema隔离，读和读不隔离</li>
<li>所有在运行的读都RUnlock了写才被唤醒</li>
</ul>
<hr>
<h2 id="Unlock"><a href="#Unlock" class="headerlink" title="Unlock"></a>Unlock</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Unlock unlocks rw for writing. It is a run-time error if rw is</span></span><br><span class="line"><span class="comment">// not locked for writing on entry to Unlock.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// As with Mutexes, a locked RWMutex is not associated with a particular</span></span><br><span class="line"><span class="comment">// goroutine. One goroutine may RLock (Lock) a RWMutex and then</span></span><br><span class="line"><span class="comment">// arrange for another goroutine to RUnlock (Unlock) it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		_ = rw.w.state</span><br><span class="line">		race.Release(unsafe.Pointer(&amp;rw.readerSem))</span><br><span class="line">		race.Disable()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Announce to readers there is no active writer.</span></span><br><span class="line">	r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)</span><br><span class="line">	<span class="keyword">if</span> r &gt;= rwmutexMaxReaders &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">		throw(<span class="string">&quot;sync: Unlock of unlocked RWMutex&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// Unblock blocked readers, if any.</span></span><br><span class="line">    <span class="comment">//唤醒所有阻塞的读</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(r); i++ &#123;</span><br><span class="line">		runtime_Semrelease(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// Allow other writers to proceed.</span></span><br><span class="line">    <span class="comment">//将锁让给其他的写</span></span><br><span class="line">	rw.w.Unlock()</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>还原readerCount的值</li>
<li>唤醒写加锁后新来的被阻塞的读</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>gin-基本操作</title>
    <url>/2020-11-05-gin-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p><a href="https://github.com/gin-gonic/gin">https://github.com/gin-gonic/gin</a>官方文档的实践，一些值得记录的地方</p>
<a id="more"></a>

<h2 id="jsoniter"><a href="#jsoniter" class="headerlink" title="jsoniter"></a>jsoniter</h2><pre><code>go build -tags=jsoniter .</code></pre>
<p>jsoniter比默认的encoding/json能快点</p>
<h2 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c.Query(&quot;lastname&quot;) &#x2F;&#x2F;shortcut for c.Request.URL.Query().Get(&quot;lastname&quot;)</span><br><span class="line">c.DefaultQuery(&quot;firstname&quot;, &quot;Guest&quot;)</span><br></pre></td></tr></table></figure>

<p>查url中的参数</p>
<h2 id="PostForm"><a href="#PostForm" class="headerlink" title="PostForm"></a>PostForm</h2><p><a href="https://github.com/gin-gonic/gin#multiparturlencoded-form">示例代码</a></p>
<p><img src="https://i.loli.net/2020/11/05/XHFKIpYtiVhamZg.jpg" alt="2020-11-05_form_post.jpg"></p>
<p>这里post的格式只能是<code>form-data</code>或者<code>x-www-form-urlencoded</code></p>
<p><strong>form-data</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">message: m111</span><br><span class="line">Postman-Token: 72271c98-353b-4a80-bdf2-740297332161</span><br><span class="line">Host: localhost:9999</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 30</span><br><span class="line"></span><br><span class="line">message&#x3D;mmmmmm&amp;nick&#x3D;nnnnnnnnnn</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>x-www-form-urlencoded</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">message: m111</span><br><span class="line">Postman-Token: dc3d1280-bbae-46b3-8eda-7df92fa08cd4</span><br><span class="line">Host: localhost:9999</span><br><span class="line">Content-Type: multipart&#x2F;form-data; boundary&#x3D;--------------------------194386765225837300878008</span><br><span class="line">Content-Length: 277</span><br><span class="line"></span><br><span class="line">----------------------------194386765225837300878008</span><br><span class="line">Content-Disposition: form-data; name&#x3D;&quot;message&quot;</span><br><span class="line"></span><br><span class="line">m23333</span><br><span class="line">----------------------------194386765225837300878008</span><br><span class="line">Content-Disposition: form-data; name&#x3D;&quot;nick&quot;</span><br><span class="line"></span><br><span class="line">n11111</span><br><span class="line">----------------------------194386765225837300878008--</span><br></pre></td></tr></table></figure>

<h2 id="FormFile"><a href="#FormFile" class="headerlink" title="FormFile"></a>FormFile</h2><p><strong>curl</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X POST http:&#x2F;&#x2F;localhost:8080&#x2F;upload \</span><br><span class="line">  -F &quot;file&#x3D;@&#x2F;Users&#x2F;appleboy&#x2F;test.zip&quot; \</span><br><span class="line">  -H &quot;Content-Type: multipart&#x2F;form-data&quot;</span><br></pre></td></tr></table></figure>

<p><strong>postman</strong></p>
<p><img src="https://i.loli.net/2020/11/05/r3UKPQXNa9g8HyF.jpg" alt="2020-11-05_formfile.jpg"></p>
<h2 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">v1 :&#x3D; router.Group(&quot;&#x2F;v1&quot;)</span><br><span class="line">	&#123;</span><br><span class="line">		v1.POST(&quot;&#x2F;login&quot;, loginEndpoint)</span><br><span class="line">		v1.POST(&quot;&#x2F;submit&quot;, submitEndpoint)</span><br><span class="line">		v1.POST(&quot;&#x2F;read&quot;, readEndpoint)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>写起来规整，匹配结果是/v1/login  /v1/submit /v1/read</p>
<h2 id="gin-New"><a href="#gin-New" class="headerlink" title="gin.New"></a>gin.New</h2><pre><code>r := gin.New()
r.Use(gin.Logger())</code></pre>
<p>new返回engine,可以自定义中间件</p>
<p>default里面也是调用的New:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Default returns an Engine instance with the Logger and Recovery middleware already attached.</span><br><span class="line">func Default() *Engine &#123;</span><br><span class="line">	debugPrintWARNINGDefault()</span><br><span class="line">	engine :&#x3D; New()</span><br><span class="line">	engine.Use(Logger(), Recovery())</span><br><span class="line">	return engine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CustomRecovery"><a href="#CustomRecovery" class="headerlink" title="CustomRecovery"></a>CustomRecovery</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Recovery middleware recovers from any panics and writes a 500 if there was one.</span><br><span class="line">	r.Use(gin.CustomRecovery(func(c *gin.Context, recovered interface&#123;&#125;) &#123;</span><br><span class="line">		if err, ok :&#x3D; recovered.(string); ok &#123;</span><br><span class="line">			c.String(http.StatusInternalServerError, fmt.Sprintf(&quot;error: %s&quot;, err))</span><br><span class="line">		&#125;</span><br><span class="line">		c.AbortWithStatus(http.StatusInternalServerError)</span><br><span class="line">	&#125;))</span><br><span class="line"></span><br><span class="line">	r.GET(&quot;&#x2F;panic&quot;, func(c *gin.Context) &#123;</span><br><span class="line">		&#x2F;&#x2F; panic with a string -- the custom middleware could save this to a database or report it to the user</span><br><span class="line">		panic(&quot;foo&quot;)</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<p>catch到panic,保证服务稳定运行</p>
<h2 id="Model-binding"><a href="#Model-binding" class="headerlink" title="Model binding"></a>Model binding</h2><p><a href="https://github.com/gin-gonic/gin#model-binding-and-validation">示例代码</a></p>
<p>bind默认情况下只要bind的参数带了，即使是空，也不认为有问题。<code>binding:&quot;required&quot;</code>可以用来约束bind的字段不为空</p>
<p>BindJSON如果bind的字段没带齐，直接返回404了。</p>
<p>ShouldBindJSON如果bind的字段没带齐，需要自行处理:<code>err := c.ShouldBindJSON(&amp;json); err != nil </code></p>
<h2 id="Validators"><a href="#Validators" class="headerlink" title="Validators"></a>Validators</h2><p><a href="https://github.com/gin-gonic/gin#custom-validators">示例代码</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Booking struct &#123;</span><br><span class="line">	CheckIn  time.Time &#96;form:&quot;check_in&quot; binding:&quot;required,bookabledate&quot; time_format:&quot;2006-01-02&quot;&#96;</span><br><span class="line">	CheckOut time.Time &#96;form:&quot;check_out&quot; binding:&quot;required,gtfield&#x3D;CheckIn&quot; time_format:&quot;2006-01-02&quot;&#96;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if v, ok :&#x3D; binding.Validator.Engine().(*validator.Validate); ok &#123;</span><br><span class="line">		v.RegisterValidation(&quot;bookabledate&quot;, bookableDate)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">var bookableDate validator.Func &#x3D; func(fl validator.FieldLevel) bool &#123;</span><br><span class="line">	date, ok :&#x3D; fl.Field().Interface().(time.Time)</span><br><span class="line">	if ok &#123;</span><br><span class="line">		today :&#x3D; time.Now()</span><br><span class="line">		if today.After(date) &#123;</span><br><span class="line">			return false</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码注册一个新的Tag，本身validator是有很多默认的Tag的，比如email或者上面代码中的gtfield=CheckIn,表示大于CheckIn.具体参考<a href="https://frankhitman.github.io/zh-CN/gin-validator/">https://frankhitman.github.io/zh-CN/gin-validator/</a></p>
<h2 id="BindQuery"><a href="#BindQuery" class="headerlink" title="BindQuery"></a>BindQuery</h2><p><a href="https://github.com/gin-gonic/gin#only-bind-query-string">示例代码</a></p>
<p>BindQuery或者ShouldBindQuery只绑定url中的字段，忽略post的body带的参数</p>
<p>具体可看<a href="https://github.com/gin-gonic/gin/issues/742">https://github.com/gin-gonic/gin/issues/742</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># only bind query</span><br><span class="line">$ curl -X GET &quot;localhost:8085&#x2F;testing?name&#x3D;eason&amp;address&#x3D;xyz&quot;</span><br><span class="line"></span><br><span class="line"># only bind query string, ignore form data</span><br><span class="line">$ curl -X POST &quot;localhost:8085&#x2F;testing?name&#x3D;eason&amp;address&#x3D;xyz&quot; --data &#39;name&#x3D;ignore&amp;address&#x3D;ignore&#39; -H &quot;Content-Type:application&#x2F;x-www-form-urlencoded&quot;</span><br></pre></td></tr></table></figure>

<h2 id="Bind"><a href="#Bind" class="headerlink" title="Bind"></a>Bind</h2><p>Bind和ShouldBind对于url和post的body都进行绑定</p>
<h2 id="BindUri"><a href="#BindUri" class="headerlink" title="BindUri"></a>BindUri</h2><p><a href="https://github.com/gin-gonic/gin#bind-uri">示例代码</a></p>
<h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p><a href="https://github.com/gin-gonic/gin#jsonp">示例代码</a></p>
<p>返回函数名包裹上参数，比json多了个callback</p>
<pre><code> curl http://127.0.0.1:8080/JSONP\?callback\=x
x(&#123;&quot;foo&quot;:&quot;bar&quot;&#125;);%</code></pre>
<h2 id="Serving-static-files"><a href="#Serving-static-files" class="headerlink" title="Serving static files"></a>Serving static files</h2><p><a href="https://github.com/gin-gonic/gin#serving-static-files">示例代码</a></p>
<h2 id="Custom-Middleware"><a href="#Custom-Middleware" class="headerlink" title="Custom Middleware"></a>Custom Middleware</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Logger</span><span class="params">()</span> <span class="title">gin</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		t := time.Now()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Set example variable</span></span><br><span class="line">		c.Set(<span class="string">&quot;example&quot;</span>, <span class="string">&quot;12345&quot;</span>)</span><br><span class="line">		fmt.Println(<span class="string">&quot;12345&quot;</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// before request</span></span><br><span class="line"></span><br><span class="line">		c.Next()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// after request</span></span><br><span class="line">		latency := time.Since(t)</span><br><span class="line">		log.Print(latency)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// access the status we are sending</span></span><br><span class="line">		status := c.Writer.Status()</span><br><span class="line">		log.Println(status)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Logger2</span><span class="params">()</span> <span class="title">gin</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		t := time.Now()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Set example variable</span></span><br><span class="line">		c.Set(<span class="string">&quot;example&quot;</span>, <span class="string">&quot;abcde&quot;</span>)</span><br><span class="line">		fmt.Println(<span class="string">&quot;abcde&quot;</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// before request</span></span><br><span class="line"></span><br><span class="line">		c.Next()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// after request</span></span><br><span class="line">		latency := time.Since(t)</span><br><span class="line">		log.Print(latency)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// access the status we are sending</span></span><br><span class="line">		status := c.Writer.Status()</span><br><span class="line">		log.Println(status)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.New()</span><br><span class="line">	r.Use(Logger())</span><br><span class="line">	r.Use(Logger2())</span><br><span class="line"></span><br><span class="line">	r.GET(<span class="string">&quot;/test&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		example := c.MustGet(<span class="string">&quot;example&quot;</span>).(<span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// it would print: &quot;12345&quot;</span></span><br><span class="line">		log.Println(example)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Listen and serve on 0.0.0.0:8080</span></span><br><span class="line">	r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>output</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[GIN-debug] Listening and serving HTTP on :8080</span><br><span class="line">12345</span><br><span class="line">abcde</span><br><span class="line">2020&#x2F;11&#x2F;05 19:39:47 abcde</span><br><span class="line">2020&#x2F;11&#x2F;05 19:39:47 203.826µs</span><br><span class="line">2020&#x2F;11&#x2F;05 19:39:47 200</span><br><span class="line">2020&#x2F;11&#x2F;05 19:39:47 243.954µs</span><br><span class="line">2020&#x2F;11&#x2F;05 19:39:47 200</span><br></pre></td></tr></table></figure>

<p>可以仿照自己写一个中间件，在请求执行的过程中会执行所有中间件。具体后面看代码了再分析</p>
<h2 id="BasicAuth"><a href="#BasicAuth" class="headerlink" title="BasicAuth"></a>BasicAuth</h2><p><a href="https://github.com/gin-gonic/gin#using-basicauth-middleware">示例代码</a></p>
<p>BasicAuth是一种鉴权的方式,具体参考<a href="https://cjting.me/2018/03/31/how-http-basic-auth-work/">HTTP Basic Auth 是怎么样工作的</a></p>
<p>示例代码效果演示：</p>
<p><img src="https://i.loli.net/2020/11/05/G7R25UCLueAcZXs.jpg" alt="2020-11-05_secret.jpg"></p>
<p>报文：</p>
<p><img src="https://i.loli.net/2020/11/05/cjs4pmFT9dh7J2A.jpg" alt="2020-11-05_401.jpg"></p>
<h2 id="Goroutines-inside-a-middleware"><a href="#Goroutines-inside-a-middleware" class="headerlink" title="Goroutines inside a middleware"></a>Goroutines inside a middleware</h2><p><a href="https://github.com/gin-gonic/gin#goroutines-inside-a-middleware">示例代码</a></p>
<p>gin下的context不是原生的context,它是并发不安全的，所以协程里面使用copy，不要用传进来的context.可参考<a href="https://www.jianshu.com/p/b3a6d5680e7c">https://www.jianshu.com/p/b3a6d5680e7c</a></p>
<h2 id="Custom-HTTP-configuration"><a href="#Custom-HTTP-configuration" class="headerlink" title="Custom HTTP configuration"></a>Custom HTTP configuration</h2><p><a href="https://github.com/gin-gonic/gin#custom-http-configuration">示例代码</a></p>
<h2 id="Run-multiple-service-using-Gin"><a href="#Run-multiple-service-using-Gin" class="headerlink" title="Run multiple service using Gin"></a>Run multiple service using Gin</h2><p><a href="https://github.com/gin-gonic/gin#run-multiple-service-using-gin">示例代码</a></p>
<p>可监听多个端口，处理相同的请求。</p>
<hr>
<p>其他根据官方文档执行下就好</p>
]]></content>
  </entry>
  <entry>
    <title>redis sorted set</title>
    <url>/2020-11-06-redis-sorted-set/</url>
    <content><![CDATA[<div class="note info">
            <p>redis有序结合的命令部分熟悉</p>
          </div>

<a id="more"></a>

<h2 id="BZPOPMAX"><a href="#BZPOPMAX" class="headerlink" title="BZPOPMAX"></a>BZPOPMAX</h2><blockquote>
<p>BZPOPMAX key [key …] timeout</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bzpopmax set2 set3 1    &#x2F;&#x2F;阻塞1s后返回nil</span><br><span class="line">(nil)</span><br><span class="line">(1.02s)</span><br><span class="line">127.0.0.1:6379&gt; bzpopmax set2 set3 0    &#x2F;&#x2F;set2和set3都是empty,timeout&#x3D;0永久阻塞 </span><br><span class="line">^C</span><br><span class="line">127.0.0.1:6379&gt; bzpopmax set0 set1 0    &#x2F;&#x2F;set0和set1都是非空，返回set0的第一个max元素</span><br><span class="line">1) &quot;set0&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;20&quot;</span><br><span class="line">127.0.0.1:6379&gt; bzpopmax set2 set1 0    &#x2F;&#x2F;set2是空，set1非空，返回非空的set1</span><br><span class="line">1) &quot;set1&quot;</span><br><span class="line">2) &quot;a&quot;</span><br><span class="line">3) &quot;1&quot;</span><br></pre></td></tr></table></figure>

<h2 id="BZPOPMIN"><a href="#BZPOPMIN" class="headerlink" title="BZPOPMIN"></a>BZPOPMIN</h2><p>同上，一个最大一个最小</p>
<h2 id="ZADD"><a href="#ZADD" class="headerlink" title="ZADD"></a>ZADD</h2><h3 id="options"><a href="#options" class="headerlink" title="options"></a>options</h3><ul>
<li>XX    只更新已存在的成员，不新增</li>
<li>NX    不更新已经存在的成员，总是新增</li>
<li>LT    如果新的分数比原来的小则更新，不新增    //ver&gt;=6.2: Added the GT and LT options.</li>
<li>GT    如果新的分数比原来的大则更新，不新增    //ver&gt;=6.2: Added the GT and LT options.</li>
<li>CH    修改返回值为发生变化的成员个数(区别原来是返回新增的成员个数)</li>
<li>INCR  类似ZINCRBY命令，增加成员的分数，只能增加一个成员</li>
</ul>
<h3 id="return-value"><a href="#return-value" class="headerlink" title="return value"></a>return value</h3><ul>
<li>默认返回新增的成员数量，不包括更新的 If the INCR option is specified, the return value will be Bulk string reply:</li>
<li>The new score of member (a double precision floating point number) represented as string, or nil if the operation was aborted (when called with either the XX or the NX option).</li>
</ul>
<h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZADD set0 10 a 20 b</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; ZADD set0 XX 11 a 30 c  &#x2F;&#x2F;更新a,新增c失败</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE set0 0 -1 WITHSCORES</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;11&quot;</span><br><span class="line">3) &quot;b&quot;</span><br><span class="line">4) &quot;20&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZADD set0 NX 40 d 12 a  &#x2F;&#x2F;新增d,更新a失败</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE set0 0 -1 WITHSCORES</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;11&quot;</span><br><span class="line">3) &quot;b&quot;</span><br><span class="line">4) &quot;20&quot;</span><br><span class="line">5) &quot;d&quot;</span><br><span class="line">6) &quot;40&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZADD set0 LT 10 a 21 b</span><br><span class="line">(error) ERR syntax error</span><br><span class="line">127.0.0.1:6379&gt; ZADD set0 LT 10 a   &#x2F;&#x2F;当前版本不支持</span><br><span class="line">(error) ERR syntax error</span><br><span class="line">127.0.0.1:6379&gt; ZADD set0 CH 12 a 30 c  &#x2F;&#x2F;变化变化的总数</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE set0 0 -1 WITHSCORES</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;12&quot;</span><br><span class="line">3) &quot;b&quot;</span><br><span class="line">4) &quot;20&quot;</span><br><span class="line">5) &quot;c&quot;</span><br><span class="line">6) &quot;30&quot;</span><br><span class="line">7) &quot;d&quot;</span><br><span class="line">8) &quot;40&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZADD set0 CH XX 11 a    &#x2F;&#x2F;配合其他参数</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ZADD set0 XX 13 a       &#x2F;&#x2F;区别老的返回值</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; ZADD set0 50.1 e    &#x2F;&#x2F;支持浮点数</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE set0 0 -1 WITHSCORES</span><br><span class="line"> 1) &quot;a&quot;</span><br><span class="line"> 2) &quot;13&quot;</span><br><span class="line"> 3) &quot;b&quot;</span><br><span class="line"> 4) &quot;20&quot;</span><br><span class="line"> 5) &quot;c&quot;</span><br><span class="line"> 6) &quot;30&quot;</span><br><span class="line"> 7) &quot;d&quot;</span><br><span class="line"> 8) &quot;40&quot;</span><br><span class="line"> 9) &quot;e&quot;</span><br><span class="line">10) &quot;50.100000000000001&quot;</span><br></pre></td></tr></table></figure>

<h2 id="ZCARD"><a href="#ZCARD" class="headerlink" title="ZCARD"></a>ZCARD</h2><p>返回key的元素个数，如果key不存在，返回0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd set1 1 a 2 b 3 c</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zcard set1</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zcard set10</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>

<h2 id="ZCOUNT"><a href="#ZCOUNT" class="headerlink" title="ZCOUNT"></a>ZCOUNT</h2><blockquote>
<p>ZCOUNT key min max</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd set7 1 a 3 b 3 c 4 d</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; zcount set7 1 4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; zcount set7 [1 (4   &#x2F;&#x2F;不支持[</span><br><span class="line">(error) ERR min or max is not a float</span><br><span class="line">127.0.0.1:6379&gt; zcount set7 1 (4</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zcount set7 -inf +inf</span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure>

<h2 id="ZINCRBY"><a href="#ZINCRBY" class="headerlink" title="ZINCRBY"></a>ZINCRBY</h2><blockquote>
<p>ZINCRBY key increment member</p>
</blockquote>
<p>给元素的分数增加/递减</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange set7 0 -1 withscores</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;b&quot;</span><br><span class="line">4) &quot;3&quot;</span><br><span class="line">5) &quot;c&quot;</span><br><span class="line">6) &quot;3&quot;</span><br><span class="line">7) &quot;d&quot;</span><br><span class="line">8) &quot;4&quot;</span><br><span class="line">127.0.0.1:6379&gt; zincrby set7 2 a</span><br><span class="line">&quot;3&quot;</span><br><span class="line">127.0.0.1:6379&gt; zincrby set7 -1 a</span><br><span class="line">&quot;2&quot;</span><br><span class="line">127.0.0.1:6379&gt; zincrby set7 5 e</span><br><span class="line">&quot;5&quot;</span><br></pre></td></tr></table></figure>

<h2 id="ZINTER"><a href="#ZINTER" class="headerlink" title="ZINTER"></a>ZINTER</h2><p><a href="https://redis.io/commands/zinter">https://redis.io/commands/zinter</a></p>
<h2 id="ZINTERSTORE"><a href="#ZINTERSTORE" class="headerlink" title="ZINTERSTORE"></a>ZINTERSTORE</h2><blockquote>
<p>ZINTERSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX]</p>
</blockquote>
<p>取有序集合的交合到一个key中<a href="http://redis.cn/commands/zinterstore.html">http://redis.cn/commands/zinterstore.html</a></p>
<h2 id="ZLEXCOUNT"><a href="#ZLEXCOUNT" class="headerlink" title="ZLEXCOUNT"></a>ZLEXCOUNT</h2><blockquote>
<p>ZLEXCOUNT key min max</p>
</blockquote>
<p>计算有序集合元素之间的元素数量，key的元素分数相同才有意义<a href="http://redis.cn/commands/zlexcount.html">http://redis.cn/commands/zlexcount.html</a></p>
<h2 id="ZMSCORE"><a href="#ZMSCORE" class="headerlink" title="ZMSCORE"></a>ZMSCORE</h2><p><a href="https://redis.io/commands/zmscore">https://redis.io/commands/zmscore</a></p>
<h2 id="ZPOPMAX"><a href="#ZPOPMAX" class="headerlink" title="ZPOPMAX"></a>ZPOPMAX</h2><p>弹出最大的值，默认1个，可加参数调整弹出的个数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange set0 0 -1 withscores</span><br><span class="line"> 1) &quot;a&quot;</span><br><span class="line"> 2) &quot;16.010000000000002&quot;</span><br><span class="line"> 3) &quot;b&quot;</span><br><span class="line"> 4) &quot;20&quot;</span><br><span class="line"> 5) &quot;g&quot;</span><br><span class="line"> 6) &quot;70&quot;</span><br><span class="line"> 7) &quot;g0&quot;</span><br><span class="line"> 8) &quot;70&quot;</span><br><span class="line"> 9) &quot;g1&quot;</span><br><span class="line">10) &quot;70&quot;</span><br><span class="line">11) &quot;g2&quot;</span><br><span class="line">12) &quot;70&quot;</span><br><span class="line">13) &quot;g3&quot;</span><br><span class="line">14) &quot;70&quot;</span><br><span class="line">127.0.0.1:6379&gt; zpopmax set0</span><br><span class="line">1) &quot;g3&quot;</span><br><span class="line">2) &quot;70&quot;</span><br><span class="line">127.0.0.1:6379&gt; zpopmax set0 3</span><br><span class="line">1) &quot;g2&quot;</span><br><span class="line">2) &quot;70&quot;</span><br><span class="line">3) &quot;g1&quot;</span><br><span class="line">4) &quot;70&quot;</span><br><span class="line">5) &quot;g0&quot;</span><br><span class="line">6) &quot;70&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrange set0 0 -1 withscores</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;16.010000000000002&quot;</span><br><span class="line">3) &quot;b&quot;</span><br><span class="line">4) &quot;20&quot;</span><br><span class="line">5) &quot;g&quot;</span><br><span class="line">6) &quot;70&quot;</span><br></pre></td></tr></table></figure>

<h2 id="ZPOPMIN"><a href="#ZPOPMIN" class="headerlink" title="ZPOPMIN"></a>ZPOPMIN</h2><p>同上，弹出最小的值，默认1个，可加参数调整弹出的个数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zpopmin set0 1</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; zpopmin set0 3</span><br><span class="line">1) &quot;c1&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;c2&quot;</span><br><span class="line">4) &quot;1&quot;</span><br><span class="line">5) &quot;c3&quot;</span><br><span class="line">6) &quot;1&quot;</span><br></pre></td></tr></table></figure>

<h2 id="ZRANGE"><a href="#ZRANGE" class="headerlink" title="ZRANGE"></a>ZRANGE</h2><blockquote>
<p>ZRANGE key start stop [WITHSCORES]</p>
</blockquote>
<p>返回一个区间的结果数组,strat从0开始，stop从zcard-1/-1开始,<code>WITHSCORES</code>结果带上score</p>
<p>结果按分数升序排列，相同分数的按key的字典正序排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange set1 0 3 withscores  &#x2F;&#x2F;3大于右边界，退化成2</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;b&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">5) &quot;c&quot;</span><br><span class="line">6) &quot;3&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrange set1 0 0 withscores</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrange set1 0 2 withscores</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;b&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">5) &quot;c&quot;</span><br><span class="line">6) &quot;3&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrange set1 0 -1 withscores &#x2F;&#x2F;-1表示右边第一个值</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;b&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">5) &quot;c&quot;</span><br><span class="line">6) &quot;3&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrange set1 0 -2 withscores &#x2F;&#x2F;-2表示右边第二个值</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;b&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrange set1 -1 -2 withscores    &#x2F;&#x2F;左边-1就越界了</span><br><span class="line">(empty list or set)</span><br><span class="line">127.0.0.1:6379&gt; zrange set1 0 -1 withscores     &#x2F;&#x2F;分数升序，字典正序</span><br><span class="line"> 1) &quot;a&quot;</span><br><span class="line"> 2) &quot;1&quot;</span><br><span class="line"> 3) &quot;b&quot;</span><br><span class="line"> 4) &quot;2&quot;</span><br><span class="line"> 5) &quot;c&quot;</span><br><span class="line"> 6) &quot;3&quot;</span><br><span class="line"> 7) &quot;c1&quot;</span><br><span class="line"> 8) &quot;3&quot;</span><br><span class="line"> 9) &quot;c2&quot;</span><br><span class="line">10) &quot;3&quot;</span><br></pre></td></tr></table></figure>

<h2 id="ZRANGEBYLEX"><a href="#ZRANGEBYLEX" class="headerlink" title="ZRANGEBYLEX"></a>ZRANGEBYLEX</h2><blockquote>
<p>ZRANGEBYLEX key min max [LIMIT offset count]</p>
</blockquote>
<p>对分数相同的元素进行ascii排序，通过memcmp函数，如果key中元素分数不一致就不要用</p>
<p>min,max的使用</p>
<ul>
<li>-表示最左边的元素，+表示最右边的元素</li>
<li><code>[</code>是包含,<code>(</code>不包含</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd set3 0 aaa 0 aba 0 abc 0 bbb 0 bcb 0 bcc 0 ccc</span><br><span class="line">(integer) 7</span><br><span class="line">127.0.0.1:6379&gt; zrangebylex set3 - +    &#x2F;&#x2F;列出所有</span><br><span class="line">1) &quot;aaa&quot;</span><br><span class="line">2) &quot;aba&quot;</span><br><span class="line">3) &quot;abc&quot;</span><br><span class="line">4) &quot;bbb&quot;</span><br><span class="line">5) &quot;bcb&quot;</span><br><span class="line">6) &quot;bcc&quot;</span><br><span class="line">7) &quot;ccc&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrangebylex set3 - + LIMIT 0 7  &#x2F;&#x2F;offset count</span><br><span class="line">1) &quot;aaa&quot;</span><br><span class="line">2) &quot;aba&quot;</span><br><span class="line">3) &quot;abc&quot;</span><br><span class="line">4) &quot;bbb&quot;</span><br><span class="line">5) &quot;bcb&quot;</span><br><span class="line">6) &quot;bcc&quot;</span><br><span class="line">7) &quot;ccc&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrangebylex set3 - + LIMIT 1 2</span><br><span class="line">1) &quot;aba&quot;</span><br><span class="line">2) &quot;abc&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrangebylex set3 [a (b  &#x2F;&#x2F;以a开头的</span><br><span class="line">1) &quot;aaa&quot;</span><br><span class="line">2) &quot;aba&quot;</span><br><span class="line">3) &quot;abc&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrangebylex set3 [ab (ac    &#x2F;&#x2F;以ab开头的</span><br><span class="line">1) &quot;aba&quot;</span><br><span class="line">2) &quot;abc&quot;</span><br></pre></td></tr></table></figure>

<h2 id="ZRANGEBYSCORE"><a href="#ZRANGEBYSCORE" class="headerlink" title="ZRANGEBYSCORE"></a>ZRANGEBYSCORE</h2><blockquote>
<p>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</p>
</blockquote>
<p>ZRANGEBYSCORE和ZRANGE配合WITHSCORES还是有区别的.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd set4 1 a  2 b  3 c  4 d 5 e 6 f</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore set4 - +  &#x2F;&#x2F;不支持这种格式</span><br><span class="line">(error) ERR min or max is not a float</span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore set4 -inf +inf    &#x2F;&#x2F;所有元素</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;c&quot;</span><br><span class="line">4) &quot;d&quot;</span><br><span class="line">5) &quot;e&quot;</span><br><span class="line">6) &quot;f&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore set4 -inf +inf LIMIT 1 2  &#x2F;&#x2F;limit</span><br><span class="line">1) &quot;b&quot;</span><br><span class="line">2) &quot;c&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore set4 -inf +inf WITHSCORES LIMIT 1 2   &#x2F;&#x2F;withscores</span><br><span class="line">1) &quot;b&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;c&quot;</span><br><span class="line">4) &quot;3&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore set4 [1 [3 WITHSCORES LIMIT 1 2   &#x2F;&#x2F;不支持[</span><br><span class="line">(error) ERR min or max is not a float</span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore set4 1 3 WITHSCORES LIMIT 1 2</span><br><span class="line">1) &quot;b&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;c&quot;</span><br><span class="line">4) &quot;3&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore set4 (1 (3 WITHSCORES LIMIT 1 2</span><br><span class="line">(empty list or set)</span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore set4 (1 (3 WITHSCORES &#x2F;&#x2F;支持(</span><br><span class="line">1) &quot;b&quot;</span><br><span class="line">2) &quot;2&quot;</span><br></pre></td></tr></table></figure>

<h2 id="ZRANK"><a href="#ZRANK" class="headerlink" title="ZRANK"></a>ZRANK</h2><blockquote>
<p>ZRANK key member</p>
</blockquote>
<p>返回元素按score的排名，从低到高，不存在的话返回nil</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd set5 1 a 2 b 3 c 4 d 5 e</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; zrank set5 a</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; zrank set5 b</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zrank set5 k</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<h2 id="ZREM"><a href="#ZREM" class="headerlink" title="ZREM"></a>ZREM</h2><blockquote>
<p>ZREM key member [member …]</p>
</blockquote>
<p>remove元素，支持一次删除多个(ver&gt;=2.4),返回删除成功的元素个数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange set5 0 -1 withscores</span><br><span class="line"> 1) &quot;a&quot;</span><br><span class="line"> 2) &quot;1&quot;</span><br><span class="line"> 3) &quot;b&quot;</span><br><span class="line"> 4) &quot;2&quot;</span><br><span class="line"> 5) &quot;c&quot;</span><br><span class="line"> 6) &quot;3&quot;</span><br><span class="line"> 7) &quot;d&quot;</span><br><span class="line"> 8) &quot;4&quot;</span><br><span class="line"> 9) &quot;e&quot;</span><br><span class="line">10) &quot;5&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrem set5 a b c o</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zrange set5 0 -1 withscores</span><br><span class="line">1) &quot;d&quot;</span><br><span class="line">2) &quot;4&quot;</span><br><span class="line">3) &quot;e&quot;</span><br><span class="line">4) &quot;5&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrem set5 p</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>

<h2 id="ZREMRANGEBYLEX"><a href="#ZREMRANGEBYLEX" class="headerlink" title="ZREMRANGEBYLEX"></a>ZREMRANGEBYLEX</h2><blockquote>
<p>ZREMRANGEBYLEX key min max</p>
</blockquote>
<p>rangeby只对分数相同的key有效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange set3 0 -1 withscores</span><br><span class="line"> 1) &quot;aaa&quot;</span><br><span class="line"> 2) &quot;0&quot;</span><br><span class="line"> 3) &quot;aba&quot;</span><br><span class="line"> 4) &quot;0&quot;</span><br><span class="line"> 5) &quot;abc&quot;</span><br><span class="line"> 6) &quot;0&quot;</span><br><span class="line"> 7) &quot;bbb&quot;</span><br><span class="line"> 8) &quot;0&quot;</span><br><span class="line"> 9) &quot;bcb&quot;</span><br><span class="line">10) &quot;0&quot;</span><br><span class="line">11) &quot;bcc&quot;</span><br><span class="line">12) &quot;0&quot;</span><br><span class="line">13) &quot;ccc&quot;</span><br><span class="line">14) &quot;0&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrangebylex set3 - +</span><br><span class="line">1) &quot;aaa&quot;</span><br><span class="line">2) &quot;aba&quot;</span><br><span class="line">3) &quot;abc&quot;</span><br><span class="line">4) &quot;bbb&quot;</span><br><span class="line">5) &quot;bcb&quot;</span><br><span class="line">6) &quot;bcc&quot;</span><br><span class="line">7) &quot;ccc&quot;</span><br><span class="line">127.0.0.1:6379&gt; zremrangebylex set3 [a (b   &#x2F;&#x2F;删除以a开头的</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zrange set3 0 -1 withscores</span><br><span class="line">1) &quot;bbb&quot;</span><br><span class="line">2) &quot;0&quot;</span><br><span class="line">3) &quot;bcb&quot;</span><br><span class="line">4) &quot;0&quot;</span><br><span class="line">5) &quot;bcc&quot;</span><br><span class="line">6) &quot;0&quot;</span><br><span class="line">7) &quot;ccc&quot;</span><br><span class="line">8) &quot;0&quot;</span><br></pre></td></tr></table></figure>

<h2 id="ZREMRANGEBYRANK"><a href="#ZREMRANGEBYRANK" class="headerlink" title="ZREMRANGEBYRANK"></a>ZREMRANGEBYRANK</h2><blockquote>
<p>ZREMRANGEBYRANK key start stop</p>
</blockquote>
<p>删除按分数排名的区间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange set4 0 -1 withscores</span><br><span class="line"> 1) &quot;a&quot;</span><br><span class="line"> 2) &quot;1&quot;</span><br><span class="line"> 3) &quot;b&quot;</span><br><span class="line"> 4) &quot;2&quot;</span><br><span class="line"> 5) &quot;c&quot;</span><br><span class="line"> 6) &quot;3&quot;</span><br><span class="line"> 7) &quot;d&quot;</span><br><span class="line"> 8) &quot;4&quot;</span><br><span class="line"> 9) &quot;e&quot;</span><br><span class="line">10) &quot;5&quot;</span><br><span class="line">11) &quot;f&quot;</span><br><span class="line">12) &quot;6&quot;</span><br><span class="line">127.0.0.1:6379&gt; zremrangebyrank set4 0 2    &#x2F;&#x2F;删除前三个</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zrange set4 0 -1 withscores</span><br><span class="line">1) &quot;d&quot;</span><br><span class="line">2) &quot;4&quot;</span><br><span class="line">3) &quot;e&quot;</span><br><span class="line">4) &quot;5&quot;</span><br><span class="line">5) &quot;f&quot;</span><br><span class="line">6) &quot;6&quot;</span><br><span class="line">127.0.0.1:6379&gt; zremrangebyrank set4 -3 -2  &#x2F;&#x2F;删除倒数第2，3个</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; zrange set4 0 -1 withscores</span><br><span class="line">1) &quot;f&quot;</span><br><span class="line">2) &quot;6&quot;</span><br></pre></td></tr></table></figure>

<h2 id="ZREMRANGEBYSCORE"><a href="#ZREMRANGEBYSCORE" class="headerlink" title="ZREMRANGEBYSCORE"></a>ZREMRANGEBYSCORE</h2><blockquote>
<p>ZREMRANGEBYSCORE key min max</p>
</blockquote>
<p><a href="https://redis.io/commands/zremrangebyscore">https://redis.io/commands/zremrangebyscore</a></p>
<h2 id="ZREVRANGE"><a href="#ZREVRANGE" class="headerlink" title="ZREVRANGE"></a>ZREVRANGE</h2><p>同上取反</p>
<h2 id="ZREVRANGEBYLEX"><a href="#ZREVRANGEBYLEX" class="headerlink" title="ZREVRANGEBYLEX"></a>ZREVRANGEBYLEX</h2><p>同上取反</p>
<h2 id="ZREVRANGEBYSCORE"><a href="#ZREVRANGEBYSCORE" class="headerlink" title="ZREVRANGEBYSCORE"></a>ZREVRANGEBYSCORE</h2><p>同上取反</p>
<h2 id="ZREVRANK"><a href="#ZREVRANK" class="headerlink" title="ZREVRANK"></a>ZREVRANK</h2><p>同上取反</p>
<h2 id="ZSCAN"><a href="#ZSCAN" class="headerlink" title="ZSCAN"></a>ZSCAN</h2><h2 id="ZSCORE"><a href="#ZSCORE" class="headerlink" title="ZSCORE"></a>ZSCORE</h2><h2 id="ZUNION"><a href="#ZUNION" class="headerlink" title="ZUNION"></a>ZUNION</h2><h2 id="ZUNIONSTORE"><a href="#ZUNIONSTORE" class="headerlink" title="ZUNIONSTORE"></a>ZUNIONSTORE</h2><h2 id="time-comlexity"><a href="#time-comlexity" class="headerlink" title="time comlexity"></a>time comlexity</h2><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1]<a href="https://redis.io/commands/zrangebylex">https://redis.io/commands/zrangebylex</a></p>
<p>[2]<a href="http://redis.cn/commands/zrangebyscore.html">http://redis.cn/commands/zrangebyscore.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>c++ volatile  atomic</title>
    <url>/2021-02-24-c++%20volatile%20atomic/</url>
    <content><![CDATA[<div class="note success">
            <p>最早接触valotile是在程序员的自我修养看到的，当时似懂非懂。这篇文章也挂在blog快一年了，今天重新查找资料，才算看明白了个大概。特此记录，毕竟是应用开发者，到此为止了</p>
          </div>

<a id="more"></a>

<h2 id="定义和区别"><a href="#定义和区别" class="headerlink" title="定义和区别"></a>定义和区别</h2><div class="note primary">
            <p>volatile是作用在单线程下，针对特定内存使用的。</p><p>atomic是c++11提供的原子类操作</p>
          </div>

<table>
<thead>
<tr>
<th></th>
<th>原子性</th>
<th>可见性</th>
<th>有序性</th>
<th>禁用优化</th>
</tr>
</thead>
<tbody><tr>
<td>atomic</td>
<td>cas实现</td>
<td>缓存一致性实现</td>
<td>内存屏障实现</td>
<td>不支持</td>
</tr>
<tr>
<td>volatile</td>
<td>不支持</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
</tbody></table>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x = y;</span><br><span class="line">a = b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可能被调整为</span></span><br><span class="line">a = b;</span><br><span class="line">x = y;</span><br></pre></td></tr></table></figure>

<h2 id="禁用优化："><a href="#禁用优化：" class="headerlink" title="禁用优化："></a>禁用优化：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//--------------</span></span><br><span class="line"><span class="keyword">int</span> a = b;</span><br><span class="line">a = b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c = <span class="number">10</span>;</span><br><span class="line">c = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可能会被编译期优化为</span></span><br><span class="line"><span class="keyword">int</span> a = b;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; <span class="title">y</span><span class="params">(x.load())</span></span>;  <span class="comment">// 读取x</span></span><br><span class="line">y.store(x.load());             <span class="comment">// 再次读取x</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//可能被优化为</span></span><br><span class="line"><span class="comment">//导致x的变化不可知</span></span><br><span class="line"><span class="keyword">register</span> = x.load();           <span class="comment">// 将x读入寄存器</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; <span class="title">y</span><span class="params">(<span class="keyword">register</span>)</span></span>;  <span class="comment">// 用寄存器值初始化y</span></span><br><span class="line">y.store(<span class="keyword">register</span>);             <span class="comment">// 将寄存器值保存至y</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>atomic和volatile是完全不同的东西。</li>
<li>atomic可用在多线程中，对小数据进行原子操作，是安全的</li>
<li>volatile用于特殊内存防止编译器级别的优化，atomic用于普通内存，优化没有副作用，如果是特殊内存就用volatile,如果并且是多线程，可以叠加atomic使用</li>
<li>可以搭配一起使用，atomic并不能取代volatile的作用，volatile也没有atomic的功能</li>
</ul>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://zhuanlan.zhihu.com/p/33074506">谈谈 C/C++ 中的 volatile</a></p>
<p><a href="https://github.com/GHScan/TechNotes/blob/master/2017/Memory_Model.md">Memory Model: 从多处理器到高级语言</a></p>
<p><a href="https://blog.csdn.net/armlinuxww/article/details/103096653">GCC 原子操作中 Acquire/Release/Consume/Relaxed 内存模型</a></p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/04/24/X8ycBQlvi5grs2a.jpg" alt="67243791_p0_lit.jpg"></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>http basis</title>
    <url>/2021-02-24-http%20basis/</url>
    <content><![CDATA[<div class="note warning">
            
          </div>

<a id="more"></a>

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>http(HyperText transfer protocol)是超文本传输协议</p>
<p>超文本： 文字，音频，视频等<br>传输：不同于路由协议，隧道协议，传输协议用于两方交换数据<br>协议：符合rfc规范的应用层协议</p>
<h2 id="相关技术"><a href="#相关技术" class="headerlink" title="相关技术"></a>相关技术</h2><ul>
<li>web服务器</li>
<li>爬虫</li>
<li>cdn</li>
<li>html/webservice/waf</li>
</ul>
<h2 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h2><p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/Snipaste_2021-02-24_11-37-57.jpg"></p>
<h3 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">request line: method + URI + version</span><br><span class="line">head: k&#x2F;v</span><br><span class="line">CRLF</span><br><span class="line">body</span><br></pre></td></tr></table></figure>

<h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">status line: version + status code + reason</span><br><span class="line">head: k&#x2F;v</span><br><span class="line">CRLF</span><br><span class="line">body</span><br></pre></td></tr></table></figure>

<h3 id="常用头"><a href="#常用头" class="headerlink" title="常用头"></a>常用头</h3><h4 id="通用字段"><a href="#通用字段" class="headerlink" title="通用字段"></a>通用字段</h4><p><code>Data</code>:通用字段，但一般放在响应头，代表报文创建时间</p>
<h4 id="请求字段"><a href="#请求字段" class="headerlink" title="请求字段"></a>请求字段</h4><p><code>host</code>: 请求消息<strong>必带</strong>字段，代表了ip地址下的具体哪台主机，可用于路由重定向</p>
<p><code>User-Agent</code>: 请求字段，描述客户端，比如chrome,实际作用不大</p>
<h4 id="响应字段"><a href="#响应字段" class="headerlink" title="响应字段"></a>响应字段</h4><p><code>server</code>:响应字段，代表web服务器软件和版本，也可以随便写一个来隐藏服务器软件</p>
<h4 id="实体字段"><a href="#实体字段" class="headerlink" title="实体字段"></a>实体字段</h4><p><code>content-lenght</code>:实体字段，代表body的长度，如果不带content-length则表示报文是不定长的，chunked类型</p>
<h3 id="method"><a href="#method" class="headerlink" title="method"></a>method</h3><p><code>GET</code> 读取下载数据         //幂等</p>
<p><code>HEAD</code> 获取数据元信息       //幂等</p>
<p><code>POST</code> 提交数据,偏向create,实际上创建修改都基本用POST   //非幂等</p>
<p><code>PUT</code> 和POST差不多，偏向update,实际多用POST替代     //幂等</p>
<p><code>DELETE</code> 删除数据       //幂等</p>
<p><code>CONNECT</code> 建立隧道，webf服务器可以因此作为代理</p>
<p><code>OPTIONS</code> 列出可选方法</p>
<p><code>TRACE</code> 追踪请求-响应的传输路径</p>
<h3 id="uri"><a href="#uri" class="headerlink" title="uri"></a>uri</h3><div class="note info">
            <p>schema :// user:passwd@ host:port path ?query #fragment</p>
          </div>

<p><a href="https://www.nginx.com/resources/library/web-application-security/?utm_medium=nginxorg&amp;utm_source=homepagehero&amp;utm_campaign=ww-nx_sec&amp;utm_content=eb&amp;_ga=2.158505918.527586210.1614136337-596008434.1614136337">https://www.nginx.com/resources/library/web-application-security/?utm_medium=nginxorg&amp;utm_source=homepagehero&amp;utm_campaign=ww-nx_sec&amp;utm_content=eb&amp;_ga=2.158505918.527586210.1614136337-596008434.1614136337</a></p>
<p><a href="https://github.com/GHScan/TechNotes/blob/master/2017/Memory_Model.md#%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%AD%E7%9A%84%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF">https://github.com/GHScan/TechNotes/blob/master/2017/Memory_Model.md#%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%AD%E7%9A%84%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF</a></p>
<p>上面的#代表锚点，直接到页面的一个标签处。因为有中文，这里也做了转义</p>
<h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><h4 id="1xx"><a href="#1xx" class="headerlink" title="1xx"></a>1xx</h4><p>提示信息，代表中间状态</p>
<p>101：切换协议</p>
<h4 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h4><p>成功信息</p>
<p>204：响应里面没有body</p>
<p>206: 响应是分段传输的一部分</p>
<h4 id="3xx"><a href="#3xx" class="headerlink" title="3xx"></a>3xx</h4><p>重定向</p>
<p>301: 永久重定向</p>
<p>302：临时重定向</p>
<p>304：缓存重定向</p>
<h4 id="4xx"><a href="#4xx" class="headerlink" title="4xx"></a>4xx</h4><p>客户端错误</p>
<p>400：格式错误</p>
<p>404：未找到</p>
<p>403：禁止访问</p>
<h4 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h4><p>服务器错误</p>
<p>503：服务器忙</p>
<h3 id="数据类型和编码"><a href="#数据类型和编码" class="headerlink" title="数据类型和编码"></a>数据类型和编码</h3><p>http是超文本传输协议，支持文本，视音频等格式，所以需要带上文件类型，因为数据可能被压缩，也要带上压缩格式，文件类型符合MIME协议</p>
<h4 id="text"><a href="#text" class="headerlink" title="text"></a>text</h4><ul>
<li>text/html  超文本文档</li>
<li>text/plain 纯文本</li>
<li>text/css  样式表</li>
</ul>
<h4 id="audio"><a href="#audio" class="headerlink" title="audio"></a>audio</h4><ul>
<li>audio/mpeg</li>
</ul>
<h4 id="video"><a href="#video" class="headerlink" title="video"></a>video</h4><ul>
<li>video/mp4</li>
</ul>
<h4 id="image"><a href="#image" class="headerlink" title="image"></a>image</h4><ul>
<li>image/gif</li>
<li>image/jpeg</li>
</ul>
<h4 id="application"><a href="#application" class="headerlink" title="application"></a>application</h4><ul>
<li>application/pdf</li>
<li>application/json</li>
</ul>
<h4 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h4><ul>
<li>gzip</li>
<li>deflate</li>
<li>br</li>
</ul>
<h3 id="语言和字符集"><a href="#语言和字符集" class="headerlink" title="语言和字符集"></a>语言和字符集</h3><ul>
<li>en-US en-GB zh-CN</li>
<li>utf-8 gbk</li>
</ul>
<h3 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">client                                          server</span><br><span class="line">Accept: text&#x2F;plain,application&#x2F;pdf          Content-Type: text&#x2F;plain</span><br><span class="line">Accept-Encoding: gzip, deflate, br          Content-Encoding: gzip</span><br><span class="line">Accept-Language: zh-CN                      Content-Language: zh-CN</span><br><span class="line">Accept-Charset: gbk, utf-8                  Content-Type: text&#x2F;plain; charset&#x3D;utf-8</span><br></pre></td></tr></table></figure>

<h3 id="分段和范围"><a href="#分段和范围" class="headerlink" title="分段和范围"></a>分段和范围</h3><p>感觉不重要，不记录了</p>
<h2 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h2><p>Connection: keep-alive 表示长连接</p>
<p>Connection: close 关闭连接</p>
<h2 id="队头阻塞"><a href="#队头阻塞" class="headerlink" title="队头阻塞"></a>队头阻塞</h2><p>因为http是请求-应答模式，一条连接上，前一个请求阻塞了，会影响后面的请求，也就是队头阻塞</p>
<p>解决办法：</p>
<p>请求方并发多个连接，一般浏览器是开6个</p>
<p>响应方开启多主机，域名分片</p>
<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/Snipaste_2021-02-24_16-25-23.jpg"></p>
<p>cookie可以用来记录客户端的状态</p>
<p><code>Expire/Max-Age</code>: 表示cookie的过期时间</p>
<p><code>HttpOnly</code>: 表示cookie只适用于http协议，防止脚本攻击</p>
<p><code>Secure</code>: 表示cookie智能通过https协议传输，但cookie本身是明文的</p>
<p><code>SameSite</code>: 表示cookie只用于本站，防止跨站攻击</p>
<p><code>Priority</code>: 表示cookie移除时的优先级</p>
<h2 id="http特点"><a href="#http特点" class="headerlink" title="http特点"></a>http特点</h2><h3 id="灵活可扩展"><a href="#灵活可扩展" class="headerlink" title="灵活可扩展"></a>灵活可扩展</h3><p>head支持自定义字段</p>
<h3 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h3><p>下层是tcp/ip</p>
<h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><p>在应用层协议中(ftp,ssh)表现突出</p>
<h3 id="请求应答"><a href="#请求应答" class="headerlink" title="请求应答"></a>请求应答</h3><p>契合c/s, b/s架构</p>
<h3 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h3><p>因为请求应答，两次连接彼此独立，不会记录请求方的状态，但可以通过cookie来实现有状态</p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>浏览器输入 <a href="http://nginx.org/">http://nginx.org/</a></p>
<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/Snipaste_2021-02-24_11-21-20_dns.jpg"></p>
<hr>
<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/Snipaste_2021-02-24_11-21-47_ws.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查dns</span><br><span class="line">三次握手</span><br><span class="line">Get &#x2F; HTTP&#x2F;1.1              &#x2F;&#x2F;拿index.html</span><br><span class="line">Get &#x2F;nginx.png HTTP&#x2F;1.1     &#x2F;&#x2F;拿网站图标,index里面的超链接</span><br><span class="line">GET &#x2F;favicon.ico HTTP&#x2F;1.1   &#x2F;&#x2F;拿浏览器那个小图标</span><br><span class="line">挥手</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>http cache</title>
    <url>/2021-02-25-http-cache/</url>
    <content><![CDATA[<div class="note danger">
            
          </div>

<a id="more"></a>

<h2 id="强制刷新"><a href="#强制刷新" class="headerlink" title="强制刷新"></a>强制刷新</h2><p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/Snipaste_2021-02-24_17-36-44-force-refresh.jpg"></p>
<h2 id="后退前进"><a href="#后退前进" class="headerlink" title="后退前进"></a>后退前进</h2><p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/Snipaste_2021-02-24_17-37-21-back.jpg"></p>
<h2 id="重新加载"><a href="#重新加载" class="headerlink" title="重新加载"></a>重新加载</h2><p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/Snipaste_2021-02-24_17-38-56-304.jpg"></p>
]]></content>
  </entry>
  <entry>
    <title>proxy_pass return rewrite try_file</title>
    <url>/2021-02-28-proxy-pass-return/</url>
    <content><![CDATA[<div class="note default">
            
          </div>

<a id="more"></a>

<h2 id="dns"><a href="#dns" class="headerlink" title="dns"></a>dns</h2><div class="note danger">
            <p><a href="http://www.riverferry.site/">www.riverferry.site</a>     34.92.9.255</p><p>nginx.org               3.125.197.172</p>
          </div>

<h2 id="nginx-conf"><a href="#nginx-conf" class="headerlink" title="nginx.conf"></a>nginx.conf</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 0.0.0.0:8888;</span><br><span class="line"></span><br><span class="line">	server_name www.riverferry.site;</span><br><span class="line"></span><br><span class="line">	location &#x2F; &#123;</span><br><span class="line">		proxy_pass http:&#x2F;&#x2F;nginx.org;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">    	listen 0.0.0.0:9999;</span><br><span class="line"></span><br><span class="line">	server_name www.riverferry.site;</span><br><span class="line"></span><br><span class="line">	location &#x2F; &#123;</span><br><span class="line">		return 301 http:&#x2F;&#x2F;nginx.org;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="proxy-pass"><a href="#proxy-pass" class="headerlink" title="proxy_pass"></a>proxy_pass</h2><p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/Snipaste_2021-03-01_17-44-53_wireshark.jpg"></p>
<hr>
<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/Snipaste_2021-03-01_17-45-19_website.jpg"></p>
<hr>
<h2 id="return"><a href="#return" class="headerlink" title="return"></a>return</h2><p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/Snipaste_2021-03-01_17-48-27_wireshark9999.jpg"></p>
<hr>
<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/Snipaste_2021-03-01_17-48-54_web9999.jpg"></p>
<hr>
<h2 id="rewrite和return的区别"><a href="#rewrite和return的区别" class="headerlink" title="rewrite和return的区别"></a>rewrite和return的区别</h2><blockquote>
<p>rewrite regex URL [flag];</p>
</blockquote>
<p>详情见<a href="https://www.nginx.com/blog/creating-nginx-rewrite-rules/">Creating NGINX Rewrite Rules</a></p>
<ul>
<li>the first argument, regex, means that NGINX Plus and NGINX rewrite the URL only if it matches the specified regular expression (in addition to matching the server or location directive). The additional test means NGINX must do more processing.</li>
<li>A second difference is that the rewrite directive can return only code 301 or 302. To return other codes, you need to include a return directive after the rewrite directive (see the example below).</li>
<li>And finally the rewrite directive does not necessarily halt NGINX’s processing of the request as return does, and it doesn’t necessarily send a redirect to the client. Unless you explicitly indicate (with flags or the syntax of the URL) that you want NGINX to halt processing or send a redirect, it runs through the entire configuration looking for directives that are defined in the Rewrite module (break, if, return, rewrite, and set), and processes them in order. If a rewritten URL matches a subsequent directive from the Rewrite module, NGINX performs the indicated action on the rewritten URL (often rewriting it again).</li>
</ul>
<hr>
<h2 id="try-files"><a href="#try-files" class="headerlink" title="try_files"></a>try_files</h2><blockquote>
<p>try_files file … uri;</p>
</blockquote>
<p>In the following example, NGINX serves a default GIF file if the file requested by the client doesn’t exist. When the client requests (for example) <a href="http://www.domain.com/images/image1.gif">http://www.domain.com/images/image1.gif</a>, NGINX first looks for image1.gif in the local directory specified by the root or alias directive that applies to the location (not shown in the snippet). If image1.gif doesn’t exist, NGINX looks for image1.gif/, and if that doesn’t exist, it redirects to /images/default.gif. That value exactly matches the second location directive, so processing stops and NGINX serves that file and marks it to be cached for 30 seconds.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;images&#x2F; &#123;</span><br><span class="line">    try_files $uri $uri&#x2F; &#x2F;images&#x2F;default.gif;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location &#x3D; &#x2F;images&#x2F;default.gif &#123;</span><br><span class="line">    expires 30s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>protobuf 整理和坑</title>
    <url>/2021-03-05-protobuf%20%E6%95%B4%E7%90%86%E5%92%8C%E5%9D%91/</url>
    <content><![CDATA[<div class="note default">
            
          </div>

<a id="more"></a>

<h2 id="message"><a href="#message" class="headerlink" title="message"></a>message</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;test</span><br><span class="line">str&#x3D;&quot;hello&quot;</span><br><span class="line">num&#x3D;10</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;A</span><br><span class="line">message Test</span><br><span class="line">&#123;</span><br><span class="line">    string Str &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;B</span><br><span class="line">message Test</span><br><span class="line">&#123;</span><br><span class="line">    string Str &#x3D; 1;</span><br><span class="line">    uint32 Num &#x3D; 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;A</span><br><span class="line">0000   1e 00 00 00 60 0d cf d3 00 35 06 40 00 00 00 00</span><br><span class="line">0010   00 00 00 00 00 00 00 00 00 00 00 01 00 00 00 00</span><br><span class="line">0020   00 00 00 00 00 00 00 00 00 00 00 01 d7 f2 27 10</span><br><span class="line">0030   fb 13 27 e9 60 69 1d 73 80 18 18 e3 00 3d 00 00</span><br><span class="line">0040   01 01 08 0a 3f 92 b3 a7 3f 92 b3 a7 00 00 0c 00</span><br><span class="line">0050   01 00 00 00 01 00 00 00 00 07 0a 05 68 65 6c 6c</span><br><span class="line">0060   6f</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;B</span><br><span class="line">0000   1e 00 00 00 60 02 12 34 00 37 06 40 00 00 00 00</span><br><span class="line">0010   00 00 00 00 00 00 00 00 00 00 00 01 00 00 00 00</span><br><span class="line">0020   00 00 00 00 00 00 00 00 00 00 00 01 f9 7e 27 10</span><br><span class="line">0030   99 7d 24 16 a6 e1 55 ff 80 18 18 e3 00 3f 00 00</span><br><span class="line">0040   01 01 08 0a 40 30 23 50 40 30 23 50 00 00 0e 00</span><br><span class="line">0050   01 00 00 00 01 00 00 00 00 09 0a 05 68 65 6c 6c</span><br><span class="line">0060   6f 10 0a</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tag&#x3D; field &lt;&lt; 3 | wire</span><br><span class="line">&#x2F;&#x2F;A</span><br><span class="line">1010            field&#x3D;1 wire&#x3D;2</span><br><span class="line">07 0a 05 68 65 6c 6c 6f</span><br><span class="line">07(字节总数) 0a(tag&#x3D;10) 05(len&#x3D;5) 68 65 6c 6c 6f(value&#x3D;hello)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;B</span><br><span class="line">0001 0000       field&#x3D;2 wire&#x3D;0</span><br><span class="line">09 0a 05 68 65 6c 6c 6f 10 0a</span><br><span class="line">09(字节总数) 0a(tag&#x3D;10) 05(len&#x3D;5) 68 65 6c 6c 6f(value&#x3D;hello) </span><br><span class="line">10(tag&#x3D;16) 0a(value&#x3D;10)</span><br></pre></td></tr></table></figure>

<h2 id="wire-type"><a href="#wire-type" class="headerlink" title="wire_type"></a>wire_type</h2><table>
<thead>
<tr>
<th>Type</th>
<th>Meaning</th>
<th>Used For</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>Varint</td>
<td>int32, int64, uint32, uint64, sint32, sint64, bool, enum</td>
</tr>
<tr>
<td>1</td>
<td>64-bit</td>
<td>fixed64, sfixed64, double</td>
</tr>
<tr>
<td>2</td>
<td>Length-delimited</td>
<td>string, bytes, embedded messages, packed repeated fields</td>
</tr>
<tr>
<td>3</td>
<td>Start group</td>
<td>groups (deprecated)</td>
</tr>
<tr>
<td>4</td>
<td>End group</td>
<td>groups (deprecated)</td>
</tr>
<tr>
<td>5</td>
<td>32-bit</td>
<td>fixed32, sfixed32, float</td>
</tr>
</tbody></table>
<h2 id="demo-code"><a href="#demo-code" class="headerlink" title="demo code"></a>demo code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>;</span><br><span class="line">package data;</span><br><span class="line"></span><br><span class="line">message Test</span><br><span class="line">&#123;</span><br><span class="line">     optional string Str = <span class="number">1</span>;</span><br><span class="line">     optional uint64 Num = <span class="number">2</span>;</span><br><span class="line">     optional ENUMDATATYPE Data = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Test2</span><br><span class="line">&#123;</span><br><span class="line">     optional string str = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ENUMDATATYPE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     DATA_UNKONW = <span class="number">-1</span>;</span><br><span class="line">     DATA_ZERO = <span class="number">0</span>;</span><br><span class="line">     DATA_ONE = <span class="number">1</span>;</span><br><span class="line">     DATA_TWO = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    data::Test tt;</span><br><span class="line">    cout &lt;&lt; tt.<span class="built_in">ParseFromArray</span>(<span class="literal">nullptr</span>, <span class="number">0</span>) &lt;&lt; endl;  <span class="comment">//1</span></span><br><span class="line">    <span class="comment">// tt.set_str(&quot;hello&quot;);</span></span><br><span class="line">    tt.<span class="built_in">set_num</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; tt.<span class="built_in">has_data</span>() &lt;&lt; endl;  <span class="comment">//0</span></span><br><span class="line">    string str1;</span><br><span class="line">    tt.<span class="built_in">SerializeToString</span>(&amp;str1);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    0x60e988:       0x10    0x0a    0x00    0x00    0x00    0x00    0x00    0x00</span></span><br><span class="line"><span class="comment">    0x60e990:       0xa0    0xea    0x60    0x00    0x00    0x00    0x00    0x00</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    tt.<span class="built_in">set_data</span>(data::DATA_UNKONW);</span><br><span class="line">    cout &lt;&lt; tt.<span class="built_in">has_data</span>() &lt;&lt; endl;  <span class="comment">//1</span></span><br><span class="line">    string str2;</span><br><span class="line">    tt.<span class="built_in">SerializeToString</span>(&amp;str2);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    0x60eaa8:       0x10    0x0a    0x18    0xff    0xff    0xff    0xff    0xff</span></span><br><span class="line"><span class="comment">    0x60eab0:       0xff    0xff    0xff    0xff    0x01    0x00    0x00    0x00</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    tt.<span class="built_in">set_data</span>(data::DATA_ONE);</span><br><span class="line">    cout &lt;&lt; tt.<span class="built_in">has_data</span>() &lt;&lt; endl;  <span class="comment">//1</span></span><br><span class="line">    string str3;</span><br><span class="line">    tt.<span class="built_in">SerializeToString</span>(&amp;str3);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    0x60ea18:       0x10    0x0a    0x18    0x01    0x00    0x00    0x00    0x00</span></span><br><span class="line"><span class="comment">    0x60ea20:       0xf0    0xe8    0x60    0x00    0x00    0x00    0x00    0x00</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">   data::Test tt2;</span><br><span class="line">   tt2.<span class="built_in">ParseFromString</span>(str3);</span><br><span class="line">   cout &lt;&lt; tt2.<span class="built_in">DebugString</span>() &lt;&lt; endl;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   Num: 10</span></span><br><span class="line"><span class="comment">   Data: DATA_ONE</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="specify-default"><a href="#specify-default" class="headerlink" title="specify default"></a>specify default</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">message Test</span><br><span class="line">&#123;</span><br><span class="line">     optional string Str &#x3D; 1;</span><br><span class="line">     optional uint64 Num &#x3D; 2;</span><br><span class="line">     optional ENUMDATATYPE Data &#x3D; 3 [default &#x3D; DATA_ONE];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;str1</span><br><span class="line">str1.data() -&gt; $1 &#x3D; data::DATA_ONE</span><br><span class="line">0x60eaa8:       0x10    0x0a    0x00    0x00    0x00    0x00    0x00    0x00</span><br><span class="line">0x60eab0:       0x60    0xed    0x60    0x00    0x00    0x00    0x00    0x00</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;str2</span><br><span class="line">0x616618:       0x10    0x0a    0x18    0xff    0xff    0xff    0xff    0xff</span><br><span class="line">0x616620:       0xff    0xff    0xff    0xff    0x01    0x00    0x00    0x00</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;str3</span><br><span class="line">0x60e988:       0x10    0x0a    0x18    0x01    0x00    0x00    0x00    0x00</span><br><span class="line">0x60e990:       0xa0    0xea    0x60    0x00    0x00    0x00    0x00    0x00</span><br></pre></td></tr></table></figure>

<h2 id="update-proto"><a href="#update-proto" class="headerlink" title="update proto"></a>update proto</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">message TestNew</span><br><span class="line">&#123;</span><br><span class="line">     optional string Str &#x3D; 1;</span><br><span class="line">     optional uint64 Num &#x3D; 2;</span><br><span class="line">     optional ENUMDATATYPENEW Data &#x3D; 3;</span><br><span class="line">     optional uint64 neww &#x3D; 4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum ENUMDATATYPE</span><br><span class="line">&#123;</span><br><span class="line">     DATA_UNKONW &#x3D; -1;</span><br><span class="line">     DATA_ZERO &#x3D; 0;</span><br><span class="line">     DATA_ONE &#x3D; 1;</span><br><span class="line">     DATA_TWO &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum ENUMDATATYPENEW</span><br><span class="line">&#123;</span><br><span class="line">     NEW_DATA_UNKONW &#x3D; -1;</span><br><span class="line">     NEW_DATA_ZERO &#x3D; 0;</span><br><span class="line">     NEW_DATA_ONE &#x3D; 1;</span><br><span class="line">     NEW_DATA_TWO &#x3D; 2;</span><br><span class="line">     NEW_DATA_NEW &#x3D; 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    data::Test tt1;</span><br><span class="line">    data::TestNew tt2;</span><br><span class="line">    tt2.<span class="built_in">set_str</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    tt2.<span class="built_in">set_num</span>(<span class="number">10</span>);</span><br><span class="line">    tt2.<span class="built_in">set_data</span>(data::NEW_DATA_NEW);</span><br><span class="line">    tt2.<span class="built_in">set_neww</span>(<span class="number">200</span>);</span><br><span class="line">    cout &lt;&lt; tt2.<span class="built_in">DebugString</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    string str;</span><br><span class="line">    tt2.<span class="built_in">SerializeToString</span>(&amp;str);</span><br><span class="line">    tt1.<span class="built_in">ParseFromString</span>(str);</span><br><span class="line">    cout &lt;&lt; tt1.<span class="built_in">DebugString</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; tt1.<span class="built_in">has_data</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Str: &quot;hello&quot;</span><br><span class="line">Num: 10</span><br><span class="line">Data: NEW_DATA_NEW</span><br><span class="line">neww: 200</span><br><span class="line"></span><br><span class="line">Str: &quot;hello&quot;</span><br><span class="line">Num: 10</span><br><span class="line">3: 3</span><br><span class="line">4: 200</span><br><span class="line"></span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://blog.csdn.net/baidu_32237719/article/details/99649451">proto编译安装</a></p>
<p><a href="https://blog.csdn.net/carson_ho/article/details/70568606">proto序列化原理</a></p>
<p><a href="https://chys.info/blog/2017-12-05-protobuf-enum-default-value">protobuf 中 enum 类型默认值的一个坑</a></p>
<p><a href="https://developers.google.com/protocol-buffers/docs/encoding#structure">protobuf message</a></p>
]]></content>
      <tags>
        <tag>proto</tag>
      </tags>
  </entry>
  <entry>
    <title>2A raft leader election</title>
    <url>/2021-03-10-2A%20raft%20leader%20election/</url>
    <content><![CDATA[<div class="note default">
            
          </div>

<a id="more"></a>

<p><a href="https://pdos.csail.mit.edu/6.824/labs/lab-raft.html">2A Introduction</a></p>
<h2 id="Part-2A"><a href="#Part-2A" class="headerlink" title="Part 2A"></a>Part 2A</h2><div class="note danger">
            <p>Implement Raft leader election and heartbeats (AppendEntries RPCs with no log entries). The goal for Part 2A is for a single leader to be elected, for the leader to remain the leader if there are no failures, and for a new leader to take over if the old leader fails or if packets to/from the old leader are lost. Run go test -run 2A -race to test your 2A code.</p>
          </div>

<div class="note default">
            <ul><li>You can’t easily run your Raft implementation directly; instead you should run it by way of the tester, i.e. go test -run 2A -race.</li><li>Follow the paper’s Figure 2. At this point you care about sending and receiving <code>RequestVote</code> RPCs, the <code>Rules for Servers</code> that relate to elections, and the <code>State</code> related to leader election,</li><li>Add the Figure 2 state for leader election to the <code>Raft struct</code> in raft.go. You’ll also need to define a struct to hold information about each <code>log entry</code>.</li><li>Fill in the RequestVoteArgs and RequestVoteReply structs. Modify Make() to create a background goroutine that will kick off leader election periodically by sending out RequestVote RPCs when it hasn’t heard from another peer for a while. This way a peer will learn who is the leader, if there is already a leader, or become the leader itself. Implement the RequestVote() RPC handler so that servers will vote for one another.</li><li>To implement heartbeats, define an AppendEntries RPC struct (though you may not need all the arguments yet), and have the leader send them out periodically. Write an AppendEntries RPC handler method that resets the election timeout so that other servers don’t step forward as leaders when one has already been elected.</li><li>Make sure the election timeouts in different peers don’t always fire at the same time, or else all peers will vote only for themselves and no one will become the leader.</li><li>The tester requires that the leader send heartbeat RPCs no more than ten times per second.</li><li>The tester requires your Raft to elect a new leader within five seconds of the failure of the old leader (if a majority of peers can still communicate). Remember, however, that leader election may require multiple rounds in case of a split vote (which can happen if packets are lost or if candidates unluckily choose the same random backoff times). You must pick election timeouts (and thus heartbeat intervals) that are short enough that it’s very likely that an election will complete in less than five seconds even if it requires multiple rounds.</li><li>The paper’s Section 5.2 mentions election timeouts in the range of 150 to 300 milliseconds. Such a range only makes sense if the leader sends heartbeats considerably more often than once per 150 milliseconds. Because the tester limits you to 10 heartbeats per second, you will have to use an election timeout larger than the paper’s 150 to 300 milliseconds, but not too large, because then you may fail to elect a leader within five seconds.</li><li>You may find Go’s rand useful.</li><li>You’ll need to write code that takes actions periodically or after delays in time. The easiest way to do this is to create a goroutine with a loop that calls time.Sleep(); (see the ticker() goroutine that Make() creates for this purpose). Don’t use Go’s time.Timer or time.Ticker, which are difficult to use correctly.</li><li>The Guidance page has some tips on how to develop and debug your code.</li><li>If your code has trouble passing the tests, read the paper’s Figure 2 again; the full logic for leader election is spread over multiple parts of the figure.</li><li>Don’t forget to implement GetState().</li><li>The tester calls your Raft’s rf.Kill() when it is permanently shutting down an instance. You can check whether Kill() has been called using rf.killed(). You may want to do this in all loops, to avoid having dead Raft instances print confusing messages.</li><li>Go RPC sends only struct fields whose names start with capital letters. Sub-structures must also have capitalized field names (e.g. fields of log records in an array). The labgob package will warn you about this; don’t ignore the warnings.</li></ul>
          </div>

<hr>
<h2 id="My-Code"><a href="#My-Code" class="headerlink" title="My Code"></a>My Code</h2><h3 id="Make"><a href="#Make" class="headerlink" title="Make"></a>Make</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// the service or tester wants to create a Raft server. the ports</span></span><br><span class="line"><span class="comment">// of all the Raft servers (including this one) are in peers[]. this</span></span><br><span class="line"><span class="comment">// server&#x27;s port is peers[me]. all the servers&#x27; peers[] arrays</span></span><br><span class="line"><span class="comment">// have the same order. persister is a place for this server to</span></span><br><span class="line"><span class="comment">// save its persistent state, and also initially holds the most</span></span><br><span class="line"><span class="comment">// recent saved state, if any. applyCh is a channel on which the</span></span><br><span class="line"><span class="comment">// tester or service expects Raft to send ApplyMsg messages.</span></span><br><span class="line"><span class="comment">// Make() must return quickly, so it should start goroutines</span></span><br><span class="line"><span class="comment">// for any long-running work.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// todo add context</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Make</span><span class="params">(peers []*labrpc.ClientEnd, me <span class="keyword">int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	persister *Persister, applyCh <span class="keyword">chan</span> ApplyMsg)</span> *<span class="title">Raft</span></span> &#123;</span><br><span class="line">	log.Println(<span class="string">&quot;begin make.., me &quot;</span>, me)</span><br><span class="line">	rf := &amp;Raft&#123;&#125;</span><br><span class="line">	rf.peers = peers</span><br><span class="line">	rf.persister = persister</span><br><span class="line">	rf.me = me</span><br><span class="line">	rf.hasLeader = <span class="literal">false</span></span><br><span class="line">	rf.refreshCh = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	rf.heartCh = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Your initialization code here (2A, 2B, 2C).</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="comment">// rand time 300-400 ms</span></span><br><span class="line">			rand.Seed(time.Now().UTC().UnixNano())</span><br><span class="line">			randtime := rand.Intn(<span class="number">100</span>) + <span class="number">300</span></span><br><span class="line">			timeout := time.After(time.Duration(randtime) * time.Millisecond)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="comment">// update log or leader</span></span><br><span class="line">			<span class="comment">// case ch := &lt;-applyCh:</span></span><br><span class="line">			<span class="comment">// 	&#123;</span></span><br><span class="line">			<span class="comment">// 		if ch.CommandValid == true &#123;</span></span><br><span class="line">			<span class="comment">// 			rf.lastApplied = ch.CommandIndex</span></span><br><span class="line">			<span class="comment">// 		&#125;</span></span><br><span class="line">			<span class="comment">// 	&#125;</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// refresh timeout</span></span><br><span class="line">			<span class="keyword">case</span> &lt;-rf.refreshCh:</span><br><span class="line"></span><br><span class="line">			<span class="comment">// begin elect</span></span><br><span class="line">			<span class="keyword">case</span> &lt;-timeout:</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> rf.killed() &#123;</span><br><span class="line">						<span class="keyword">return</span></span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">go</span> rf.startElection(me)</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// begin heartbeat</span></span><br><span class="line">			<span class="keyword">case</span> &lt;-rf.heartCh:</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> rf.killed() &#123;</span><br><span class="line">						<span class="keyword">return</span></span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="comment">// The tester requires that the leader send heartbeat RPCs no more than ten times per second.</span></span><br><span class="line">					<span class="keyword">for</span> num, _ := <span class="keyword">range</span> peers &#123;</span><br><span class="line">						<span class="comment">// heartbeat</span></span><br><span class="line">						<span class="keyword">if</span> num != me &#123;</span><br><span class="line">							<span class="keyword">go</span> rf.heartBeatOne(num)</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// initialize from state persisted before a crash</span></span><br><span class="line">	rf.readPersist(persister.ReadRaftState())</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> rf</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="startElection"><a href="#startElection" class="headerlink" title="startElection"></a>startElection</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">startElection</span><span class="params">(me <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> count <span class="keyword">int</span> = <span class="built_in">len</span>(rf.peers)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// become candidater</span></span><br><span class="line">	log.Println(<span class="string">&quot;me become candidater &quot;</span>, me)</span><br><span class="line">	rf.mu.Lock()</span><br><span class="line">	rf.hasLeader = <span class="literal">false</span></span><br><span class="line">	rf.currentTerm++</span><br><span class="line">	rf.votenum = <span class="number">1</span></span><br><span class="line">	rf.isLeader = <span class="literal">false</span></span><br><span class="line">	rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> num, _ := <span class="keyword">range</span> rf.peers &#123;</span><br><span class="line">		<span class="keyword">if</span> num != me &#123;</span><br><span class="line">			<span class="keyword">var</span> args RequestVoteArgs</span><br><span class="line">			<span class="keyword">var</span> reply RequestVoteReply</span><br><span class="line"></span><br><span class="line">			rf.mu.Lock()</span><br><span class="line">			<span class="comment">// already has leader</span></span><br><span class="line">			<span class="keyword">if</span> rf.hasLeader == <span class="literal">true</span> &#123;</span><br><span class="line">				log.Println(<span class="string">&quot;break elect,  hasleader, who =  &quot;</span>, me)</span><br><span class="line">				rf.mu.Unlock()</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			args.Term = rf.currentTerm</span><br><span class="line">			args.CandidateId = me</span><br><span class="line">			lognum := <span class="built_in">len</span>(rf.log)</span><br><span class="line">			<span class="keyword">if</span> lognum &gt; <span class="number">0</span> &#123;</span><br><span class="line">				args.LastLogIndex = rf.log[lognum<span class="number">-1</span>].Index</span><br><span class="line">				args.LastLogTerm = rf.log[lognum<span class="number">-1</span>].Term</span><br><span class="line">			&#125;</span><br><span class="line">			rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(server <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">				ret := rf.sendRequestVote(server, &amp;args, &amp;reply)</span><br><span class="line">				<span class="keyword">if</span> ret != <span class="literal">true</span> &#123;</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				rf.mu.Lock()</span><br><span class="line">				<span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">				<span class="comment">// become follower</span></span><br><span class="line">				<span class="keyword">if</span> reply.Term &gt; rf.currentTerm &#123;</span><br><span class="line">					log.Println(<span class="string">&quot;me become follower &quot;</span>, me)</span><br><span class="line">					rf.isLeader = <span class="literal">false</span></span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> reply.VoteGranted == <span class="literal">true</span> &#123;</span><br><span class="line">					rf.votenum++</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				log.Println(<span class="string">&quot;votenum count/2 me &quot;</span>, rf.votenum, count/<span class="number">2</span>, me)</span><br><span class="line">				<span class="comment">// become leader</span></span><br><span class="line">				<span class="keyword">if</span> rf.votenum &gt; count/<span class="number">2</span> &#123;</span><br><span class="line">					log.Println(<span class="string">&quot;become leader me&quot;</span>, me)</span><br><span class="line">					rf.hasLeader = <span class="literal">true</span></span><br><span class="line">					<span class="keyword">if</span> !rf.isLeader &#123;</span><br><span class="line">						rf.isLeader = <span class="literal">true</span></span><br><span class="line">						rf.heartCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;(num)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="heartBeatOne"><a href="#heartBeatOne" class="headerlink" title="heartBeatOne"></a>heartBeatOne</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">heartBeatOne</span><span class="params">(num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> req AppendEntriesReq</span><br><span class="line">		<span class="keyword">var</span> rsp AppendEntriesRsp</span><br><span class="line"></span><br><span class="line">		rf.mu.Lock()</span><br><span class="line">		rf.refreshCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		<span class="keyword">if</span> !rf.hasLeader || !rf.isLeader || rf.killed() &#123;</span><br><span class="line">			rf.mu.Unlock()</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		req.Term = rf.currentTerm</span><br><span class="line">		req.LeaderId = rf.me</span><br><span class="line">		rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">		ret := rf.sendAppendEntries(num, &amp;req, &amp;rsp)</span><br><span class="line">		<span class="keyword">if</span> ret != <span class="literal">true</span> &#123;</span><br><span class="line">			log.Println(<span class="string">&quot;sendAppendEntries err, server =  me = &quot;</span>, num, rf.me)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// expired</span></span><br><span class="line">		rf.mu.Lock()</span><br><span class="line">		<span class="keyword">if</span> rsp.Term &gt; rf.currentTerm &#123;</span><br><span class="line">			rf.isLeader = <span class="literal">false</span></span><br><span class="line">			rf.mu.Unlock()</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">		time.Sleep(<span class="number">150</span> * time.Millisecond)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RequestVote"><a href="#RequestVote" class="headerlink" title="RequestVote"></a>RequestVote</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// example RequestVote RPC handler.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">RequestVote</span><span class="params">(args *RequestVoteArgs, reply *RequestVoteReply)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Your code here (2A, 2B).</span></span><br><span class="line">	<span class="comment">//1. Reply false if term &lt; currentTerm (§5.1)</span></span><br><span class="line">	<span class="comment">//2. If votedFor is null or candidateId, and candidate’s log is at</span></span><br><span class="line">	<span class="comment">//least as up-to-date as receiver’s log, grant vote (§5.2, §5.4)</span></span><br><span class="line">	<span class="keyword">if</span> rf.killed() &#123;</span><br><span class="line">		reply.VoteGranted = <span class="literal">false</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rf.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> args.Term &lt; rf.currentTerm &#123;</span><br><span class="line">		reply.VoteGranted = <span class="literal">false</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> args.Term &gt; rf.currentTerm &#123;</span><br><span class="line">		reply.VoteGranted = <span class="literal">true</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">// args.Term == rf.currentTerm</span></span><br><span class="line">		<span class="comment">// one term only vote one server</span></span><br><span class="line">		<span class="keyword">if</span> rf.votedFor == <span class="number">0</span> || rf.votedFor == args.CandidateId &#123;</span><br><span class="line">			loglen := <span class="built_in">len</span>(rf.log)</span><br><span class="line">			<span class="keyword">if</span> loglen == <span class="number">0</span> &#123;</span><br><span class="line">				reply.VoteGranted = <span class="literal">true</span></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> args.LastLogTerm &gt; rf.log[loglen<span class="number">-1</span>].Term ||</span><br><span class="line">				(args.LastLogTerm == rf.log[loglen<span class="number">-1</span>].Term &amp;&amp; args.LastLogIndex &gt;= rf.log[loglen<span class="number">-1</span>].Index) &#123;</span><br><span class="line">				reply.VoteGranted = <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> reply.VoteGranted == <span class="literal">true</span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;me vote him &quot;</span>, rf.me, args.CandidateId)</span><br><span class="line">		rf.votedFor = args.CandidateId</span><br><span class="line">		rf.isLeader = <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	reply.Term = rf.currentTerm</span><br><span class="line">	rf.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AppendEntries"><a href="#AppendEntries" class="headerlink" title="AppendEntries"></a>AppendEntries</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Receiver implementation:</span></span><br><span class="line"><span class="comment">// 1. Reply false if term &lt; currentTerm (§5.1)</span></span><br><span class="line"><span class="comment">// 2. Reply false if log doesn’t contain an entry at prevLogIndex</span></span><br><span class="line"><span class="comment">// whose term matches prevLogTerm (§5.3)</span></span><br><span class="line"><span class="comment">// 3. If an existing entry conflicts with a new one (same index</span></span><br><span class="line"><span class="comment">// but different terms), delete the existing entry and all that</span></span><br><span class="line"><span class="comment">// follow it (§5.3)</span></span><br><span class="line"><span class="comment">// 4. Append any new entries not already in the log</span></span><br><span class="line"><span class="comment">// 5. If leaderCommit &gt; commitIndex, set commitIndex = min(leaderCommit, index of last new entry)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">AppendEntries</span><span class="params">(req *AppendEntriesReq, rsp *AppendEntriesRsp)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> rf.killed() &#123;</span><br><span class="line">		rsp.Success = <span class="literal">false</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rf.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		rsp.Term = rf.currentTerm</span><br><span class="line">		rf.mu.Unlock()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// expired</span></span><br><span class="line">	<span class="keyword">if</span> req.Term &lt; rf.currentTerm &#123;</span><br><span class="line">		rsp.Success = <span class="literal">false</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// heartbeat</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(req.Entries) == <span class="number">0</span> &#123;</span><br><span class="line">		rf.hasLeader = <span class="literal">true</span></span><br><span class="line">		rf.currentTerm = req.Term</span><br><span class="line">		rf.isLeader = <span class="literal">false</span></span><br><span class="line">		rf.refreshCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		rsp.Success = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(rf.log) &gt; req.PrevLogIndex &amp;&amp; rf.log[req.PrevLogIndex].Term != req.PrevLogTerm &#123;</span><br><span class="line">		rsp.Success = <span class="literal">false</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rsp.Success = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">for</span> _, value := <span class="keyword">range</span> req.Entries &#123;</span><br><span class="line">		rf.log[value.Index] = value</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// why?</span></span><br><span class="line">	<span class="keyword">if</span> req.LeaderCommit &gt; rf.commitIndex &#123;</span><br><span class="line">		<span class="keyword">if</span> req.LeaderCommit &lt; req.Entries[<span class="built_in">len</span>(req.Entries)<span class="number">-1</span>].Index &#123;</span><br><span class="line">			rf.commitIndex = req.LeaderCommit</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			rf.commitIndex = req.Entries[<span class="built_in">len</span>(req.Entries)<span class="number">-1</span>].Index</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="test"><a href="#test" class="headerlink" title="test"></a>test</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;bin&#x2F;sh</span><br><span class="line"></span><br><span class="line">for((i&#x3D;1;i&lt;&#x3D;500;i++));</span><br><span class="line">do</span><br><span class="line">echo &quot;---------------------$i&quot; &gt;&gt;2a.log</span><br><span class="line">go test -run 2A -race  2&gt;&amp;1 &gt;&gt;2a.log</span><br><span class="line">echo &quot;&quot;</span><br><span class="line">done;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep PASS 2a.log | wc -l</span><br><span class="line">500</span><br><span class="line"></span><br><span class="line">ok  	pathname	7.480s</span><br><span class="line">ok  	pathname	7.453s</span><br><span class="line">ok  	pathname	7.463s</span><br><span class="line">ok  	pathname	7.581s</span><br><span class="line">ok  	pathname	7.587s</span><br><span class="line">ok  	pathname	7.534s</span><br><span class="line">ok  	pathname	7.483s</span><br><span class="line">ok  	pathname	7.667s</span><br><span class="line">ok  	pathname	7.499s</span><br><span class="line">ok  	pathname	7.520s</span><br><span class="line">ok  	pathname	7.539s</span><br><span class="line">ok  	pathname	7.475s</span><br><span class="line">ok  	pathname	7.519s</span><br><span class="line">ok  	pathname	7.657s</span><br><span class="line">ok  	pathname	7.617s</span><br><span class="line">ok  	pathname	7.728s</span><br><span class="line">ok  	pathname	7.539s</span><br><span class="line">ok  	pathname	8.254s</span><br><span class="line">ok  	pathname	7.591s</span><br><span class="line">ok  	pathname	7.618s</span><br><span class="line">ok  	pathname	7.703s</span><br><span class="line">ok  	pathname	8.075s</span><br><span class="line">ok  	pathname	7.509s</span><br><span class="line">ok  	pathname	7.644s</span><br><span class="line">ok  	pathname	7.381s</span><br><span class="line">ok  	pathname	7.607s</span><br><span class="line">ok  	pathname	7.616s</span><br><span class="line">ok  	pathname	7.646s</span><br><span class="line">ok  	pathname	7.571s</span><br><span class="line">ok  	pathname	7.443s</span><br><span class="line">ok  	pathname	7.533s</span><br><span class="line">ok  	pathname	7.552s</span><br><span class="line">ok  	pathname	7.562s</span><br><span class="line">ok  	pathname	8.243s</span><br><span class="line">ok  	pathname	7.559s</span><br><span class="line">ok  	pathname	8.128s</span><br><span class="line">ok  	pathname	8.000s</span><br><span class="line">ok  	pathname	7.654s</span><br><span class="line">ok  	pathname	7.579s</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>raft</tag>
      </tags>
  </entry>
  <entry>
    <title>when goroutine quit</title>
    <url>/2021-03-17-when-goroutine-quit/</url>
    <content><![CDATA[<div class="note default">
            
          </div>


<a id="more"></a>

<h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;main defer&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;one defer&quot;</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;two defer&quot;</span>)</span><br><span class="line">			f2, err := os.OpenFile(<span class="string">&quot;log2&quot;</span>, os.O_WRONLY|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="built_in">panic</span>(<span class="string">&quot;open err&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			write := bufio.NewWriter(f2)</span><br><span class="line">			<span class="keyword">defer</span> f2.Close()</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				write.WriteString(<span class="string">&quot;two here\n&quot;</span>)</span><br><span class="line">				write.Flush()</span><br><span class="line"></span><br><span class="line">				time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line"></span><br><span class="line">		f1, err := os.OpenFile(<span class="string">&quot;log1&quot;</span>, os.O_WRONLY|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">&quot;open err&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		write := bufio.NewWriter(f1)</span><br><span class="line">		<span class="keyword">defer</span> f1.Close()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">			write.WriteString(<span class="string">&quot;one here\n&quot;</span>)</span><br><span class="line">			write.Flush()</span><br><span class="line"></span><br><span class="line">			time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;main exit&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="output"><a href="#output" class="headerlink" title="output"></a>output</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">one defer</span><br><span class="line">main exit</span><br><span class="line">main defer</span><br></pre></td></tr></table></figure>

<h2 id="log1"><a href="#log1" class="headerlink" title="log1"></a>log1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">one here</span><br><span class="line">one here</span><br></pre></td></tr></table></figure>

<h2 id="log2"><a href="#log2" class="headerlink" title="log2"></a>log2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">two here</span><br><span class="line">two here</span><br><span class="line">two here</span><br><span class="line">two here</span><br><span class="line">two here</span><br></pre></td></tr></table></figure>

<h2 id="conclusions"><a href="#conclusions" class="headerlink" title="conclusions"></a>conclusions</h2><ul>
<li>main routine quit, all other routine quit</li>
<li>a routine(not main) quit, child routine unaffected</li>
<li>use channel/context to exit other routine</li>
</ul>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树 segm tree</title>
    <url>/2021-05-01-%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<div class="note default">
            <p>线段树（英语：Segment tree）是一种二叉树形数据结构，1977年由Jon Louis Bentley发明，用以存储区间或线段，并且允许快速查询结构内包含某一点的所有区间。</p><p>一个包含n个区间的线段树，空间复杂度为O(n)，查询的时间复杂度则为O(logn + k)，其中k是符合条件的区间数量。</p>
          </div>


<a id="more"></a>

<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SEGMENT_NODE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">int</span> end;</span><br><span class="line">    <span class="keyword">int</span> sum; <span class="comment">// can be max/min</span></span><br><span class="line">    SEGMENT_NODE* left;</span><br><span class="line">    SEGMENT_NODE* right;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SEGMENT_NODE</span>(<span class="keyword">int</span> input_start = <span class="number">0</span>, <span class="keyword">int</span> input_end = <span class="number">0</span>, <span class="keyword">int</span> input_sum = <span class="number">0</span>, SEGMENT_NODE* input_left = </span><br><span class="line">        <span class="literal">nullptr</span>, SEGMENT_NODE* input_right = <span class="literal">nullptr</span>):</span><br><span class="line">        <span class="built_in">start</span>(input_start), </span><br><span class="line">        <span class="built_in">end</span>(input_end),</span><br><span class="line">        <span class="built_in">sum</span>(input_sum),</span><br><span class="line">        <span class="built_in">left</span>(input_left),</span><br><span class="line">        <span class="built_in">right</span>(input_right)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">SEGMENT_NODE</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> left;</span><br><span class="line">        <span class="keyword">delete</span> right;</span><br><span class="line">        left = right = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; segmentNode;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">segmentTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        unique_ptr&lt;segmentNode&gt; root_;</span><br><span class="line">        <span class="function">segmentNode* <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">updateTree</span><span class="params">(segmentNode* node, <span class="keyword">int</span> index, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">querySum</span><span class="params">(segmentNode* node, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">segmentTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!nums.<span class="built_in">empty</span>())</span><br><span class="line">                root_.<span class="built_in">reset</span>(<span class="built_in">buildTree</span>(<span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, nums));</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">updateTree</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">querySum</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">segmentNode* <span class="title">segmentTree::buildTree</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start == end)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">segmentNode</span>(start, end, nums[start]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">auto</span> left = <span class="built_in">buildTree</span>(start, mid, nums);</span><br><span class="line">    <span class="keyword">auto</span> right = <span class="built_in">buildTree</span>(mid + <span class="number">1</span>, end, nums);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">segmentNode</span>(start, end, left-&gt;sum + right-&gt;sum, left, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">segmentTree::updateTree</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">updateTree</span>(root_.<span class="built_in">get</span>(), index, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">segmentTree::updateTree</span><span class="params">(segmentNode* node, <span class="keyword">int</span> index, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (index == node-&gt;start &amp;&amp; index == node-&gt;end)</span><br><span class="line">    &#123;</span><br><span class="line">        node-&gt;sum = value;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> mid = node-&gt;start + (node-&gt;end - node-&gt;start) / <span class="number">2</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (index &lt;= mid)</span><br><span class="line">        <span class="built_in">updateTree</span>(node-&gt;left, index, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">updateTree</span>(node-&gt;right, index, value);</span><br><span class="line"></span><br><span class="line">    node-&gt;sum = (node-&gt;left != <span class="literal">nullptr</span> ? node-&gt;left-&gt;sum : <span class="number">0</span>)  +</span><br><span class="line">        (node-&gt;right != <span class="literal">nullptr</span> ? node-&gt;right-&gt;sum : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">segmentTree::querySum</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root_ == <span class="literal">nullptr</span> || start &gt; end || start &lt; <span class="number">0</span> || end &gt; root_-&gt;end)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">querySum</span>(root_.<span class="built_in">get</span>(), start, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">segmentTree::querySum</span><span class="params">(segmentNode* node, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (start == node-&gt;start &amp;&amp; end == node-&gt;end)</span><br><span class="line">        <span class="keyword">return</span> node-&gt;sum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> mid = node-&gt;start + (node-&gt;end - node-&gt;start) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (end &lt;= mid)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">querySum</span>(node-&gt;left, start, end);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (start &gt; mid)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">querySum</span>(node-&gt;right, start, end);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">querySum</span>(node-&gt;left, start, mid) + <span class="built_in">querySum</span>(node-&gt;right, mid + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="307-solution"><a href="#307-solution" class="headerlink" title="307 solution"></a>307 solution</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums):<span class="built_in">segTree_</span>(nums) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        segTree_.<span class="built_in">updateTree</span>(index, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> segTree_.<span class="built_in">querySum</span>(left, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    segmentTree segTree_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://www.youtube.com/watch?v=rYBtViWXYeI">https://www.youtube.com/watch?v=rYBtViWXYeI</a></p>
<p><a href="https://leetcode-cn.com/problems/range-sum-query-mutable/">leetcode307</a></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组</title>
    <url>/2021-05-02-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<div class="note default">
            <p>树状数组或二元索引树（英语：Binary Indexed Tree），又以其发明者命名为Fenwick树.</p><p>按照Peter M. Fenwick的说法，正如所有的整数都可以表示成2的幂和，我们也可以把一串序列表示成一系列子序列的和。采用这个想法，我们可将一个前缀和划分成多个子序列的和，而划分的方法与数的2的幂和具有极其相似的方式。一方面，子序列的个数是其二进制表示中1的个数，另一方面，子序列代表的f[i]的个数也是2的幂</p>
          </div>


<a id="more"></a>

<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fenwickTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">fenwickTree</span>(<span class="keyword">int</span> size):<span class="built_in">sums_</span>(size, <span class="number">0</span>)&#123;&#125;; <span class="comment">// n + 1</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> delta)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; sums_.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            sums_[index] += delta;</span><br><span class="line">            index += <span class="built_in">lowBit</span>(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res += sums_[index];</span><br><span class="line">            index -= <span class="built_in">lowBit</span>(index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowBit</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">return</span> i &amp; (-i); &#125;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; sums_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="307-solution"><a href="#307-solution" class="headerlink" title="307 solution"></a>307 solution</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums):<span class="built_in">nums_</span>(<span class="built_in">move</span>(nums)), <span class="built_in">tree_</span>(nums_.<span class="built_in">size</span>() + <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// index start from 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums_.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            tree_.<span class="built_in">update</span>(i + <span class="number">1</span>, nums_[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        tree_.<span class="built_in">update</span>(index + <span class="number">1</span>, val - nums_[index]);</span><br><span class="line">        nums_[index] = val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tree_.<span class="built_in">query</span>(right + <span class="number">1</span>) - tree_.<span class="built_in">query</span>(left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; nums_;</span><br><span class="line">    fenwickTree tree_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="315-solution"><a href="#315-solution" class="headerlink" title="315 solution"></a>315 solution</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 5 2 6 1 -&gt; 2 1 1 0</span></span><br><span class="line"><span class="comment">// 1 6 2 5 -&gt; 0 1 1 2</span></span><br><span class="line"><span class="comment">// 1 2 5 6</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">countSmaller</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">set&lt;<span class="keyword">int</span>&gt; <span class="title">oSet</span><span class="params">(nums.cbegin(), nums.cend())</span></span>;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ranks;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 树状数组是从1开始的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; num : oSet)</span><br><span class="line">            ranks[num] = ++i;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="function">fenwickTree <span class="title">tree</span><span class="params">(oSet.size() + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = nums.<span class="built_in">rbegin</span>(); it != nums.<span class="built_in">rend</span>(); ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(tree.<span class="built_in">query</span>(ranks[*it] - <span class="number">1</span>));</span><br><span class="line">            tree.<span class="built_in">update</span>(ranks[*it], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;ans.<span class="built_in">crbegin</span>(), ans.<span class="built_in">crend</span>()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://www.youtube.com/watch?v=WbafSgetDDk">https://www.youtube.com/watch?v=WbafSgetDDk</a></p>
<p><a href="https://leetcode-cn.com/problems/range-sum-query-mutable/">leetcode307</a></p>
<p><a href="">leetcode315</a></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵快速幂</title>
    <url>/2021-05-03-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    <content><![CDATA[<div class="note default">
            <p>todo</p>
          </div>


<a id="more"></a>



]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2021-05-04-%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<div class="note default">
            <p>在计算机科学中，并查集（英文：Disjoint-set data structure，直译为不交集数据结构）是一种数据结构，用于处理一些不交集（Disjoint sets，一系列没有重复元素的集合）的合并及查询问题。并查集支持如下操作：</p><ul><li>查询：查询某个元素属于哪个集合，通常是返回集合内的一个“代表元素”。这个操作是为了判断两个元素是否在同一个集合之中。</li><li>合并：将两个集合合并为一个。</li><li>添加：添加一个新集合，其中有一个新元素。添加操作不如查询和合并操作重要，常常被忽略。</li></ul><p>由于支持查询和合并这两种操作，并查集在英文中也被称为联合-查找数据结构（Union-find data structure）或者合并-查找集合（Merge-find set）。</p>
          </div>


<a id="more"></a>

<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unionFindSet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unionFindSet</span>(<span class="keyword">int</span> n):<span class="built_in">parents_</span>(n, <span class="number">0</span>), <span class="built_in">ranks_</span>(n, <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parents_.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            parents_[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// path compression</span></span><br><span class="line">        <span class="keyword">if</span> (parents_[i] != i)</span><br><span class="line">            parents_[i] = <span class="built_in">find</span>(parents_[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> parents_[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">unionTwo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// merge</span></span><br><span class="line">        <span class="keyword">auto</span> px = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">auto</span> py = <span class="built_in">find</span>(y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (px == py)   </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ranks_[px] &lt; ranks_[py])</span><br><span class="line">            parents_[px] = py;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ranks_[px] &gt; ranks_[py])</span><br><span class="line">            parents_[py] = px;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            parents_[px] = py;</span><br><span class="line">            ranks_[py]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; parents_;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ranks_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="737"><a href="#737" class="headerlink" title="737"></a>737</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dfs</span></span><br><span class="line"><span class="comment">// class Solution &#123;</span></span><br><span class="line"><span class="comment">// public:</span></span><br><span class="line"><span class="comment">//     bool areSentencesSimilarTwo(vector&lt;string&gt;&amp; sentence1, vector&lt;string&gt;&amp; sentence2, vector&lt;vector&lt;string&gt;&gt;&amp; similarPairs) &#123;</span></span><br><span class="line"><span class="comment">//         int n1 = sentence1.size();</span></span><br><span class="line"><span class="comment">//         int n2 = sentence2.size();</span></span><br><span class="line"><span class="comment">//         if (n1 != n2)</span></span><br><span class="line"><span class="comment">//             return false;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         unordered_map&lt;string, unordered_set&lt;string&gt;&gt; simiMap;</span></span><br><span class="line"><span class="comment">//         for (const auto&amp; p : similarPairs)</span></span><br><span class="line"><span class="comment">//         &#123;</span></span><br><span class="line"><span class="comment">//             // 对称性</span></span><br><span class="line"><span class="comment">//             simiMap[p.front()].insert(p.back());</span></span><br><span class="line"><span class="comment">//             simiMap[p.back()].insert(p.front());</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         for (int i = 0; i &lt; n1; ++i)</span></span><br><span class="line"><span class="comment">//         &#123;</span></span><br><span class="line"><span class="comment">//             const auto&amp; s1 = sentence1[i];</span></span><br><span class="line"><span class="comment">//             const auto&amp; s2 = sentence2[i];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//             // 自身</span></span><br><span class="line"><span class="comment">//             if (s1 == s2)</span></span><br><span class="line"><span class="comment">//                 continue;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//             unordered_set&lt;string&gt; visited;</span></span><br><span class="line"><span class="comment">//             if (!arewordsSimilarTwo(s1, s2, simiMap, visited))</span></span><br><span class="line"><span class="comment">//                 return false;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         return true;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     // dfs</span></span><br><span class="line"><span class="comment">//     bool arewordsSimilarTwo(const string&amp; s1, const string&amp; s2,  unordered_map&lt;string, unordered_set&lt;string&gt;&gt;&amp; simiMap, unordered_set&lt;string&gt;&amp; visited)</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         if (s1 == s2)</span></span><br><span class="line"><span class="comment">//             return true;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         visited.insert(s1);</span></span><br><span class="line"><span class="comment">//         for (const auto&amp; s : simiMap[s1])</span></span><br><span class="line"><span class="comment">//         &#123;</span></span><br><span class="line"><span class="comment">//             if (visited.count(s))</span></span><br><span class="line"><span class="comment">//                 continue;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//             auto ret = arewordsSimilarTwo(s, s2, simiMap, visited);</span></span><br><span class="line"><span class="comment">//             if (ret)</span></span><br><span class="line"><span class="comment">//                 return true;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         return false;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ufs</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unionFindSet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">find</span><span class="params">(<span class="keyword">const</span> string&amp; s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!parents_.<span class="built_in">count</span>(s))</span><br><span class="line">            parents_.<span class="built_in">emplace</span>(s, s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parents_[s] != s)</span><br><span class="line">            parents_[s] = <span class="built_in">find</span>(parents_[s]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> parents_[s];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">unionTwo</span><span class="params">(<span class="keyword">const</span> string&amp; s1, <span class="keyword">const</span> string&amp; s2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p1 = <span class="built_in">find</span>(s1);</span><br><span class="line">        <span class="keyword">auto</span> p2 = <span class="built_in">find</span>(s2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p1 == p2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ranks_[p1] &lt; ranks_[p2])</span><br><span class="line">        &#123;</span><br><span class="line">            parents_[p1] = p2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ranks_[p1] &gt; ranks_[p2])</span><br><span class="line">        &#123;</span><br><span class="line">            parents_[p2] = p1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            parents_[p1] = p2;</span><br><span class="line">            ranks_[p2]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;string, string&gt; parents_;</span><br><span class="line">    unordered_map&lt;string, <span class="keyword">int</span>&gt; ranks_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">areSentencesSimilarTwo</span><span class="params">(vector&lt;string&gt;&amp; sentence1, vector&lt;string&gt;&amp; sentence2, vector&lt;vector&lt;string&gt;&gt;&amp; similarPairs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = sentence1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n2 = sentence2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n1 != n2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        unionFindSet ufs;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : similarPairs)</span><br><span class="line">        &#123;</span><br><span class="line">            ufs.<span class="built_in">unionTwo</span>(p.<span class="built_in">front</span>(), p.<span class="built_in">back</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n1; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; s1 = sentence1[i];</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; s2 = sentence2[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s1 == s2)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">auto</span> p1 = ufs.<span class="built_in">find</span>(s1);</span><br><span class="line">            <span class="keyword">auto</span> p2 = ufs.<span class="built_in">find</span>(s2);</span><br><span class="line">            <span class="keyword">if</span> (p1 != p2)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="684"><a href="#684" class="headerlink" title="684"></a>684</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (edges.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function">unionFindSet <span class="title">ufs</span><span class="params">(edges.size() + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> edge : edges)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ufs.<span class="built_in">unionTwo</span>(edge.<span class="built_in">front</span>(), edge.<span class="built_in">back</span>()))</span><br><span class="line">                <span class="keyword">return</span> edge;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="547"><a href="#547" class="headerlink" title="547"></a>547</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; isConnected)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isConnected.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">unionFindSet <span class="title">ufs</span><span class="params">(isConnected.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; isConnected.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; isConnected[<span class="number">0</span>].<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (isConnected[i][j])</span><br><span class="line">                    ufs.<span class="built_in">unionTwo</span>(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; oSet;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; isConnected.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            oSet.<span class="built_in">insert</span>(ufs.<span class="built_in">find</span>(i));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oSet.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="399"><a href="#399" class="headerlink" title="399"></a>399</h2><p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/20220118_1.drawio.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unionFindSet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="keyword">const</span> string&amp; s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parents_.<span class="built_in">count</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pair&lt;string, double&gt; find(const string&amp; s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化单个节点</span></span><br><span class="line">        <span class="keyword">if</span> (!parents_.<span class="built_in">count</span>(s))</span><br><span class="line">            parents_.<span class="built_in">emplace</span>(s, pair&lt;string, <span class="keyword">double</span>&gt;&#123;s, <span class="number">1.0</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// path compression</span></span><br><span class="line">        <span class="keyword">if</span> (parents_[s].first != s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = <span class="built_in">find</span>(parents_[s].first);</span><br><span class="line">            parents_[s].first = p.first;</span><br><span class="line">            parents_[s].second *= p.second; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> parents_[s];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// x/y = val</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">unionTwo</span><span class="params">(<span class="keyword">const</span> string&amp; x, <span class="keyword">const</span> string&amp; y, <span class="keyword">double</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// merge</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; [px, vx] = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; [py, vy] = <span class="built_in">find</span>(y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (px == py)   </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ranks_[px] &lt; ranks_[py])</span><br><span class="line">        &#123;</span><br><span class="line">            parents_[px] = <span class="built_in">make_pair</span>(py, val * vy / vx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ranks_[px] &gt; ranks_[py])</span><br><span class="line">            parents_[py] = <span class="built_in">make_pair</span>(px, vx / val / vy);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// px/py = ?</span></span><br><span class="line">            <span class="comment">// x / px = vx</span></span><br><span class="line">            <span class="comment">// y / py = vy</span></span><br><span class="line">            <span class="comment">// x / y = val</span></span><br><span class="line">            <span class="comment">// vx * ? = val * vy</span></span><br><span class="line">            parents_[px] = <span class="built_in">make_pair</span>(py, val * vy / vx);</span><br><span class="line">            ranks_[py]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;string, pair&lt;string, <span class="keyword">double</span>&gt;&gt; parents_;</span><br><span class="line">    unordered_map&lt;string, <span class="keyword">int</span>&gt; ranks_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据题目可知，除法的传递是需要支持的</span></span><br><span class="line"><span class="comment">// 自身的除法也要支持(equations中存在的元素)</span></span><br><span class="line"><span class="comment">// 反向的除法也要支持</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">double</span>&gt; <span class="title">calcEquation</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;<span class="keyword">double</span>&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        unionFindSet ufs;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; equations.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ufs.<span class="built_in">unionTwo</span>(equations[i].<span class="built_in">front</span>(), equations[i].<span class="built_in">back</span>(), values[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="keyword">double</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; it: queries)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> a = it.<span class="built_in">front</span>();</span><br><span class="line">            <span class="keyword">auto</span> b = it.<span class="built_in">back</span>();</span><br><span class="line">            <span class="keyword">if</span> (!ufs.<span class="built_in">exist</span>(a) || !ufs.<span class="built_in">exist</span>(b))</span><br><span class="line">                ans.<span class="built_in">push_back</span>(<span class="number">-1.0</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">auto</span>&amp; [pa, va] = ufs.<span class="built_in">find</span>(a);</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">auto</span>&amp; [pb, vb] = ufs.<span class="built_in">find</span>(b);</span><br><span class="line">                <span class="keyword">if</span> (pa != pb)</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(<span class="number">-1.0</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// pa == pb</span></span><br><span class="line">                    <span class="comment">// a / b = ?</span></span><br><span class="line">                    <span class="comment">// a / pa * pa / b</span></span><br><span class="line">                    <span class="comment">// a / pa / b / pa</span></span><br><span class="line">                    <span class="comment">// va / vb</span></span><br><span class="line">                    ans.<span class="built_in">push_back</span>(va / vb);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="685"><a href="#685" class="headerlink" title="685"></a>685</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="839"><a href="#839" class="headerlink" title="839"></a>839</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://leetcode-cn.com/problems/sentence-similarity-ii/submissions/">leetcode 737</a></p>
<p><a href="https://leetcode-cn.com/problems/redundant-connection/">leetcode 684</a></p>
<p><a href="https://leetcode-cn.com/problems/number-of-provinces/submissions/">leetcode 547</a></p>
<p><a href="https://leetcode-cn.com/problems/evaluate-division/submissions/">leetcode 399</a></p>
<p><a href="">leetcode 685</a></p>
<p><a href="">leetcode 839</a></p>
<p><a href="https://www.youtube.com/watch?v=VJnUwsE4fWA">https://www.youtube.com/watch?v=VJnUwsE4fWA</a></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>基数排序+计数排序+桶排序</title>
    <url>/2021-05-05-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F+%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F+%E6%A1%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<div class="note default">
            <p>基数排序+计数排序+桶排序梳理</p>
          </div>


<a id="more"></a>

<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><blockquote>
<p>计数排序（Counting sort）是一种稳定的线性时间排序算法。该算法于1954年由 Harold H. Seward 提出。计数排序使用一个额外的数组{\displaystyle C} C ，其中第i个元素是待排序数组{\displaystyle A}A中值等于{\displaystyle i}i的元素的个数。然后根据数组{\displaystyle C} C 来将{\displaystyle A}A中的元素排到正确的位置。</p>
</blockquote>
<p>数据量大，范围小,非比较排序</p>
<p>用累加数组解决稳定性问题</p>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><blockquote>
<p>基数排序（英语：Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>
</blockquote>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><blockquote>
<p>桶排序（Bucket sort）或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间。但桶排序并不是比较排序，他不受到nlogn下限的影响。</p>
</blockquote>
<p>桶排序以下列程序进行：</p>
<ul>
<li>设置一个定量的数组当作空桶子。</li>
<li>寻访序列，并且把项目一个一个放到对应的桶子去。</li>
<li>对每个不是空的桶子进行排序。</li>
<li>从不是空的桶子里把项目再放回原来的序列中。</li>
</ul>
<p>拷贝一份wiki上的代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BUCKET_NUM = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> i=<span class="number">0</span>)</span>:mData(i),mNext(NULL)&#123;</span>&#125;</span><br><span class="line">	ListNode* mNext;</span><br><span class="line">	<span class="keyword">int</span> mData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">insert</span><span class="params">(ListNode* head,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">	ListNode dummyNode;</span><br><span class="line">	ListNode *newNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">	ListNode *pre,*curr;</span><br><span class="line">	dummyNode.mNext = head;</span><br><span class="line">	pre = &amp;dummyNode;</span><br><span class="line">	curr = head;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">NULL</span>!=curr &amp;&amp; curr-&gt;mData&lt;=val)&#123;</span><br><span class="line">		pre = curr;</span><br><span class="line">		curr = curr-&gt;mNext;</span><br><span class="line">	&#125;</span><br><span class="line">	newNode-&gt;mNext = curr;</span><br><span class="line">	pre-&gt;mNext = newNode;</span><br><span class="line">	<span class="keyword">return</span> dummyNode.mNext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode *head1,ListNode *head2)</span></span>&#123;</span><br><span class="line">	ListNode dummyNode;</span><br><span class="line">	ListNode *dummy = &amp;dummyNode;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">NULL</span>!=head1 &amp;&amp; <span class="literal">NULL</span>!=head2)&#123;</span><br><span class="line">		<span class="keyword">if</span>(head1-&gt;mData &lt;= head2-&gt;mData)&#123;</span><br><span class="line">			dummy-&gt;mNext = head1;</span><br><span class="line">			head1 = head1-&gt;mNext;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			dummy-&gt;mNext = head2;</span><br><span class="line">			head2 = head2-&gt;mNext;</span><br><span class="line">		&#125;</span><br><span class="line">		dummy = dummy-&gt;mNext;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span>!=head1) dummy-&gt;mNext = head1;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span>!=head2) dummy-&gt;mNext = head2;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> dummyNode.mNext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BucketSort</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> arr[])</span></span>&#123;</span><br><span class="line">	<span class="function">vector&lt;ListNode*&gt; <span class="title">buckets</span><span class="params">(BUCKET_NUM,(ListNode*)(<span class="number">0</span>))</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		<span class="keyword">int</span> index = arr[i]/BUCKET_NUM;</span><br><span class="line">		ListNode *head = buckets.<span class="built_in">at</span>(index);</span><br><span class="line">		buckets.<span class="built_in">at</span>(index) = <span class="built_in">insert</span>(head,arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode *head = buckets.<span class="built_in">at</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;BUCKET_NUM;++i)&#123;</span><br><span class="line">		head = <span class="built_in">Merge</span>(head,buckets.<span class="built_in">at</span>(i));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		arr[i] = head-&gt;mData;</span><br><span class="line">		head = head-&gt;mNext;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="164"><a href="#164" class="headerlink" title="164"></a>164</h2><h3 id="基数排序求解"><a href="#基数排序求解" class="headerlink" title="基数排序求解"></a>基数排序求解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基数排序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// &#x27;nums&#x27; must consist of values from 0 to 1000000000 only</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumGap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">oVec</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> max_num = *<span class="built_in">max_element</span>(nums.<span class="built_in">cbegin</span>(), nums.<span class="built_in">cend</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= max_num; i *= <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            array&lt;<span class="keyword">int</span>, 10&gt; count&#123;&#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> idx = nums[j] / i % <span class="number">10</span>;</span><br><span class="line">                count[idx]++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; <span class="number">10</span>; ++k)</span><br><span class="line">                count[k] += count[k<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 反向很重要，保持稳定性，这样排百位的时候个位也是有序的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> idx = nums[j] / i % <span class="number">10</span>;</span><br><span class="line">                oVec[count[idx] - <span class="number">1</span>] = nums[j];</span><br><span class="line">                count[idx]--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nums.<span class="built_in">swap</span>(oVec);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">            ans = <span class="built_in">max</span>(nums[i] - nums[i<span class="number">-1</span>], ans);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="桶排序求解"><a href="#桶排序求解" class="headerlink" title="桶排序求解"></a>桶排序求解</h3><p><strong>计算桶的长度：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l &#x3D; max(1, ((max_num - min_num) &#x2F; (n - 1)))</span><br></pre></td></tr></table></figure>

<p>这里算的是非负整数，长度至少为1。长度这么取也是有道理的：</p>
<p>数组里面每2个数之间的差值都 &gt;= (max_num - min_num) / (n - 1)),可以证明:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假定数组里面每2个数的差值都&lt; (max_num - min_num) &#x2F; (n - 1)),一共有n个数，故可知：</span><br><span class="line"></span><br><span class="line">num(n) - num(n-1) + num(n-1) - num(n-2) ... + num(2) - num(1)</span><br><span class="line">&#x3D; num(n) - num(1) </span><br><span class="line"></span><br><span class="line">num(n) - num(1) &lt; (n-1)*(max_num - min_num) &#x2F; (n - 1))</span><br><span class="line">num(n) - num(1) &lt; max_num - min_num</span><br><span class="line">这显然不合理，所以就是说数组中必然存在2数之间差值大于(max_num - min_num) &#x2F; (n - 1)的，而(max_num - min_num) &#x2F; (n - 1)指的是桶的长度，所以说数组中必然存在相邻2数之间差值大于桶长度l的，也就是存在相邻的2个数跨相邻(相邻中间也可能存在空的桶)的桶。这个数必然大于一个桶内的2个数的差值，所以只需要记录每个桶的最大值和最小值，最后计算&quot;相邻&quot;桶的最大值和最小值的差值来找最大值就是结果。</span><br></pre></td></tr></table></figure>

<p><strong>计算桶的个数：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">((max_num - min_num) &#x2F; l ) + 1</span><br></pre></td></tr></table></figure>

<p>因为是左开右闭区间，加1保证最大值在一个桶内</p>
<p><strong>计算一个输入值对应桶的索引:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(num - min_num) &#x2F; l</span><br></pre></td></tr></table></figure>

<p>因为是左开右闭区间，数组又是从0开始的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 桶排序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumGap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max_num = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> min_num = *<span class="built_in">min_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> bl = <span class="built_in">max</span>(<span class="number">1</span>, (max_num - min_num) / (n - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">int</span> bc = (max_num - min_num) / bl + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 本题的数的取值范围是</span></span><br><span class="line">        <span class="comment">// nums&#x27; must consist of values from 0 to 1000000000 only</span></span><br><span class="line">        vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; <span class="built_in">bucket</span>(bc, &#123;INT_MAX, INT_MIN&#125;);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> idx = (num - min_num) / bl;</span><br><span class="line">            bucket[idx].first = <span class="built_in">min</span>(bucket[idx].first, num);</span><br><span class="line">            bucket[idx].second = <span class="built_in">max</span>(bucket[idx].second, num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> prev_second = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bc; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (prev_second != INT_MIN &amp;&amp; bucket[i].first != INT_MAX)</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, bucket[i].first - prev_second);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (bucket[i].second != INT_MIN)</span><br><span class="line">                prev_second = bucket[i].second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://leetcode-cn.com/problems/maximum-gap/">leetcode 164</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E6%A1%B6%E6%8E%92%E5%BA%8F">https://zh.wikipedia.org/wiki/%E6%A1%B6%E6%8E%92%E5%BA%8F</a></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>windows下vscode远程配置环境</title>
    <url>/2021-05-18-windows%E4%B8%8Bvscode%E8%BF%9C%E7%A8%8B%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%20copy/</url>
    <content><![CDATA[<div class="note default">
            <p>公司办公环境是mac下vscode通过ssh连接的docker编译环境，自己的win10就没配编译环境。一般简单的测试都是用在线的编译器，最近在看一些东西，感觉还是本地的方便一些，就把本地环境也搞了下。有些坑记录下，便于以后使用</p>
          </div>


<a id="more"></a>

<h2 id="vscode添加remote-ssh"><a href="#vscode添加remote-ssh" class="headerlink" title="vscode添加remote ssh"></a>vscode添加remote ssh</h2><p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/vscode-ssh_1.jpg"></p>
<h2 id="配置config"><a href="#配置config" class="headerlink" title="配置config"></a>配置config</h2><p>~/.ssh/config里面的配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># dev</span><br><span class="line">Host 0.0.0.0</span><br><span class="line">User username</span><br><span class="line">Port 12345</span><br><span class="line">HostName 0.0.0.0</span><br><span class="line">IdentityFile E:&#x2F;*&#x2F;*&#x2F;rsa</span><br></pre></td></tr></table></figure>

<p>注意分隔符</p>
<h2 id="权限问题"><a href="#权限问题" class="headerlink" title="权限问题"></a>权限问题</h2><p>一直提示rsa文件权限不对，参考这里: <a href="https://superuser.com/questions/1296024/windows-ssh-permissions-for-private-key-are-too-open">Windows SSH: Permissions for ‘private-key’ are too open</a></p>
<h2 id="ssh-port"><a href="#ssh-port" class="headerlink" title="ssh port"></a>ssh port</h2><p>裸ssh 22端口不安全，我就改了，但是服务器厂商开了selinux,导致这里多了一步</p>
<p>vim /etc/ssh/sshd_config</p>
<p>semanage port -a -t http_port_t -p tcp 8888</p>
<p>参考: <a href="http://www.shangdixinxi.com/detail-1097088.html">SELinux 开放和关闭端口</a></p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/vscode-ssh_3.jpg"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不建议直接用root用户，我懒得弄了</p>
]]></content>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>c++ stl 排序总结</title>
    <url>/2021-05-24-c++%20stl%20%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93%20/</url>
    <content><![CDATA[<div class="note default">
            <p><effective stl> 条款31 中提到了这几种排序的性能优先级(时间和空间消耗)，前面的更优<br>1 partition<br>2 stable_partition<br>3 nth_element<br>4 partial_sort<br>5 sort<br>6 stable_sort<br>? priority_queue(快排比堆排序好点，具体看上一篇文章)</p><p>站在手写堆排序，快速选择的角度，来看看这些函数的源码是怎么实现的。</p>
          </div>

<a id="more"></a>

<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/20210925_01%20(1).png"></p>
<h2 id="nth-element"><a href="#nth-element" class="headerlink" title="nth_element"></a>nth_element</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">nth_element</span><span class="params">(_RandomAccessIter __first, _RandomAccessIter __nth,</span></span></span><br><span class="line"><span class="function"><span class="params">                        _RandomAccessIter __last)</span> </span>&#123;</span><br><span class="line">  __nth_element(__first, __nth, __last, __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> __nth_element(_RandomAccessIter __first, _RandomAccessIter __nth,</span><br><span class="line">                   _RandomAccessIter __last, _Tp*) &#123;</span><br><span class="line">  <span class="keyword">while</span> (__last - __first &gt; <span class="number">3</span>) &#123;</span><br><span class="line">    _RandomAccessIter __cut =</span><br><span class="line">      __unguarded_partition(__first, __last,</span><br><span class="line">                            _Tp(__median(*__first,</span><br><span class="line">                                         *(__first + (__last - __first)/<span class="number">2</span>),</span><br><span class="line">                                         *(__last - <span class="number">1</span>))));</span><br><span class="line">    <span class="keyword">if</span> (__cut &lt;= __nth)</span><br><span class="line">      __first = __cut;  <span class="comment">// 缩小范围，更靠近结果</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">      __last = __cut;   <span class="comment">// 缩小范围，更靠近结果</span></span><br><span class="line">  &#125;</span><br><span class="line">  __insertion_sort(__first, __last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了看起来方便，用的gcc 2.95.1的源码。这里有nth_element函数的重载，支持自定义比较函数，核心逻辑是一致的。就拿简单的没有自定义函数的来看。__last - __first &gt; 3的时候用快速选择，__nth_element里面while循环在重复调用__unguarded_partition,没有使用递归。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// __median (an extension, not present in the C++ standard).</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">const</span> _Tp&amp; __median(<span class="keyword">const</span> _Tp&amp; __a, <span class="keyword">const</span> _Tp&amp; __b, <span class="keyword">const</span> _Tp&amp; __c) &#123;</span><br><span class="line">  <span class="keyword">if</span> (__a &lt; __b)</span><br><span class="line">    <span class="keyword">if</span> (__b &lt; __c)</span><br><span class="line">      <span class="keyword">return</span> __b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (__a &lt; __c)</span><br><span class="line">      <span class="keyword">return</span> __c;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> __a;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (__a &lt; __c)</span><br><span class="line">    <span class="keyword">return</span> __a;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (__b &lt; __c)</span><br><span class="line">    <span class="keyword">return</span> __c;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> __b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line">_RandomAccessIter __unguarded_partition(_RandomAccessIter __first, </span><br><span class="line">                                        _RandomAccessIter __last, </span><br><span class="line">                                        _Tp __pivot) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (*__first &lt; __pivot)</span><br><span class="line">      ++__first;</span><br><span class="line">    --__last;   <span class="comment">// 第一次进来是end() - 1, 后面的情况和++__first是对应的</span></span><br><span class="line">    <span class="keyword">while</span> (__pivot &lt; *__last)</span><br><span class="line">      --__last;</span><br><span class="line">    <span class="keyword">if</span> (!(__first &lt; __last))</span><br><span class="line">      <span class="keyword">return</span> __first;</span><br><span class="line">    <span class="built_in">iter_swap</span>(__first, __last); <span class="comment">// 大的放右边 小的放左边</span></span><br><span class="line">    ++__first;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>__median这里取的是中位数，很多地方快速排序会拿第一个或最后一个作为__pivot,无关紧要。__unguarded_partition的__pivot是值传递，因为这里会swap。然后最终都要走到插入排序__insertion_sort来收尾。因为看的是不带自定义比较函数的版本，所以这块的逻辑都是按默认的升序来的。看了下gcc 9.2.0逻辑也是差不多的，多了一种__heap_select的情况，不深究了。</p>
<p>这里的命名可以看出来需要传入random的iterator,这是要注意的。</p>
<p>新版本的带比较函数的版本有这样的注释：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief Sort a sequence just enough to find a particular position</span></span><br><span class="line"><span class="comment"> *         using a predicate for comparison.</span></span><br><span class="line"><span class="comment"> *  @ingroup sorting_algorithms</span></span><br><span class="line"><span class="comment"> *  @param  __first   An iterator.</span></span><br><span class="line"><span class="comment"> *  @param  __nth     Another iterator.</span></span><br><span class="line"><span class="comment"> *  @param  __last    Another iterator.</span></span><br><span class="line"><span class="comment"> *  @param  __comp    A comparison functor.</span></span><br><span class="line"><span class="comment"> *  @return  Nothing.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Rearranges the elements in the range @p [__first,__last) so that @p *__nth</span></span><br><span class="line"><span class="comment"> *  is the same element that would have been in that position had the</span></span><br><span class="line"><span class="comment"> *  whole sequence been sorted. The elements either side of @p *__nth are</span></span><br><span class="line"><span class="comment"> *  not completely sorted, but for any iterator @e i in the range</span></span><br><span class="line"><span class="comment"> *  @p [__first,__nth) and any iterator @e j in the range @p [__nth,__last) it</span></span><br><span class="line"><span class="comment"> *  holds that @p __comp(*j,*i) is false.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>comp ([fisrt, nth), [nth, last)) = false; </p>
<h2 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="keyword">class</span> _<span class="title">Predicate</span>&gt;</span></span><br><span class="line">_ForwardIter __partition(_ForwardIter __first,</span><br><span class="line">		         _ForwardIter __last,</span><br><span class="line">			 _Predicate   __pred,</span><br><span class="line">			 forward_iterator_tag) &#123;</span><br><span class="line">  <span class="keyword">if</span> (__first == __last) <span class="keyword">return</span> __first;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (__pred(*__first))</span><br><span class="line">    <span class="keyword">if</span> (++__first == __last) <span class="keyword">return</span> __first;</span><br><span class="line"></span><br><span class="line">  _ForwardIter __next = __first;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (++__next != __last)</span><br><span class="line">    <span class="keyword">if</span> (__pred(*__next)) &#123;</span><br><span class="line">      <span class="built_in">swap</span>(*__first, *__next);</span><br><span class="line">      ++__first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> __first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">BidirectionalIter</span>, <span class="keyword">class</span> _<span class="title">Predicate</span>&gt;</span></span><br><span class="line">_BidirectionalIter __partition(_BidirectionalIter __first,</span><br><span class="line">                               _BidirectionalIter __last,</span><br><span class="line">			       _Predicate __pred,</span><br><span class="line">			       bidirectional_iterator_tag) &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">      <span class="keyword">if</span> (__first == __last)</span><br><span class="line">        <span class="keyword">return</span> __first;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (__pred(*__first))</span><br><span class="line">        ++__first;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    --__last;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">      <span class="keyword">if</span> (__first == __last)</span><br><span class="line">        <span class="keyword">return</span> __first;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!__pred(*__last))</span><br><span class="line">        --__last;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">iter_swap</span>(__first, __last);</span><br><span class="line">    ++__first;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIter</span>, <span class="keyword">class</span> _<span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> _ForwardIter <span class="title">partition</span><span class="params">(_ForwardIter __first,</span></span></span><br><span class="line"><span class="function"><span class="params">   			      _ForwardIter __last,</span></span></span><br><span class="line"><span class="function"><span class="params">			      _Predicate   __pred)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> __partition(__first, __last, __pred, __ITERATOR_CATEGORY(__first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里对forward_iterator_tag和bidirectional_iterator_tag做了特化，因为is a的关系，random_access_iterator_tag也可以使用。这里特殊处理应该是有其他考虑。这里只看看单向的实现。</p>
<p>看了下和前面的nth_elements几乎一样的逻辑，单向的有点不同，但也好理解。nth_element强调的是在排序中的位置，partition更注重按功能分区，一次就完成了不需要多次执行缩小范围到具体的位置，并且支持的iterator的种类更多。</p>
<h2 id="partial-sort"><a href="#partial-sort" class="headerlink" title="partial_sort"></a>partial_sort</h2><p>同样是2个函数，一个多个自定义函数的参数，只看下默认的实现逻辑。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// partial_sort, partial_sort_copy, and auxiliary functions.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> __partial_sort(_RandomAccessIter __first, _RandomAccessIter __middle,</span><br><span class="line">                    _RandomAccessIter __last, _Tp*) &#123;</span><br><span class="line">  <span class="built_in">make_heap</span>(__first, __middle);</span><br><span class="line">  <span class="keyword">for</span> (_RandomAccessIter __i = __middle; __i &lt; __last; ++__i)</span><br><span class="line">    <span class="keyword">if</span> (*__i &lt; *__first) </span><br><span class="line">      __pop_heap(__first, __middle, __i, _Tp(*__i),</span><br><span class="line">                 __DISTANCE_TYPE(__first));</span><br><span class="line">  <span class="built_in">sort_heap</span>(__first, __middle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">partial_sort</span><span class="params">(_RandomAccessIter __first,</span></span></span><br><span class="line"><span class="function"><span class="params">                         _RandomAccessIter __middle,</span></span></span><br><span class="line"><span class="function"><span class="params">                         _RandomAccessIter __last)</span> </span>&#123;</span><br><span class="line">  __partial_sort(__first, __middle, __last, __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// partial_sort, partial_sort_copy, and auxiliary functions.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIter</span>, <span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> __partial_sort(_RandomAccessIter __first, _RandomAccessIter __middle,</span><br><span class="line">                    _RandomAccessIter __last, _Tp*) &#123;</span><br><span class="line">  <span class="built_in">make_heap</span>(__first, __middle);</span><br><span class="line">  <span class="keyword">for</span> (_RandomAccessIter __i = __middle; __i &lt; __last; ++__i)</span><br><span class="line">    <span class="keyword">if</span> (*__i &lt; *__first) </span><br><span class="line">      __pop_heap(__first, __middle, __i, _Tp(*__i),</span><br><span class="line">                 __DISTANCE_TYPE(__first));</span><br><span class="line">  <span class="built_in">sort_heap</span>(__first, __middle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STL_LIMITED_DEFAULT_TEMPLATES</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Sequence</span> =</span> vector&lt;_Tp&gt;, </span><br><span class="line">          <span class="class"><span class="keyword">class</span> _<span class="title">Compare</span> =</span> less&lt;<span class="keyword">typename</span> _Sequence::value_type&gt; &gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Sequence</span>, <span class="keyword">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>前面都是函数模板，而priority_queue是一个单独的类。<br>单独整理了一篇: <a href="https://riverferry.site/2021-09-24-stl%20priority_queue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">stl priority_queue源码分析</a></p>
]]></content>
      <tags>
        <tag>c++</tag>
        <tag>stl</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>stl priority_queue源码分析</title>
    <url>/2021-05-24-stl%20priority_queue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<div class="note default">
            <p>分析stl sort函数的时候，发现优先级队列挺麻烦的，单独整理一篇</p>
          </div>

<a id="more"></a>

<h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STL_LIMITED_DEFAULT_TEMPLATES</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Sequence</span> =</span> vector&lt;_Tp&gt;, </span><br><span class="line">          <span class="class"><span class="keyword">class</span> _<span class="title">Compare</span> =</span> less&lt;<span class="keyword">typename</span> _Sequence::value_type&gt; &gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Sequence</span>, <span class="keyword">class</span> _<span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>看看常用的几个函数的实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">front</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type&amp; __x)</span> </span>&#123;</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      c.<span class="built_in">push_back</span>(__x); </span><br><span class="line">      <span class="built_in">push_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp);</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(c.<span class="built_in">clear</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">__STL_TRY &#123;</span><br><span class="line">    <span class="built_in">pop_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp);</span><br><span class="line">    c.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line">__STL_UNWIND(c.<span class="built_in">clear</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>// 不带自定义排序的版本，默认是个最大堆</p>
<h3 id="push-heap"><a href="#push-heap" class="headerlink" title="push_heap"></a>push_heap</h3><p>这里添加新元素的方法是：从下往上堆化</p>
<ul>
<li>先往完全二叉树的最后一个节点即随机迭代器的end()插入一个新元素，位置记为hole_index</li>
<li>然后逐层往上和父节点比较，如果不满足最大堆的性质就覆盖父节点(这里没有直接swap)，直到top_index也就是堆顶结束</li>
</ul>
<p>这里传入了value是个值对象，在priority_queue::push_back(tmp)中value就是tmp,是vector的最后一个元素,在priority_queue::pop()中，value是数组原来最后的那个元素，但进到这个函数的时候最后一个元素已经被front()覆盖了，此时比堆化的是一个小数组。如下演示:</p>
<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/20210925_push_heap.gif"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Heap-manipulation functions: push_heap, pop_heap, make_heap, sort_heap.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> _<span class="title">Distance</span>, <span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">__push_heap(_RandomAccessIterator __first,</span><br><span class="line">            _Distance __holeIndex, _Distance __topIndex, _Tp __value)</span><br><span class="line">&#123;</span><br><span class="line">  _Distance __parent = (__holeIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">while</span> (__holeIndex &gt; __topIndex &amp;&amp; *(__first + __parent) &lt; __value) &#123;</span><br><span class="line">    *(__first + __holeIndex) = *(__first + __parent);</span><br><span class="line">    __holeIndex = __parent;</span><br><span class="line">    __parent = (__holeIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">  &#125;    </span><br><span class="line">  *(__first + __holeIndex) = __value;   <span class="comment">// 这一步很重要，因为value不一定就是back()的元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> _<span class="title">Distance</span>, <span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">__push_heap_aux(_RandomAccessIterator __first,</span><br><span class="line">                _RandomAccessIterator __last, _Distance*, _Tp*)</span><br><span class="line">&#123;</span><br><span class="line">  __push_heap(__first, _Distance((__last - __first) - <span class="number">1</span>), _Distance(<span class="number">0</span>), </span><br><span class="line">              _Tp(*(__last - <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line"><span class="built_in">push_heap</span>(_RandomAccessIterator __first, _RandomAccessIterator __last)</span><br><span class="line">&#123;</span><br><span class="line">  __push_heap_aux(__first, __last,</span><br><span class="line">                  __DISTANCE_TYPE(__first), __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="pop-heap"><a href="#pop-heap" class="headerlink" title="pop_heap"></a>pop_heap</h3><p>移除堆顶元素,这里比较复杂，一般介绍的删除堆顶的方法是:</p>
<ul>
<li>把最后一个元素的值拷贝到堆顶</li>
<li>然后删除最后一个元素</li>
<li>在接着从堆顶<strong>往下堆化</strong>更新</li>
</ul>
<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/20210925_pop_heap.gif"></p>
<p>但这里却不是这么实现的，简单概括下就是(按照默认的最大堆看)：</p>
<ul>
<li>把堆顶的元素的值拷贝到最后一个元素</li>
<li>然后往下查找左右节点，把最大值(更新hole_index为当前的最大值的索引)拷贝到父节点(只比较左右节点，不和父节点比较)</li>
<li>如果一直找直到找到了最后一个节点，则把倒数第二个节点(hole_index)拷贝到父节点 </li>
<li>push_heap插入原来被覆盖掉的尾节点back()的值，范围是从first到前面最后那个hole_index</li>
</ul>
<p>分析：因为第一步用front()覆盖了back(),导致有2个重复的值，并且少了一个value(即原来的back()).后面一直按照com的规则，用最大值覆盖父节点，往下层走，保证上层都是符合堆化规则的。一直找到最后一层的最大值，这个最大值已经被copy然后赋值到上一层了，所以是重复存在的值，这时候相当于用value替换了这个重复的值，然后还是<strong>往上堆化</strong>.</p>
<p>画了个示意图：</p>
<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/20210925_heap_3_new.png"></p>
<p>if (__secondChild == __len)这种情况需要特别处理:</p>
<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/20210925_heap_4_new.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> _<span class="title">Distance</span>, <span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">__adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,</span><br><span class="line">              _Distance __len, _Tp __value)</span><br><span class="line">&#123;</span><br><span class="line">  _Distance __topIndex = __holeIndex;</span><br><span class="line">  _Distance __secondChild = <span class="number">2</span> * __holeIndex + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">while</span> (__secondChild &lt; __len) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*(__first + __secondChild) &lt; *(__first + (__secondChild - <span class="number">1</span>)))  <span class="comment">// __secondChild = 孩子节点的较大值</span></span><br><span class="line">      __secondChild--;</span><br><span class="line"></span><br><span class="line">    *(__first + __holeIndex) = *(__first + __secondChild);  <span class="comment">// __secondChild的值赋值给父节点__holeIndex</span></span><br><span class="line">    __holeIndex = __secondChild;</span><br><span class="line">    __secondChild = <span class="number">2</span> * (__secondChild + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__secondChild == __len) &#123;     <span class="comment">// 碰到了最后的元素，也就是原来的堆顶元素</span></span><br><span class="line">    *(__first + __holeIndex) = *(__first + (__secondChild - <span class="number">1</span>));</span><br><span class="line">    __holeIndex = __secondChild - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  __push_heap(__first, __holeIndex, __topIndex, __value);   <span class="comment">// push原来的最后那个元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,</span><br><span class="line">           _RandomAccessIterator __result, _Tp __value, _Distance*)</span><br><span class="line">&#123;</span><br><span class="line">  *__result = *__first;     <span class="comment">// 用堆顶元素覆盖最后一个元素</span></span><br><span class="line">  __adjust_heap(__first, _Distance(<span class="number">0</span>), _Distance(__last - __first), __value);   <span class="comment">// 传入原来最后的元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">__pop_heap_aux(_RandomAccessIterator __first, _RandomAccessIterator __last,</span><br><span class="line">               _Tp*)</span><br><span class="line">&#123;</span><br><span class="line">  __pop_heap(__first, __last - <span class="number">1</span>, __last - <span class="number">1</span>, </span><br><span class="line">             _Tp(*(__last - <span class="number">1</span>)), __DISTANCE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pop_heap</span><span class="params">(_RandomAccessIterator __first, </span></span></span><br><span class="line"><span class="function"><span class="params">                     _RandomAccessIterator __last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __pop_heap_aux(__first, __last, __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="make-heap"><a href="#make-heap" class="headerlink" title="make_heap"></a>make_heap</h3><p>建堆，步骤：</p>
<ul>
<li>从最后的一个非叶子节点(parent)开始往下堆化，每次用孩子节点的较大值覆盖父节点的值，一层一层往下执行<ul>
<li>记录当前parent = old_parent</li>
<li>走到最后的位置是hole_index</li>
<li>hole_index和它的now_parent是相同的值</li>
<li>push_heap原来的old_parent值到random_iter[old_parent : hole_index]</li>
</ul>
</li>
<li>退一步(old_parent-1)，由底层到top,逐层一个一个执行上一步的步骤</li>
<li>执行到top停止</li>
</ul>
<p>代码逻辑示例图：</p>
<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/20210925_6.png"></p>
<p>直接swap交换的话逻辑会简单很多:</p>
<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/20210925_head_6.gif"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> _<span class="title">Distance</span>, <span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">__adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,</span><br><span class="line">              _Distance __len, _Tp __value)</span><br><span class="line">&#123;</span><br><span class="line">  _Distance __topIndex = __holeIndex;</span><br><span class="line">  _Distance __secondChild = <span class="number">2</span> * __holeIndex + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">while</span> (__secondChild &lt; __len) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*(__first + __secondChild) &lt; *(__first + (__secondChild - <span class="number">1</span>)))  <span class="comment">// __secondChild = 孩子节点的较大值</span></span><br><span class="line">      __secondChild--;</span><br><span class="line"></span><br><span class="line">    *(__first + __holeIndex) = *(__first + __secondChild);  <span class="comment">// __secondChild的值赋值给父节点__holeIndex</span></span><br><span class="line">    __holeIndex = __secondChild;</span><br><span class="line">    __secondChild = <span class="number">2</span> * (__secondChild + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__secondChild == __len) &#123;     <span class="comment">// 碰到了最后的元素，也就是原来的堆顶元素</span></span><br><span class="line">    *(__first + __holeIndex) = *(__first + (__secondChild - <span class="number">1</span>));</span><br><span class="line">    __holeIndex = __secondChild - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  __push_heap(__first, __holeIndex, __topIndex, __value);   <span class="comment">// push原来的最后那个元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">__make_heap(_RandomAccessIterator __first,</span><br><span class="line">            _RandomAccessIterator __last, _Tp*, _Distance*)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__last - __first &lt; <span class="number">2</span>) <span class="keyword">return</span>; <span class="comment">// 只有一个元素</span></span><br><span class="line">  _Distance __len = __last - __first; <span class="comment">// 元素个数</span></span><br><span class="line">  _Distance __parent = (__len - <span class="number">2</span>)/<span class="number">2</span>; <span class="comment">// 最后一个节点的父节点的距离</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    __adjust_heap(__first, __parent, __len, _Tp(*(__first + __parent)));</span><br><span class="line">    <span class="keyword">if</span> (__parent == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    __parent--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line"><span class="built_in">make_heap</span>(_RandomAccessIterator __first, _RandomAccessIterator __last)</span><br><span class="line">&#123;</span><br><span class="line">  __make_heap(__first, __last,</span><br><span class="line">              __VALUE_TYPE(__first), __DISTANCE_TYPE(__first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="time-complexity"><a href="#time-complexity" class="headerlink" title="time complexity"></a>time complexity</h2><p>时间复杂度</p>
<table>
<thead>
<tr>
<th>建堆</th>
<th>插入</th>
<th>删除</th>
<th>排序</th>
</tr>
</thead>
<tbody><tr>
<td>O(n)</td>
<td>O(logn)</td>
<td>O(logn)</td>
<td>O(nlogn)</td>
</tr>
</tbody></table>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>原地排序算法依赖于有序容器，快排也是原地排序(有序容器)</li>
<li>不稳定的排序，和快排一样</li>
<li>不是顺序访问，对cpu缓存不友好，这一点不如quicksort</li>
<li>数据交换次数多于快排</li>
</ul>
]]></content>
      <tags>
        <tag>c++</tag>
        <tag>stl</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1504 Count Submatrices With All Ones</title>
    <url>/2021-06-23-1504%20Count%20Submatrices%20With%20All%20Ones%20copy/</url>
    <content><![CDATA[<div class="note default">
            <p><a href="https://leetcode-cn.com/problems/count-submatrices-with-all-ones/">题目</a> 给你一个只包含 0 和 1 的 rows * columns 矩阵 mat，请你返回有多少个子矩形的元素全部都是 1 。</p>
          </div>


<a id="more"></a>


<h2 id="1-solution"><a href="#1-solution" class="headerlink" title="1 solution"></a>1 solution</h2><p>动态规划算法，比较好理解，对于1d的数组，总的矩形个数是:</p>
<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/Untitled%20Diagram.png"></p>
<p>对于2d的数组，可以先算1d的个数，然后每次加上上一行的数组，合起来算最小宽度的新的数组的个数，这样可以涵盖所有的情况，如图:</p>
<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/Untitled%20Diagram%20(1).png"></p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 solution 动态规划</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSubmat</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = mat.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (mat[i][j])</span><br><span class="line">                    mat[i][j] += j == <span class="number">0</span> ? <span class="number">0</span> :mat[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (mat[i][j] &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    res += mat[i][j];</span><br><span class="line">                    <span class="keyword">auto</span> small = mat[i][j];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = i - <span class="number">1</span>; k &gt;= <span class="number">0</span> &amp;&amp; mat[k][j] &gt; <span class="number">0</span>; --k)</span><br><span class="line">                    &#123;</span><br><span class="line">                        small = <span class="built_in">min</span>(mat[k][j], small);</span><br><span class="line">                        res += small;</span><br><span class="line">                    &#125;   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(mmn) </p>
<p>空间复杂度 O(1)</p>
<h2 id="2-solution"><a href="#2-solution" class="headerlink" title="2 solution"></a>2 solution</h2><p>单调栈算法，上面动态规划其实只是横向的动态规划，纵向每次都还要往上遍历包含重复的情况。而且往上有个规律就是上面宽度只能小于等于当前的宽度，这样才能构成新的矩形。这里存在单调性的情况，所以可以考虑用单调栈，但这个实现起来非常麻烦，我也是看着官方题解想了半天</p>
<p>可以先回顾下算柱状图中最大矩形的时候怎么用单调栈的:</p>
<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/Untitled%20Diagram%20(3).png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push i &#x3D; 0</span><br><span class="line">pop i &#x3D; 0,  max &#x3D; 2 * 1 </span><br><span class="line">push i &#x3D; 1</span><br><span class="line">push i &#x3D; 2</span><br><span class="line">push i &#x3D; 3</span><br><span class="line">pop i &#x3D; 3,  max &#x3D; 3 * 1</span><br><span class="line">pop i &#x3D; 2,  max &#x3D; 2 * 2</span><br><span class="line">pop i &#x3D; 1,  max &#x3D; 1 * 4</span><br></pre></td></tr></table></figure>

<p>这里稍加转换可以用在本题，入栈的时候加上栈内的值的和就可以了，也就是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push i &#x3D; 2, h[2] + h[1]</span><br><span class="line">push i &#x3D; 3, h[3] + h[2] + h[1] </span><br></pre></td></tr></table></figure>

<p>直接这样写还是不行的，因为已经出栈i = 0, 也有一个1会被后面的使用，这是个理解的难点。因此题解里面栈内存的是pair(i, height), 也就是加了个高度。默认入栈高度为1，对于栈内元素全部出栈后接着入栈的第一个元素，高度要加上前面的pop元素的高度。说多了容易被语言困扰，看代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2 solution 单调栈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSubmat</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = mat.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">heights</span><span class="params">(m + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> addMutiRow = [&amp;m, &amp;res](vector&lt;<span class="keyword">int</span>&gt;&amp; heights) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// (row, high) </span></span><br><span class="line">            stack&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; st;</span><br><span class="line">            st.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span>; </span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> high = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; m + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> top = st.<span class="built_in">top</span>();</span><br><span class="line">                <span class="keyword">if</span> (heights[i] &gt;= heights[top.first])</span><br><span class="line">                &#123;</span><br><span class="line">                    sum += heights[i];                    </span><br><span class="line">                    count += sum;</span><br><span class="line">                    st.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(i++, high));</span><br><span class="line">                    high = <span class="number">1</span>;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    st.<span class="built_in">pop</span>();  </span><br><span class="line">                    high += top.second;</span><br><span class="line">                    sum -= ((heights[top.first] - heights[i]) * top.second);        </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (mat[i][j])</span><br><span class="line">                    mat[i][j] += j == <span class="number">0</span> ? <span class="number">0</span> :mat[i][j - <span class="number">1</span>];   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">                heights[i + <span class="number">1</span>] = mat[i][j];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> num = <span class="built_in">addMutiRow</span>(heights);</span><br><span class="line">            res += num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>无意间发现了这道题，动态规划挺好理解的，单调栈看了思路后尝试自己写，结果写了半天没写出来，淦啊。然后钻牛角尖浪费了不少时间，就这样吧</p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>raft</title>
    <url>/2021-09-01-raft/</url>
    <content><![CDATA[<div class="note default">
            <p>分布式系统通过复制状态机来解决分布式的容错。对于多副本，如何保持一致性是很难的。raft作为分布式共识算法来解决一致性问题。以前有过mit的实验总结，这篇对于概念做一个总结，用自己的语言复一下论文。</p>
          </div>


<a id="more"></a>

<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/raft-%E5%9B%BE1.png"></p>
<h3 id="paxos的优缺点"><a href="#paxos的优缺点" class="headerlink" title="paxos的优缺点"></a>paxos的优缺点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">paxos的缺点：</span><br><span class="line"></span><br><span class="line">* 难以理解</span><br><span class="line">    * 单决策和多决策</span><br><span class="line">* 工程难以实现</span><br><span class="line">    * 论文缺乏细节，各种实现不一，并且没有公开</span><br><span class="line"></span><br><span class="line">对等的点对点的方式作为核心(也提议了一种弱领导人的方式提高性能)</span><br><span class="line"></span><br><span class="line">paxos算法本身被证明是正确可行的，但是工程实现遇到很多问题，需要对协议进行更改，最终导致实现的定制化的paxos的正确性没法证明了，比如chubby的实现</span><br><span class="line"></span><br><span class="line">优点：</span><br><span class="line">性能更好，可用性更高</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="raft特点"><a href="#raft特点" class="headerlink" title="raft特点"></a>raft特点</h3><p>raft一致性算法的特性：</p>
<ul>
<li>安全性保证</li>
<li>可用性</li>
<li>不依赖时序保证一致性</li>
<li>小部分较慢的节点不会影响系统整体的性能</li>
<li>日志不允许有空洞(如果两个日志在某一索引位置term任期号相同，则认为从头到该索引的所有日志都相同)</li>
</ul>
<p>raft的优点：</p>
<ul>
<li>工程实现简单</li>
<li>易于理解</li>
<li>操作的高效性</li>
<li>状态的数量少，考虑的情况没那么复杂</li>
</ul>
<hr>
<h3 id="领导人选举"><a href="#领导人选举" class="headerlink" title="领导人选举"></a>领导人选举</h3><p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/raft-%E5%9B%BE4.png"></p>
<p>通过领导人保证日志的一致性，由领导人告诉节点日志条目应该放在日志中的位置，而不需要和其他节点进行商议。领导人失去连接后，新的领导人会被选出来。</p>
<p>节点初始状态是跟随者，只能响应领导者和候选者的rpc,如果跟随者一段时间内都没有收到消息，则会给自己的term加一，然后发起选举，争取投票，这个过程可能产生3种结果</p>
<p><strong>成为领导人</strong></p>
<p>每一个服务器给一个任期最多只投一张票，按照先来先服务的原则，保证同一任期内最多有1个领导人。一旦获得了多数票，则切换自己的状态为领导人，并发送附加日志的rpc心跳包(日志内容为空)来维持自己的领导，组织其他的选举发生</p>
<p><strong>其他节点成为领导人</strong></p>
<p>作为候选者，收到了其他节点的附加rpc请求，该节点的任期号不小于自己的节点，则承认对方为领导人，自己切换回跟随者状态。如果对方的任期号比自己的小，则拒绝，继续收集选票。</p>
<p><strong>一段时间内都没有领导人选举成功</strong></p>
<p>当有多个候选者收集选票的时候，选票会被瓜分，以至于没有人成功获选直至超时后大家都给任期号加1，再次尝试选举。这个过程可能一直僵持下去。</p>
<p>raft通过随机生成选举超时时间，来避免多个节点同时发起选举。解决这个问题。通过这种不确定性来保证算法的可理解性和正确性。</p>
<hr>
<h3 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h3><p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/raft-%E5%9B%BE6.png"></p>
<p>由领导人接收客户端的日志，然后复制到集群中的其他节点，<strong>强制</strong>其他节点的日志和自己保持一致</p>
<p>日志由日志的<code>索引</code>，<code>任期号</code>，<code>指令</code>组成。领导人发送附加日志rpc给其他节点，当大多数节点都将该日志复制成功，领导人将该日志状态设为已提交，已提交的会被持久化，并保证所有节点最终都会应用该日志。已提交日志之前的所有日志也认为是已提交的。</p>
<p>raft维护着以下特性：</p>
<ul>
<li>如果不同的日志中的两个日志条目拥有相同的索引号和任期号，那么他们存储了相同的指令</li>
<li>如果不同的日志中的两天日志条目拥有相同的索引号和任期号，那么他们前面的所有日志是相同的</li>
</ul>
<p>第一个特性是这样保证的：</p>
<p>一个任期最多只会有1个领导人，所有相同任期的领导人是相同的。然后领导人只会增加日志(跟随者可能会覆盖老的日志)，不会删除修改老的日志，一个索引位置的日志是不会改变的。</p>
<p>第二个特性是这样保证的：</p>
<p>每一个附加日志rpc都会额外发送前一个日志的索引和任期号，当跟随者发现自己的prev日志的索引和任期号对不上则会拒绝接收新的日志条目，领导者需要再返回更老的日志条目来让跟随着对齐(通过领导者给每一个跟随者维护一个nextindex)。即s(n) = t(n), 且s(n-1) = t(n-1), 则[0,n]上s和t是一样的</p>
<hr>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>如果一个服务器节点已经应用了一个<strong>确定</strong>的日志条目到它的状态机中，那么其他的服务器节点不能在同一个日志索引位置应用一个不同的指令。</p>
<p>由于领导人只追加日志，不会修改删除自己的老的日志，并通过强制其他节点和自己保持一致来保证整体的一致性，所以领导人自己需要有<strong>领导人完整特性</strong>的保证，确保选举出来的领导人，<strong>拥有自己任期之前的所有已提交的日志</strong>。这需要一些特性来保证，如下：</p>
<p><strong>选举限制</strong>：选举需要获得大多数节点的选票，日志的提交也需要大多数节点的确认，所以如果一个节点成功当选领导人，那么它肯定不会被拥有最新提交日志的节点拒绝。从而保证自己拥有最新的提交日志。选举的时候，候选者会在rpc中带上自己的最新的日志，跟随者/候选者会比对自身的日志，如果收到的日志比自己的旧，则不会同意当选，新的定义是：</p>
<ul>
<li>如果任期不一样，则任期大的是新的</li>
<li>如果任期一样，则日志长的(日志索引更大的)是新的</li>
</ul>
<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/raft-%E5%9B%BE8.png"></p>
<p><strong>领导人提交自己任期内的日志</strong>： 领导人拥有的老的任期内的日志，即使在大多数节点上保存了，也不能确保该日志是已经提交的，这里，<strong>领导人只能对自己任期内的日志通过大多数确认来提交</strong>。就是说领导人通过限制计算自己任期内的日志的大多数节点来维持的已提交状态，可以保证自己这个日志之前的所有在自己机器上的老的日志，也是已提交的(大多数写了)</p>
<hr>
<h3 id="成员变更"><a href="#成员变更" class="headerlink" title="成员变更"></a>成员变更</h3><p>如果跟随者或者候选者崩溃了，raft通过无限的重试来解决，这里raft的rpc请求保证都是幂等(全局的序列号)的，所以重试不会有问题。</p>
<hr>
<h3 id="集群变化"><a href="#集群变化" class="headerlink" title="集群变化"></a>集群变化</h3><p>这个挺复杂的，简单记录下，后面看看源码实现再分析。</p>
<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/raft-%E5%9B%BE10.png"></p>
<p>首先这里存在出现2个相同任期下的不同领导人问题：</p>
<p>这里有个前提是lerder可以拿到新加入节点的信息，集群总数也会更新，然后这里出现问题的一种场景：</p>
<ul>
<li>s3作为old的leader(term=1),在集群新增了s4/s5后，s3宕机</li>
<li>然后s1通过term=2拿到了s1/s2的选票成为leader.</li>
<li>s3恢复，用term=2拿到了S4/s5的选票成为leader</li>
<li>s1和s3都是leader,并且term相同</li>
</ul>
<p>论文中提到了2阶段的方案，通过共同一致来实现：</p>
<ul>
<li>old的集群拥有old的配置，比如(123)</li>
<li>新的集群拥有新的配置，比如(4,5)</li>
<li>s3的配置是(123-45)</li>
</ul>
<p>s3需要同步(123-45给其他节点)，提交成功后，再提交一个(12345)给所有节点，这时候第二阶段下才是新的集群完全生效的时候，如果s3提交(12345)前失败了，对于new(45)的节点，不能单独依赖自己单一节点的大多数来选举，只有old和接收old-new的节点可以当选。</p>
<p>以后再补充吧</p>
<hr>
<h3 id="日志压缩"><a href="#日志压缩" class="headerlink" title="日志压缩"></a>日志压缩</h3><p>时间久了日志太占空间了，可以对已经提交的持久化了的日志进行压缩，这个不需要领导人协调，因为已提交日志本身就是领导人确认的，这里可以通过lsm树做日志的压缩，还需要保存压缩日志最后的索引和任期号，用于后续日志的同步。如果作为领导人，有节点日志落后太多，也可以发送快照给他来同步。</p>
<hr>
<h3 id="客户端交互"><a href="#客户端交互" class="headerlink" title="客户端交互"></a>客户端交互</h3><p>客户端随机发给一个节点，如果该节点不是领导人则会重定向到领导人，如果领导人崩溃了，则会超时，后面重新选举。</p>
<p>如果领导人提交了日志，但是响应客户端前崩溃了，客户端可能重新提交请求，导致新的领导人再次执行了。这里需要做幂等处理，可能的方案是用<strong>全局的序列号</strong>。</p>
<p><strong>脏数据问题</strong>？对于只读的请求，领导人可能已经被废弃了，这时候可能返回脏数据给客户端，raft是这样处理的:</p>
<ul>
<li>领导人返回只读请求前，先发一个空的提交日志给其他节点，保证自己前面的日志都被大多数节点持久化为已提交，考虑前面那个图，4任期日志前面的2只有在附加4的时候，才能保证2都被写提交。就是说领导人只能提交自己当前任期内的大多数日志，所以需要当前任期由日志写才能保证老的日志真的已提交了</li>
<li>第二点是返回只读请求前，领导人需要和大多数节点确认下，自己是不是最新的唯一的领导人，这个可以通过心跳包来确认(给大多数节点心跳来确认)，也可以通过租约机制？</li>
</ul>
<h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><p><a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md">https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md</a></p>
]]></content>
  </entry>
  <entry>
    <title>一致性哈希</title>
    <url>/2021-09-03-%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/</url>
    <content><![CDATA[<div class="note default">
            
          </div>


<a id="more"></a>




<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
  </entry>
  <entry>
    <title>mapreduce</title>
    <url>/2021-09-04-mapreduce/</url>
    <content><![CDATA[<div class="note default">
            
          </div>


<a id="more"></a>




<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
  </entry>
  <entry>
    <title>centos8虚拟机双网卡+docker配置本地环境</title>
    <url>/2021-10-06-centos8%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%8C%E7%BD%91%E5%8D%A1+docker%E9%85%8D%E7%BD%AE%E6%9C%AC%E5%9C%B0%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<div class="note default">
            <p>最近公司网络策略变更，云服务器之间访问变得严格了，需要申请策略流程比较繁琐。所以想着在本地装一个虚拟机，用pc端的内网代理实现访问测试环境，再搞个docker把自己服务器镜像过来，配置过程还是有不少坑的，这篇文章记录下。</p>
          </div>


<a id="more"></a>

<h2 id="配置虚拟机环境"><a href="#配置虚拟机环境" class="headerlink" title="配置虚拟机环境"></a>配置虚拟机环境</h2><p>以前个人用过vmware,但是公司环境考虑到版权问题，这个软件也没有内部license,所以只好用virtualbox。使用下来这个开源的东西确实不好用，凑活吧。</p>
<p>这里本地找到了一个原来下载的centos8的iso，就直接用了，网络策略使用双网卡，一个nat用来访问外网，一个host only用来本地ssh访问。一般的配置如下:</p>
<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/20211011_1.jpg"></p>
<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/20211011_2.jpg"></p>
<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/20211011_3.jpg"></p>
<p>一开始安装通过光驱启动，安装完之后，启动方式改为硬盘启动。然后进去linux后，配置下网卡，/etc/sysconfig/network-scripts/里面把2个网卡的ONBOOT都改成yes,然后把host only的BOOTPROTO改成静态,便于ssh登录，参考:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TYPE&#x3D;Ethernet</span><br><span class="line">PROXY_METHOD&#x3D;none</span><br><span class="line">BROWSER_ONLY&#x3D;no</span><br><span class="line">BOOTPROTO&#x3D;static</span><br><span class="line">IPADDR&#x3D;*.*.*.*</span><br><span class="line">NETMASK&#x3D;255.255.255.0</span><br><span class="line">DNS1&#x3D;8.8.8.8</span><br><span class="line">DNS2&#x3D;114.114.114.114</span><br><span class="line">DEFROUTE&#x3D;yes</span><br><span class="line">IPV4_FAILURE_FATAL&#x3D;no</span><br><span class="line">IPV6INIT&#x3D;no</span><br><span class="line">IPV6_AUTOCONF&#x3D;no</span><br><span class="line">IPV6_DEFROUTE&#x3D;no</span><br><span class="line">IPV6_FAILURE_FATAL&#x3D;no</span><br><span class="line">IPV6_ADDR_GEN_MODE&#x3D;stable-privacy</span><br><span class="line">NAME&#x3D;enp0s8</span><br><span class="line">UUID&#x3D;*************************</span><br><span class="line">DEVICE&#x3D;enp0s8</span><br><span class="line">ONBOOT&#x3D;yes</span><br><span class="line">HWADDR&#x3D;***************</span><br></pre></td></tr></table></figure>

<p>由于是centos8,不能用systemctl restart network了，这里需要</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmcli connecttion reload</span><br><span class="line">nmcli device reapply enp0s8</span><br><span class="line">nmcli device reapply enp0s3</span><br></pre></td></tr></table></figure>

<p>然后就可以本地iterm2用ssh登陆了</p>
<h2 id="配置ssh"><a href="#配置ssh" class="headerlink" title="配置ssh"></a>配置ssh</h2><p>加个私钥和alias用起来方便</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// local</span><br><span class="line">ssh-keygen -t rsa -C river -f localvm</span><br><span class="line"></span><br><span class="line">cat localvm.pub</span><br><span class="line"></span><br><span class="line">// remote</span><br><span class="line">echo pub &gt;&gt; ~/.ssh/authorized_keys</span><br><span class="line"></span><br><span class="line">// local </span><br><span class="line">echo &quot;alias dev@local=&#x27;ssh -i ~/.ssh/localvm -p 22 root@0.0.0.0&#x27;&quot; &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure>

<p>关闭图形界面:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl get-default</span><br><span class="line"></span><br><span class="line">// 设置为图形界面</span><br><span class="line">systemctl set-default graphical.target</span><br><span class="line"></span><br><span class="line">// 不开启图形界面</span><br><span class="line">systemctl set-default multi-user.target</span><br></pre></td></tr></table></figure>

<h2 id="配置yum源"><a href="#配置yum源" class="headerlink" title="配置yum源"></a>配置yum源</h2><p>我这里没有墙，就不配源了</p>
<h2 id="配置docker启动环境"><a href="#配置docker启动环境" class="headerlink" title="配置docker启动环境"></a>配置docker启动环境</h2><p>yum install -y yum-utils device-mapper-persistent-data lvm2</p>
<p>yum-config-manager –add-repo <a href="https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo">https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</a></p>
<p>yum install docker-ce docker-ce-cli containerd.io</p>
<p>上面最后一步会报错<code>Problem 1: problem with installed package podman-1.6.4-10.module_el8.2.0+305+5e198a41.x86_6</code>，是因为centos8默认的podman会和docker冲突，这里可以选择卸载podman</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 参考:https://www.cnblogs.com/891288436xiaoyu/p/14092383.html</span><br><span class="line">dnf remove podman</span><br><span class="line"></span><br><span class="line">yum erase podman buildah</span><br></pre></td></tr></table></figure>


<p>sudo systemctl enable docker</p>
<p>sudo systemctl start docker</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker run --rm hello-world</span><br><span class="line">Unable to find image &#x27;hello-world:latest&#x27; locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">2db29710123e: Pull complete</span><br><span class="line">Digest: sha256:9ade9cc2e26189a19c2e8854b9c8f1e14829b51c55a630ee675a5a9540ef6ccf</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"><span class="meta"> $</span><span class="bash"> docker run -it ubuntu bash</span></span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure>

<h2 id="安装容器镜像"><a href="#安装容器镜像" class="headerlink" title="安装容器镜像"></a>安装容器镜像</h2><p>这里我是内网的仓库，具体就不记录了，记录下基本命令</p>
<p>docker login ***</p>
<p>docker pull ***</p>
<p>ok之后执行:</p>
<p>docker run -itd ****:tagid /bin/bash</p>
<p>docker container ls</p>
<p>docker exec -it **** bash</p>
<p>大功告成</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://yeasy.gitbook.io/docker_practice/install/centos">https://yeasy.gitbook.io/docker_practice/install/centos</a></p>
<p><a href="https://developer.aliyun.com/article/753261">https://developer.aliyun.com/article/753261</a></p>
<p><a href="https://rqsir.github.io/2019/05/23/VirtualBox-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/">https://rqsir.github.io/2019/05/23/VirtualBox-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/</a></p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>protobuf varint and zigzag</title>
    <url>/2021-10-09-protobuf%20varint%20and%20zigzag/</url>
    <content><![CDATA[<div class="note default">
            <p>看leveldb源码的时候遇到了protobuf的varint,以前整理protobuf序列化格式的时候了解过，但没有整理过，这次从二进制和源码的角度好好梳理下</p>
          </div>


<a id="more"></a>

<table>
<thead>
<tr>
<th>Type</th>
<th>Meaning</th>
<th>Used For</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>Varint</td>
<td>int32, int64, uint32, uint64, sint32, sint64, bool, enum</td>
</tr>
<tr>
<td>1</td>
<td>64-bit</td>
<td>fixed64, sfixed64, double</td>
</tr>
<tr>
<td>2</td>
<td>Length-delimited</td>
<td>string, bytes, embedded messages, packed repeated fields</td>
</tr>
<tr>
<td>3</td>
<td>Start group</td>
<td>groups (deprecated)</td>
</tr>
<tr>
<td>4</td>
<td>End group</td>
<td>groups (deprecated)</td>
</tr>
<tr>
<td>5</td>
<td>32-bit</td>
<td>fixed32, sfixed32, float</td>
</tr>
</tbody></table>
<p>int32, int64, uint32, uint64, sint32, sint64, bool, enum采用Varint编码进行压缩，int32/uint32表示正数占用1-5个字节，如果用int32/int64表示负数则占用10个字节(因为int32/int64默认都是转换成了64位处理的，负数最高位非0，又因为标志位的原因需要多2个字节),tag也占用1个字节。字符串类型的是tag-len-value，没有压缩。</p>
<h2 id="positive-number"><a href="#positive-number" class="headerlink" title="positive number"></a>positive number</h2><h3 id="proto"><a href="#proto" class="headerlink" title="proto"></a>proto</h3><figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> data;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="built_in">uint32</span> cmd = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    data::Hello test;</span><br><span class="line">    test.<span class="built_in">set_cmd</span>(<span class="number">300</span>);</span><br><span class="line">    <span class="keyword">auto</span> s = test.<span class="built_in">SerializeAsString</span>();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) x&#x2F;t s.data()</span><br><span class="line">0x7fffffffe440:	00000000 00000010 10101100 00001000</span><br><span class="line">(gdb) x&#x2F;t &amp;i</span><br><span class="line">0x7fffffffe46c:	00000000 00000000 00000001 00101100</span><br></pre></td></tr></table></figure>

<h3 id="analyze"><a href="#analyze" class="headerlink" title="analyze"></a>analyze</h3><p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/20211003_01.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;((<span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(FIELD_NUMBER) &lt;&lt; <span class="number">3</span>) | (TYPE))</span><br><span class="line">(field_number &lt;&lt; <span class="number">3</span>) | wire_type = <span class="number">0000</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure>

<h3 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">PROTOBUF_ALWAYS_INLINE <span class="keyword">static</span> <span class="keyword">uint8_t</span>* <span class="title">UnsafeVarint</span><span class="params">(T value, <span class="keyword">uint8_t</span>* ptr)</span> </span>&#123;</span><br><span class="line">  <span class="built_in"><span class="keyword">static_assert</span></span>(std::is_unsigned&lt;T&gt;::value,</span><br><span class="line">                <span class="string">&quot;Varint serialization must be unsigned&quot;</span>);</span><br><span class="line">  ptr[<span class="number">0</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(value);</span><br><span class="line">  <span class="keyword">if</span> (value &lt; <span class="number">0x80</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ptr + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Turn on continuation bit in the byte we just wrote.</span></span><br><span class="line">  ptr[<span class="number">0</span>] |= <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(<span class="number">0x80</span>);</span><br><span class="line">  value &gt;&gt;= <span class="number">7</span>;</span><br><span class="line">  ptr[<span class="number">1</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(value);</span><br><span class="line">  <span class="keyword">if</span> (value &lt; <span class="number">0x80</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ptr + <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ptr += <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// Turn on continuation bit in the byte we just wrote.</span></span><br><span class="line">    ptr[<span class="number">-1</span>] |= <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(<span class="number">0x80</span>);</span><br><span class="line">    value &gt;&gt;= <span class="number">7</span>;</span><br><span class="line">    *ptr = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(value);</span><br><span class="line">    ++ptr;</span><br><span class="line">  &#125; <span class="keyword">while</span> (value &gt;= <span class="number">0x80</span>);</span><br><span class="line">  <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Negative-numbers"><a href="#Negative-numbers" class="headerlink" title="Negative numbers"></a>Negative numbers</h2><p>int32/int64是有符号的,用来表示负数会占10个字节。所以表示负数的话尽可能用sint32/sint64,这样的话会使用zigzag编码，用正数表述负数(zigzag)然后用varint表示来节省空间。</p>
<table>
<thead>
<tr>
<th>signed original</th>
<th>encoded as</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>-1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>-2</td>
<td>3</td>
</tr>
<tr>
<td>2147483647</td>
<td>4294967294</td>
</tr>
<tr>
<td>-2147483648</td>
<td>4294967295</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Type</span> &#123;</span></span><br><span class="line">  TYPE_DOUBLE = <span class="number">1</span>,    <span class="comment">// double, exactly eight bytes on the wire.</span></span><br><span class="line">  TYPE_FLOAT = <span class="number">2</span>,     <span class="comment">// float, exactly four bytes on the wire.</span></span><br><span class="line">  TYPE_INT64 = <span class="number">3</span>,     <span class="comment">// int64, varint on the wire.  Negative numbers</span></span><br><span class="line">                      <span class="comment">// take 10 bytes.  Use TYPE_SINT64 if negative</span></span><br><span class="line">                      <span class="comment">// values are likely.</span></span><br><span class="line">  TYPE_UINT64 = <span class="number">4</span>,    <span class="comment">// uint64, varint on the wire.</span></span><br><span class="line">  TYPE_INT32 = <span class="number">5</span>,     <span class="comment">// int32, varint on the wire.  Negative numbers</span></span><br><span class="line">                      <span class="comment">// take 10 bytes.  Use TYPE_SINT32 if negative</span></span><br><span class="line">                      <span class="comment">// values are likely.</span></span><br><span class="line">  TYPE_FIXED64 = <span class="number">6</span>,   <span class="comment">// uint64, exactly eight bytes on the wire.</span></span><br><span class="line">  TYPE_FIXED32 = <span class="number">7</span>,   <span class="comment">// uint32, exactly four bytes on the wire.</span></span><br><span class="line">  TYPE_BOOL = <span class="number">8</span>,      <span class="comment">// bool, varint on the wire.</span></span><br><span class="line">  TYPE_STRING = <span class="number">9</span>,    <span class="comment">// UTF-8 text.</span></span><br><span class="line">  TYPE_GROUP = <span class="number">10</span>,    <span class="comment">// Tag-delimited message.  Deprecated.</span></span><br><span class="line">  TYPE_MESSAGE = <span class="number">11</span>,  <span class="comment">// Length-delimited message.</span></span><br><span class="line"></span><br><span class="line">  TYPE_BYTES = <span class="number">12</span>,     <span class="comment">// Arbitrary byte array.</span></span><br><span class="line">  TYPE_UINT32 = <span class="number">13</span>,    <span class="comment">// uint32, varint on the wire</span></span><br><span class="line">  TYPE_ENUM = <span class="number">14</span>,      <span class="comment">// Enum, varint on the wire</span></span><br><span class="line">  TYPE_SFIXED32 = <span class="number">15</span>,  <span class="comment">// int32, exactly four bytes on the wire</span></span><br><span class="line">  TYPE_SFIXED64 = <span class="number">16</span>,  <span class="comment">// int64, exactly eight bytes on the wire</span></span><br><span class="line">  TYPE_SINT32 = <span class="number">17</span>,    <span class="comment">// int32, ZigZag-encoded varint on the wire</span></span><br><span class="line">  TYPE_SINT64 = <span class="number">18</span>,    <span class="comment">// int64, ZigZag-encoded varint on the wire</span></span><br><span class="line"></span><br><span class="line">  MAX_TYPE = <span class="number">18</span>,  <span class="comment">// Constant useful for defining lookup tables</span></span><br><span class="line">                  <span class="comment">// indexed by Type.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="proto-1"><a href="#proto-1" class="headerlink" title="proto"></a>proto</h3><figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="keyword">optional</span> <span class="built_in">int32</span>  int_32 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">optional</span> <span class="built_in">uint32</span> u_int_32 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">optional</span> <span class="built_in">sint32</span>  s_int_32 = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">optional</span> <span class="built_in">fixed32</span>  f_32 = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">optional</span> <span class="built_in">sfixed32</span> sf_32 = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="demo-1"><a href="#demo-1" class="headerlink" title="demo"></a>demo</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OUTPUT_VALUE_AND_SIZE(TYPE, INPUT)  \</span></span><br><span class="line">    data::Hello VAR##TYPE;   \</span><br><span class="line">    VAR##TYPE.set_##<span class="built_in">TYPE</span>(INPUT); \</span><br><span class="line">    cout &lt;&lt; VAR##TYPE.<span class="built_in">TYPE</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt;  VAR##TYPE.<span class="built_in">SerializeAsString</span>().<span class="built_in">length</span>() &lt;&lt; endl;    \</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">OUTPUT_VALUE_AND_SIZE</span>(int_32, <span class="number">-1</span>);      <span class="comment">// -1 11</span></span><br><span class="line">    <span class="built_in">OUTPUT_VALUE_AND_SIZE</span>(u_int_32, <span class="number">-1</span>);    <span class="comment">// 4294967295 6</span></span><br><span class="line">    <span class="built_in">OUTPUT_VALUE_AND_SIZE</span>(s_int_32, <span class="number">-1</span>);    <span class="comment">// -1 2</span></span><br><span class="line">    <span class="built_in">OUTPUT_VALUE_AND_SIZE</span>(f_32, <span class="number">-1</span>);        <span class="comment">// 4294967295 5</span></span><br><span class="line">    <span class="built_in">OUTPUT_VALUE_AND_SIZE</span>(sf_32, <span class="number">-1</span>);       <span class="comment">// -1 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="source-code-1"><a href="#source-code-1" class="headerlink" title="source code"></a>source code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 32 bit</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">uint8_t</span>* <span class="title">WireFormatLite::WriteInt32ToArray</span><span class="params">(<span class="keyword">int</span> field_number,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">int32_t</span> value,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">uint8_t</span>* target)</span> </span>&#123;</span><br><span class="line">  target = <span class="built_in">WriteTagToArray</span>(field_number, WIRETYPE_VARINT, target);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">WriteInt32NoTagToArray</span>(value, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">uint8_t</span>* <span class="title">WireFormatLite::WriteInt32NoTagToArray</span><span class="params">(<span class="keyword">int32_t</span> value,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                       <span class="keyword">uint8_t</span>* target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> io::CodedOutputStream::<span class="built_in">WriteVarint32SignExtendedToArray</span>(value, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">uint8_t</span>* <span class="title">CodedOutputStream::WriteVarint32SignExtendedToArray</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int32_t</span> value, <span class="keyword">uint8_t</span>* target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">WriteVarint64ToArray</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(value), target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 64 bit</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">uint8_t</span>* <span class="title">WireFormatLite::WriteInt64ToArray</span><span class="params">(<span class="keyword">int</span> field_number,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">int64_t</span> value,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">uint8_t</span>* target)</span> </span>&#123;</span><br><span class="line">  target = <span class="built_in">WriteTagToArray</span>(field_number, WIRETYPE_VARINT, target);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">WriteInt64NoTagToArray</span>(value, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">uint8_t</span>* <span class="title">WireFormatLite::WriteInt64NoTagToArray</span><span class="params">(<span class="keyword">int64_t</span> value,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                       <span class="keyword">uint8_t</span>* target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> io::CodedOutputStream::<span class="built_in">WriteVarint64ToArray</span>(</span><br><span class="line">      <span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(value), target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// same</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">uint8_t</span>* <span class="title">CodedOutputStream::WriteVarint64ToArray</span><span class="params">(<span class="keyword">uint64_t</span> value,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        <span class="keyword">uint8_t</span>* target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> EpsCopyOutputStream::<span class="built_in">UnsafeVarint</span>(value, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">WireFormatLite::ZigZagEncode32</span><span class="params">(<span class="keyword">int32_t</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Note:  the right-shift must be arithmetic</span></span><br><span class="line">  <span class="comment">// Note:  left shift must be unsigned because of overflow</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(n) &lt;&lt; <span class="number">1</span>) ^ <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(n &gt;&gt; <span class="number">31</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">uint64_t</span> <span class="title">WireFormatLite::ZigZagEncode64</span><span class="params">(<span class="keyword">int64_t</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Note:  the right-shift must be arithmetic</span></span><br><span class="line">  <span class="comment">// Note:  left shift must be unsigned because of overflow</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(n) &lt;&lt; <span class="number">1</span>) ^ <span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(n &gt;&gt; <span class="number">63</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://developers.google.com/protocol-buffers/docs/encoding#varints">https://developers.google.com/protocol-buffers/docs/encoding#varints</a></p>
<p><a href="https://izualzhy.cn/protobuf-encode-varint-and-zigzag">protobuf编码之varint/zigzag</a></p>
]]></content>
      <tags>
        <tag>protobuf</tag>
        <tag>leveldb</tag>
      </tags>
  </entry>
  <entry>
    <title>gperftool分析leveldb内存申请</title>
    <url>/2021-10-10-gperftool%E5%88%86%E6%9E%90leveldb%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7/</url>
    <content><![CDATA[<div class="note default">
            <p>总结下gperftool的使用，写了个leveldb大量写数据的demo用来测试。</p>
          </div>


<a id="more"></a>

<h2 id="gperftool安装使用"><a href="#gperftool安装使用" class="headerlink" title="gperftool安装使用"></a>gperftool安装使用</h2><h3 id="install-libunwind"><a href="#install-libunwind" class="headerlink" title="install libunwind"></a>install libunwind</h3><p>git clone <a href="mailto:&#x67;&#x69;&#x74;&#x40;&#103;&#105;&#116;&#104;&#x75;&#x62;&#46;&#x63;&#x6f;&#x6d;">&#x67;&#x69;&#x74;&#x40;&#103;&#105;&#116;&#104;&#x75;&#x62;&#46;&#x63;&#x6f;&#x6d;</a>:libunwind/libunwind.git</p>
<p>cd libunwind/</p>
<p>autoreconf -i</p>
<p>./configure</p>
<p>make</p>
<p>make install</p>
<h3 id="install-gperftools"><a href="#install-gperftools" class="headerlink" title="install gperftools"></a>install gperftools</h3><p>git clone <a href="https://github.com/gperftools/gperftools">https://github.com/gperftools/gperftools</a></p>
<p>cd gperftools/</p>
<p>./autogen.sh</p>
<p>./configure</p>
<p>make</p>
<p>make install prefix=/usr</p>
<h3 id="图形化工具"><a href="#图形化工具" class="headerlink" title="图形化工具"></a>图形化工具</h3><p>yum install graphviz</p>
<p>yum install ghostscript</p>
<h2 id="测试leveldb的demo"><a href="#测试leveldb的demo" class="headerlink" title="测试leveldb的demo"></a>测试leveldb的demo</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;leveldb/db.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gperftools/profiler.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// g++ -o run run.cpp -pthread -lleveldb -std=c++11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ASSERT_STATUS(status, db)       \</span></span><br><span class="line">    <span class="keyword">do</span>&#123;                                 \</span><br><span class="line">        <span class="keyword">if</span> (!status.<span class="built_in">ok</span>())               \</span><br><span class="line">        &#123;                               \</span><br><span class="line">            <span class="keyword">delete</span> db;                  \</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;                  \</span><br><span class="line">        &#125;                               \</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>)                         \</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ProfilerStart(&quot;/root/code/leveldb/heap.prof&quot;);</span></span><br><span class="line">    leveldb::DB* db;</span><br><span class="line">    leveldb::Options options;</span><br><span class="line">    options.create_if_missing = <span class="literal">true</span>;</span><br><span class="line">    leveldb::Status status = leveldb::DB::<span class="built_in">Open</span>(options, <span class="string">&quot;/tmp/testdb&quot;</span>, &amp;db);</span><br><span class="line">    <span class="built_in">assert</span>(status.<span class="built_in">ok</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> k&#123;<span class="number">0</span>&#125;; k &lt; <span class="number">10000000</span>; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        std::string key = <span class="built_in">to_string</span>(k+<span class="number">600000</span>);</span><br><span class="line">        std::string value = <span class="string">&quot;river_fdsssssdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd&quot;</span> + <span class="built_in">to_string</span>(k);</span><br><span class="line">        status = db-&gt;<span class="built_in">Put</span>(leveldb::<span class="built_in">WriteOptions</span>(), key, value);</span><br><span class="line">        <span class="built_in">ASSERT_STATUS</span>(status, db);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;get key = &quot; &lt;&lt; key &lt;&lt; &quot;, value = &quot; &lt;&lt; str &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// cin.get();</span></span><br><span class="line">    <span class="keyword">delete</span> db;</span><br><span class="line">    <span class="comment">// ProfilerStop();</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ok!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">g++ run.cpp -std=c++<span class="number">11</span> -lleveldb -pthread -ltcmalloc -lprofiler -g -o run</span><br><span class="line"></span><br><span class="line">HEAPPROFILE=<span class="string">&quot;/root/code/leveldb/run&quot;</span> ./run</span><br><span class="line"></span><br><span class="line">pprof --pdf run run<span class="number">.0001</span>.heap &gt;run.pdf</span><br></pre></td></tr></table></figure>

<div class="pdfobject-container" data-target="https://riverferry.site/pdf/run.pdf" data-height="1000px"></div>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/gperftools/gperftools/blob/master/README">https://github.com/gperftools/gperftools/blob/master/README</a></p>
<p><a href="https://github.com/libunwind/libunwind">https://github.com/libunwind/libunwind</a></p>
<p><a href="https://gperftools.github.io/gperftools/heapprofile.html">https://gperftools.github.io/gperftools/heapprofile.html</a></p>
<p><a href="https://www.cnblogs.com/GODYCA/archive/2013/05/28/3104281.html">https://www.cnblogs.com/GODYCA/archive/2013/05/28/3104281.html</a></p>
]]></content>
      <tags>
        <tag>leveldb</tag>
        <tag>gperftool</tag>
      </tags>
  </entry>
  <entry>
    <title>leveldb源码分析(1) 编译安装</title>
    <url>/2021-10-11-leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(1)%20%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<div class="note default">
            <p>项目有用到leveldb,打算最近看看源码，整理个系列文章，这是第一篇编译安装。<a href="https://github.com/RiverFerry/leveldb-learn-log">源码注释地址</a></p>
          </div>


<a id="more"></a>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>git clone –recurse-submodules <a href="https://github.com/google/leveldb.git">https://github.com/google/leveldb.git</a></p>
<p>yum install -y cmake</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmake: symbol lookup error: cmake: undefined symbol: archive_write_add_filter_zstd</span><br><span class="line"></span><br><span class="line">yum install  libarchive</span><br></pre></td></tr></table></figure>

<p>mkdir -p build &amp;&amp; cd build</p>
<p>cmake -DCMAKE_BUILD_TYPE=Release .. &amp;&amp; cmake –build .</p>
<p>cp libleveldb.a /usr/local/lib</p>
<p>cp -r include/leveldb/ /usr/local/include/</p>
<h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;leveldb/db.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ASSERT_STATUS(status, db)       \</span></span><br><span class="line">    <span class="keyword">do</span>&#123;                                 \</span><br><span class="line">        <span class="keyword">if</span> (!status.<span class="built_in">ok</span>())               \</span><br><span class="line">        &#123;                               \</span><br><span class="line">            <span class="keyword">delete</span> db;                  \</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;                  \</span><br><span class="line">        &#125;                               \</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>)                         \</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  leveldb::DB* db;</span><br><span class="line">  leveldb::Options options;</span><br><span class="line">  options.create_if_missing = <span class="literal">true</span>;</span><br><span class="line">  leveldb::Status status = leveldb::DB::<span class="built_in">Open</span>(options, <span class="string">&quot;/tmp/testdb&quot;</span>, &amp;db);</span><br><span class="line">  <span class="built_in">assert</span>(status.<span class="built_in">ok</span>());</span><br><span class="line"></span><br><span class="line">  std::string key = <span class="string">&quot;1001&quot;</span>;</span><br><span class="line">  std::string value = <span class="string">&quot;river&quot;</span>;</span><br><span class="line">  std::string str;</span><br><span class="line">  status = db-&gt;<span class="built_in">Put</span>(leveldb::<span class="built_in">WriteOptions</span>(), key, value);</span><br><span class="line">  <span class="built_in">ASSERT_STATUS</span>(status, db);</span><br><span class="line"> </span><br><span class="line">  status = db-&gt;<span class="built_in">Get</span>(leveldb::<span class="built_in">ReadOptions</span>(), key, &amp;str);</span><br><span class="line">  <span class="built_in">ASSERT_STATUS</span>(status, db);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;get key = &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot;, value = &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">delete</span> db;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@dev leveldb]# .&#x2F;run </span><br><span class="line">get key &#x3D; 1001, value &#x3D; river</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/google/leveldb">https://github.com/google/leveldb</a></p>
<p><a href="https://zh.wikipedia.org/wiki/LevelDB">https://zh.wikipedia.org/wiki/LevelDB</a></p>
]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>leveldb</tag>
      </tags>
  </entry>
  <entry>
    <title>leveldb源码分析(2) 架构与文件分析</title>
    <url>/2021-10-11-leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(2)%20%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<div class="note default">
            <p>项目有用到leveldb,打算最近看看源码，整理个系列文章，这是第2篇架构与文件分析。网上找的中文资料大多数都是互相复制，年代也比较早，想找个框架图也不知道谁是作者，英文搜索发现leveldb的资料更少。所以打算主要参考github官方的介绍以及源码，然后借鉴一些网上的blog,最后自己手动画一个框架图，加深理解。<a href="https://github.com/RiverFerry/leveldb-learn-log">源码注释地址</a></p>
          </div>


<a id="more"></a>


<h2 id="11"><a href="#11" class="headerlink" title="11"></a>11</h2><p>一些参数</p>
<table>
<thead>
<tr>
<th>aa</th>
<th>bb</th>
</tr>
</thead>
<tbody><tr>
<td>kTargetFileSize</td>
<td>生成sstable的大小</td>
</tr>
<tr>
<td>write_buffer_size</td>
<td>memtable的大小</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>leveldb</tag>
      </tags>
  </entry>
  <entry>
    <title>leveldb源码分析(3) 内存管理 Arena</title>
    <url>/2021-10-12-leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(3)%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20Arena/</url>
    <content><![CDATA[<div class="note default">
            <p>项目有用到leveldb,打算最近看看源码，整理个系列文章，这是第3篇架构内存管理Arena。前面gperftool分析结果已经显示了leveldb申请内存主要在Arena,这篇从源码角度再分析下。<a href="https://github.com/RiverFerry/leveldb-learn-log">源码注释地址</a></p>
          </div>


<a id="more"></a>


<h2 id="调用关系"><a href="#调用关系" class="headerlink" title="调用关系"></a>调用关系</h2><p>从上篇gperftool的分析可以看到put数据的时候有2个地方申请了内存：</p>
<table>
<thead>
<tr>
<th>MemTable::Add</th>
<th>SkipList::Insert</th>
</tr>
</thead>
<tbody><tr>
<td>arena_.Allocate</td>
<td>arena_-&gt;AllocateAligned</td>
</tr>
</tbody></table>
<p>整体逻辑画了个图,后面源码具体分析</p>
<img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/20211005_1_400dpi.png" width="70%" height="70%">

<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="Arena-Allocate"><a href="#Arena-Allocate" class="headerlink" title="Arena::Allocate"></a>Arena::Allocate</h3><p>申请的内存小于可用大小alloc_bytes_remaining_的话，直接拿alloc_ptr_后面的，否则要重新申请：</p>
<ul>
<li>大于kBlockSize / 4，直接申请一个新的block，指向的heap的<strong>大小就是需要的bytes</strong></li>
<li>否则，申请一个新的block，指向的heap的<strong>大小是kBlockSize</strong>(当前代码是4096)。并更新alloc_ptr_和alloc_bytes_remaining_</li>
</ul>
<p>也就是说如果alloc_bytes_remaining_不够的话，就重新new一个空间，原来剩余的就浪费了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span>* <span class="title">Arena::Allocate</span><span class="params">(<span class="keyword">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// The semantics of what to return are a bit messy if we allow</span></span><br><span class="line">  <span class="comment">// 0-byte allocations, so we disallow them here (we don&#x27;t need</span></span><br><span class="line">  <span class="comment">// them for our internal use).</span></span><br><span class="line">  <span class="built_in">assert</span>(bytes &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (bytes &lt;= alloc_bytes_remaining_) &#123;</span><br><span class="line">    <span class="keyword">char</span>* result = alloc_ptr_;</span><br><span class="line">    alloc_ptr_ += bytes;</span><br><span class="line">    alloc_bytes_remaining_ -= bytes;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">AllocateFallback</span>(bytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Arena::AllocateFallback</span><span class="params">(<span class="keyword">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (bytes &gt; kBlockSize / <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="comment">// Object is more than a quarter of our block size.  Allocate it separately</span></span><br><span class="line">    <span class="comment">// to avoid wasting too much space in leftover bytes.</span></span><br><span class="line">    <span class="keyword">char</span>* result = <span class="built_in">AllocateNewBlock</span>(bytes);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We waste the remaining space in the current block.</span></span><br><span class="line">  alloc_ptr_ = <span class="built_in">AllocateNewBlock</span>(kBlockSize);</span><br><span class="line">  alloc_bytes_remaining_ = kBlockSize;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span>* result = alloc_ptr_;</span><br><span class="line">  alloc_ptr_ += bytes;</span><br><span class="line">  alloc_bytes_remaining_ -= bytes;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Arena::AllocateNewBlock</span><span class="params">(<span class="keyword">size_t</span> block_bytes)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span>* result = <span class="keyword">new</span> <span class="keyword">char</span>[block_bytes];</span><br><span class="line">  blocks_.<span class="built_in">push_back</span>(result);</span><br><span class="line">  memory_usage_.<span class="built_in">fetch_add</span>(block_bytes + <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>*),</span><br><span class="line">                          std::memory_order_relaxed);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Arena-AllocateAligned"><a href="#Arena-AllocateAligned" class="headerlink" title="Arena::AllocateAligned"></a>Arena::AllocateAligned</h3><p>注意<code>AllocateFallback always returned aligned memory</code>这句话，对应的是:</p>
<blockquote>
<p>Allocates size bytes of storage, suitably aligned to represent any object of that size, and returns a non-null pointer to the first byte of this block. On failure, it throws a bad_alloc exception.</p>
</blockquote>
<p><a href="http://www.cplusplus.com/reference/new/operator%20new/">http://www.cplusplus.com/reference/new/operator%20new/</a></p>
<p>也就是说new返回的是内存对齐的。如果是在原来空间上申请，需要自行对齐下，如下文。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Arena::AllocateAligned</span><span class="params">(<span class="keyword">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> align = (<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">void</span>*) &gt; <span class="number">8</span>) ? <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">void</span>*) : <span class="number">8</span>;</span><br><span class="line">  <span class="built_in"><span class="keyword">static_assert</span></span>((align &amp; (align - <span class="number">1</span>)) == <span class="number">0</span>,</span><br><span class="line">                <span class="string">&quot;Pointer size should be a power of 2&quot;</span>);</span><br><span class="line">  <span class="keyword">size_t</span> current_mod = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(alloc_ptr_) &amp; (align - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">size_t</span> slop = (current_mod == <span class="number">0</span> ? <span class="number">0</span> : align - current_mod); <span class="comment">// 当前alloc_ptr_距离对齐差几个字节</span></span><br><span class="line">  <span class="keyword">size_t</span> needed = bytes + slop;</span><br><span class="line">  <span class="keyword">char</span>* result;</span><br><span class="line">  <span class="keyword">if</span> (needed &lt;= alloc_bytes_remaining_) &#123;</span><br><span class="line">    result = alloc_ptr_ + slop;</span><br><span class="line">    alloc_ptr_ += needed;</span><br><span class="line">    alloc_bytes_remaining_ -= needed;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// AllocateFallback always returned aligned memory</span></span><br><span class="line">    result = <span class="built_in">AllocateFallback</span>(bytes);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 再次判断</span></span><br><span class="line">  <span class="built_in">assert</span>((<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(result) &amp; (align - <span class="number">1</span>)) == <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>Arena没有实现删除合并的逻辑，本身内存池回收合并就比较麻烦，这里调用方是给memtable使用的，每个memtable删除的时候会析构整个Arena的空间，下一次新的memtable创建再重新申请。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Arena::~<span class="built_in">Arena</span>() &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; blocks_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] blocks_[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>leveldb</tag>
      </tags>
  </entry>
  <entry>
    <title>leveldb源码分析(4) memtable and log</title>
    <url>/2021-10-13-leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(4)%20memtable%20and%20log/</url>
    <content><![CDATA[<div class="note default">
            <p>项目有用到leveldb,打算最近看看源码，整理个系列文章，这是第4篇memtable and log。<a href="https://github.com/RiverFerry/leveldb-learn-log">源码注释地址</a></p>
          </div>

<a id="more"></a>

<p>代码细节在github fork的仓库注释了，这里主要记录下大概的流程。从put开始。</p>
<h2 id="put"><a href="#put" class="headerlink" title="put"></a>put</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// slice是一个简单的c风格字符串的封装，记录了地址和大小</span></span><br><span class="line"><span class="comment">// 用户传入的string的key和value经由slice对应的ctor进行转换</span></span><br><span class="line"><span class="function">Status <span class="title">DB::Put</span><span class="params">(<span class="keyword">const</span> WriteOptions&amp; opt, <span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  WriteBatch batch; <span class="comment">// ctor让rep_ resize为kHeader(12bytes = 8-seq + 4-count)</span></span><br><span class="line">  batch.<span class="built_in">Put</span>(key, value);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Write</span>(opt, &amp;batch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteBatch::Put</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 以第9个字节为起始地址，设置count(int32, 小端字节序)大小</span></span><br><span class="line">  WriteBatchInternal::<span class="built_in">SetCount</span>(<span class="keyword">this</span>, WriteBatchInternal::<span class="built_in">Count</span>(<span class="keyword">this</span>) + <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 第13个字节记录type, 0-&gt;delete 1-&gt;value</span></span><br><span class="line">  rep_.<span class="built_in">push_back</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(kTypeValue));  </span><br><span class="line">  <span class="built_in">PutLengthPrefixedSlice</span>(&amp;rep_, key);   <span class="comment">// 第14个字节开始记录varint32(key的大小)+char*(key的data)</span></span><br><span class="line">  <span class="built_in">PutLengthPrefixedSlice</span>(&amp;rep_, value); <span class="comment">// 继续在后面写入varint32(value的大小)+char*(value的data)</span></span><br><span class="line">  <span class="comment">// 至此，WriteBatch的rep_中记录了一些信息，我画个图表示下</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/20211013_01.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// write主要干了三件事</span></span><br><span class="line"><span class="function">Status <span class="title">DBImpl::Write</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// step 1: 判断memtable还有空间没，是否需要新建memtable, 以及level-0的sstable文件个数是否达到阈值，需要慢速写/停止写, 具体在代码仓库记录</span></span><br><span class="line">    <span class="comment">// 这里会new memtable</span></span><br><span class="line">    <span class="built_in">MakeRoomForWrite</span>(...)</span><br><span class="line">    <span class="comment">// step 2: 生成Log用的格式，并写入</span></span><br><span class="line">    log_-&gt;<span class="built_in">AddRecord</span>(WriteBatchInternal::<span class="built_in">Contents</span>(write_batch));</span><br><span class="line">    <span class="comment">// step 3: 生成memtable用的格式，并写入</span></span><br><span class="line">    status = WriteBatchInternal::<span class="built_in">InsertInto</span>(write_batch, mem_);</span><br><span class="line">    <span class="comment">// 2 3步下文分别梳理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="log"><a href="#log" class="headerlink" title="log"></a>log</h2><p>AddRecord(…)</p>
<p>这块比较麻烦，代码里面我都注释了，这块只画个图描述下。日志是按block来处理的，代码里面一个block是32768字节，block由若干个record组成。每次put一个kv就是若干个record, 因为这里分段存储的，先看一个record的格式：</p>
<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/20211014_record.png"></p>
<p>如果一个put的kv可以在block的avail剩余空间内存储，则type=kFullType, 只需要一个record:</p>
<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/20211014_full.png"></p>
<p>如果block遗留空间不够，则要拆分为多个block, 可能是一个begin(1个) + middle(0-n个) + end(1个),如图：</p>
<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/20211014_frag.png"></p>
<p>另外需要注意的，如果一个block的剩余空间小于一个header(7个字节)，则去下一个block存储，也就是说data会被拆分到多个block, 但一个header是不能被拆分的。还有就是每次拼成一个record都会被flush刷盘。record里面的data就是rep_ ，没有再转换。</p>
<h2 id="memtable"><a href="#memtable" class="headerlink" title="memtable"></a>memtable</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">WriteBatchInternal::<span class="built_in">InsertInto</span>(write_batch, mem_)</span><br><span class="line">    <span class="built_in">Iterate</span>(&amp;inserter)</span><br><span class="line">        remove rep_前面<span class="number">13</span>个字节</span><br><span class="line">        handler-&gt;<span class="built_in">Put</span>(key, value)</span><br><span class="line">            mem_-&gt;<span class="built_in">Add</span>(sequence_, kTypeValue, key, value)</span><br><span class="line">        handler-&gt;<span class="built_in">Delete</span>(key)</span><br><span class="line">            mem_-&gt;<span class="built_in">Add</span>(sequence_, kTypeDeletion, key, <span class="built_in">Slice</span>())</span><br></pre></td></tr></table></figure>

<p>memtable先将数据存在heap, 然后把地址放到skiplist, 这里有一些数据结构：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MemTable::<span class="built_in">Add</span>(...)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Format of an entry is concatenation of:</span></span><br><span class="line">    <span class="comment">//  key_size     : varint32 of internal_key.size()</span></span><br><span class="line">    <span class="comment">//  key bytes    : char[internal_key.size()]</span></span><br><span class="line">    <span class="comment">//  value_size   : varint32 of value.size()</span></span><br><span class="line">    <span class="comment">//  value bytes  : char[value.size()]</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> encoded_len = <span class="built_in">VarintLength</span>(internal_key_size) +</span><br><span class="line">                             internal_key_size + <span class="built_in">VarintLength</span>(val_size) +</span><br><span class="line">                             val_size;</span><br><span class="line">    arena_.<span class="built_in">Allocate</span>(encoded_len);</span><br><span class="line">    <span class="built_in">EncodeVarint32</span>(buf, internal_key_size);</span><br><span class="line">    <span class="built_in">memcpy</span>(p, key.<span class="built_in">data</span>(), key_size);</span><br><span class="line">    <span class="built_in">EncodeFixed64</span>(p, (s &lt;&lt; <span class="number">8</span>) | type);</span><br><span class="line">    <span class="built_in">EncodeVarint32</span>(p, val_size);</span><br><span class="line">    <span class="built_in">memcpy</span>(p, value.<span class="built_in">data</span>(), val_size);</span><br><span class="line"></span><br><span class="line">    table_.<span class="built_in">Insert</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里申请了一块内存，保存了key和value的值，大小是:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    encoded_len</span><br><span class="line">    (key-len + key-data) + (seq) + (val-len + val-data)</span><br><span class="line">-&gt;  (varint32 + <span class="keyword">char</span>*) + (int64) + (varint32 + <span class="keyword">char</span>*)</span><br><span class="line">-&gt;  (<span class="number">1</span><span class="number">-5</span> + n) + <span class="number">8</span> + (<span class="number">1</span><span class="number">-5</span> + n)bytes</span><br></pre></td></tr></table></figure>

<p>然后把这块内存地址传给skiplist, 建立索引，这块我画个图记录下。skiplist初始化后是new了一块空间，用head_指过去，如图：</p>
<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/20211014_memtable.png"></p>
<p>插入节点后：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Insert</span><br><span class="line">    FindGreaterOrEqual  <span class="comment">// 找插入点</span></span><br><span class="line">    RandomHeight        <span class="comment">// 随机生成高度</span></span><br><span class="line">    NewNode             <span class="comment">// new heap</span></span><br><span class="line">    SetNext             <span class="comment">// 完善链表</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/20211014_memtable_insert.png"></p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://web.archive.org/web/20120131105110/http://rdc.taobao.com/blog/cs/wp-content/plugins/leveldb%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90.pdf">https://web.archive.org/web/20120131105110/http://rdc.taobao.com/blog/cs/wp-content/plugins/leveldb%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90.pdf</a></p>
]]></content>
      <tags>
        <tag>leveldb</tag>
      </tags>
  </entry>
  <entry>
    <title>leveldb源码分析(5) sstable文件</title>
    <url>/2021-10-27-leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(5)%20sstable%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<div class="note default">
            <p>项目有用到leveldb,打算最近看看源码，整理个系列文章，这是第5篇sstable文件。<a href="https://github.com/RiverFerry/leveldb-learn-log">源码注释地址</a></p>
          </div>


<a id="more"></a>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>从上一篇的流程中可以看到这里会出现压缩的场景:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MakeRoomForWrite</span><br><span class="line">    MaybeScheduleCompaction</span><br><span class="line">        BackgroundCompaction</span><br><span class="line">            CompactMemTable</span><br><span class="line">                WriteLevel0Table</span><br><span class="line">                    BuildTable</span><br></pre></td></tr></table></figure>

<p>BuildTable中open一个新的文件名，然后执行<code>finish</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">TableBuilder::Finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写 data_block</span></span><br><span class="line">    <span class="built_in">Flush</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写 filter_block</span></span><br><span class="line">    <span class="built_in">WriteRawBlock</span>(r-&gt;filter_block-&gt;<span class="built_in">Finish</span>(), kNoCompression,  </span><br><span class="line">                  &amp;filter_block_handle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写 meta_index_block</span></span><br><span class="line">    <span class="built_in">WriteBlock</span>(&amp;meta_index_block, &amp;metaindex_block_handle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写 index_block</span></span><br><span class="line">    <span class="built_in">WriteBlock</span>(&amp;r-&gt;index_block, &amp;index_block_handle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写 footer</span></span><br><span class="line">    r-&gt;status = r-&gt;file-&gt;<span class="built_in">Append</span>(footer_encoding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WriteRawBlock/WriteBlock会调用Append写，posix下优先写buf,buf不够直接调用write写文件。</p>
<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/20211103_new_2.png"></p>
<p>分别看看用处：</p>
<h3 id="BlockBuilder"><a href="#BlockBuilder" class="headerlink" title="BlockBuilder"></a>BlockBuilder</h3><p>BlockBuilder的成员变量如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Options* options_;</span><br><span class="line">std::string buffer_;              <span class="comment">// Destination buffer</span></span><br><span class="line">std::vector&lt;<span class="keyword">uint32_t</span>&gt; restarts_;  <span class="comment">// Restart points</span></span><br><span class="line"><span class="keyword">int</span> counter_;                     <span class="comment">// Number of entries emitted since restart</span></span><br><span class="line"><span class="keyword">bool</span> finished_;                   <span class="comment">// Has Finish() been called?</span></span><br><span class="line">std::string last_key_;</span><br></pre></td></tr></table></figure>

<p>buffer_指向的内容就是下图的第2行，其中每一个entry的格式是第一行的表示。restarts_记录了每一个前缀压缩新的开始点，最后会把这些值存入buffer_后面。其他几个字段没那么重要了。</p>
<img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/20211027_new.png" width="100%" height="100%">

<h3 id="data-block"><a href="#data-block" class="headerlink" title="data_block"></a>data_block</h3><p><code>data_block</code>的类型是<strong>BlockBuilder</strong>，add的kv(一个entry)是(key, value);</p>
<h3 id="filter-block"><a href="#filter-block" class="headerlink" title="filter_block"></a>filter_block</h3><p>filter_block的类型是<strong>FilterBlockBuilder</strong>,成员变量如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> FilterPolicy* policy_;</span><br><span class="line">std::string keys_;             <span class="comment">// Flattened(扁平) key contents</span></span><br><span class="line">std::vector&lt;<span class="keyword">size_t</span>&gt; start_;    <span class="comment">// Starting index in keys_ of each key</span></span><br><span class="line">std::string result_;           <span class="comment">// Filter data computed so far</span></span><br><span class="line">std::vector&lt;Slice&gt; tmp_keys_;  <span class="comment">// policy_-&gt;CreateFilter() argument</span></span><br><span class="line">std::vector&lt;<span class="keyword">uint32_t</span>&gt; filter_offsets_;</span><br></pre></td></tr></table></figure>

<p>keys_和start_在AddKey的时候赋值，如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FilterBlockBuilder::AddKey</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line">  Slice k = key;</span><br><span class="line">  start_.<span class="built_in">push_back</span>(keys_.<span class="built_in">size</span>());</span><br><span class="line">  keys_.<span class="built_in">append</span>(k.<span class="built_in">data</span>(), k.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/20211102_1.png"></p>
<p>看下<code>StartBlock</code>的实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FilterBlockBuilder::StartBlock</span><span class="params">(<span class="keyword">uint64_t</span> block_offset)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// kFilterBase = 2kb</span></span><br><span class="line">  <span class="keyword">uint64_t</span> filter_index = (block_offset / kFilterBase);</span><br><span class="line">  <span class="built_in">assert</span>(filter_index &gt;= filter_offsets_.<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">while</span> (filter_index &gt; filter_offsets_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="built_in">GenerateFilter</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>StartBlock</code>被调用的地方有:</p>
<ul>
<li>TableBuilder构造函数</li>
<li>TableBuilder::Flush()</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">TableBuilder::<span class="built_in">TableBuilder</span>(<span class="keyword">const</span> Options&amp; options, WritableFile* file)</span><br><span class="line">    : <span class="built_in">rep_</span>(<span class="keyword">new</span> <span class="built_in">Rep</span>(options, file)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (rep_-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    rep_-&gt;filter_block-&gt;<span class="built_in">StartBlock</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableBuilder::Flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  <span class="built_in">assert</span>(!r-&gt;closed);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">ok</span>()) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;data_block.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">assert</span>(!r-&gt;pending_index_entry);</span><br><span class="line">  <span class="built_in">WriteBlock</span>(&amp;r-&gt;data_block, &amp;r-&gt;pending_handle); <span class="comment">// data_block写到buf或文件</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    r-&gt;pending_index_entry = <span class="literal">true</span>;</span><br><span class="line">    r-&gt;status = r-&gt;file-&gt;<span class="built_in">Flush</span>(); <span class="comment">// 缓存buf刷新到文件</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    r-&gt;filter_block-&gt;<span class="built_in">StartBlock</span>(r-&gt;offset); <span class="comment">// ==</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>filter_offsets_中存了每个<code>filter</code>的offset,每个filter记录sstable的data_block的2kb的kv的特征值(默认是bloom filter算的Bits)。所以StartBlock函数的入参拿到新的sstable中data_block的offset/2kb，如果比filter_offsets_原来的值大，就不断GenerateFilter生成新的filter,没生成一个filter_offsets_的size就加一。</p>
<p>看下Finish的实现:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Slice <span class="title">FilterBlockBuilder::Finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!start_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="built_in">GenerateFilter</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Append array of per-filter offsets</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> array_offset = result_.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; filter_offsets_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="built_in">PutFixed32</span>(&amp;result_, filter_offsets_[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">PutFixed32</span>(&amp;result_, array_offset);</span><br><span class="line">  <span class="comment">// kFilterBaseLg = 11</span></span><br><span class="line">  result_.<span class="built_in">push_back</span>(kFilterBaseLg);  <span class="comment">// Save encoding parameter in result</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Slice</span>(result_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，每执行一次GenerateFilter，keys_和start_都会clear.但filter_offsets_的值是一直在的。然后这个过程中生成的filter内容都保存在result_.最后Finish的时候filter_offsets_的值以及原来result_的size都会写到result_的后面，kFilterBaseLg=11(1 &lt;&lt; 11, 表示2kb)也会写到后面。也就是说最后Finish完就生成了一个新的filter_block。其中result_指向的内容如下：</p>
<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/20211103_2_new.png"></p>
<p>这就是一个filter_block的内容。后面数据读取单独整理一篇再分析读取的逻辑。</p>
<h3 id="meta-index-block"><a href="#meta-index-block" class="headerlink" title="meta_index_block"></a>meta_index_block</h3><p><code>meta_index_block</code>的类型是<strong>BlockBuilder</strong>, add的kv(一个entry)是(filter.leveldb.BuiltinBloomFilter2, string(filter_block_handle)); filter_block_handle记录了filter_block的位置信息</p>
<h3 id="index-block"><a href="#index-block" class="headerlink" title="index_block"></a>index_block</h3><p><code>index_block</code>的类型是<strong>BlockBuilder</strong>, add的kv(一个entry)是(last_key, string(pending_handle));last_key记录了data_block的最后一个key, pending_handle记录了最后一个data_block的位置信息。</p>
<p>last_key更新的位置:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableBuilder::Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    r-&gt;last_key.<span class="built_in">assign</span>(key.<span class="built_in">data</span>(), key.<span class="built_in">size</span>());</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pending_handle更新的位置：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">TableBuilder::<span class="built_in">Flush</span>()</span><br><span class="line">    <span class="built_in">WriteBlock</span>(&amp;r-&gt;data_block, &amp;r-&gt;pending_handle)</span><br><span class="line">        <span class="built_in">WriteRawBlock</span>(block_contents, type, handle);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableBuilder::WriteRawBlock</span><span class="params">(<span class="keyword">const</span> Slice&amp; block_contents,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 CompressionType type, BlockHandle* handle)</span> </span>&#123;</span><br><span class="line">Rep* r = rep_;</span><br><span class="line">handle-&gt;<span class="built_in">set_offset</span>(r-&gt;offset);</span><br><span class="line"><span class="comment">// block_contents是data_block压缩后的值</span></span><br><span class="line">handle-&gt;<span class="built_in">set_size</span>(block_contents.<span class="built_in">size</span>());</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="footer"><a href="#footer" class="headerlink" title="footer"></a>footer</h3><p>Footer有2个数据成员, 记录了metaindex_handle_和index_handle_,也即meta_index_block和index_block的位置信息.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Footer encapsulates the fixed information stored at the tail</span></span><br><span class="line"><span class="comment">// end of every table file.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Footer</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  BlockHandle metaindex_handle_;</span><br><span class="line">  BlockHandle index_handle_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BlockHandle is a pointer to the extent of a file that stores a data</span></span><br><span class="line"><span class="comment">// block or a meta block.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockHandle</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">uint64_t</span> offset_;</span><br><span class="line">  <span class="keyword">uint64_t</span> size_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://web.archive.org/web/20120131105110/http://rdc.taobao.com/blog/cs/wp-content/plugins/leveldb%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90.pdf">https://web.archive.org/web/20120131105110/http://rdc.taobao.com/blog/cs/wp-content/plugins/leveldb%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90.pdf</a></p>
<p><a href="http://catkang.github.io/2017/01/17/leveldb-data.html">http://catkang.github.io/2017/01/17/leveldb-data.html</a></p>
<p><a href="https://www.bookstack.cn/read/Leveldb-handbook/spilt.2.b308da3c3d01f3cd.md">https://www.bookstack.cn/read/Leveldb-handbook/spilt.2.b308da3c3d01f3cd.md</a></p>
<p><a href="https://izualzhy.cn/leveldb-block">https://izualzhy.cn/leveldb-block</a></p>
]]></content>
      <tags>
        <tag>leveldb</tag>
      </tags>
  </entry>
  <entry>
    <title>leveldb源码分析(6) 文件压缩</title>
    <url>/2021-11-04-leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(6)%20%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[<div class="note default">
            <p>项目有用到leveldb,打算最近看看源码，整理个系列文章，这是第6篇文件压缩。<a href="https://github.com/RiverFerry/leveldb-learn-log">源码注释地址</a></p>
          </div>


<a id="more"></a>

<p>文件分为minor compaction,major compaction,手动压缩</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">LogAndApply</span><br><span class="line">  Finalize</span><br><span class="line"></span><br><span class="line">VersionSet::Recover</span><br><span class="line">  Finalize</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">TEST_CompactRange</span><br><span class="line">BackgroundCall</span><br><span class="line">DBImpl::Get</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  DBIter::<span class="built_in">FindNextUserEntry</span>()</span><br><span class="line">  DBIter::<span class="built_in">FindPrevUserEntry</span>()</span><br><span class="line">    DBIter::ParseKey</span><br><span class="line">      DBImpl::RecordReadSample</span><br><span class="line"></span><br><span class="line">DBImpl::Write</span><br><span class="line">  DBImpl::MakeRoomForWrite</span><br><span class="line"></span><br><span class="line">DB::Open</span><br><span class="line"></span><br><span class="line">  DBImpl::<span class="built_in">MaybeScheduleCompaction</span>()</span><br><span class="line">    DBImpl::<span class="built_in">BackgroundCall</span>()</span><br><span class="line">      DBImpl::<span class="built_in">BackgroundCompaction</span>()</span><br><span class="line">        LogAndApply</span><br><span class="line">        DBImpl::<span class="built_in">CompactMemTable</span>()</span><br><span class="line">          LogAndAppyl</span><br><span class="line">        DBImpl::<span class="built_in">DoCompactionWork</span>(CompactionState* compact)</span><br><span class="line">          DBImpl::<span class="built_in">CompactMemTable</span>()</span><br><span class="line">            LogAndApply</span><br><span class="line">          DBImpl::<span class="built_in">InstallCompactionResults</span>(CompactionState* compact)</span><br><span class="line">            LogAndApply</span><br><span class="line"></span><br><span class="line">DB::<span class="built_in">Open</span>(<span class="keyword">const</span> Options&amp; options, <span class="keyword">const</span> std::string&amp; dbname, DB** dbptr)</span><br><span class="line">  LogAndApply</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Finalize"><a href="#Finalize" class="headerlink" title="Finalize"></a>Finalize</h3><p>Finalize函数就为了得到这两个值compaction_level_和compaction_score_，也即适合压缩的层级和分值。细节在后面整理了，这块总结下：</p>
<p>先计算每一层的Score，最大的那一层先压缩，计算策略是：</p>
<ul>
<li>level-0: level-0的所有sstable文件个数/4</li>
<li>level-n: level-n的所有sstable文件大小和/MaxBytesForLevel</li>
</ul>
<p><code>MaxBytesForLevel</code>的值下文也写出来了。</p>
<p>这块第0层的策略和其他层不太一样，原因我参考<a href="https://web.archive.org/web/20120131105110/http://rdc.taobao.com/blog/cs/wp-content/plugins/leveldb%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90.pdf">这里</a>记录下：</p>
<ul>
<li>level-0的sstable可能overlap,所以level-0上sstable过多会影响效率</li>
<li>level-0的sstable是immutable直接dump过来的，不受sstable的max_file_size(默认2M)控制</li>
</ul>
<p>todo:</p>
<ul>
<li>immutable的大小限制由write_buffer_size控制，默认是4M。<br><code>kL0_SlowdownWritesTrigger</code>(=8, level-0的sstable文件个数&gt;=8的时候，MakeRoomForWrite里面开始慢处理写)/<code>kL0_StopWritesTrigger</code>(=12, level-0的sstable文件个数&gt;=12的时候，MakeRoomForWrite停止写)</li>
<li>这里的score最大值是1？</li>
<li>实测.ldb的大小是3.5M?</li>
<li>MaxBytesForLevel = 10(^i)?</li>
<li>allowed_seek = max(100, sstable_size/16k), get一次这个值-1，小于0的时候合并</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Finalize: 敲定</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VersionSet::Finalize</span><span class="params">(Version* v)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Precomputed best level for next compaction</span></span><br><span class="line">  <span class="keyword">int</span> best_level = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">double</span> best_score = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// kNumLevels = 7， 一共有几层？ 为什么这里只循环6次？</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels - <span class="number">1</span>; level++) &#123;</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// We treat level-0 specially by bounding the number of files</span></span><br><span class="line">      <span class="comment">// instead of number of bytes for two reasons:</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// (1) With larger write-buffer sizes, it is nice not to do too</span></span><br><span class="line">      <span class="comment">// many level-0 compactions.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// (2) The files in level-0 are merged on every read and</span></span><br><span class="line">      <span class="comment">// therefore we wish to avoid too many files when the individual</span></span><br><span class="line">      <span class="comment">// file size is small (perhaps because of a small write-buffer</span></span><br><span class="line">      <span class="comment">// setting, or very high compression ratios, or lots of</span></span><br><span class="line">      <span class="comment">// overwrites/deletions).</span></span><br><span class="line">      <span class="comment">// kL0_CompactionTrigger = 4</span></span><br><span class="line">      score = v-&gt;files_[level].<span class="built_in">size</span>() /</span><br><span class="line">              <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(config::kL0_CompactionTrigger);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Compute the rati(比率) of current size to size limit.</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint64_t</span> level_bytes = <span class="built_in">TotalFileSize</span>(v-&gt;files_[level]);</span><br><span class="line">      score =</span><br><span class="line">          <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(level_bytes) / <span class="built_in">MaxBytesForLevel</span>(options_, level);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (score &gt; best_score) &#123;</span><br><span class="line">      best_level = level;</span><br><span class="line">      best_score = score;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  v-&gt;compaction_level_ = best_level;</span><br><span class="line">  v-&gt;compaction_score_ = best_score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="TotalFileSize"><a href="#TotalFileSize" class="headerlink" title="TotalFileSize"></a>TotalFileSize</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int64_t</span> <span class="title">TotalFileSize</span><span class="params">(<span class="keyword">const</span> std::vector&lt;FileMetaData*&gt;&amp; files)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int64_t</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; files.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    sum += files[i]-&gt;file_size;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MaxBytesForLevel"><a href="#MaxBytesForLevel" class="headerlink" title="MaxBytesForLevel"></a>MaxBytesForLevel</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算大于0的level层级的文件数据最大值</span></span><br><span class="line"><span class="comment">// 第一个参数没有用到？也没见有重载的情况</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">MaxBytesForLevel</span><span class="params">(<span class="keyword">const</span> Options* options, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Note: the result for level zero is not really used since we set</span></span><br><span class="line">  <span class="comment">// the level-0 compaction threshold(临界点) based on number of files.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Result for both level-0 and level-1</span></span><br><span class="line">  <span class="comment">// level = 2开始每层*10</span></span><br><span class="line">  <span class="keyword">double</span> result = <span class="number">10.</span> * <span class="number">1048576.0</span>;</span><br><span class="line">  <span class="keyword">while</span> (level &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    result *= <span class="number">10</span>;</span><br><span class="line">    level--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个值可以简单算下：</p>
<table>
<thead>
<tr>
<th>level</th>
<th>score_double</th>
<th>score_LL</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1.04858e+07</td>
<td>10485760</td>
</tr>
<tr>
<td>1</td>
<td>1.04858e+07</td>
<td>10485760</td>
</tr>
<tr>
<td>2</td>
<td>1.04858e+08</td>
<td>104857600</td>
</tr>
<tr>
<td>3</td>
<td>1.04858e+09</td>
<td>1048576000</td>
</tr>
<tr>
<td>4</td>
<td>1.04858e+10</td>
<td>10485760000</td>
</tr>
<tr>
<td>5</td>
<td>1.04858e+11</td>
<td>104857600000</td>
</tr>
<tr>
<td>6</td>
<td>1.04858e+12</td>
<td>1048576000000</td>
</tr>
</tbody></table>
<p>state类保存Seek的状态信息</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://web.archive.org/web/20120131105110/http://rdc.taobao.com/blog/cs/wp-content/plugins/leveldb%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90.pdf">https://web.archive.org/web/20120131105110/http://rdc.taobao.com/blog/cs/wp-content/plugins/leveldb%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90.pdf</a></p>
<p><a href="http://catkang.github.io/2017/01/17/leveldb-data.html">http://catkang.github.io/2017/01/17/leveldb-data.html</a></p>
<p><a href="https://www.bookstack.cn/read/Leveldb-handbook/spilt.2.b308da3c3d01f3cd.md">https://www.bookstack.cn/read/Leveldb-handbook/spilt.2.b308da3c3d01f3cd.md</a></p>
<p><a href="https://izualzhy.cn/leveldb-block">https://izualzhy.cn/leveldb-block</a></p>
]]></content>
      <tags>
        <tag>leveldb</tag>
      </tags>
  </entry>
  <entry>
    <title>leveldb源码分析(7) 版本控制 version</title>
    <url>/2021-11-05-leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(7)%20%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%20version/</url>
    <content><![CDATA[<div class="note default">
            <p>项目有用到leveldb,打算最近看看源码，整理个系列文章，这是第7篇版本控制 version。<a href="https://github.com/RiverFerry/leveldb-learn-log">源码注释地址</a></p>
          </div>


<a id="more"></a>

<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/20220308_new.png"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="VersionSet"><a href="#VersionSet" class="headerlink" title="VersionSet"></a>VersionSet</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VersionSet</span> &#123;</span></span><br><span class="line">    Env* <span class="keyword">const</span> env_;</span><br><span class="line">    <span class="keyword">const</span> std::string dbname_;</span><br><span class="line">    <span class="keyword">const</span> Options* <span class="keyword">const</span> options_;</span><br><span class="line">    <span class="comment">// sstable的table cache</span></span><br><span class="line">    TableCache* <span class="keyword">const</span> table_cache_;</span><br><span class="line">    <span class="comment">//  对 key 做比较的 comparator</span></span><br><span class="line">    <span class="keyword">const</span> InternalKeyComparator icmp_;</span><br><span class="line">    <span class="comment">// 下一个可用的 FileNumber</span></span><br><span class="line">    <span class="keyword">uint64_t</span> next_file_number_;</span><br><span class="line">    <span class="comment">// manifest的file number</span></span><br><span class="line">    <span class="keyword">uint64_t</span> manifest_file_number_;</span><br><span class="line">    <span class="comment">// 最后用过的 SequnceNumber</span></span><br><span class="line">    <span class="keyword">uint64_t</span> last_sequence_;</span><br><span class="line">    <span class="comment">// log 文件的 FileNumber</span></span><br><span class="line">    <span class="keyword">uint64_t</span> log_number_;</span><br><span class="line">    <span class="comment">// 辅助 log 文件的 FileNumber，在 compact memtable 时，置为 0.</span></span><br><span class="line">    <span class="keyword">uint64_t</span> prev_log_number_;  <span class="comment">// 0 or backing store for memtable being compacted</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Opened lazily</span></span><br><span class="line">    <span class="comment">// manifest 文件的封装</span></span><br><span class="line">    WritableFile* descriptor_file_;</span><br><span class="line">    <span class="comment">// manifest 文件的 writer</span></span><br><span class="line">    log::Writer* descriptor_log_;</span><br><span class="line">    <span class="comment">// 双向循环链表的头节点</span></span><br><span class="line">    Version dummy_versions_;  <span class="comment">// Head of circular doubly-linked list of versions.</span></span><br><span class="line">    <span class="comment">// 当前的version</span></span><br><span class="line">    Version* current_;        </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Per-level key at which the next compaction at that level should start.</span></span><br><span class="line">    <span class="comment">// Either an empty string, or a valid InternalKey.</span></span><br><span class="line">    <span class="comment">// 下一次 compact 的 start-key。compact_pointer_就保存着每个 level</span></span><br><span class="line">    <span class="comment">// 除了 current_外的 Version，并不会做 compact，所以这个值并不保存在 Version 中</span></span><br><span class="line">    std::string compact_pointer_[config::kNumLevels];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Version"><a href="#Version" class="headerlink" title="Version"></a>Version</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Version</span> &#123;</span></span><br><span class="line">    VersionSet* vset_;  <span class="comment">// VersionSet to which this Version belongs</span></span><br><span class="line">    Version* next_;     <span class="comment">// Next version in linked list</span></span><br><span class="line">    Version* prev_;     <span class="comment">// Previous version in linked list</span></span><br><span class="line">    <span class="keyword">int</span> refs_;          <span class="comment">// Number of live refs to this version</span></span><br><span class="line">    <span class="comment">// 2维数组保存每一层的sst文件(该版本的)</span></span><br><span class="line">    std::vector&lt;FileMetaData*&gt; files_[config::kNumLevels];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// seek触发compaction</span></span><br><span class="line">    FileMetaData* file_to_compact_;</span><br><span class="line">    <span class="keyword">int</span> file_to_compact_level_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容量触发compaction</span></span><br><span class="line">    <span class="keyword">double</span> compaction_score_;</span><br><span class="line">    <span class="keyword">int</span> compaction_level_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Version是一个链表类，头结点保存在vset_.dummy_versions_。Version还保存了当前版本下每个level的所有文件信息，以及将要压缩的文件和层级等信息。</p>
<hr>
<h3 id="VersionEdit"><a href="#VersionEdit" class="headerlink" title="VersionEdit"></a>VersionEdit</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VersionEdit</span> &#123;</span></span><br><span class="line">    std::string comparator_;</span><br><span class="line">    <span class="keyword">uint64_t</span> log_number_;</span><br><span class="line">    <span class="keyword">uint64_t</span> prev_log_number_;</span><br><span class="line">    <span class="keyword">uint64_t</span> next_file_number_;</span><br><span class="line">    SequenceNumber last_sequence_;</span><br><span class="line">    <span class="keyword">bool</span> has_comparator_;</span><br><span class="line">    <span class="keyword">bool</span> has_log_number_;</span><br><span class="line">    <span class="keyword">bool</span> has_prev_log_number_;</span><br><span class="line">    <span class="keyword">bool</span> has_next_file_number_;</span><br><span class="line">    <span class="keyword">bool</span> has_last_sequence_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上一次压缩的最大key</span></span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="keyword">int</span>, InternalKey&gt;&gt; compact_pointers_;</span><br><span class="line">    <span class="comment">// 删除的sst</span></span><br><span class="line">    DeletedFileSet deleted_files_;</span><br><span class="line">    <span class="comment">// 新增的sst</span></span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="keyword">int</span>, FileMetaData&gt;&gt; new_files_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一次压缩都会新增/删除sst,删除也不一定真的删除，因为是多版本带引用计数的，这里versionEdit是2个version之间sst的变化，会wal到manifest持久化。重启db的时候根据manifest重建versionSet和version,看下manifest的内容:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@dev testdb]# &#x2F;root&#x2F;leveldb&#x2F;build&#x2F;leveldbutil dump MANIFEST-000013</span><br><span class="line">--- offset 0; VersionEdit &#123;</span><br><span class="line">  Comparator: leveldb.BytewiseComparator</span><br><span class="line">  AddFile: 0 11 325262 &#39;1000372555&#39; @ 1009 : 1 .. &#39;999733429&#39; @ 8727 : 1</span><br><span class="line">  AddFile: 0 8 422 &#39;1189641421&#39; @ 20 : 1 .. &#39;846930886&#39; @ 12 : 1</span><br><span class="line">  AddFile: 0 5 333 &#39;1646668802&#39; @ 10 : 1 .. &#39;1646668802&#39; @ 1 : 1</span><br><span class="line">&#125;</span><br><span class="line">--- offset 163; VersionEdit &#123;</span><br><span class="line">  LogNumber: 15</span><br><span class="line">  PrevLogNumber: 0</span><br><span class="line">  NextFile: 16</span><br><span class="line">  LastSeq: 20020</span><br><span class="line">  AddFile: 0 14 325262 &#39;1000372555&#39; @ 11009 : 1 .. &#39;999733429&#39; @ 18727 : 1</span><br><span class="line">&#125;</span><br><span class="line">--- offset 223; VersionEdit &#123;</span><br><span class="line">  LogNumber: 15</span><br><span class="line">  PrevLogNumber: 0</span><br><span class="line">  NextFile: 17</span><br><span class="line">  LastSeq: 21954</span><br><span class="line">  CompactPointer: 0 &#39;999733429&#39; @ 8727 : 1</span><br><span class="line">  RemoveFile: 0 5</span><br><span class="line">  RemoveFile: 0 8</span><br><span class="line">  RemoveFile: 0 11</span><br><span class="line">  RemoveFile: 0 14</span><br><span class="line">  AddFile: 1 16 325291 &#39;1000372555&#39; @ 11009 : 1 .. &#39;999733429&#39; @ 18727 : 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里引入一个问题：<strong>manifest文件丢失，leveldb还能恢复数据吗？</strong></p>
<p>答案是可以的，因为log里面有完整的数据，重放log里没有写入的数据到memtable,再dump到level0里面，然后一层层压缩，建立新的manifest即可，具体参见<a href="https://www.cnblogs.com/cobbliu/p/6193164.html">这篇文章</a></p>
<hr>
<h3 id="recover"><a href="#recover" class="headerlink" title="recover"></a>recover</h3><p>todo</p>
<h3 id="builder"><a href="#builder" class="headerlink" title="builder"></a>builder</h3><p>todo</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://web.archive.org/web/20120131105110/http://rdc.taobao.com/blog/cs/wp-content/plugins/leveldb%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90.pdf">https://web.archive.org/web/20120131105110/http://rdc.taobao.com/blog/cs/wp-content/plugins/leveldb%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90.pdf</a></p>
<p><a href="http://catkang.github.io/2017/01/17/leveldb-data.html">http://catkang.github.io/2017/01/17/leveldb-data.html</a></p>
<p><a href="https://www.bookstack.cn/read/Leveldb-handbook/spilt.2.b308da3c3d01f3cd.md">https://www.bookstack.cn/read/Leveldb-handbook/spilt.2.b308da3c3d01f3cd.md</a></p>
<p><a href="https://izualzhy.cn/leveldb-block">https://izualzhy.cn/leveldb-block</a></p>
<p><a href="https://hardcore.feishu.cn/docs/doccnWaz1fjIxeyRosRTojk4irs">https://hardcore.feishu.cn/docs/doccnWaz1fjIxeyRosRTojk4irs</a></p>
]]></content>
      <tags>
        <tag>leveldb</tag>
      </tags>
  </entry>
  <entry>
    <title>leveldb源码分析(8) 迭代器 iterator</title>
    <url>/2021-11-06-leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(8)%20%E8%BF%AD%E4%BB%A3%E5%99%A8%20iterator/</url>
    <content><![CDATA[<div class="note default">
            <p>项目有用到leveldb,打算最近看看源码，整理个系列文章，这是第8篇迭代器 iterator。<a href="https://github.com/RiverFerry/leveldb-learn-log">源码注释地址</a></p>
          </div>


<a id="more"></a>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>纯基类的定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LEVELDB_EXPORT</span> <span class="title">Iterator</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Iterator</span>();</span><br><span class="line">  <span class="built_in">Iterator</span>(<span class="keyword">const</span> Iterator&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Iterator&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Iterator&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Iterator</span>();</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Valid</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SeekToFirst</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SeekToLast</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Slice&amp; target)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Prev</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Slice <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Slice <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Status <span class="title">status</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">using</span> CleanupFunction = <span class="built_in"><span class="keyword">void</span></span> (*)(<span class="keyword">void</span>* arg1, <span class="keyword">void</span>* arg2);</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">RegisterCleanup</span><span class="params">(CleanupFunction function, <span class="keyword">void</span>* arg1, <span class="keyword">void</span>* arg2)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">CleanupNode</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> function == <span class="literal">nullptr</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="built_in">assert</span>(function != <span class="literal">nullptr</span>);</span><br><span class="line">      (*function)(arg1, arg2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CleanupFunction function;</span><br><span class="line">    <span class="keyword">void</span>* arg1;</span><br><span class="line">    <span class="keyword">void</span>* arg2;</span><br><span class="line">    CleanupNode* next;</span><br><span class="line">  &#125;;</span><br><span class="line">  CleanupNode cleanup_head_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>涉及的子类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MemTableIterator : public Iterator</span><br><span class="line">class DBIter : public Iterator</span><br><span class="line">class ModelIter : public Iterator</span><br><span class="line">class Version::LevelFileNumIterator : public Iterator</span><br><span class="line">class Block::Iter : public Iterator</span><br><span class="line">class EmptyIterator : public Iterator</span><br><span class="line">class MergingIterator : public Iterator</span><br><span class="line">class KeyConvertingIterator : public Iterator</span><br><span class="line">class TwoLevelIterator : public Iterator</span><br></pre></td></tr></table></figure>

<h3 id="MemTableIterator"><a href="#MemTableIterator" class="headerlink" title="MemTableIterator"></a>MemTableIterator</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对跳表的iterator进行了简单的封装</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemTableIterator</span> :</span> <span class="keyword">public</span> Iterator &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  MemTable::Table::Iterator iter_;</span><br><span class="line">  std::string tmp_;  <span class="comment">// For passing to EncodeKey</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>就是封装了MemTable::Table::Iterator，也就是skiplist的封装，skiplist的构造见<a href="https://riverferry.site/2021-10-13-leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(4)%20memtable%20and%20log/">https://riverferry.site/2021-10-13-leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(4)%20memtable%20and%20log/</a></p>
<h3 id="DBIter"><a href="#DBIter" class="headerlink" title="DBIter"></a>DBIter</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Memtables and sstables that make the DB representation contain</span></span><br><span class="line"><span class="comment">// (userkey,seq,type) =&gt; uservalue entries.  DBIter</span></span><br><span class="line"><span class="comment">// combines multiple entries for the same userkey found in the DB</span></span><br><span class="line"><span class="comment">// representation into a single entry while accounting for sequence</span></span><br><span class="line"><span class="comment">// numbers, deletion markers, overwrites, etc.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBIter</span> :</span> <span class="keyword">public</span> Iterator &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Which direction is the iterator currently moving?</span></span><br><span class="line">  <span class="comment">// (1) When moving forward, the internal iterator is positioned at</span></span><br><span class="line">  <span class="comment">//     the exact entry that yields this-&gt;key(), this-&gt;value()</span></span><br><span class="line">  <span class="comment">// (2) When moving backwards, the internal iterator is positioned</span></span><br><span class="line">  <span class="comment">//     just before all entries whose user key == this-&gt;key().</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Direction</span> &#123;</span> kForward, kReverse &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">DBIter</span>(DBImpl* db, <span class="keyword">const</span> Comparator* cmp, Iterator* iter, SequenceNumber s,</span><br><span class="line">         <span class="keyword">uint32_t</span> seed)</span><br><span class="line">      : <span class="built_in">db_</span>(db),</span><br><span class="line">        <span class="built_in">user_comparator_</span>(cmp),</span><br><span class="line">        <span class="built_in">iter_</span>(iter),</span><br><span class="line">        <span class="built_in">sequence_</span>(s),</span><br><span class="line">        <span class="built_in">direction_</span>(kForward),</span><br><span class="line">        <span class="built_in">valid_</span>(<span class="literal">false</span>),</span><br><span class="line">        <span class="built_in">rnd_</span>(seed),</span><br><span class="line">        <span class="built_in">bytes_until_read_sampling_</span>(<span class="built_in">RandomCompactionPeriod</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">DBIter</span>(<span class="keyword">const</span> DBIter&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  DBIter&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> DBIter&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">DBIter</span>() <span class="keyword">override</span> &#123; <span class="keyword">delete</span> iter_; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Valid</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> valid_; &#125;</span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(valid_);</span><br><span class="line">    <span class="keyword">return</span> (direction_ == kForward) ? <span class="built_in">ExtractUserKey</span>(iter_-&gt;<span class="built_in">key</span>()) : saved_key_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Slice <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(valid_);</span><br><span class="line">    <span class="keyword">return</span> (direction_ == kForward) ? iter_-&gt;<span class="built_in">value</span>() : saved_value_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Status <span class="title">status</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (status_.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> iter_-&gt;<span class="built_in">status</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> status_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Prev</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Slice&amp; target)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToFirst</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToLast</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">FindNextUserEntry</span><span class="params">(<span class="keyword">bool</span> skipping, std::string* skip)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">FindPrevUserEntry</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">ParseKey</span><span class="params">(ParsedInternalKey* key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SaveKey</span><span class="params">(<span class="keyword">const</span> Slice&amp; k, std::string* dst)</span> </span>&#123;</span><br><span class="line">    dst-&gt;<span class="built_in">assign</span>(k.<span class="built_in">data</span>(), k.<span class="built_in">size</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ClearSavedValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (saved_value_.<span class="built_in">capacity</span>() &gt; <span class="number">1048576</span>) &#123;</span><br><span class="line">      std::string empty;</span><br><span class="line">      <span class="built_in">swap</span>(empty, saved_value_);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      saved_value_.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Picks the number of bytes that can be read until a compaction is scheduled.</span></span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">RandomCompactionPeriod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rnd_.<span class="built_in">Uniform</span>(<span class="number">2</span> * config::kReadBytesPeriod);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  DBImpl* db_;</span><br><span class="line">  <span class="keyword">const</span> Comparator* <span class="keyword">const</span> user_comparator_;</span><br><span class="line">  Iterator* <span class="keyword">const</span> iter_;</span><br><span class="line">  SequenceNumber <span class="keyword">const</span> sequence_;</span><br><span class="line">  Status status_;</span><br><span class="line">  std::string saved_key_;    <span class="comment">// == current key when direction_==kReverse</span></span><br><span class="line">  std::string saved_value_;  <span class="comment">// == current raw value when direction_==kReverse</span></span><br><span class="line">  Direction direction_;</span><br><span class="line">  <span class="keyword">bool</span> valid_;</span><br><span class="line">  Random rnd_;</span><br><span class="line">  <span class="keyword">size_t</span> bytes_until_read_sampling_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Version-LevelFileNumIterator"><a href="#Version-LevelFileNumIterator" class="headerlink" title="Version::LevelFileNumIterator"></a>Version::LevelFileNumIterator</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// An internal iterator.  For a given version/level pair, yields</span></span><br><span class="line"><span class="comment">// information about the files in the level.  For a given entry, key()</span></span><br><span class="line"><span class="comment">// is the largest key that occurs in the file, and value() is an</span></span><br><span class="line"><span class="comment">// 16-byte value containing the file number and file size, both</span></span><br><span class="line"><span class="comment">// encoded using EncodeFixed64.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Version</span>:</span>:LevelFileNumIterator : <span class="keyword">public</span> Iterator &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">LevelFileNumIterator</span>(<span class="keyword">const</span> InternalKeyComparator&amp; icmp,</span><br><span class="line">                       <span class="keyword">const</span> std::vector&lt;FileMetaData*&gt;* flist)</span><br><span class="line">      : <span class="built_in">icmp_</span>(icmp), <span class="built_in">flist_</span>(flist), <span class="built_in">index_</span>(flist-&gt;<span class="built_in">size</span>()) &#123;  <span class="comment">// Marks as invalid</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Valid</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> index_ &lt; flist_-&gt;<span class="built_in">size</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Slice&amp; target)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    index_ = <span class="built_in">FindFile</span>(icmp_, *flist_, target);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToFirst</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; index_ = <span class="number">0</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToLast</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    index_ = flist_-&gt;<span class="built_in">empty</span>() ? <span class="number">0</span> : flist_-&gt;<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    index_++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Prev</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="keyword">if</span> (index_ == <span class="number">0</span>) &#123;</span><br><span class="line">      index_ = flist_-&gt;<span class="built_in">size</span>();  <span class="comment">// Marks as invalid</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      index_--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="keyword">return</span> (*flist_)[index_]-&gt;largest.<span class="built_in">Encode</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Slice <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="built_in">EncodeFixed64</span>(value_buf_, (*flist_)[index_]-&gt;number);</span><br><span class="line">    <span class="built_in">EncodeFixed64</span>(value_buf_ + <span class="number">8</span>, (*flist_)[index_]-&gt;file_size);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Slice</span>(value_buf_, <span class="built_in"><span class="keyword">sizeof</span></span>(value_buf_));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Status <span class="title">status</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> Status::<span class="built_in">OK</span>(); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> InternalKeyComparator icmp_;</span><br><span class="line">  <span class="keyword">const</span> std::vector&lt;FileMetaData*&gt;* <span class="keyword">const</span> flist_;</span><br><span class="line">  <span class="keyword">uint32_t</span> index_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Backing store for value().  Holds the file number and size.</span></span><br><span class="line">  <span class="keyword">mutable</span> <span class="keyword">char</span> value_buf_[<span class="number">16</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>flist_用vector保存了这一层所有的sst文件。index_作为迭代器当前指向的位置，value返回16字节的字符串，包含sst文件的编号和大小，key返回sst文件的最大内部key</p>
<hr>
<h3 id="TwoLevelIterator"><a href="#TwoLevelIterator" class="headerlink" title="TwoLevelIterator"></a>TwoLevelIterator</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoLevelIterator</span> :</span> <span class="keyword">public</span> Iterator &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">TwoLevelIterator</span>(Iterator* index_iter, BlockFunction block_function,</span><br><span class="line">                   <span class="keyword">void</span>* arg, <span class="keyword">const</span> ReadOptions&amp; options);</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">TwoLevelIterator</span>() <span class="keyword">override</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Slice&amp; target)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToFirst</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToLast</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Prev</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Valid</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> data_iter_.<span class="built_in">Valid</span>(); &#125;</span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="keyword">return</span> data_iter_.<span class="built_in">key</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Slice <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="keyword">return</span> data_iter_.<span class="built_in">value</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Status <span class="title">status</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="comment">// It&#x27;d be nice if status() returned a const Status&amp; instead of a Status</span></span><br><span class="line">    <span class="keyword">if</span> (!index_iter_.<span class="built_in">status</span>().<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> index_iter_.<span class="built_in">status</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data_iter_.<span class="built_in">iter</span>() != <span class="literal">nullptr</span> &amp;&amp; !data_iter_.<span class="built_in">status</span>().<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> data_iter_.<span class="built_in">status</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> status_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SaveError</span><span class="params">(<span class="keyword">const</span> Status&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (status_.<span class="built_in">ok</span>() &amp;&amp; !s.<span class="built_in">ok</span>()) status_ = s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SkipEmptyDataBlocksForward</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SkipEmptyDataBlocksBackward</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetDataIterator</span><span class="params">(Iterator* data_iter)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">InitDataBlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  BlockFunction block_function_;</span><br><span class="line">  <span class="keyword">void</span>* arg_;</span><br><span class="line">  <span class="keyword">const</span> ReadOptions options_;</span><br><span class="line">  Status status_;</span><br><span class="line">  IteratorWrapper index_iter_;</span><br><span class="line">  IteratorWrapper data_iter_;  <span class="comment">// May be nullptr</span></span><br><span class="line">  <span class="comment">// If data_iter_ is non-null, then &quot;data_block_handle_&quot; holds the</span></span><br><span class="line">  <span class="comment">// &quot;index_value&quot; passed to block_function_ to create the data_iter_.</span></span><br><span class="line">  std::string data_block_handle_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>关键是data_iter_和index_iter_,后面补充</p>
<hr>
<h3 id="Block-Iter"><a href="#Block-Iter" class="headerlink" title="Block::Iter"></a>Block::Iter</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Block</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Initialize the block with the specified contents.</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Block</span><span class="params">(<span class="keyword">const</span> BlockContents&amp; contents)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Block</span>(<span class="keyword">const</span> Block&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Block&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Block&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Block</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_; &#125;</span><br><span class="line">  <span class="function">Iterator* <span class="title">NewIterator</span><span class="params">(<span class="keyword">const</span> Comparator* comparator)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Iter</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">uint32_t</span> <span class="title">NumRestarts</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* data_;</span><br><span class="line">  <span class="keyword">size_t</span> size_;</span><br><span class="line">  <span class="keyword">uint32_t</span> restart_offset_;  <span class="comment">// Offset in data_ of restart array</span></span><br><span class="line">  <span class="keyword">bool</span> owned_;               <span class="comment">// Block owns data_[]</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中的Iter：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Block::Iter : public Iterator &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="EmptyIterator"><a href="#EmptyIterator" class="headerlink" title="EmptyIterator"></a>EmptyIterator</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmptyIterator</span> :</span> <span class="keyword">public</span> Iterator &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">EmptyIterator</span>(<span class="keyword">const</span> Status&amp; s) : <span class="built_in">status_</span>(s) &#123;&#125;</span><br><span class="line">  ~<span class="built_in">EmptyIterator</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Valid</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Slice&amp; target)</span> <span class="keyword">override</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToFirst</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToLast</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="built_in">assert</span>(<span class="literal">false</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Prev</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="built_in">assert</span>(<span class="literal">false</span>); &#125;</span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Slice</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Slice <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Slice</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Status <span class="title">status</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> status_; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Status status_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>暂时不知道这个有啥用，后面见到了再补充</p>
<hr>
<h3 id="MergingIterator"><a href="#MergingIterator" class="headerlink" title="MergingIterator"></a>MergingIterator</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MergingIterator</span> :</span> <span class="keyword">public</span> Iterator &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后面补充</p>
<hr>
<h3 id="KeyConvertingIterator"><a href="#KeyConvertingIterator" class="headerlink" title="KeyConvertingIterator"></a>KeyConvertingIterator</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A helper class that converts internal format keys into user keys</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KeyConvertingIterator</span> :</span> <span class="keyword">public</span> Iterator &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">KeyConvertingIterator</span><span class="params">(Iterator* iter)</span> : iter_(iter) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">KeyConvertingIterator</span>(<span class="keyword">const</span> KeyConvertingIterator&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  KeyConvertingIterator&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> KeyConvertingIterator&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">KeyConvertingIterator</span>() <span class="keyword">override</span> &#123; <span class="keyword">delete</span> iter_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Valid</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> iter_-&gt;<span class="built_in">Valid</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Slice&amp; target)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="function">ParsedInternalKey <span class="title">ikey</span><span class="params">(target, kMaxSequenceNumber, kTypeValue)</span></span>;</span><br><span class="line">    std::string encoded;</span><br><span class="line">    <span class="built_in">AppendInternalKey</span>(&amp;encoded, ikey);</span><br><span class="line">    iter_-&gt;<span class="built_in">Seek</span>(encoded);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToFirst</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; iter_-&gt;<span class="built_in">SeekToFirst</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SeekToLast</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; iter_-&gt;<span class="built_in">SeekToLast</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; iter_-&gt;<span class="built_in">Next</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Prev</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; iter_-&gt;<span class="built_in">Prev</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    ParsedInternalKey key;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ParseInternalKey</span>(iter_-&gt;<span class="built_in">key</span>(), &amp;key)) &#123;</span><br><span class="line">      status_ = Status::<span class="built_in">Corruption</span>(<span class="string">&quot;malformed internal key&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Slice</span>(<span class="string">&quot;corrupted key&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> key.user_key;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Slice <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> iter_-&gt;<span class="built_in">value</span>(); &#125;</span><br><span class="line">  <span class="function">Status <span class="title">status</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> status_.<span class="built_in">ok</span>() ? iter_-&gt;<span class="built_in">status</span>() : status_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">mutable</span> Status status_;</span><br><span class="line">  Iterator* iter_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="ModelIter"><a href="#ModelIter" class="headerlink" title="ModelIter"></a>ModelIter</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelDB</span> :</span> <span class="keyword">public</span> DB &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ModelIter</span> :</span> <span class="keyword">public</span> Iterator &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">ModelIter</span>(<span class="keyword">const</span> KVMap* map, <span class="keyword">bool</span> owned)</span><br><span class="line">            : <span class="built_in">map_</span>(map), <span class="built_in">owned_</span>(owned), <span class="built_in">iter_</span>(map_-&gt;<span class="built_in">end</span>()) &#123;&#125;</span><br><span class="line">        ~<span class="built_in">ModelIter</span>() <span class="keyword">override</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (owned_) <span class="keyword">delete</span> map_;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Valid</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> iter_ != map_-&gt;<span class="built_in">end</span>(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">SeekToFirst</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; iter_ = map_-&gt;<span class="built_in">begin</span>(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">SeekToLast</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map_-&gt;<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            iter_ = map_-&gt;<span class="built_in">end</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            iter_ = map_-&gt;<span class="built_in">find</span>(map_-&gt;<span class="built_in">rbegin</span>()-&gt;first);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Slice&amp; k)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        iter_ = map_-&gt;<span class="built_in">lower_bound</span>(k.<span class="built_in">ToString</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; ++iter_; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Prev</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; --iter_; &#125;</span><br><span class="line">        <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> iter_-&gt;first; &#125;</span><br><span class="line">        <span class="function">Slice <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> iter_-&gt;second; &#125;</span><br><span class="line">        <span class="function">Status <span class="title">status</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> Status::<span class="built_in">OK</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">const</span> KVMap* <span class="keyword">const</span> map_;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">bool</span> owned_;  <span class="comment">// Do we own map_</span></span><br><span class="line">        KVMap::const_iterator iter_;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://web.archive.org/web/20120131105110/http://rdc.taobao.com/blog/cs/wp-content/plugins/leveldb%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90.pdf">https://web.archive.org/web/20120131105110/http://rdc.taobao.com/blog/cs/wp-content/plugins/leveldb%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90.pdf</a></p>
<p><a href="http://catkang.github.io/2017/01/17/leveldb-data.html">http://catkang.github.io/2017/01/17/leveldb-data.html</a></p>
<p><a href="https://www.bookstack.cn/read/Leveldb-handbook/spilt.2.b308da3c3d01f3cd.md">https://www.bookstack.cn/read/Leveldb-handbook/spilt.2.b308da3c3d01f3cd.md</a></p>
<p><a href="https://izualzhy.cn/leveldb-block">https://izualzhy.cn/leveldb-block</a></p>
<p><a href="https://hardcore.feishu.cn/docs/doccnWaz1fjIxeyRosRTojk4irs">https://hardcore.feishu.cn/docs/doccnWaz1fjIxeyRosRTojk4irs</a></p>
]]></content>
      <tags>
        <tag>leveldb</tag>
      </tags>
  </entry>
  <entry>
    <title>leveldb源码分析(9) 完整的读取流程</title>
    <url>/2021-11-07-leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(9)%20%E5%AE%8C%E6%95%B4%E7%9A%84%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<div class="note default">
            <p>项目有用到leveldb,打算最近看看源码，整理个系列文章，这是第9篇完整的读取流程。<a href="https://github.com/RiverFerry/leveldb-learn-log">源码注释地址</a></p>
          </div>


<a id="more"></a>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>todo</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://web.archive.org/web/20120131105110/http://rdc.taobao.com/blog/cs/wp-content/plugins/leveldb%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90.pdf">https://web.archive.org/web/20120131105110/http://rdc.taobao.com/blog/cs/wp-content/plugins/leveldb%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90.pdf</a></p>
<p><a href="http://catkang.github.io/2017/01/17/leveldb-data.html">http://catkang.github.io/2017/01/17/leveldb-data.html</a></p>
<p><a href="https://www.bookstack.cn/read/Leveldb-handbook/spilt.2.b308da3c3d01f3cd.md">https://www.bookstack.cn/read/Leveldb-handbook/spilt.2.b308da3c3d01f3cd.md</a></p>
<p><a href="https://izualzhy.cn/leveldb-block">https://izualzhy.cn/leveldb-block</a></p>
]]></content>
      <tags>
        <tag>leveldb</tag>
      </tags>
  </entry>
  <entry>
    <title>leveldb源码分析(10) lru cache</title>
    <url>/2021-11-08-leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(10)%20lru%20cache/</url>
    <content><![CDATA[<div class="note default">
            <p>leveldb内部实现了一个简单的lru,整理下</p>
          </div>


<a id="more"></a>

<p>通过内部实现的一个简单的hash_table和一个lru双向链表来实现。并且提供了shard的lru_cache,默认分成16片，减少锁冲突，有点像go里面的一个map的分片实现。</p>
<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/lrucache_rgb.png"></p>
<h2 id="LRUHandle"><a href="#LRUHandle" class="headerlink" title="LRUHandle"></a>LRUHandle</h2><p>链表节点数据结构定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LRUHandle</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span>* value;</span><br><span class="line">  <span class="built_in"><span class="keyword">void</span></span> (*deleter)(<span class="keyword">const</span> Slice&amp;, <span class="keyword">void</span>* value);</span><br><span class="line">  LRUHandle* next_hash;</span><br><span class="line">  LRUHandle* next;</span><br><span class="line">  LRUHandle* prev;</span><br><span class="line">  <span class="keyword">size_t</span> charge;  <span class="comment">// TODO(opt): Only allow uint32_t?</span></span><br><span class="line">  <span class="keyword">size_t</span> key_length;</span><br><span class="line">  <span class="keyword">bool</span> in_cache;     <span class="comment">// Whether entry is in the cache.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> refs;     <span class="comment">// References, including cache reference, if present.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> hash;     <span class="comment">// Hash of key(); used for fast sharding(分片) and comparisons</span></span><br><span class="line">  <span class="keyword">char</span> key_data[<span class="number">1</span>];  <span class="comment">// Beginning of key</span></span><br><span class="line"></span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// next_ is only equal to this if the LRU handle is the list head of an</span></span><br><span class="line">    <span class="comment">// empty list. List heads never have meaningful keys.</span></span><br><span class="line">    <span class="built_in">assert</span>(next != <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Slice</span>(key_data, key_length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>delete</code>支持外部传入自定义的回收函数指针</li>
<li><code>next</code>是lru链表的下一节点</li>
<li><code>prev</code>是lru链表的下一节点</li>
<li><code>next_hash</code>是hash table拉链的下一节点</li>
<li><code>refs</code>引用计数，=1的时候在lru_链表，&gt;1的时候在in_use_链表，=0的时候回收资源，在in_use_链表的时候即使cache超过容量，也不能回收</li>
<li><code>charge</code>占用容量</li>
</ul>
<h2 id="HandleTable"><a href="#HandleTable" class="headerlink" title="HandleTable"></a>HandleTable</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HandleTable</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// The table consists of an array of buckets where each bucket is</span></span><br><span class="line">  <span class="comment">// a linked list of cache entries that hash into the bucket.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> length_; <span class="comment">// bucket数量</span></span><br><span class="line">  <span class="keyword">uint32_t</span> elems_;  <span class="comment">// 节点数量</span></span><br><span class="line">  LRUHandle** list_; <span class="comment">// 保存指针的数组，数组大小是length_</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>length_</code>是桶的大小，就是list_数组的大小，初始化为4，后面按2倍扩容</li>
<li><code>elems_</code>节点数量，当节点数量&gt;length_的时候，开始扩容，resize函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果没有冲突，Insert后返回空</span></span><br><span class="line"><span class="comment">// 如果冲突，覆盖冲突节点(hash表key不能重复)</span></span><br><span class="line"><span class="function">LRUHandle* <span class="title">Insert</span><span class="params">(LRUHandle* h)</span> </span>&#123;</span><br><span class="line">  LRUHandle** ptr = <span class="built_in">FindPointer</span>(h-&gt;<span class="built_in">key</span>(), h-&gt;hash);</span><br><span class="line">  LRUHandle* old = *ptr;</span><br><span class="line">  h-&gt;next_hash = (old == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : old-&gt;next_hash);</span><br><span class="line">  *ptr = h;</span><br><span class="line">  <span class="keyword">if</span> (old == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    ++elems_;</span><br><span class="line">    <span class="keyword">if</span> (elems_ &gt; length_) &#123;</span><br><span class="line">      <span class="comment">// Since each cache entry is fairly large, we aim for a small</span></span><br><span class="line">      <span class="comment">// average linked list length (&lt;= 1).</span></span><br><span class="line">      <span class="comment">// 扩容的时机比较特殊，没有按装载因子算，元素个数大于桶的大小就扩容了， 链表不会太长</span></span><br><span class="line">      <span class="built_in">Resize</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是新的key，就插入到桶的拉链的尾。</p>
<p>如果是存在的key，则覆盖原来的值，insert完后调用FinishErase(table_.Insert(e)),来回收原来的key.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果是存在的节点，直接覆盖节点的地址为next_hash的地址，return 原来的地址(finish函数remove)</span></span><br><span class="line">  <span class="function">LRUHandle* <span class="title">Remove</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span> </span>&#123;</span><br><span class="line">    LRUHandle** ptr = <span class="built_in">FindPointer</span>(key, hash);</span><br><span class="line">    LRUHandle* result = *ptr;</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      *ptr = result-&gt;next_hash;</span><br><span class="line">      --elems_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="LRUCache"><a href="#LRUCache" class="headerlink" title="LRUCache"></a>LRUCache</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A single shard of sharded cache.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">LRUCache</span>();</span><br><span class="line">  ~<span class="built_in">LRUCache</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Separate from constructor so caller can easily make an array of LRUCache</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetCapacity</span><span class="params">(<span class="keyword">size_t</span> capacity)</span> </span>&#123; capacity_ = capacity; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Like Cache methods, but with an extra &quot;hash&quot; parameter.</span></span><br><span class="line">  <span class="function">Cache::Handle* <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash, <span class="keyword">void</span>* value,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">size_t</span> charge,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">void</span> (*deleter)(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">void</span>* value))</span></span>;</span><br><span class="line">  <span class="function">Cache::Handle* <span class="title">Lookup</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Release</span><span class="params">(Cache::Handle* handle)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Erase</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Prune</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">TotalCharge</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> usage_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">LRU_Remove</span><span class="params">(LRUHandle* e)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">LRU_Append</span><span class="params">(LRUHandle* list, LRUHandle* e)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Ref</span><span class="params">(LRUHandle* e)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Unref</span><span class="params">(LRUHandle* e)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">FinishErase</span><span class="params">(LRUHandle* e)</span> <span class="title">EXCLUSIVE_LOCKS_REQUIRED</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialized before use.</span></span><br><span class="line">  <span class="comment">// 容量</span></span><br><span class="line">  <span class="keyword">size_t</span> capacity_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// mutex_ protects the following state.</span></span><br><span class="line">  <span class="keyword">mutable</span> port::Mutex mutex_;</span><br><span class="line">  <span class="comment">// 使用量</span></span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> usage_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Dummy head of LRU list.</span></span><br><span class="line">  <span class="comment">// lru.prev is newest entry, lru.next is oldest entry.</span></span><br><span class="line">  <span class="comment">// Entries have refs==1 and in_cache==true.</span></span><br><span class="line">  <span class="comment">// lru头结点,头结点是dummy不保存外部数据</span></span><br><span class="line">  <span class="comment">// refs==1在lru_链表，&gt;1在in_use链表，1代表cache本身的引用，client每使用一次会+1</span></span><br><span class="line">  <span class="function">LRUHandle lru_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Dummy head of in-use list.</span></span><br><span class="line">  <span class="comment">// Entries are in use by clients, and have refs &gt;= 2 and in_cache==true.</span></span><br><span class="line">  <span class="comment">// in_use头结点，被client使用的在in_use_链表,其他的在lru_链表</span></span><br><span class="line">  <span class="function">LRUHandle in_use_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">HandleTable table_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>引用计数&gt;1放在in_use_链表，=1放在lru_，=0就开始释放资源了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::LRU_Append</span><span class="params">(LRUHandle* list, LRUHandle* e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Make &quot;e&quot; newest entry by inserting just before *list</span></span><br><span class="line">  e-&gt;next = list;</span><br><span class="line">  e-&gt;prev = list-&gt;prev;</span><br><span class="line">  e-&gt;prev-&gt;next = e;</span><br><span class="line">  e-&gt;next-&gt;prev = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::LRU_Remove</span><span class="params">(LRUHandle* e)</span> </span>&#123;</span><br><span class="line">  e-&gt;next-&gt;prev = e-&gt;prev;</span><br><span class="line">  e-&gt;prev-&gt;next = e-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>lru_和in_use_</strong>是dummy的头结点，初始化的时候，next和prev都指向自己。后面append插入dummy的左边第一个位置，remove移除dummy右边的第一个元素，因为是循环链表，所以dummy即是头也是尾。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Cache::Handle* <span class="title">LRUCache::Lookup</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  LRUHandle* e = table_.<span class="built_in">Lookup</span>(key, hash);</span><br><span class="line">  <span class="keyword">if</span> (e != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">Ref</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;Cache::Handle*&gt;(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过hash table来实现O(1)的查找，没查一次引用计数+1，如果再lru_,则重新放入in_use_.</p>
<h2 id="ShardedLRUCache"><a href="#ShardedLRUCache" class="headerlink" title="ShardedLRUCache"></a>ShardedLRUCache</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kNumShardBits = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 分片，16个</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kNumShards = <span class="number">1</span> &lt;&lt; kNumShardBits;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShardedLRUCache</span> :</span> <span class="keyword">public</span> Cache &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  LRUCache shard_[kNumShards];</span><br><span class="line">  port::Mutex id_mutex_;</span><br><span class="line">  <span class="keyword">uint64_t</span> last_id_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用数组存了多个LRUCache,基本的实现，一目了然。</p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>leveldb源码分析(1x) 总结</title>
    <url>/2021-11-10-leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(1x)%20%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<div class="note default">
            <p>项目有用到leveldb,打算最近看看源码，整理个系列文章，这是第10篇总结。<a href="https://github.com/RiverFerry/leveldb-learn-log">源码注释地址</a></p>
          </div>


<a id="more"></a>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>todo</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://web.archive.org/web/20120131105110/http://rdc.taobao.com/blog/cs/wp-content/plugins/leveldb%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90.pdf">https://web.archive.org/web/20120131105110/http://rdc.taobao.com/blog/cs/wp-content/plugins/leveldb%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90.pdf</a></p>
<p><a href="http://catkang.github.io/2017/01/17/leveldb-data.html">http://catkang.github.io/2017/01/17/leveldb-data.html</a></p>
<p><a href="https://www.bookstack.cn/read/Leveldb-handbook/spilt.2.b308da3c3d01f3cd.md">https://www.bookstack.cn/read/Leveldb-handbook/spilt.2.b308da3c3d01f3cd.md</a></p>
<p><a href="https://izualzhy.cn/leveldb-block">https://izualzhy.cn/leveldb-block</a></p>
]]></content>
      <tags>
        <tag>leveldb</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ std::thread</title>
    <url>/2022-03-30-C++%20std::thread/</url>
    <content><![CDATA[<div class="note default">
            <p>linux 2.1和linux2.6在线程实现上是不同的。在Linux2.4中，LinuxThreads是用单独的进程实现每个线程的，这使得它很难与posix线程的行为匹配。在linux2.6中，对linux内核和线程库进行了很大的修改，采用了一个称为Native POSIX线程库(NPTL)的新线程实现。它支持单个进程中有多个线程的模型，也更容易支持posix线程的语义。</p>
          </div>


<a id="more"></a>

<table>
<thead>
<tr>
<th>date</th>
<th>author</th>
<th>gcc</th>
<th>kernel</th>
<th>glibc</th>
</tr>
</thead>
<tbody><tr>
<td>20220331</td>
<td>river</td>
<td>gcc-11.2.0</td>
<td>linux-4.18.1</td>
<td>glibc-2.35</td>
</tr>
</tbody></table>
<div class="pdfobject-container" data-target="https://riverferry.site/pdf/pthread.pdf" data-height="1000px"></div>

<h2 id="std-thread"><a href="#std-thread" class="headerlink" title="std::thread"></a>std::thread</h2><h3 id="datastruct"><a href="#datastruct" class="headerlink" title="datastruct"></a>datastruct</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">thread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">using</span> native_handle_type = <span class="keyword">__gthread_t</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/// thread::id</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">id</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      native_handle_type	_M_thread;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">id</span>() <span class="keyword">noexcept</span> : _M_thread() &#123; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">explicit</span></span><br><span class="line">      <span class="built_in">id</span>(native_handle_type __id) : _M_thread(__id) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">thread</span>;</span></span><br><span class="line">      <span class="keyword">friend</span> <span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;</span>id&gt;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">friend</span> <span class="keyword">bool</span></span><br><span class="line">      <span class="keyword">operator</span>==(id __x, id __y) <span class="keyword">noexcept</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cpp_lib_three_way_comparison</span></span><br><span class="line">      <span class="keyword">friend</span> strong_ordering</span><br><span class="line">      <span class="keyword">operator</span>&lt;=&gt;(id __x, id __y) <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      <span class="keyword">friend</span> <span class="keyword">bool</span></span><br><span class="line">      <span class="keyword">operator</span>&lt;(id __x, id __y) <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">CharT</span>, <span class="keyword">class</span> _<span class="title">Traits</span>&gt;</span></span><br><span class="line">	<span class="keyword">friend</span> basic_ostream&lt;_CharT, _Traits&gt;&amp;</span><br><span class="line">	<span class="keyword">operator</span>&lt;&lt;(basic_ostream&lt;_CharT, _Traits&gt;&amp; __out, id __id);</span><br><span class="line">    &#125;;</span><br><span class="line">	<span class="comment">// member</span></span><br><span class="line">	id				_M_id;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ctor</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">thread</span>() <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _GLIBCXX_HAS_GTHREADS</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Callable, <span class="keyword">typename</span>... _Args,</span><br><span class="line">	     <span class="keyword">typename</span> = _Require&lt;__not_same&lt;_Callable&gt;&gt;&gt;</span><br><span class="line">      <span class="keyword">explicit</span></span><br><span class="line">      <span class="built_in">thread</span>(_Callable&amp;&amp; __f, _Args&amp;&amp;... __args)</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="built_in"><span class="keyword">static_assert</span></span>( __is_invocable&lt;<span class="keyword">typename</span> decay&lt;_Callable&gt;::type,</span><br><span class="line">				      <span class="keyword">typename</span> decay&lt;_Args&gt;::type...&gt;::value,</span><br><span class="line">	  <span class="string">&quot;std::thread arguments must be invocable after conversion to rvalues&quot;</span></span><br><span class="line">	  );</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> GTHR_ACTIVE_PROXY</span></span><br><span class="line">	<span class="comment">// Create a reference to pthread_create, not just the gthr weak symbol.</span></span><br><span class="line">	<span class="keyword">auto</span> __depend = <span class="keyword">reinterpret_cast</span>&lt;<span class="built_in"><span class="keyword">void</span></span>(*)()&gt;(&amp;pthread_create);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="keyword">auto</span> __depend = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">using</span> _Wrapper = _Call_wrapper&lt;_Callable, _Args...&gt;;</span><br><span class="line">	<span class="comment">// Create a call wrapper with DECAY_COPY(__f) as its target object</span></span><br><span class="line">	<span class="comment">// and DECAY_COPY(__args)... as its bound argument entities.</span></span><br><span class="line">	_M_start_thread(_State_ptr(<span class="keyword">new</span> _State_impl&lt;_Wrapper&gt;(</span><br><span class="line">	      std::forward&lt;_Callable&gt;(__f), std::forward&lt;_Args&gt;(__args)...)),</span><br><span class="line">	    __depend);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// dtor</span></span><br><span class="line">	~<span class="built_in">thread</span>()</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">joinable</span>())</span><br><span class="line">	std::<span class="built_in">terminate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// rule of four</span></span><br><span class="line">	<span class="built_in">thread</span>(<span class="keyword">const</span> thread&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">thread</span>(thread&amp;&amp; <span class="keyword">__t</span>) <span class="keyword">noexcept</span></span><br><span class="line">    &#123; <span class="built_in">swap</span>(<span class="keyword">__t</span>); &#125;</span><br><span class="line"></span><br><span class="line">    thread&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> thread&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    thread&amp; <span class="keyword">operator</span>=(thread&amp;&amp; <span class="keyword">__t</span>) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">joinable</span>())</span><br><span class="line">	std::<span class="built_in">terminate</span>();</span><br><span class="line">      <span class="built_in">swap</span>(<span class="keyword">__t</span>);</span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>thread::id::native_handle_type在linux-posix下就是<code>typedef pthread_t __gthread_t;</code>c++的thread封装了pthread_t类型。删掉了拷贝构造和拷贝赋值函数。移动构造和移动赋值用到了经典了<code>copy and swap idiom</code></p>
<h3 id="joinable"><a href="#joinable" class="headerlink" title="joinable"></a>joinable</h3><blockquote>
<p>checks whether the thread is joinable, i.e. potentially running in parallel context (public member function)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span></span><br><span class="line">    <span class="built_in">joinable</span>() <span class="keyword">const</span> <span class="keyword">noexcept</span></span><br><span class="line">    &#123; <span class="keyword">return</span> !(_M_id == <span class="built_in">id</span>()); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span></span><br><span class="line">  <span class="keyword">operator</span>==(thread::id __x, thread::id __y) <span class="keyword">noexcept</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// pthread_equal is undefined if either thread ID is not valid, so we</span></span><br><span class="line">    <span class="comment">// can&#x27;t safely use __gthread_equal on default-constructed values (nor</span></span><br><span class="line">    <span class="comment">// the non-zero value returned by this_thread::get_id() for</span></span><br><span class="line">    <span class="comment">// single-threaded programs using GNU libc). Assume EqualityComparable.</span></span><br><span class="line">    <span class="keyword">return</span> __x._M_thread == __y._M_thread;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_equal</span><span class="params">(<span class="keyword">pthread_t</span> t1, <span class="keyword">pthread_t</span> t2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">The pthread_equal() function shall return a non-zero value if t1</span></span><br><span class="line"><span class="comment">       and t2 are equal; otherwise, zero shall be returned.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       If either t1 or t2 are not valid thread IDs, the behavior is</span></span><br><span class="line"><span class="comment">       undefined.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>linux3.2.0使用无符号长整形表示pthread_t,但在其他平台实现是不一样的。所以这里通过和默认值做比较来判断_M_id是否是有效的。之所以不用pthread_equal原因如上。</p>
<p>这里有点不好理解再补充下： <strong>thread</strong>的构造函数传入callable执行函数，内部会掉pthread_create,pthread_create会申请pthread_t的值，然后赋值给thread::id::_M_thread,所以只有pthread创建了线程std::thread才是joinable的。</p>
<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><blockquote>
<pre><code>waits for the thread to finish its execution (public member function)</code></pre>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span></span><br><span class="line">  thread::<span class="built_in">join</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> __e = EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_M_id != <span class="built_in">id</span>())</span><br><span class="line">      __e = __gthread_join(_M_id._M_thread, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__e)</span><br><span class="line">      __throw_system_error(__e);</span><br><span class="line"></span><br><span class="line">    _M_id = <span class="built_in">id</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span><br><span class="line">__gthread_join (<span class="keyword">__gthread_t</span> __threadid, <span class="keyword">void</span> **__value_ptr)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __gthrw_(pthread_join) (__threadid, __value_ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用posix的pthread_join来实现，第2个参数传的0，不接收pthread_exit传出来的值。最后给_M_id赋初始值表示无效。</p>
<h3 id="detach"><a href="#detach" class="headerlink" title="detach"></a>detach</h3><blockquote>
<p>permits the thread to execute independently from the thread handle (public member function)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">  thread::<span class="built_in">detach</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> __e = EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_M_id != <span class="built_in">id</span>())</span><br><span class="line">      __e = __gthread_detach(_M_id._M_thread);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__e)</span><br><span class="line">      __throw_system_error(__e);</span><br><span class="line"></span><br><span class="line">    _M_id = <span class="built_in">id</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span><br><span class="line">__gthread_detach (<span class="keyword">__gthread_t</span> __threadid)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __gthrw_(pthread_detach) (__threadid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用posix的pthread_detach来实现。最后给_M_id赋初始值表示无效。</p>
<h3 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h3><blockquote>
<p>swaps two thread objects (public member function)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">    <span class="built_in">swap</span>(thread&amp; <span class="keyword">__t</span>) <span class="keyword">noexcept</span></span><br><span class="line">    &#123; std::<span class="built_in">swap</span>(_M_id, <span class="keyword">__t</span>._M_id); &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">  <span class="built_in">swap</span>(thread&amp; __x, thread&amp; __y) <span class="keyword">noexcept</span></span><br><span class="line">  &#123; __x.<span class="built_in">swap</span>(__y); &#125;</span><br></pre></td></tr></table></figure>

<p>实现copy and swap</p>
<h3 id="hardware-concurrency"><a href="#hardware-concurrency" class="headerlink" title="hardware_concurrency"></a>hardware_concurrency</h3><blockquote>
<p>returns the number of concurrent threads supported by the implementation (public static member function)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns a value that hints at the number of hardware thread contexts.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line">    <span class="built_in">hardware_concurrency</span>() <span class="keyword">noexcept</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line">  thread::<span class="built_in">hardware_concurrency</span>() <span class="keyword">noexcept</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> __n = _GLIBCXX_NPROCS;</span><br><span class="line">    <span class="keyword">if</span> (__n &lt; <span class="number">0</span>)</span><br><span class="line">      __n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> __n;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在多核系统中返回cpu核心的数量，当无法获取返回0.</p>
<h3 id="get-id"><a href="#get-id" class="headerlink" title="get_id"></a>get_id</h3><blockquote>
<p>returns the id of the thread (public member function)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">id</span><br><span class="line">    <span class="built_in">get_id</span>() <span class="keyword">const</span> <span class="keyword">noexcept</span></span><br><span class="line">    &#123; <span class="keyword">return</span> _M_id; &#125;</span><br></pre></td></tr></table></figure>

<p>返回thread::id，还有个this_thread::get_id()可以返回任意thread的thread::id</p>
<h3 id="native-handle"><a href="#native-handle" class="headerlink" title="native_handle"></a>native_handle</h3><blockquote>
<p>returns the underlying implementation-defined thread handle (public member function)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">native_handle_type</span><br><span class="line">    <span class="built_in">native_handle</span>()</span><br><span class="line">    &#123; <span class="keyword">return</span> _M_id._M_thread; &#125;</span><br></pre></td></tr></table></figure>

<p>返回原生的线程id数据结构，posix下是pthread_t</p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://en.cppreference.com/w/cpp/thread/thread">https://en.cppreference.com/w/cpp/thread/thread</a></p>
<p><a href="https://man7.org/linux/man-pages/man3/pthread_equal.3p.html">https://man7.org/linux/man-pages/man3/pthread_equal.3p.html</a></p>
<p><a href="https://bewaremypower.github.io/2018/12/31/C-11%E4%B8%ADstd-thread%E5%92%8Cpthread%E6%B7%B7%E7%94%A8%E7%9A%84%E5%9D%91/">https://bewaremypower.github.io/2018/12/31/C-11%E4%B8%ADstd-thread%E5%92%8Cpthread%E6%B7%B7%E7%94%A8%E7%9A%84%E5%9D%91/</a></p>
]]></content>
      <tags>
        <tag>c++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ std::mutex</title>
    <url>/2022-03-31-C++%20std::mutex/</url>
    <content><![CDATA[<div class="note default">
            <p>std::mutex/std::lock_guard/std::unique_lock/std::scoped_lock/std::recursive_mutex等族函数简单梳理</p>
          </div>


<a id="more"></a>

<table>
<thead>
<tr>
<th>date</th>
<th>author</th>
<th>gcc</th>
<th>kernel</th>
<th>glibc</th>
</tr>
</thead>
<tbody><tr>
<td>20220331</td>
<td>river</td>
<td>gcc-11.2.0</td>
<td>linux-4.18.1</td>
<td>glibc-2.35</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>class</th>
<th>since</th>
<th>file</th>
<th>meaning</th>
</tr>
</thead>
<tbody><tr>
<td>std::mutex</td>
<td>C++11</td>
<td>std_mutex.h</td>
<td>pthread_mutex_t的封装</td>
</tr>
<tr>
<td>std::lock_guard</td>
<td>C++11</td>
<td>std_mutex.h</td>
<td>简单的mutex的守卫类，没有对外接口，支持std::adopt_lock</td>
</tr>
<tr>
<td>std::unique_lock</td>
<td>C++11</td>
<td>unique_lock.h</td>
<td>mutex的守卫类，有对外接口，支持std::adopt_lock/std::defer_lock/std::try_to_lock</td>
</tr>
<tr>
<td>std::scoped_lock</td>
<td>C++17</td>
<td>mutex</td>
<td>支持对多个mutex的加锁，内部依赖std::lock(…)</td>
</tr>
<tr>
<td>std::recursive_mutex</td>
<td>C++11</td>
<td>mutex</td>
<td>递归锁，通过pthread_mutex_t的attr中参数实现递归</td>
</tr>
<tr>
<td>std::adopt_lock</td>
<td>C++17</td>
<td>std_mutex.h</td>
<td>不执行lock(),但保存mutex的地址/引用</td>
</tr>
<tr>
<td>std::defer_lock</td>
<td>C++11</td>
<td>std_mutex.h</td>
<td>不执行lock(),也不own</td>
</tr>
<tr>
<td>std::try_to_lock</td>
<td>C++11</td>
<td>std_mutex.h</td>
<td>通过pthread_mutex_trylock的结果决定是否own</td>
</tr>
<tr>
<td>std::lock</td>
<td>C++11</td>
<td>mutex</td>
<td>依赖c++17的模板推导机制，支持锁多个lockable object</td>
</tr>
</tbody></table>
<div class="pdfobject-container" data-target="https://riverferry.site/pdf/pthread.pdf" data-height="1000px"></div>

<h2 id="std-mutex"><a href="#std-mutex" class="headerlink" title="std::mutex"></a>std::mutex</h2><p>#include &lt;gcc-11.2.0/libstdc++-v3/include/bits/std_mutex.h&gt;</p>
<h3 id="datastruct"><a href="#datastruct" class="headerlink" title="datastruct"></a>datastruct</h3><p>mutex::__mutex_base::_M_mutex即是pthread_mutex_t.</p>
<h3 id="lock"><a href="#lock" class="headerlink" title="lock()"></a>lock()</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">    <span class="built_in">lock</span>()</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> __e = __gthread_mutex_lock(&amp;_M_mutex);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// EINVAL, EAGAIN, EBUSY, EINVAL, EDEADLK(may)</span></span><br><span class="line">      <span class="keyword">if</span> (__e)</span><br><span class="line">	__throw_system_error(__e);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>对应pthread_mutex_lock,失败抛异常.</p>
<h3 id="try-lock"><a href="#try-lock" class="headerlink" title="try_lock()"></a>try_lock()</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span></span><br><span class="line">    <span class="built_in">try_lock</span>() <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// XXX EINVAL, EAGAIN, EBUSY</span></span><br><span class="line">      <span class="keyword">return</span> !__gthread_mutex_trylock(&amp;_M_mutex);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>对应pthread_mutex_trylock,不抛异常.</p>
<h3 id="unlock"><a href="#unlock" class="headerlink" title="unlock()"></a>unlock()</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">    <span class="built_in">unlock</span>()</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// XXX EINVAL, EAGAIN, EPERM</span></span><br><span class="line">      __gthread_mutex_unlock(&amp;_M_mutex);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>对应pthread_mutex_unlock.</p>
<h3 id="native-handle"><a href="#native-handle" class="headerlink" title="native_handle()"></a>native_handle()</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">native_handle_type</span><br><span class="line">    <span class="built_in">native_handle</span>() <span class="keyword">noexcept</span></span><br><span class="line">    &#123; <span class="keyword">return</span> &amp;_M_mutex; &#125;</span><br></pre></td></tr></table></figure>

<p>返回pthread_mutex_t.</p>
<h2 id="std-lock-guard"><a href="#std-lock-guard" class="headerlink" title="std::lock_guard"></a>std::lock_guard</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** @brief A simple scoped lock type.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * A lock_guard controls mutex ownership within a scope, releasing</span></span><br><span class="line"><span class="comment">   * ownership in the destructor.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Mutex&gt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">lock_guard</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">typedef</span> _Mutex mutex_type;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">explicit</span> <span class="title">lock_guard</span><span class="params">(mutex_type&amp; __m)</span> : _M_device(__m)</span></span><br><span class="line"><span class="function">      &#123;</span> _M_device.<span class="built_in">lock</span>(); &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">lock_guard</span>(mutex_type&amp; __m, <span class="keyword">adopt_lock_t</span>) <span class="keyword">noexcept</span> : _M_device(__m)</span><br><span class="line">      &#123; &#125; <span class="comment">// calling thread owns mutex</span></span><br><span class="line"></span><br><span class="line">      ~<span class="built_in">lock_guard</span>()</span><br><span class="line">      &#123; _M_device.<span class="built_in">unlock</span>(); &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">lock_guard</span>(<span class="keyword">const</span> lock_guard&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">      lock_guard&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> lock_guard&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      mutex_type&amp;  _M_device;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>非常简单的一个守卫类。传的是一个”mutex”的引用, 没有提供对外的函数。如果带std::adopt_lock初始化，则只引用不加锁,如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">std::lock_guard&lt;std::mutex&gt; lock(m,std::adopt_lock);</span><br></pre></td></tr></table></figure>

<p>构造函数必须传入一个”mutex”的左值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mutex m;</span><br><span class="line">lock_guard&lt;mutex&gt; l1; &#x2F;&#x2F; err</span><br><span class="line">lock_guard&lt;mutex&gt; l2(); &#x2F;&#x2F; 成函数声明了</span><br><span class="line">lock_guard&lt;mutex&gt; l3(m); &#x2F;&#x2F; ok</span><br></pre></td></tr></table></figure>

<h2 id="unique-lock"><a href="#unique-lock" class="headerlink" title="unique_lock"></a>unique_lock</h2><p>相比lock_guard，多了一堆外部接口。多了一个own成员表示是否持有，自由度更高，支持defer_lock</p>
<h3 id="def"><a href="#def" class="headerlink" title="def"></a>def</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** @brief A movable scoped lock type.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * A unique_lock controls mutex ownership within a scope. Ownership of the</span></span><br><span class="line"><span class="comment">   * mutex can be delayed until after construction and can be transferred</span></span><br><span class="line"><span class="comment">   * to another unique_lock by move construction or move assignment. If a</span></span><br><span class="line"><span class="comment">   * mutex lock is owned when the destructor runs ownership will be released.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @ingroup mutexes</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Mutex&gt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">unique_lock</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">typedef</span> _Mutex mutex_type;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">unique_lock</span>() <span class="keyword">noexcept</span></span><br><span class="line">      : _M_device(<span class="number">0</span>), _M_owns(<span class="literal">false</span>)</span><br><span class="line">      &#123; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">explicit</span> <span class="title">unique_lock</span><span class="params">(mutex_type&amp; __m)</span></span></span><br><span class="line"><span class="function">      : _M_device(std::__addressof(__m)), _M_owns(false)</span></span><br><span class="line"><span class="function">      &#123;</span></span><br><span class="line">	<span class="built_in">lock</span>();</span><br><span class="line">	_M_owns = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">unique_lock</span>(mutex_type&amp; __m, <span class="keyword">defer_lock_t</span>) <span class="keyword">noexcept</span></span><br><span class="line">      : _M_device(std::__addressof(__m)), _M_owns(<span class="literal">false</span>)</span><br><span class="line">      &#123; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">unique_lock</span>(mutex_type&amp; __m, <span class="keyword">try_to_lock_t</span>)</span><br><span class="line">      : _M_device(std::__addressof(__m)), _M_owns(_M_device-&gt;<span class="built_in">try_lock</span>())</span><br><span class="line">      &#123; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">unique_lock</span>(mutex_type&amp; __m, <span class="keyword">adopt_lock_t</span>) <span class="keyword">noexcept</span></span><br><span class="line">      : _M_device(std::__addressof(__m)), _M_owns(<span class="literal">true</span>)</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="comment">// XXX calling thread owns mutex</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Clock, <span class="keyword">typename</span> _Duration&gt;</span><br><span class="line">	<span class="built_in">unique_lock</span>(mutex_type&amp; __m,</span><br><span class="line">		    <span class="keyword">const</span> chrono::time_point&lt;_Clock, _Duration&gt;&amp; __atime)</span><br><span class="line">	: _M_device(std::__addressof(__m)),</span><br><span class="line">	  _M_owns(_M_device-&gt;<span class="built_in">try_lock_until</span>(__atime))</span><br><span class="line">	&#123; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Rep, <span class="keyword">typename</span> _Period&gt;</span><br><span class="line">	<span class="built_in">unique_lock</span>(mutex_type&amp; __m,</span><br><span class="line">		    <span class="keyword">const</span> chrono::duration&lt;_Rep, _Period&gt;&amp; __rtime)</span><br><span class="line">	: _M_device(std::__addressof(__m)),</span><br><span class="line">	  _M_owns(_M_device-&gt;<span class="built_in">try_lock_for</span>(__rtime))</span><br><span class="line">	&#123; &#125;</span><br><span class="line"></span><br><span class="line">      ~<span class="built_in">unique_lock</span>()</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="keyword">if</span> (_M_owns)</span><br><span class="line">	  <span class="built_in">unlock</span>();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">unique_lock</span>(<span class="keyword">const</span> unique_lock&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">      unique_lock&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> unique_lock&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">unique_lock</span>(unique_lock&amp;&amp; __u) <span class="keyword">noexcept</span></span><br><span class="line">      : _M_device(__u._M_device), _M_owns(__u._M_owns)</span><br><span class="line">      &#123;</span><br><span class="line">	__u._M_device = <span class="number">0</span>;</span><br><span class="line">	__u._M_owns = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      unique_lock&amp; <span class="keyword">operator</span>=(unique_lock&amp;&amp; __u) <span class="keyword">noexcept</span></span><br><span class="line">      &#123;</span><br><span class="line">	<span class="keyword">if</span>(_M_owns)</span><br><span class="line">	  <span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">unique_lock</span>(std::<span class="built_in">move</span>(__u)).<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">	__u._M_device = <span class="number">0</span>;</span><br><span class="line">	__u._M_owns = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">      </span>&#123; <span class="keyword">return</span> <span class="built_in">owns_lock</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      mutex_type*	_M_device;</span><br><span class="line">      <span class="keyword">bool</span>		_M_owns;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="lock-1"><a href="#lock-1" class="headerlink" title="lock()"></a>lock()</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">      <span class="built_in">lock</span>()</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="keyword">if</span> (!_M_device)</span><br><span class="line">	  __throw_system_error(<span class="built_in"><span class="keyword">int</span></span>(errc::operation_not_permitted));</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (_M_owns)</span><br><span class="line">	  __throw_system_error(<span class="built_in"><span class="keyword">int</span></span>(errc::resource_deadlock_would_occur));</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	  &#123;</span><br><span class="line">	    _M_device-&gt;<span class="built_in">lock</span>();</span><br><span class="line">	    _M_owns = <span class="literal">true</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>unique_lock构造函数可以不传”mutex”进来，所以分3种情况,最终调用posix的lock().</p>
<ul>
<li>没关联Mutex</li>
<li>没hold mutex</li>
<li>hold mutex</li>
</ul>
<h3 id="try-lock-1"><a href="#try-lock-1" class="headerlink" title="try_lock()"></a>try_lock()</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span></span><br><span class="line">      <span class="built_in">try_lock</span>()</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="keyword">if</span> (!_M_device)</span><br><span class="line">	  __throw_system_error(<span class="built_in"><span class="keyword">int</span></span>(errc::operation_not_permitted));</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (_M_owns)</span><br><span class="line">	  __throw_system_error(<span class="built_in"><span class="keyword">int</span></span>(errc::resource_deadlock_would_occur));</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	  &#123;</span><br><span class="line">	    _M_owns = _M_device-&gt;<span class="built_in">try_lock</span>();</span><br><span class="line">	    <span class="keyword">return</span> _M_owns;</span><br><span class="line">	  &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>也是3种情况，和lock()差不多，调用posix的try_lock().</p>
<h3 id="try-lock-for"><a href="#try-lock-for" class="headerlink" title="try_lock_for()"></a>try_lock_for()</h3><blockquote>
<p>attempts to lock (i.e., takes ownership of) the associated TimedLockable mutex, returns if the mutex has been unavailable for the specified time duration (public member function)</p>
</blockquote>
<p>支持不同时间格式的timeout来try_lock,底层是posix的pthread_mutex_timedlock/pthread_mutex_clocklock</p>
<h3 id="try-lock-until"><a href="#try-lock-until" class="headerlink" title="try_lock_until"></a>try_lock_until</h3><blockquote>
<p>tries to lock (i.e., takes ownership of) the associated TimedLockable mutex, returns if the mutex has been unavailable until specified time point has been reached (public member function)</p>
</blockquote>
<p>支持不同时间格式的timeout来try_lock,底层是posix的pthread_mutex_timedlock/pthread_mutex_clocklock</p>
<h3 id="unlock-1"><a href="#unlock-1" class="headerlink" title="unlock()"></a>unlock()</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">      <span class="built_in">unlock</span>()</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="keyword">if</span> (!_M_owns)</span><br><span class="line">	  __throw_system_error(<span class="built_in"><span class="keyword">int</span></span>(errc::operation_not_permitted));</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (_M_device)</span><br><span class="line">	  &#123;</span><br><span class="line">	    _M_device-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">	    _M_owns = <span class="literal">false</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>未拥有就unlock会异常</p>
<h3 id="swap"><a href="#swap" class="headerlink" title="swap()"></a>swap()</h3><blockquote>
<p>swaps state with another std::unique_lock(public member function)</p>
</blockquote>
<h3 id="release"><a href="#release" class="headerlink" title="release()"></a>release()</h3><blockquote>
<p>disassociates the associated mutex without unlocking (i.e., releasing ownership of) it<br>(public member function)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mutex_type*</span><br><span class="line">      <span class="built_in">release</span>() <span class="keyword">noexcept</span></span><br><span class="line">      &#123;</span><br><span class="line">	mutex_type* __ret = _M_device;</span><br><span class="line">	_M_device = <span class="number">0</span>;</span><br><span class="line">	_M_owns = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> __ret;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>释放所有权，状态置为空，返回原来的mutex的地址。</p>
<h3 id="mutex"><a href="#mutex" class="headerlink" title="mutex()"></a>mutex()</h3><blockquote>
<p>returns a pointer to the associated mutex (public member function)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mutex_type*</span><br><span class="line">      <span class="built_in">mutex</span>() <span class="keyword">const</span> <span class="keyword">noexcept</span></span><br><span class="line">      &#123; <span class="keyword">return</span> _M_device; &#125;</span><br></pre></td></tr></table></figure>

<p>返回锁的地址</p>
<h3 id="owns-lock"><a href="#owns-lock" class="headerlink" title="owns_lock"></a>owns_lock</h3><blockquote>
<p>tests whether the lock owns (i.e., has locked) its associated mutex (public member function)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span></span><br><span class="line">      <span class="built_in">owns_lock</span>() <span class="keyword">const</span> <span class="keyword">noexcept</span></span><br><span class="line">      &#123; <span class="keyword">return</span> _M_owns; &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="scoped-lock"><a href="#scoped-lock" class="headerlink" title="scoped_lock"></a>scoped_lock</h2><p>代码不多，放上来了。scoped_lock只接收一个参数的话和lock_guard看起来没啥区别，主要是对于多个参数的使用比较好，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// s1</span></span><br><span class="line">&#123;</span><br><span class="line">  std::mutex m1, m2;</span><br><span class="line">  std::<span class="built_in">lock</span>(m1, m2);</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">l1</span><span class="params">(m1, std::adopt_lock)</span></span>;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">l2</span><span class="params">(m2, std::adopt_lock)</span></span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// s2</span></span><br><span class="line">&#123;</span><br><span class="line">  std::mutex m1, m2;</span><br><span class="line">  std::scoped_lock&lt;std::mutex, std::mutex&gt; sl(m1, m2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201703L</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __cpp_lib_scoped_lock 201703</span></span><br><span class="line">  <span class="comment">/** @brief A scoped lock type for multiple lockable objects.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * A scoped_lock controls mutex ownership within a scope, releasing</span></span><br><span class="line"><span class="comment">   * ownership in the destructor.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... _MutexTypes&gt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">scoped_lock</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">explicit</span> <span class="title">scoped_lock</span><span class="params">(_MutexTypes&amp;... __m)</span> : _M_devices(std::tie(__m...))</span></span><br><span class="line"><span class="function">      &#123;</span> std::<span class="built_in">lock</span>(__m...); &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">explicit</span> <span class="title">scoped_lock</span><span class="params">(<span class="keyword">adopt_lock_t</span>, _MutexTypes&amp;... __m)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">      : _M_devices(std::tie(__m...))</span></span><br><span class="line"><span class="function">      &#123;</span> &#125; <span class="comment">// calling thread owns mutex</span></span><br><span class="line"></span><br><span class="line">      ~<span class="built_in">scoped_lock</span>()</span><br><span class="line">      &#123; std::<span class="built_in">apply</span>([](<span class="keyword">auto</span>&amp;... __m) &#123; (__m.<span class="built_in">unlock</span>(), ...); &#125;, _M_devices); &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">scoped_lock</span>(<span class="keyword">const</span> scoped_lock&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">      scoped_lock&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> scoped_lock&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      tuple&lt;_MutexTypes&amp;...&gt; _M_devices;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">scoped_lock</span>&lt;</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">explicit</span> <span class="title">scoped_lock</span><span class="params">()</span> </span>= <span class="keyword">default</span>;</span><br><span class="line">      <span class="function"><span class="keyword">explicit</span> <span class="title">scoped_lock</span><span class="params">(<span class="keyword">adopt_lock_t</span>)</span> <span class="keyword">noexcept</span> </span>&#123; &#125;</span><br><span class="line">      ~<span class="built_in">scoped_lock</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">scoped_lock</span>(<span class="keyword">const</span> scoped_lock&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">      scoped_lock&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> scoped_lock&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Mutex&gt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">scoped_lock</span>&lt;</span>_Mutex&gt;</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">using</span> mutex_type = _Mutex;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">explicit</span> <span class="title">scoped_lock</span><span class="params">(mutex_type&amp; __m)</span> : _M_device(__m)</span></span><br><span class="line"><span class="function">      &#123;</span> _M_device.<span class="built_in">lock</span>(); &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">explicit</span> <span class="title">scoped_lock</span><span class="params">(<span class="keyword">adopt_lock_t</span>, mutex_type&amp; __m)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">      : _M_device(__m)</span></span><br><span class="line"><span class="function">      &#123;</span> &#125; <span class="comment">// calling thread owns mutex</span></span><br><span class="line"></span><br><span class="line">      ~<span class="built_in">scoped_lock</span>()</span><br><span class="line">      &#123; _M_device.<span class="built_in">unlock</span>(); &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">scoped_lock</span>(<span class="keyword">const</span> scoped_lock&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">      scoped_lock&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> scoped_lock&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      mutex_type&amp;  _M_device;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// C++17</span></span></span><br></pre></td></tr></table></figure>

<h2 id="recursive-mutex"><a href="#recursive-mutex" class="headerlink" title="recursive_mutex"></a>recursive_mutex</h2><blockquote>
<p>线程对已经获取的 std::mutex (已经上锁)再次上锁是错误的，尝试这样做会导致未定义行为。在某些情况下，一个线程会尝试在释放一个互斥量前多次获取。因此，C++标准库提供了 std::recursive_mutex 类。</p>
</blockquote>
<p>recursive_mutex::__recursive_mutex_base::_M_mutex就是pthread_mutex_t.<br>recursive_mutex和mutex的区别主要在构造函数中，给pthread_mutex_t加了attr(<strong>PTHREAD_MUTEX_RECURSIVE</strong>):</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span><br><span class="line">__gthread_recursive_mutex_init_function (<span class="keyword">__gthread_recursive_mutex_t</span> *__mutex)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__gthread_active_p ())</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">pthread_mutexattr_t</span> __attr;</span><br><span class="line">      <span class="keyword">int</span> __r;</span><br><span class="line"></span><br><span class="line">      __r = __gthrw_(pthread_mutexattr_init) (&amp;__attr);</span><br><span class="line">      <span class="keyword">if</span> (!__r)</span><br><span class="line">	__r = __gthrw_(pthread_mutexattr_settype) (&amp;__attr,</span><br><span class="line">						   PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line">      <span class="keyword">if</span> (!__r)</span><br><span class="line">	__r = __gthrw_(pthread_mutex_init) (__mutex, &amp;__attr);</span><br><span class="line">      <span class="keyword">if</span> (!__r)</span><br><span class="line">	__r = __gthrw_(pthread_mutexattr_destroy) (&amp;__attr);</span><br><span class="line">      <span class="keyword">return</span> __r;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PTHREAD_MUTEX_RECURSIVE在posix下的实现,就是保存了tid+count,来维持一个引用计数，如下：</p>
<h3 id="lock-2"><a href="#lock-2" class="headerlink" title="lock"></a>lock</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (__builtin_expect (PTHREAD_MUTEX_TYPE (mutex)</span><br><span class="line">			     == PTHREAD_MUTEX_RECURSIVE_NP, <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Recursive mutex.  */</span></span><br><span class="line">      <span class="keyword">pid_t</span> id = THREAD_GETMEM (THREAD_SELF, tid);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Check whether we already hold the mutex.  */</span></span><br><span class="line">      <span class="keyword">if</span> (mutex-&gt;__data.__owner == id)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* Just bump the counter.  */</span></span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (mutex-&gt;__data.__count + <span class="number">1</span> == <span class="number">0</span>))</span><br><span class="line">	    <span class="comment">/* Overflow of the counter.  */</span></span><br><span class="line">	    <span class="keyword">return</span> EAGAIN;</span><br><span class="line"></span><br><span class="line">	  ++mutex-&gt;__data.__count;</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We have to get the mutex.  */</span></span><br><span class="line">      LLL_MUTEX_LOCK_OPTIMIZED (mutex);</span><br><span class="line"></span><br><span class="line">      assert (mutex-&gt;__data.__owner == <span class="number">0</span>);</span><br><span class="line">      mutex-&gt;__data.__count = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="unlock-2"><a href="#unlock-2" class="headerlink" title="unlock"></a>unlock</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (__builtin_expect (PTHREAD_MUTEX_TYPE (mutex)</span><br><span class="line">			      == PTHREAD_MUTEX_RECURSIVE_NP, <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Recursive mutex.  */</span></span><br><span class="line">      <span class="keyword">if</span> (mutex-&gt;__data.__owner != THREAD_GETMEM (THREAD_SELF, tid))</span><br><span class="line">	<span class="keyword">return</span> EPERM;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (--mutex-&gt;__data.__count != <span class="number">0</span>)</span><br><span class="line">	<span class="comment">/* We still hold the mutex.  */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">goto</span> normal;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="std-lock"><a href="#std-lock" class="headerlink" title="std::lock"></a>std::lock</h2><p>std::lock对可变参数的对象进行加锁，实现上不放代码了，简单地说：</p>
<ul>
<li>通过unique_lock来加锁</li>
<li>通过unique_lock::release释放所有权，不解锁</li>
<li>通过模板递归实例化来处理…args</li>
</ul>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://en.cppreference.com/w/cpp/thread/mutex">https://en.cppreference.com/w/cpp/thread/mutex</a></p>
]]></content>
      <tags>
        <tag>c++</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Storage class specifiers</title>
    <url>/2022-04-07-C++%20Storage%20class%20specifiers/</url>
    <content><![CDATA[<div class="note default">
            <p>todo</p>
          </div>


<a id="more"></a>


<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://en.cppreference.com/w/cpp/language/storage_duration">https://en.cppreference.com/w/cpp/language/storage_duration</a></p>
<p><a href="https://www.zhihu.com/question/20630104">https://www.zhihu.com/question/20630104</a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>install kubesphere on k8s</title>
    <url>/2022-06-27-install%20kubesphere%20on%20k8s/</url>
    <content><![CDATA[<div class="note default">
            <p>原来在gke上面装过很顺利，后面自己kubeadm安装的cluster再安装遇到了一些问题，记录下</p>
          </div>


<a id="more"></a>

<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>按照<a href="https://kubesphere.io/zh/docs/v3.3/quick-start/minimal-kubesphere-on-k8s/">官方文档</a>安装就可以了，但是自己这里<strong>kubectl get svc/ks-console -n kubesphere-system</strong>看不到资源，日志也有报错：<code>Stop if StorageClass was not found</code>。gke环境sc这些默认都给配置好了，自己搭的环境就需要自己折腾了</p>
<p>参考<a href="https://kubesphere.com.cn/forum/d/3705-kubernetes-stop-if-storageclass-was-not-found/7">这个链接</a>，里面有处理方式，就是手动加了sc，但这样并不能解决对于我遇到的情况。</p>
<p>我用的rook作为存储插件，手动加sc可以参考：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line">[<span class="string">root@master</span> <span class="string">~</span>]<span class="comment"># cat sc.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">ceph.rook.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pool</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">replicapool</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">rook-ceph</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicated:</span></span><br><span class="line">    <span class="attr">size:</span> <span class="number">3</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">storage.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StorageClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">block-service</span></span><br><span class="line"><span class="attr">provisioner:</span> <span class="string">ceph.rook.io/block</span></span><br><span class="line"><span class="attr">parameters:</span></span><br><span class="line">  <span class="attr">pool:</span> <span class="string">replicapool</span></span><br><span class="line">  <span class="comment">#The value of &quot;clusterNamespace&quot; MUST be the same as the one in which your rook cluster exist</span></span><br><span class="line">  <span class="comment">#  clusterNamespace: rook-ceph</span></span><br></pre></td></tr></table></figure>

<p>gce下可以参考这个：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">storage.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StorageClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">gce-sc</span></span><br><span class="line"><span class="attr">provisioner:</span> <span class="string">kubernetes.io/gce-pd</span></span><br><span class="line"><span class="attr">parameters:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">pd-ssd</span></span><br></pre></td></tr></table></figure>

<p>另外还需要设置一个default的sc:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl patch storageclass gce-sc -p &#39;&#123;&quot;metadata&quot;: &#123;&quot;annotations&quot;:&#123;&quot;storageclass.kubernetes.io&#x2F;is-default-class&quot;:&quot;true&quot;&#125;&#125;&#125;&#39;</span><br></pre></td></tr></table></figure>

<p>具体参考这里<a href="https://kubernetes.io/docs/tasks/administer-cluster/change-default-storage-class/">Change the default StorageClass</a></p>
<p>最后如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@master ~]# kubectl get sc --all-namespaces</span><br><span class="line">NAME               PROVISIONER            RECLAIMPOLICY   VOLUMEBINDINGMODE   ALLOWVOLUMEEXPANSION   AGE</span><br><span class="line">gce-sc (default)   kubernetes.io&#x2F;gce-pd   Delete          Immediate           false                  47h</span><br></pre></td></tr></table></figure>

<p>重新安装下kubesphere就ok.</p>
<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/%E6%88%AA%E5%B1%8F2022-06-29%20%E4%B8%8A%E5%8D%8810.39.49.png"></p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://kubesphere.io/zh/docs/v3.3/quick-start/minimal-kubesphere-on-k8s/">https://kubesphere.io/zh/docs/v3.3/quick-start/minimal-kubesphere-on-k8s/</a></p>
<p><a href="https://cloud.google.com/sdk/gcloud/reference/container/clusters/create">https://cloud.google.com/sdk/gcloud/reference/container/clusters/create</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>linkerd</tag>
      </tags>
  </entry>
  <entry>
    <title>install linkerd on k8s with nginx ingress control</title>
    <url>/2022-06-28-install%20linkerd%20on%20k8s%20with%20nginx%20ingress%20control/</url>
    <content><![CDATA[<div class="note default">
            <p>linkerd安装后监听的本地端口，从外部访问需要特别配置。这篇文章环境基于gce下kubeadm部署的k8s，不同环境可能情况不同。</p>
          </div>


<a id="more"></a>

<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>按照官方的<a href="https://linkerd.io/2.11/getting-started/#step-3-install-the-control-plane-onto-your-cluster">步骤</a>就行了，装完linkerd和linkerd viz,最后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">linkerd viz dashboard &amp;</span><br></pre></td></tr></table></figure>

<p>就自动监听127.0.0.1了，本地部署的话到这里就可以结束了。我用的gce通过kubeadm部署的，公有云环境稍微复杂点，最后我用的方案是<code>ingress-nginx-control</code>来实现，中间挺折腾的，记录下。</p>
<p>官方提供了几种expose access的<a href="https://linkerd.io/2.11/tasks/exposing-dashboard/#ambassador">方式</a>,我用的nginx,如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web-ingress-auth</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">linkerd-viz</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">auth:</span> <span class="string">YWRtaW46JGFwcjEkbjdDdTZnSGwkRTQ3b2dmN0NPOE5SWWpFakJPa1dNLgoK</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># apiVersion: networking.k8s.io/v1beta1 # for k8s &lt; v1.19</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web-ingress</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">linkerd-viz</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/upstream-vhost:</span> <span class="string">$service_name.$namespace.svc.cluster.local:8084</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/configuration-snippet:</span> <span class="string">|</span></span><br><span class="line">      <span class="string">proxy_set_header</span> <span class="string">Origin</span> <span class="string">&quot;&quot;</span><span class="string">;</span></span><br><span class="line">      <span class="string">proxy_hide_header</span> <span class="string">l5d-remote-ip;</span></span><br><span class="line">      <span class="string">proxy_hide_header</span> <span class="string">l5d-server-id;</span>      </span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/auth-type:</span> <span class="string">basic</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/auth-secret:</span> <span class="string">web-ingress-auth</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/auth-realm:</span> <span class="string">&#x27;Authentication Required&#x27;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ingressClassName:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">dashboard.example.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">8084</span></span><br></pre></td></tr></table></figure>

<p>这里声明了一个ingress和一个secret,我不打算加https,所以不搞证书了，按照示例的账号密码就可以了。然后需要自己部署ingress-nginx-control,来根据上面的ingress生成具体的服务.<br>这里也按照<a href="https://kubernetes.github.io/ingress-nginx/deploy/">官方文档安装</a>就行了。</p>
<p>上面官方yam里面已经提供了service,默认是loadbalancer,在公有云上面比较麻烦，<code>kubectl get service -n **</code>后没有看到exterlnal ip,参考网上的<a href="https://stackoverflow.com/questions/44110876/kubernetes-service-external-ip-pending">方法</a>,手动加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">spec:</span><br><span class="line">  type: LoadBalancer</span><br><span class="line">  externalIPs:</span><br><span class="line">  - 192.168.0.10</span><br></pre></td></tr></table></figure>

<p>之后能看到ip了，我在node/master节点都可以访问，但通过本地或者其他地址访问还是不行，具体原因未知。后面为了节约时间手动改成nodeport了，改后也不能直接访问，还需要一步特别配置，在service的yml里面改一下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">//</span> <span class="string">before</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">externalTrafficPolicy:</span> <span class="string">Local</span></span><br><span class="line"></span><br><span class="line"><span class="string">//</span> <span class="string">after</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">externalTrafficPolicy:</span> <span class="string">Cluster</span></span><br></pre></td></tr></table></figure>

<p>再之后就ok了，可以通过域名用http访问了，账号密码官网有，这里改密码目前还没看怎么处理，毕竟是个测试环境，不打算长期用，就不折腾了，后面inject app后看看其他功能。</p>
<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/%E6%88%AA%E5%B1%8F2022-06-29%20%E4%B8%8A%E5%8D%8810.07.22.png"></p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://linkerd.io/2.11/getting-started/#step-3-install-the-control-plane-onto-your-cluster">linkerd.io</a></p>
<p><a href="https://kubernetes.github.io/ingress-nginx/deploy/">ingress-nginx</a></p>
<p><a href="https://cloud.google.com/community/tutorials/nginx-ingress-gke">gke上安装步骤</a></p>
<p><a href="https://oracle.github.io/cloudtestdrive/AppDev/cloud-native/livelabs/individual/kubernetes/kubernetes-complete/index.html?lab=linkerd-install">Cloud Native - Service mesh install and setup</a></p>
<p><a href="https://www.digitalocean.com/community/tutorials/how-to-install-and-use-linkerd-with-kubernetes">How To Install and Use Linkerd with Kubernetes</a></p>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>linkerd</tag>
      </tags>
  </entry>
  <entry>
    <title>java and spring中的注解</title>
    <url>/2022-08-27-java%20and%20spring%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<div class="note default">
            <p>因为用到了spring boot在开发，所以开始正式学习java语法和生态。这一篇是关于注解的。</p>
          </div>


<a id="more"></a>

<h2 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h2><h3 id="Component-Service-Repository-Control-RestControl"><a href="#Component-Service-Repository-Control-RestControl" class="headerlink" title="@Component @Service @Repository @Control @RestControl"></a>@Component @Service @Repository @Control @RestControl</h3><p><a href="https://www.baeldung.com/spring-component-repository-service">https://www.baeldung.com/spring-component-repository-service</a></p>
<p><a href="https://www.baeldung.com/spring-bean-annotations">https://www.baeldung.com/spring-bean-annotations</a></p>
<h2 id="inject"><a href="#inject" class="headerlink" title="inject"></a>inject</h2><h3 id="AutoWired-Resource-Inject"><a href="#AutoWired-Resource-Inject" class="headerlink" title="@AutoWired @Resource @Inject"></a>@AutoWired @Resource @Inject</h3><p><a href="https://stackoverflow.com/questions/4093504/resource-vs-autowired">https://stackoverflow.com/questions/4093504/resource-vs-autowired</a></p>
<p>这篇文章很不错，读完就懂了：<a href="https://www.baeldung.com/spring-annotations-resource-inject-autowire">Wiring in Spring: @Autowired, @Resource and @Inject</a></p>
<h2 id="lombok"><a href="#lombok" class="headerlink" title="lombok"></a>lombok</h2><blockquote>
<p>Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java.<br>Never write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more.</p>
</blockquote>
<h3 id="Data"><a href="#Data" class="headerlink" title="@Data"></a>@Data</h3><blockquote>
<p>All together now: A shortcut for @ToString, @EqualsAndHashCode, @Getter on all fields, @Setter on all non-final fields, and @RequiredArgsConstructor!</p>
</blockquote>
<p><a href="https://projectlombok.org/features/Data">https://projectlombok.org/features/Data</a></p>
<h3 id="NoArgsConstructor-RequiredArgsConstructor-AllArgsConstructor"><a href="#NoArgsConstructor-RequiredArgsConstructor-AllArgsConstructor" class="headerlink" title="@NoArgsConstructor, @RequiredArgsConstructor, @AllArgsConstructor"></a>@NoArgsConstructor, @RequiredArgsConstructor, @AllArgsConstructor</h3><p><a href="https://projectlombok.org/features/constructor">https://projectlombok.org/features/constructor</a></p>
<h3 id="Builder"><a href="#Builder" class="headerlink" title="@Builder"></a>@Builder</h3><p><a href="https://projectlombok.org/features/Builder">https://projectlombok.org/features/Builder</a></p>
<p>javadoc也写的挺详细的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">The builder annotation creates a so-called <span class="string">&#x27;builder&#x27;</span> aspect to the <span class="class"><span class="keyword">class</span> <span class="title">that</span> <span class="title">is</span> <span class="title">annotated</span> <span class="title">or</span> <span class="title">the</span> <span class="title">class</span> <span class="title">that</span> <span class="title">contains</span> <span class="title">a</span> <span class="title">member</span> <span class="title">which</span> <span class="title">is</span> <span class="title">annotated</span> <span class="title">with</span> @<span class="title">Builder</span>.</span></span><br><span class="line"><span class="class"><span class="title">If</span> <span class="title">a</span> <span class="title">member</span> <span class="title">is</span> <span class="title">annotated</span>, <span class="title">it</span> <span class="title">must</span> <span class="title">be</span> <span class="title">either</span> <span class="title">a</span> <span class="title">constructor</span> <span class="title">or</span> <span class="title">a</span> <span class="title">method</span>. <span class="title">If</span> <span class="title">a</span> <span class="title">class</span> <span class="title">is</span> <span class="title">annotated</span>, <span class="title">then</span> <span class="title">a</span> <span class="title">package</span>-<span class="title">private</span> <span class="title">constructor</span> <span class="title">is</span> <span class="title">generated</span> <span class="title">with</span> <span class="title">all</span> <span class="title">fields</span> <span class="title">as</span> <span class="title">arguments</span> (<span class="title">as</span> <span class="title">if</span> @<span class="title">AllArgsConstructor</span>(<span class="title">access</span> </span>= AccessLevel.PACKAGE) is present on the <span class="class"><span class="keyword">class</span>), <span class="title">and</span> <span class="title">it</span> <span class="title">is</span> <span class="title">as</span> <span class="title">if</span> <span class="title">this</span> <span class="title">constructor</span> <span class="title">has</span> <span class="title">been</span> <span class="title">annotated</span> <span class="title">with</span> @<span class="title">Builder</span> <span class="title">instead</span>. <span class="title">Note</span> <span class="title">that</span> <span class="title">this</span> <span class="title">constructor</span> <span class="title">is</span> <span class="title">only</span> <span class="title">generated</span> <span class="title">if</span> <span class="title">you</span> <span class="title">haven</span>&#x27;<span class="title">t</span> <span class="title">written</span> <span class="title">any</span> <span class="title">constructors</span> <span class="title">and</span> <span class="title">also</span> <span class="title">haven</span>&#x27;<span class="title">t</span> <span class="title">added</span> <span class="title">any</span> <span class="title">explicit</span> @<span class="title">XArgsConstructor</span> <span class="title">annotations</span>. <span class="title">In</span> <span class="title">those</span> <span class="title">cases</span>, <span class="title">lombok</span> <span class="title">will</span> <span class="title">assume</span> <span class="title">an</span> <span class="title">all</span>-<span class="title">args</span> <span class="title">constructor</span> <span class="title">is</span> <span class="title">present</span> <span class="title">and</span> <span class="title">generate</span> <span class="title">code</span> <span class="title">that</span> <span class="title">uses</span> <span class="title">it</span></span>; <span class="keyword">this</span> means you<span class="string">&#x27;d get a compiler error if this constructor is not present.</span></span><br><span class="line"><span class="string">The effect of @Builder is that an inner class is generated named TBuilder, with a private constructor. Instances of TBuilder are made with the method named builder() which is also generated for you in the class itself (not in the builder class).</span></span><br><span class="line"><span class="string">The TBuilder class contains 1 method for each parameter of the annotated constructor / method (each field, when annotating a class), which returns the builder itself. The builder also has a build() method which returns a completed instance of the original type, created by passing all parameters as set via the various other methods in the builder to the constructor or method that was annotated with @Builder. The return type of this method will be the same as the relevant class, unless a method has been annotated, in which case it&#x27;</span>ll be equal to the <span class="keyword">return</span> type of that method.</span><br><span class="line">Complete documentation is found at the project lombok features page <span class="keyword">for</span> <span class="meta">@Builder</span> . </span><br><span class="line">Before:</span><br><span class="line">  <span class="meta">@Builder</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Example</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  	<span class="keyword">private</span> T foo;</span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">final</span> String bar;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">After:</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Example</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  	<span class="keyword">private</span> T foo;</span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">final</span> String bar;</span><br><span class="line">  	</span><br><span class="line">  	<span class="function"><span class="keyword">private</span> <span class="title">Example</span><span class="params">(T foo, String bar)</span> </span>&#123;</span><br><span class="line">  		<span class="keyword">this</span>.foo = foo;</span><br><span class="line">  		<span class="keyword">this</span>.bar = bar;</span><br><span class="line">  	&#125;</span><br><span class="line">  	</span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ExampleBuilder&lt;T&gt; <span class="title">builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  		<span class="keyword">return</span> <span class="keyword">new</span> ExampleBuilder&lt;T&gt;();</span><br><span class="line">  	&#125;</span><br><span class="line">  	</span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBuilder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  		<span class="keyword">private</span> T foo;</span><br><span class="line">  		<span class="keyword">private</span> String bar;</span><br><span class="line">  		</span><br><span class="line">  		<span class="function"><span class="keyword">private</span> <span class="title">ExampleBuilder</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  		</span><br><span class="line">  		<span class="function"><span class="keyword">public</span> ExampleBuilder <span class="title">foo</span><span class="params">(T foo)</span> </span>&#123;</span><br><span class="line">  			<span class="keyword">this</span>.foo = foo;</span><br><span class="line">  			<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  		&#125;</span><br><span class="line">  		</span><br><span class="line">  		<span class="function"><span class="keyword">public</span> ExampleBuilder <span class="title">bar</span><span class="params">(String bar)</span> </span>&#123;</span><br><span class="line">  			<span class="keyword">this</span>.bar = bar;</span><br><span class="line">  			<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  		&#125;</span><br><span class="line">  		</span><br><span class="line">  		<span class="meta">@java</span>.lang.<span class="function">Override <span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  			<span class="keyword">return</span> <span class="string">&quot;ExampleBuilder(foo = &quot;</span> + foo + <span class="string">&quot;, bar = &quot;</span> + bar + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">  		&#125;</span><br><span class="line">  		</span><br><span class="line">  		<span class="function"><span class="keyword">public</span> Example <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  			<span class="keyword">return</span> <span class="keyword">new</span> Example(foo, bar);</span><br><span class="line">  		&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h2><p>其他的遇到了再补充，找到合适的资料就贴上来，尽量看上游的资料。</p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://projectlombok.org/">https://projectlombok.org/</a></p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>prometheus+grafana单机部署</title>
    <url>/2022-08-31-prometheus+grafana%E5%8D%95%E6%9C%BA%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<div class="note default">
            <p>今天有个python的grpc server,新起的服务，有一些功能还在调试需要测下性能，拿到rps,tp99,cpu等信息。就想着部署下prometheus+grafana在单机下使用，原来k8s下linkerd里面已经集成了这些，并且linkerd代理了每个服务，所以可以跨语言。我这里是单机的，服务的metric需要单独设置，官方的grpc只有go/java的exporter,网上找了只有几颗星的<a href="https://github.com/lchenn/py-grpc-prometheus">https://github.com/lchenn/py-grpc-prometheus</a>个人实现的python版本，先拿来试着用，本文主要记录下单机部署prometheus+grafana的过程</p>
          </div>


<a id="more"></a>

<h2 id="prometheus"><a href="#prometheus" class="headerlink" title="prometheus"></a>prometheus</h2><p>直接docker运行的，参考官方的<a href="https://prometheus.io/docs/prometheus/latest/installation/">步骤</a>,prometheus只是pull数据的，本身不收集数据，所以docker运行简单方便。需要自己配置exporter，所以命令可以挂在宿主机的yml文件进去：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line">    -p 9090:9090 \</span><br><span class="line">    -v &#x2F;path&#x2F;to&#x2F;prometheus.yml:&#x2F;etc&#x2F;prometheus&#x2F;prometheus.yml \</span><br><span class="line">    prom&#x2F;prometheus</span><br></pre></td></tr></table></figure>

<p>prometheus.yml简单配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">global:</span><br><span class="line">  scrape_interval: 15s</span><br><span class="line"></span><br><span class="line">scrape_configs:</span><br><span class="line">- job_name: node</span><br><span class="line">  static_configs:</span><br><span class="line">  - targets: [&#39;localhost:9100&#39;]</span><br></pre></td></tr></table></figure>

<h2 id="node-exporter"><a href="#node-exporter" class="headerlink" title="node exporter"></a>node exporter</h2><p>参考官方<a href="https://prometheus.io/docs/guides/node-exporter/">步骤</a>即可，然后配置到prometheus的配置文件就行了。</p>
<h2 id="grafana"><a href="#grafana" class="headerlink" title="grafana"></a>grafana</h2><p>参考官方的<a href="https://grafana.com/docs/grafana/v9.0/setup-grafana/installation/rpm/">步骤</a>,我这里因为是阿里云的机器别人配置的，好像是有外部的防火墙配置，所以需要修改默认的3000端口，<code>/etc/grafana/grafana.ini</code>里面找到port就行了改一下，然后重启<strong>systemctl restart grafana-server</strong>;默认的用户和密码也在这个文件里面，第一次登陆成功会提升修改密码的。</p>
<p>然后就是配置数据源为prometheus：</p>
<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/20220831182849.png"></p>
<p>再接着加dashboard,官方有模板，拿来用就行，我目前只部署了系统数据收集的node exporter,所以copy <a href="https://grafana.com/grafana/dashboards/1860-node-exporter-full/">this</a>过来就ok了，最终结果：</p>
<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/grafana.png"></p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://help.aliyun.com/document_detail/123108.html">https://help.aliyun.com/document_detail/123108.html</a></p>
<p><a href="https://grafana.com/grafana/dashboards/1860-node-exporter-full/">https://grafana.com/grafana/dashboards/1860-node-exporter-full/</a></p>
<p><a href="https://github.com/lchenn/py-grpc-prometheus">https://github.com/lchenn/py-grpc-prometheus</a></p>
<p><a href="https://grafana.com/docs/grafana/v9.0/setup-grafana/installation/rpm/">https://grafana.com/docs/grafana/v9.0/setup-grafana/installation/rpm/</a></p>
<p><a href="https://prometheus.io/docs/guides/node-exporter/">https://prometheus.io/docs/guides/node-exporter/</a></p>
<p><a href="https://rm-rf.medium.com/how-to-install-and-configure-prometheus-node-exporter-node-exporter-as-a-service-on-centos-7-50339b086704">https://rm-rf.medium.com/how-to-install-and-configure-prometheus-node-exporter-node-exporter-as-a-service-on-centos-7-50339b086704</a></p>
<p><a href="https://prometheus.io/docs/instrumenting/exporters/">https://prometheus.io/docs/instrumenting/exporters/</a></p>
]]></content>
      <tags>
        <tag>prometheus</tag>
        <tag>grafana</tag>
      </tags>
  </entry>
  <entry>
    <title>promql 语法学习</title>
    <url>/2022-09-02-promql%20%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<div class="note default">
            <p>学习promql常用语法，更好的理解qps,tp99等参数</p>
          </div>


<a id="more"></a>

<h2 id="promql"><a href="#promql" class="headerlink" title="promql"></a>promql</h2><p>In Prometheus’s expression language, an expression or sub-expression can evaluate to one of four types:</p>
<ul>
<li><strong>Instant vector</strong> - a set of time series containing a single sample for each time series, all sharing the same timestamp</li>
<li><strong>Range vector</strong> - a set of time series containing a range of data points over time for each time series</li>
<li><strong>Scalar</strong> - a simple numeric floating point value</li>
<li><strong>String</strong> - a simple string value; currently unused</li>
</ul>
<h3 id="gauge"><a href="#gauge" class="headerlink" title="gauge"></a>gauge</h3><p>gauge是忽高忽低的一个类型，比较适合算瞬时值，或者 avg,min,max,topk这些,例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># HELP go_goroutines Number of goroutines that currently exist.</span><br><span class="line"># TYPE go_goroutines gauge</span><br><span class="line">go_goroutines 9</span><br><span class="line"></span><br><span class="line">topk(5,go_goroutines&#123;job&#x3D;&quot;$job&quot;&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="counter"><a href="#counter" class="headerlink" title="counter"></a>counter</h3><p>counter是持续递增的类型，例如rpc的数量，总的处理时间这些。</p>
<h3 id="rate-irate-increase"><a href="#rate-irate-increase" class="headerlink" title="rate irate increase"></a>rate irate increase</h3><p><a href="https://prometheus.io/docs/prometheus/latest/querying/functions/#rate">rate</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rate(grpc_server_handling_seconds_count&#123;job&#x3D;&quot;grpc-go&quot;,grpc_type&#x3D;&quot;unary&quot;&#125;[30s])</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/rate.png"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">irate(grpc_server_handling_seconds_count&#123;job&#x3D;&quot;grpc-go&quot;,grpc_type&#x3D;&quot;unary&quot;&#125;[30s])</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/irate.png"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">increase(grpc_server_handling_seconds_count&#123;job&#x3D;&quot;grpc-go&quot;,grpc_type&#x3D;&quot;unary&quot;&#125;[30s])</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/increase.png"></p>
<p>我这里单线程发了100次rpc，总体增长是比较平滑的。rate是算duration(这里是30s)的开始和结尾2个point的数据，除以时间间隔得到的增长率。irate是取duration的最后2个时间点的数据，这个取决于step的大小，所以irate在开始和结尾的瞬间增长下降是很快的。而rate在30s就趋于稳定了，因为我这里客户端发的频率比较稳定。</p>
<p>increase和rate的区别是，increase不除以时间间隔，算的是增长不是增长率，这个可以看下源码一目了然：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// === rate(node parser.ValueTypeMatrix) Vector ===</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcRate</span><span class="params">(vals []parser.Value, args parser.Expressions, enh *EvalNodeHelper)</span> <span class="title">Vector</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> extrapolatedRate(vals, args, enh, <span class="literal">true</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// === increase(node parser.ValueTypeMatrix) Vector ===</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcIncrease</span><span class="params">(vals []parser.Value, args parser.Expressions, enh *EvalNodeHelper)</span> <span class="title">Vector</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> extrapolatedRate(vals, args, enh, <span class="literal">true</span>, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">extrapolatedRate</span><span class="params">(vals []parser.Value, args parser.Expressions, enh *EvalNodeHelper, isCounter, isRate <span class="keyword">bool</span>)</span> <span class="title">Vector</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> isRate &#123;</span><br><span class="line">		resultValue = resultValue / ms.Range.Seconds()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再看这里：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rate(grpc_server_handling_seconds_count&#123;job&#x3D;&quot;grpc-go&quot;,grpc_type&#x3D;&quot;unary&quot;&#125;[2s])</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/rate-2.png"></p>
<p>因为step=1s，这里rate的duration取2s，结果和irate一样了。</p>
<h3 id="avg-avg-over-time"><a href="#avg-avg-over-time" class="headerlink" title="avg avg_over_time"></a>avg avg_over_time</h3><p>avg_over_time(range-vector): the average value of all points in the specified interval.</p>
<h3 id="sum-sum-over-time"><a href="#sum-sum-over-time" class="headerlink" title="sum sum_over_time"></a>sum sum_over_time</h3><p><strong>sum_over_time</strong>:</p>
<p>The following functions allow aggregating each series of a given range vector over time and return an instant vector with per-series aggregation results:</p>
<ul>
<li>avg_over_time(range-vector): the average value of all points in the specified interval.</li>
<li>min_over_time(range-vector): the minimum value of all points in the specified interval.</li>
<li>max_over_time(range-vector): the maximum value of all points in the specified interval.</li>
<li>sum_over_time(range-vector): the sum of all values in the specified interval.</li>
<li>count_over_time(range-vector): the count of all values in the specified interval.</li>
<li>quantile_over_time(scalar, range-vector): the φ-quantile (0 ≤ φ ≤ 1) of the values in the specified interval.</li>
<li>stddev_over_time(range-vector): the population standard deviation of the values in the specified interval.</li>
<li>stdvar_over_time(range-vector): the population standard variance of the values in the specified interval.</li>
<li>last_over_time(range-vector): the most recent point value in specified interval.</li>
<li>present_over_time(range-vector): the value 1 for any series in the specified interval.</li>
</ul>
<p>Note that all values in the specified interval have the same weight in the aggregation even if the values are not equally spaced throughout the interval.</p>
<p><strong>sum</strong>:</p>
<p>Prometheus supports the following built-in aggregation operators that can be used to aggregate the elements of a single instant vector, resulting in a new vector of fewer elements with aggregated values:</p>
<p><a href="https://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators">ORIGIN LINK</a></p>
<ul>
<li>sum (calculate sum over dimensions)</li>
<li>min (select minimum over dimensions)</li>
<li>max (select maximum over dimensions)</li>
<li>avg (calculate the average over dimensions)</li>
<li>group (all values in the resulting vector are 1)</li>
<li>stddev (calculate population standard deviation over dimensions)</li>
<li>stdvar (calculate population standard variance over dimensions)</li>
<li>count (count number of elements in the vector)</li>
<li>count_values (count number of elements with the same value)</li>
<li>bottomk (smallest k elements by sample value)</li>
<li>topk (largest k elements by sample value)</li>
<li>quantile (calculate φ-quantile (0 ≤ φ ≤ 1) over dimensions)</li>
</ul>
<p>These operators can either be used to aggregate over all label dimensions or preserve distinct dimensions by including a without or by clause. These clauses may be used before or after the expression.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;aggr-op&gt; [without|by (&lt;label list&gt;)] ([parameter,] &lt;vector expression&gt;)</span><br></pre></td></tr></table></figure>

<p>or</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;aggr-op&gt;([parameter,] &lt;vector expression&gt;) [without|by (&lt;label list&gt;)]</span><br></pre></td></tr></table></figure>

<p>具体看官方文档吧，简单的说sum是对instant-vector的操作，还可以对label进行过滤。</p>
<p>这两个都是聚合操作，可以算多个实例的和。sum还可以根据label过滤。区别主要就是作用的对象不同，instant vs range;</p>
<p>测试效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; query</span><br><span class="line">grpc_server_handling_seconds_bucket&#123;job&#x3D;&quot;grpc-go&quot;,grpc_service&#x3D;~&quot;proto.DemoService&quot;,le&#x3D;~&quot;0.01|0.005|1&quot;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; result</span><br><span class="line">grpc_server_handling_seconds_bucket&#123;grpc_method&#x3D;&quot;SayHello&quot;, grpc_service&#x3D;&quot;proto.DemoService&quot;, grpc_type&#x3D;&quot;unary&quot;, instance&#x3D;&quot;0.0.0.0:50001&quot;, job&#x3D;&quot;grpc-go&quot;, le&#x3D;&quot;0.005&quot;&#125;</span><br><span class="line">231</span><br><span class="line">grpc_server_handling_seconds_bucket&#123;grpc_method&#x3D;&quot;SayHello&quot;, grpc_service&#x3D;&quot;proto.DemoService&quot;, grpc_type&#x3D;&quot;unary&quot;, instance&#x3D;&quot;0.0.0.0:50001&quot;, job&#x3D;&quot;grpc-go&quot;, le&#x3D;&quot;0.01&quot;&#125;</span><br><span class="line">231</span><br><span class="line">grpc_server_handling_seconds_bucket&#123;grpc_method&#x3D;&quot;SayHello&quot;, grpc_service&#x3D;&quot;proto.DemoService&quot;, grpc_type&#x3D;&quot;unary&quot;, instance&#x3D;&quot;0.0.0.0:50001&quot;, job&#x3D;&quot;grpc-go&quot;, le&#x3D;&quot;1&quot;&#125;</span><br><span class="line">231</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;query</span><br><span class="line">sum(grpc_server_handling_seconds_bucket&#123;job&#x3D;&quot;grpc-go&quot;,grpc_service&#x3D;~&quot;proto.DemoService&quot;,le&#x3D;~&quot;0.01|0.005|1&quot;&#125;) by (grpc_method)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;result</span><br><span class="line">&#123;grpc_method&#x3D;&quot;SayHello&quot;&#125;	693</span><br></pre></td></tr></table></figure>

<p>over_time也是类似的。</p>
<h3 id="histogram"><a href="#histogram" class="headerlink" title="histogram"></a>histogram</h3><p>这是grpcserver的api接口拿到的数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grpc_server_handling_seconds_bucket&#123;grpc_method&#x3D;&quot;SayHello&quot;,grpc_service&#x3D;&quot;proto.DemoService&quot;,grpc_type&#x3D;&quot;unary&quot;,le&#x3D;&quot;0.005&quot;&#125; 231</span><br><span class="line">grpc_server_handling_seconds_bucket&#123;grpc_method&#x3D;&quot;SayHello&quot;,grpc_service&#x3D;&quot;proto.DemoService&quot;,grpc_type&#x3D;&quot;unary&quot;,le&#x3D;&quot;0.01&quot;&#125; 231</span><br><span class="line">grpc_server_handling_seconds_bucket&#123;grpc_method&#x3D;&quot;SayHello&quot;,grpc_service&#x3D;&quot;proto.DemoService&quot;,grpc_type&#x3D;&quot;unary&quot;,le&#x3D;&quot;0.025&quot;&#125; 231</span><br><span class="line">grpc_server_handling_seconds_bucket&#123;grpc_method&#x3D;&quot;SayHello&quot;,grpc_service&#x3D;&quot;proto.DemoService&quot;,grpc_type&#x3D;&quot;unary&quot;,le&#x3D;&quot;0.05&quot;&#125; 231</span><br><span class="line">grpc_server_handling_seconds_bucket&#123;grpc_method&#x3D;&quot;SayHello&quot;,grpc_service&#x3D;&quot;proto.DemoService&quot;,grpc_type&#x3D;&quot;unary&quot;,le&#x3D;&quot;0.1&quot;&#125; 231</span><br><span class="line">grpc_server_handling_seconds_bucket&#123;grpc_method&#x3D;&quot;SayHello&quot;,grpc_service&#x3D;&quot;proto.DemoService&quot;,grpc_type&#x3D;&quot;unary&quot;,le&#x3D;&quot;0.25&quot;&#125; 231</span><br><span class="line">grpc_server_handling_seconds_bucket&#123;grpc_method&#x3D;&quot;SayHello&quot;,grpc_service&#x3D;&quot;proto.DemoService&quot;,grpc_type&#x3D;&quot;unary&quot;,le&#x3D;&quot;0.5&quot;&#125; 231</span><br><span class="line">grpc_server_handling_seconds_bucket&#123;grpc_method&#x3D;&quot;SayHello&quot;,grpc_service&#x3D;&quot;proto.DemoService&quot;,grpc_type&#x3D;&quot;unary&quot;,le&#x3D;&quot;1&quot;&#125; 231</span><br><span class="line">grpc_server_handling_seconds_bucket&#123;grpc_method&#x3D;&quot;SayHello&quot;,grpc_service&#x3D;&quot;proto.DemoService&quot;,grpc_type&#x3D;&quot;unary&quot;,le&#x3D;&quot;2.5&quot;&#125; 331</span><br><span class="line">grpc_server_handling_seconds_bucket&#123;grpc_method&#x3D;&quot;SayHello&quot;,grpc_service&#x3D;&quot;proto.DemoService&quot;,grpc_type&#x3D;&quot;unary&quot;,le&#x3D;&quot;5&quot;&#125; 351</span><br><span class="line">grpc_server_handling_seconds_bucket&#123;grpc_method&#x3D;&quot;SayHello&quot;,grpc_service&#x3D;&quot;proto.DemoService&quot;,grpc_type&#x3D;&quot;unary&quot;,le&#x3D;&quot;10&quot;&#125; 351</span><br><span class="line">grpc_server_handling_seconds_bucket&#123;grpc_method&#x3D;&quot;SayHello&quot;,grpc_service&#x3D;&quot;proto.DemoService&quot;,grpc_type&#x3D;&quot;unary&quot;,le&#x3D;&quot;+Inf&quot;&#125; 351</span><br><span class="line">grpc_server_handling_seconds_sum&#123;grpc_method&#x3D;&quot;SayHello&quot;,grpc_service&#x3D;&quot;proto.DemoService&quot;,grpc_type&#x3D;&quot;unary&quot;&#125; 160.067727291</span><br><span class="line">grpc_server_handling_seconds_count&#123;grpc_method&#x3D;&quot;SayHello&quot;,grpc_service&#x3D;&quot;proto.DemoService&quot;,grpc_type&#x3D;&quot;unary&quot;&#125; 351</span><br></pre></td></tr></table></figure>

<p>这里的grpc-go的prome里面直接用了prome官方的bucket定义，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DefBuckets &#x3D; []float64&#123;.005, .01, .025, .05, .1, .25, .5, 1, 2.5, 5, 10&#125;</span><br></pre></td></tr></table></figure>

<p>和上面api拿到的是一致的。</p>
<table>
<thead>
<tr>
<th>Bucket</th>
<th>Count</th>
</tr>
</thead>
<tbody><tr>
<td>0-0.005</td>
<td>231</td>
</tr>
<tr>
<td>0-0.01</td>
<td>231</td>
</tr>
<tr>
<td>0-0.025</td>
<td>231</td>
</tr>
<tr>
<td>0-0.05</td>
<td>231</td>
</tr>
<tr>
<td>0-0.1</td>
<td>231</td>
</tr>
<tr>
<td>0-0.25</td>
<td>231</td>
</tr>
<tr>
<td>0-0.5</td>
<td>231</td>
</tr>
<tr>
<td>0-1</td>
<td>231</td>
</tr>
<tr>
<td>0-2.5</td>
<td>331</td>
</tr>
<tr>
<td>0-5</td>
<td>331</td>
</tr>
<tr>
<td>0-10</td>
<td>331</td>
</tr>
<tr>
<td>0-+Inf</td>
<td>331</td>
</tr>
</tbody></table>
<p>这里之前我的服务都是官方的demo，一个简单的回显程序所以速度很快，所以bucket都是231，后面我加了sleep(1s),后面的bucket就变了。</p>
<h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><p>Summaries also measure events and are an alternative to histograms. They are cheaper, but lose more data. They are calculated on the application level hence aggregation of metrics from multiple instances of the same process is not possible. They are used when the buckets of a metric is not known beforehand, but it is highly recommended to use histograms over summaries whenever possible.</p>
<p>summary和histogram有点像，但是summary是在client端计算quantile的，并且不能aggregation.summaries的quantitile是提前写死的，client返回这个的精确值，不像bucket是近似值，但是histogram是prom端计算的，所以quantitile是可以手动调整的，牺牲的是prom的性能不是client的性能。官方不推荐用summary,实际也比较少见使用。</p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://prometheus.io/docs/prometheus/latest/querying/basics/">https://prometheus.io/docs/prometheus/latest/querying/basics/</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/354565885">https://zhuanlan.zhihu.com/p/354565885</a></p>
<p><a href="https://mp.weixin.qq.com/s/QkDUQOx9w1HZIFyyvIzp-A">https://mp.weixin.qq.com/s/QkDUQOx9w1HZIFyyvIzp-A</a></p>
]]></content>
      <tags>
        <tag>promql</tag>
      </tags>
  </entry>
  <entry>
    <title>文件审计-auditd</title>
    <url>/2019-05-11-%E6%96%87%E4%BB%B6%E5%AE%A1%E8%AE%A1auditd/</url>
    <content><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#audit%E7%AE%80%E4%BB%8B">audit简介</a></li>
<li><a href="#auditd%E5%B7%A5%E5%85%B7">auditd工具</a></li>
<li><a href="#auditd%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">auditd使用方法</a></li>
<li><a href="#auditctl">auditctl</a></li>
<li><a href="#autrace">autrace</a></li>
<li><a href="#ausearch">ausearch</a></li>
<li><a href="#aureport">aureport</a></li>
<li><a href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">配置文件</a></li>
<li><a href="#%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6">日志文件</a></li>
<li><a href="#%E5%AE%9E%E8%B7%B5">实践</a></li>
</ul>
<a id="more"></a>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>文件系统是计算机信息系统中至关重要的资源，而文件监控正是监控系统安全状态，保证计算机系统安全的关键技术。在Linux系统中，诸如 /etc/passwd, /usr/local/sbin 的文件和目录尤为关键。任何对这些文件的破坏和篡改都会引起严重的安全问题。甚至造成系统瘫痪，因此我们有必要使用一种好的策略和工具来对文件系统进行保护。</p>
</blockquote>
<h2 id="audit简介"><a href="#audit简介" class="headerlink" title="audit简介"></a>audit简介</h2><blockquote>
<p>audit是linux系统中用于记录用户底层调用情况的系统，如记录用户执行的open、exit等系统调用。并会将记录写到日志文件中。在内核里有内核审计模块，核外有核外的审计后台进程auditd。应用进程给内核发送审计消息，内核的审计模块再把消息转发给用户空间的后台进程auditd处理</p>
</blockquote>
<h2 id="auditd工具"><a href="#auditd工具" class="headerlink" title="auditd工具"></a>auditd工具</h2><blockquote>
<p>auditd是audit系统的用户空间程序.主要作用是将audit记录信息写到磁盘上<br>auditd在大多数linux系统中默认安装的,如果没有的话网上搜索下安装也比较简单</p>
</blockquote>
<pre><code>auditd在启动时会读取2个配置文件:
/etc/audit/auditd.conf   audit配置文件
/etc/audit/audit.rules   audit规则文件</code></pre>
<h2 id="auditd使用方法"><a href="#auditd使用方法" class="headerlink" title="auditd使用方法"></a>auditd使用方法</h2><ul>
<li>auditd [ -f ]    <br></li>
</ul>
<blockquote>
<p>选项-f表示让auditctl在前台运行，以方便调试，消息可以直接输出到stderr，而不是输出到log系统 <br></p>
</blockquote>
<h2 id="auditctl"><a href="#auditctl" class="headerlink" title="auditctl"></a>auditctl</h2><blockquote>
<p>工具auditctl控制行为、得到状态、从内核审计系统增加或删除规则 <br></p>
</blockquote>
<table>
    <thead>
        <tr>
            <th style="text-align:center">选项名</th>
            <th style="text-align:center">选项的值</th>
            <th style="text-align:center">说明</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>-b</td>
            <td></td>
            <td>设置内核允许的缓冲区数，默认值为64</td>
        </tr>
        <tr>
            <td>-e [0|1]</td>
            <td></td>
            <td>关闭或启动内核审计系统</td>
        </tr>
        <tr>
            <td>-f [0..2]</td>
            <td></td>
            <td>设置失败标识0=silent 1=printk 2=panic，默认值为1。设置内核如何处理临界错误，如：backlog限制超出、内存错误等</td>
        </tr>
        <tr>
            <td>-h</td>
            <td></td>
            <td>帮助信息</td>
        </tr>
        <tr>
            <td>-i</td>
            <td></td>
            <td>当从文件中读取规则时忽略错误</td>
        </tr>
        <tr>
            <td>-l</td>
            <td></td>
            <td>列出所有的规则，每行一条规则</td>
        </tr>
        <tr>
            <td>-k [key]</td>
            <td></td>
            <td>设置审计规则上的过滤关键词key，key是不超过32字节长的任意字符串，它能唯一鉴别由watch产生的审计记录</td>
        </tr>
        <tr>
            <td>-m text</td>
            <td></td>
            <td>仅由root用户发送用户空间消息到审计系统。为文件系统watch设置许可过滤器。r=read，w=write，x=execute，a=attribute change。这些许可不是文件的标准许可，而是系统调用使用的，read和write系统调用将忽略这种设置，否则它们将淹没log</td>
        </tr>
        <tr>
            <td>-r [rate]</td>
            <td></td>
            <td>设置每秒传输的消息数限制，默认值为0，表示无限制</td>
        </tr>
        <tr>
            <td>-R [file]</td>
            <td></td>
            <td>从file文件中读取规则</td>
        </tr>
        <tr>
            <td>-s</td>
            <td></td>
            <td>报告状态</td>
        </tr>
        <tr>
            <td>-a [l,a]</td>
            <td></td>
            <td>追加规则到l链表，a表示规则的动作</td>
        </tr>
        <tr>
            <td>有效链表名l</td>
            <td>task</td>
            <td>追加规则到每个任务链表AUDIT_FILTER_TASK 。域应用任务创建时的uid、gid等</td>
        </tr>
        <tr>
            <td>有效链表名l</td>
            <td>entry</td>
            <td>追加规则到系统调用进入链表AUDIT_FILTER_ENTRY，用于决定进入到系统调用时是否创建审计事件</td>
        </tr>
        <tr>
            <td>有效链表名l</td>
            <td>exit</td>
            <td>追加规则到系统调用退出链表AUDIT_FILTER_EXIT 。用于决定退出系统调用时是否创建审计事件</td>
        </tr>
        <tr>
            <td>有效链表名l</td>
            <td>user</td>
            <td>追加规则到用户消息过滤链表AUDIT_FILTER_USER ，内核在转播用户空间产生的事件到审计后台之前，用这个链表过滤这些事件。仅域为uid、auid、gid和pid时有效</td>
        </tr>
        <tr>
            <td>有效链表名l</td>
            <td>exclude</td>
            <td>用于过滤不想看到的事件，对应内核消息过滤链表AUDIT_FILTER_TYPE</td>
        </tr>
        <tr>
            <td>规则的有效动作a</td>
            <td>never</td>
            <td>不产生审计记录</td>
        </tr>
        <tr>
            <td>规则的有效动作a</td>
            <td>always</td>
            <td>分配一个审计上下文，在系统调用退出时填充</td>
        </tr>
        <tr>
            <td>-A [l,a]</td>
            <td></td>
            <td>添加规则到l链表头，动作为a</td>
        </tr>
        <tr>
            <td>-d [l,a]</td>
            <td></td>
            <td>从带有a动作的l链表删除规则</td>
        </tr>
        <tr>
            <td>-D</td>
            <td></td>
            <td>删除所有的规则和watch</td>
        </tr>
        <tr>
            <td>-S [系统调用名或号|all]</td>
            <td></td>
            <td>如果程序使用指定的系统调用，则它启动一项审计记录。如果给出域规则而没有指定系统调用，它将默认为所有系统调用</td>
        </tr>
        <tr>
            <td>-F [n=v | n!=v | n&lt;v | n&gt;v | n&lt;=v | n&gt;=v]</td>
            <td></td>
            <td>创建一个规则域：名字、操作、值。可以单个命令行传递最多64个域。每个域必须启动一个审计记录。可支持6种操作：等于、不等于、小于、大于、小于或等于和大于或等于</td>
        </tr>
        <tr>
            <td>-w [path]</td>
            <td></td>
            <td>为文件系统对象[path]插入一个watch（监视）。不支持匹配符</td>
        </tr>
        <tr>
            <td>-W [path]</td>
            <td></td>
            <td>移去文件系统对象[path]上的watch</td>
        </tr>
    </tbody>
</table>

<ul>
<li>-F 对应的域<br><br><img src="https://i.loli.net/2019/05/12/5cd6f1d545f81.png"></li>
</ul>
<h2 id="autrace"><a href="#autrace" class="headerlink" title="autrace"></a>autrace</h2><blockquote>
<p>autrace是一个程序，它将添加审计规则、类似于strace跟踪一个进程，审计信息的结果将记录在审计log文件中。在目标程序执行的前后，它都将删除审计规则。目前没用,以后补充<br></p>
</blockquote>
<h2 id="ausearch"><a href="#ausearch" class="headerlink" title="ausearch"></a>ausearch</h2><blockquote>
<p>工具ausearch用于查询审计后台的日志，它能基于不同搜索规则的事件查询审计后台日志。每个系统调用进入内核空间运行时有个唯一的事件ID，系统调用在进入内核后的运行过程的审计事件共享这个ID <br></p>
</blockquote>
<table>
    <thead align="center">
        <tr>
            <th style="text-align:center">option</th>
            <th style="text-align:center">full name</th>
            <th style="text-align:center">description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>-a</td>
            <td>--event audit-event-id</td>
            <td>基于event ID检索（msg里包含time_stamp和eventID）</td>
        </tr>
        <tr>
            <td>-c</td>
            <td>--comm</td>
            <td>基于comm名称检索</td>
        </tr>
        <tr>
            <td>-e</td>
            <td>--exit</td>
            <td>基于exit code或errno检索</td>
        </tr>
        <tr>
            <td>-f</td>
            <td>--file</td>
            <td>基于filename检索</td>
        </tr>
        <tr>
            <td>-ga</td>
            <td>--gid-all all-group-id</td>
            <td>基于group ID或groupname检索</td>
        </tr>
        <tr>
            <td>-ge</td>
            <td>--gid-effectuve effective-group-id</td>
            <td>基于effective group ID或name检索</td>
        </tr>
        <tr>
            <td>-gi</td>
            <td>--gid group-id</td>
            <td>基于group ID或name检索</td>
        </tr>
        <tr>
            <td>-h</td>
            <td>--help</td>
            <td>帮助信息</td>
        </tr>
        <tr>
            <td>-hn</td>
            <td>--host host-name</td>
            <td>基于hostname检索，hostname不会进行解析</td>
        </tr>
        <tr>
            <td>-i</td>
            <td>--interpret</td>
            <td>将数字编码解析问字符串（很多字段都进行了数字编码，通过此参数还原）</td>
        </tr>
        <tr>
            <td>-if</td>
            <td>--input file-name</td>
            <td>搜索给定的文件，而不会去系统的audit日志中检索。通过这个参数可以将日志导出到其他机器上进行检索</td>
        </tr>
        <tr>
            <td>--input-logs</td>
            <td></td>
            <td>使用auditd.conf中配置的日志文件路径来做检索，该参数用于写cron job的时候配合使用</td>
        </tr>
        <tr>
            <td>--just-one</td>
            <td></td>
            <td>当出现了第一条匹配的日志时即停止检索，所以只会检索出第一条匹配的结果</td>
        </tr>
        <tr>
            <td>-k</td>
            <td>--key key-string</td>
            <td>基于key进行检索</td>
        </tr>
        <tr>
            <td>-l</td>
            <td>--line-buffered</td>
            <td>如果默认的缓冲规则不能满足需要，通过此参数可以将每条输出都立即flush到连接的stdout流中</td>
        </tr>
        <tr>
            <td>-m</td>
            <td>--message message-type |comma-sep-message-type-list</td>
            <td>使用messagetype进行索引，可以指定某个type，也可以使用“逗号”将多个messagetype并列起来，逗号两侧不能有空格。可以使用ALL作为message type，用于匹配所有message type</td>
        </tr>
        <tr>
            <td>-n</td>
            <td>--node node-name</td>
            <td>匹配node name</td>
        </tr>
        <tr>
            <td>-o</td>
            <td>--objectSE-Linux-context-string</td>
            <td>匹配tcontext(object)</td>
        </tr>
        <tr>
            <td>-p</td>
            <td>--pid process-id</td>
            <td>匹配process ID</td>
        </tr>
        <tr>
            <td>-pp</td>
            <td>--ppidparent-process-id</td>
            <td>匹配parent process ID</td>
        </tr>
        <tr>
            <td>-r</td>
            <td>--raw</td>
            <td>将未经格式化处理的原日志输出</td>
        </tr>
        <tr>
            <td>-sc</td>
            <td>--syscallsyscall-name-or-value</td>
            <td>匹配syscall参数</td>
        </tr>
        <tr>
            <td>-se</td>
            <td>--context SE-Linux-context-string</td>
            <td>匹配scontext/subject或tcontext/object</td>
        </tr>
        <tr>
            <td>--session Login-Session-ID</td>
            <td></td>
            <td>匹配用户的Login Session ID</td>
        </tr>
        <tr>
            <td>-su</td>
            <td>--subject SE-Linux-context-string</td>
            <td>匹配scontext(subject)</td>
        </tr>
        <tr>
            <td>-sv</td>
            <td>--success success-value</td>
            <td>匹配success value</td>
        </tr>
        <tr>
            <td>-te</td>
            <td>--end[end-date][end-time]</td>
            <td>匹配time stamp等于或早于给定参数的event，时间格式与本地时间格式匹配，如果省略掉日期，则默认指定today作为默认值。如果省略掉时间，则now作为默认值，使用24小时制。例如09/03/2009 18:00:00。常用的一些预定义的关键字：now/recent/today/yesterday/this-week/week-ago/this-month/this-year，其中，recent表示10分钟之前，其他的都可以按照字面意思理解</td>
        </tr>
        <tr>
            <td>-ts</td>
            <td>--start [start-date][start-time]</td>
            <td>与-te参数类似，用于过滤日期和时间晚于给定时间的event。区别是如果时间参数省略，会以midnight作为默认值</td>
        </tr>
        <tr>
            <td>-tm</td>
            <td>--terminal terminal</td>
            <td>匹配terminal参数</td>
        </tr>
        <tr>
            <td>-ua</td>
            <td>--uid-all all-user-id</td>
            <td>匹配user ID/effective user ID/login user ID(auid)</td>
        </tr>
        <tr>
            <td>-ue</td>
            <td>--uid-effective</td>
            <td>effective-user-id：匹配effective user ID</td>
        </tr>
        <tr>
            <td>-ui</td>
            <td> --uid user-id</td>
            <td>匹配user ID</td>
        </tr>
        <tr>
            <td>-ul</td>
            <td>--loginuid login-id</td>
            <td>匹配login user ID</td>
        </tr>
        <tr>
            <td>-uu</td>
            <td>--uuid guest-uuid</td>
            <td>匹配guest UUID</td>
        </tr>
        <tr>
            <td>-v</td>
            <td>--version</td>
            <td>打印版本</td>
        </tr>
        <tr>
            <td>-vm</td>
            <td>--vm-name guest-name</td>
            <td>匹配guest name</td>
        </tr>
        <tr>
            <td>-w</td>
            <td>--word</td>
            <td>条件中如果有字符串匹配，必须完全匹配，例如filename/hostname/terminal/SELinux context</td>
        </tr>
        <tr>
            <td>-x</td>
            <td>--executable executable</td>
            <td>匹配executable名</td>
        </tr>
    </tbody>
</table>

<h2 id="aureport"><a href="#aureport" class="headerlink" title="aureport"></a>aureport</h2><blockquote>
<p>工具aureport用于产生审计后台日志的总结报告</p>
</blockquote>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><pre><code>/etc/audit/auditd.conf 有以下作用
1. 设置审计消息的专用日志文件
2. 确定是否循环使用日志文件
3. 如果日志文件的启动用掉了太多磁盘空间则发出警告
4. 配置审计规则记录更详细的信息
5. 激活文件和目录观察器
[root@localhost ~]# cat /etc/audit/auditd.conf 
#
# This file controls the configuration of the audit daemon
#

log_file = /var/log/audit/audit.log
log_format = RAW
log_group = root
priority_boost = 4
flush = INCREMENTAL
freq = 20
num_logs = 5
disp_qos = lossy
dispatcher = /sbin/audispd
name_format = NONE
##name = mydomain
max_log_file = 6 
max_log_file_action = ROTATE
space_left = 75
space_left_action = SYSLOG
action_mail_acct = root
admin_space_left = 50
admin_space_left_action = SUSPEND
disk_full_action = SUSPEND
disk_error_action = SUSPEND
##tcp_listen_port = 
tcp_listen_queue = 5
tcp_max_per_addr = 1
##tcp_client_ports = 1024-65535
tcp_client_max_idle = 0
enable_krb5 = no
krb5_principal = auditd
##krb5_key_file = /etc/audit/audit.key</code></pre>
<p><a href="https://linux.die.net/man/8/auditd.conf">配置文件说明</a> <br></p>
<ul>
<li><p>log_file<br></p>
<blockquote>
<p>审计日志文件的完整路径。如果您配置守护进程向除默认/var/log/audit/外的目录中写日志文件时，一定要修改它上面的文件权限，使得只有根用户有读、写和执行权限。所有其他用户都不能访问这个目录或这个目录中的日志文件</p>
</blockquote>
</li>
<li><p>log_format<br></p>
<blockquote>
<p>写日志时要使用的格式。当设置为RAW时，数据会以从内核中检索到的格式写到日志文件中。当设置为NOLOG时，数据不会写到日志文件中，但是如果用dispatcher选项指定了一个，则数据仍然会发送到审计事件调度程序中</p>
</blockquote>
</li>
<li><p>priority_boost<br></p>
<blockquote>
<p>审计应采用多少优先级推进守护进程。必须是非负数。0表示没有变化</p>
</blockquote>
</li>
<li><p>flush<br></p>
<blockquote>
<p>多长时间向日志文件中写一次数据。值可以是NONE、INCREMENTAL、DATA和SYNC之一。如果设置为NONE，则不需要做特殊努力来将数据 刷新到日志文件中。如果设置为INCREMENTAL，则freq参数用于确定发出显式刷新磁盘的频率。如果设置为DATA，则审计数据和日志文 件一直是同步的。如果设置为SYNC，则每次写到日志文件时，数据和元数据是同步的</p>
</blockquote>
</li>
<li><p>freq<br></p>
<blockquote>
<p>如果flush设置为INCREMETNAL，审计守护进程在写到日志文件中前从内核中接收的记录数</p>
</blockquote>
</li>
<li><p>num_logs<br></p>
<blockquote>
<p>max_log_file_action设置为ROTATE时要保存的日志文件数目。必须是0~99之间的数。如果设置为小于2，则不会循环日志。如果递 增了日志文件的数目，就可能有必要递增/etc/audit/audit.rules中的内核backlog设置值，以便留出日志循环的时间。如果没有设 置num_logs值，它就默认为0，意味着从来不循环日志文件</p>
</blockquote>
</li>
<li><p>dispatcher<br></p>
<blockquote>
<p>当启动这个守护进程时，由审计守护进程自动启动程序。所有守护进程都传递给这个程序。可以用它来进一步定制报表或者以与您的自定义分析程序兼容的不同格式 产生它们。自定义程序的示例代码可以在/usr/share/doc/audit- [version]/skeleton.c中找到。由于调度程序用根用户特权运行，因此使用这个选项时要极其小心。这个选项不是必需的</p>
</blockquote>
</li>
<li><p>disp_qos<br></p>
<blockquote>
<p>控制调度程序与审计守护进程之间的通信类型。有效值为lossy和lossless。如果设置为lossy，若审计守护进程与调度程序之间的缓冲区已满 (缓冲区为128千字节)，则发送给调度程序的引入事件会被丢弃。然而，只要log_format没有设置为nolog，事件就仍然会写到磁盘中。如果设 置为lossless，则在向调度程序发送事件之前和将日志写到磁盘之前，调度程序会等待缓冲区有足够的空间</p>
</blockquote>
</li>
<li><p>max_log_file<br></p>
<blockquote>
<p>以兆字节表示的最大日志文件容量。当达到这个容量时，会执行max_log_file _action指定的动作</p>
</blockquote>
</li>
<li><p>max_log_file_action<br></p>
<blockquote>
<p>当达到max_log_file的日志文件大小时采取的动作。值必须是IGNORE、SYSLOG、SUSPEND、ROTATE和KEEP_LOGS之 一。如果设置为IGNORE，则在日志文件达到max_log_file后不采取动作。如果设置为SYSLOG，则当达到文件容量时会向系统日志/var /log/messages中写入一条警告。如果设置为SUSPEND，则当达到文件容量后不会向日志文件写入审计消息。如果设置为ROTATE，则当达 到指定文件容量后会循环日志文件，但是只会保存一定数目的老文件，这个数目由num_logs参数指定。老文件的文件名将为audit.log.N，其中 N是一个数字。这个数字越大，则文件越老。如果设置为KEEP_LOGS，则会循环日志文件，但是会忽略num_logs参数，因此不会删除日志文件</p>
</blockquote>
</li>
<li><p>space_left<br></p>
<blockquote>
<p>以兆字节表示的磁盘空间数量。当达到这个水平时，会采取space_left_action参数中的动作</p>
</blockquote>
</li>
<li><p>space_left_action<br></p>
<blockquote>
<p>当磁盘空间量达到space_left中的值时，采取这个动作。有效值为IGNORE、SYSLOG、EMAIL、SUSPEND、SINGLE和 HALT。如果设置为IGNORE，则不采取动作。如果设置为SYSLOG，则向系统日志/var/log/messages写一条警告消息。如果设置为 EMAIL，则从action_mail_acct向这个地址发送一封电子邮件，并向/var/log/messages中写一条警告消息。如果设置为 SUSPEND，则不再向审计日志文件中写警告消息。如果设置为SINGLE，则系统将在单用户模式下。如果设置为SALT，则系统会关闭</p>
</blockquote>
</li>
<li><p>action_mail_acct<br></p>
<blockquote>
<p>负责维护审计守护进程和日志的管理员的电子邮件地址。如果地址没有主机名，则假定主机名为本地地址，比如root。必须安装sendmail并配置为向指定电子邮件地址发送电子邮件</p>
</blockquote>
</li>
<li><p>admin_space_left<br></p>
<blockquote>
<p>以兆字节表示的磁盘空间数量。用这个选项设置比space_left_action更多的主动性动作，以防万一space_left_action没有让 管理员释放任何磁盘空间。这个值应小于space_left_action。如果达到这个水平，则会采取admin_space_left_ action所指定的动作</p>
</blockquote>
</li>
<li><p>admin_space_left_action<br></p>
<blockquote>
<p>当自由磁盘空间量达到admin_space_left指定的值时，则采取动作。有效值为IGNORE、SYSLOG、EMAIL、SUSPEND、SINGLE和HALT。与这些值关联的动作与space_left_action中的相同</p>
</blockquote>
</li>
<li><p>disk_full_action<br></p>
<blockquote>
<p>如果含有这个审计文件的分区已满，则采取这个动作。可能值为IGNORE、SYSLOG、SUSPEND、SINGLE和HALT。与这些值关联的动作与space_left _action中的相同。<br><br>提示：如果不循环审计日志文件，则含有/var/log/audit/的分区可能变满并引起系统错误。因此，建议让/var/log/audit/位于一个单独的专用分区</p>
</blockquote>
</li>
<li><p>disk_error_action<br></p>
<blockquote>
<p>如果在写审计日志或循环日志文件时检测到错误时采取的动作。值必须是IGNORE、SYSLOG、SUSPEND、SINGLE和HALT之一。与这些值关的动作与space_left_action中的相同。<br></p>
</blockquote>
</li>
</ul>
<h2 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h2><p><a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/security_guide/sec-understanding_audit_log_files">日志文件字段说明</a><br></p>
<blockquote>
<p>type=SYSCALL msg=audit(1557677628.183:175): arch=c000003e syscall=59 success=yes exit=0 a0=c3a2d0 a1=c39d60 a2=c20a00 a3=7fff1f5044e0 items=3 ppid=5886 pid=6624 auid=0 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0 tty=pts1 ses=4 comm=”river.sh” exe=”/usr/bin/bash” key=”TheRiver”<br><br>type=EXECVE msg=audit(1557677628.183:175): argc=2 a0=”/bin/sh” a1=”./river.sh”<br><br>type=CWD msg=audit(1557677628.183:175):  cwd=”/home/river”<br><br>type=PATH msg=audit(1557677628.183:175): item=0 name=”./river.sh” inode=1000168 dev=fd:01 mode=0100755 ouid=0 ogid=0 rdev=00:00 objtype=NORMAL<br><br>type=PATH msg=audit(1557677628.183:175): item=1 name=(null) inode=67111165 dev=fd:01 mode=0100755 ouid=0 ogid=0 rdev=00:00 objtype=NORMAL<br><br>type=PATH msg=audit(1557677628.183:175): item=2 name=(null) inode=146951365 dev=fd:01 mode=0100755 ouid=0 ogid=0 rdev=00:00 objtype=NORMAL<br></p>
</blockquote>
<ul>
<li><code>type=SYSCALL</code>这一行说明了audit的消息类型，audit消息类型可以对照<a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Security_Guide/sec-Audit_Record_Types.html%E7%9A%84%E8%A1%A8%E6%A0%BC%E8%BF%9B%E7%A8%8B%E6%9F%A5%E7%9C%8B%EF%BC%8CSYSCALL%E8%AF%B4%E6%98%8E%E6%AD%A4%E6%AC%A1audit%E8%AE%B0%E5%BD%95%E7%9A%84%E6%98%AF%E4%B8%80%E6%AC%A1%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8Kernel%E7%9A%84%E8%AE%B0%E5%BD%95">https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Security_Guide/sec-Audit_Record_Types.html的表格进程查看，SYSCALL说明此次audit记录的是一次系统调用Kernel的记录</a>    </li>
<li><code>msg=audit(1557677628.183:175)</code>这一行的格式是(time_stamp:ID)，time_stamp是unix时间，可以将其转化为其他时间格式，可以使用站长工具进行转换：<a href="http://tool.chinaz.com/Tools/unixtime.aspx%E3%80%82%E7%9B%B8%E5%90%8C%E7%9A%84audit">http://tool.chinaz.com/Tools/unixtime.aspx。相同的audit</a> event可能会产生多条time_stamp和event ID相同的log<br></li>
<li><code>msg</code>后面跟了很多形式为“name=value”的键值对，这些键值对由kernel或者用户空间的进程产生<br></li>
<li><code>arch=c000003e</code>标明CPU的类型，c000003e对应x86_64，使用ausearch查看audit日志时会自动将其解码</li>
<li><code>syscall=59</code>指出了发送给kernel的系统调用的类型，可以使用ausyscall –dump来显示所有的syscall的说明<br></li>
<li><code>succeed=yes/no</code>，说明此次syscall成功或失败<br></li>
<li><code>exit=0</code>说明syscall的返回值是0<br></li>
<li><code>a0，a1，a2，a3</code>指明了前4个参数，也是编码成16进制，通过ausearch命令可以解码查看<br></li>
<li><code>items</code>指出event中的path记录的数量<br></li>
<li><code>ppid=5886</code>输入栏记录了父进程ID（PPID）<br></li>
<li><code>pid=6624</code>输入栏记录了进程ID（PID）<br></li>
<li><code>auid=0</code>输入栏记录了审核用户ID，这个是loginuid。这个ID是用户在登录时使用的并且即使当用户身份改变时，也可以通过每个进程获取该ID。（例如，通过切换用户账户，使用su - john命令）<br></li>
<li><code>uid=0</code>指出了对应进程的所有者ID<br></li>
<li><code>gid=0</code>对应进程的group ID<br></li>
<li><code>euid=0</code>对应进程的effective user ID<br></li>
<li><code>suid=0</code>对应set user ID<br></li>
<li><code>fsuid</code>对应file system user ID<br></li>
<li><code>egid=0</code>对应effective group ID<br></li>
<li><code>sgid</code>对应set group ID<br></li>
<li><code>fsgid</code>对应file system group ID<br></li>
<li><code>tty=pts1</code>指出对应进程是在哪个终端启动的<br></li>
<li><code>ses=4</code>指出了对应进程的session ID<br></li>
<li><code>comm=&quot;river.sh&quot;</code>对应了进程执行的命令<br></li>
<li><code>exe=&quot;/usr/bin/bash&quot;</code>指出了进程的执行文件的路径<br></li>
<li><code>key=&quot;TheRiver&quot;</code>是管理员定义的标明是哪条rule输出了这条audit日志<br></li>
<li><code>CWD</code>指出了进程的执行目录（current working directory），cwd字段指出了第一条日志中syscall的执行路径<br></li>
<li><code>第三条日志</code>用来记录所有传递给syscall作为参数的路径，在这个audit事件中，仅有/etc/ssh/sshd_config作为参数进行传递，通过name字段指明<br></li>
<li><code>inode</code>指出了与文件或目录相对应的inode number，可以通过下面的命令查看inode对应的文件或目录:<code>find / -inum [inode number] -print</code> – /home/river/river.sh <br></li>
<li><code>dev=fd:01</code>指出文件或目录对应的device ID<br></li>
<li><code>mode=0100755</code>对应文件或目录的权限:rwxr-xr-x 1 root root<br></li>
<li><code>ouid</code>对应文件的owner’s user ID<br></li>
<li><code>ogid</code>对应文件的owner’s group ID<br></li>
</ul>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p><img src="https://i.loli.net/2019/05/12/5cd6fd5e0e6c3.png"><br><img src="https://i.loli.net/2019/05/12/5cd6fd5e19f06.png"></p>
<pre><code>auditctl加入的规则是临时生效的,想永久生效需要在规则文件中加入,然后重启:service auditd restart</code></pre>
]]></content>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>理解平均负载</title>
    <url>/2019-07-31-%E7%90%86%E8%A7%A3%E5%B9%B3%E5%9D%87%E8%B4%9F%E8%BD%BD/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在极客时间上学习的<a href="https://time.geekbang.org/column/intro/140">Linux性能优化实战</a><br>这里把自己实践的过程记录下，文章会援引很多课程中的资料,详情还是建议点击上面的链接去购买课程</p>
<a id="more"></a>

<h2 id="什么是平均负载"><a href="#什么是平均负载" class="headerlink" title="什么是平均负载"></a>什么是平均负载</h2><p><code>平均负载</code>是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数，它和 CPU 使用率并没有直接关系。<br><br>所谓<code>可运行状态的进程</code>，是指正在使用 CPU 或者正在等待 CPU 的进程，也就是我们常用 ps 命令看到的，处于 R 状态（Running 或 Runnable）的进程。<br><br>而<code>不可中断状态的进程</code>，则是正处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最常见的是等待硬件设备的 I/O 响应，也就是我们在 ps 命令中看到的 D 状态（Uninterruptible Sleep，也称为 Disk Sleep）的进程。<br><br>比如，当一个进程向磁盘读写数据时，为了保证数据的一致性，在得到磁盘回复前，它是不能被其他进程或者中断打断的，这个时候的进程就处于不可中断状态。如果此时的进程被打断了，就容易出现磁盘数据与进程数据不一致的问题。<br>所以，不可中断状态实际上是系统对进程和硬件设备的一种保护机制。</p>
<h2 id="查看平均负载"><a href="#查看平均负载" class="headerlink" title="查看平均负载"></a>查看平均负载</h2><pre><code>[root@localhost /]# uptime
 08:18:23 up  9:10,  2 users,  load average: 0.44, 0.68, 0.86

[root@localhost /]# date
2019年 07月 31日 星期三 08:18:57 CST

[root@localhost /]# who
root     tty1         2019-07-30 23:08
root     pts/0        2019-07-30 23:08 (192.168.1.5)

[root@localhost /]# who -b
系统引导 2019-07-30 23:08</code></pre>
<p>uptime的结果:</p>
<pre><code>08:18:23      //当前时间
up  9:10     //系统运行时间
2 users      //登录用户数
0.44        //过去1分钟的平均负载
0.68        //过去5分钟的平均负载
0.86        //过去15分钟的平均负载</code></pre>
<h2 id="平均负载是否合理"><a href="#平均负载是否合理" class="headerlink" title="平均负载是否合理"></a>平均负载是否合理</h2><p>平均负载可以理解为平均活跃进程数,即平均负载等于CPU个数的时候，是比较理想的,CPU被充分利用.超过CPU个数则负载高</p>
<h3 id="查看CPU个数"><a href="#查看CPU个数" class="headerlink" title="查看CPU个数"></a>查看CPU个数</h3><pre><code>[root@localhost ~]# grep &#39;model name&#39; /proc/cpuinfo | wc -l
1

[root@localhost ~]# grep &#39;model name&#39; /proc/cpuinfo 
model name    : AMD Ryzen 5 2600X Six-Core Processor</code></pre>
<p>网上看的另一种查看的方法:</p>
<pre><code>[root@localhost ~]# cat /proc/cpuinfo 
processor    : 0
vendor_id    : AuthenticAMD
cpu family    : 23
model        : 8
model name    : AMD Ryzen 5 2600X Six-Core Processor
stepping    : 2
microcode    : 0x800820b
cpu MHz        : 3599.994
cache size    : 512 KB
physical id    : 0
siblings    : 1
core id        : 0
cpu cores    : 1
apicid        : 0
initial apicid    : 0
fpu        : yes
fpu_exception    : yes
cpuid level    : 13
wp        : yes
flags        : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 syscall nx mmxext fxsr_opt pdpe1gb rdtscp lm constant_tsc rep_good nopl tsc_reliable nonstop_tsc eagerfpu pni pclmulqdq ssse3 fma cx16 sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx f16c rdrand hypervisor lahf_lm extapic cr8_legacy abm sse4a misalignsse 3dnowprefetch osvw arat xsaveopt fsgsbase bmi1 avx2 smep bmi2 rdseed adx smap
bogomips    : 7199.98
TLB size    : 2560 4K pages
clflush size    : 64
cache_alignment    : 64
address sizes    : 43 bits physical, 48 bits virtual
power management:

其中physical id代表第几个CPU,cpu cores代表CPU的核数.即1个CPU</code></pre>
<p>与实际一致：</p>
<p><img src="https://i.loli.net/2019/07/31/5d41a5d4e39cf62250.png"></p>
<p>根据网上说的,平均负载超出70%就需要重视了,可以排查下导致负载高的原因.</p>
<h2 id="模拟测试"><a href="#模拟测试" class="headerlink" title="模拟测试"></a>模拟测试</h2><p>需要两个2个工具:</p>
<p>安装stress:</p>
<pre><code>yum install -y epel-release
yum install -y stress</code></pre>
<p>第二部安装的时候报错了:</p>
<pre><code>[root@localhost ~]# yum install -y stress
已加载插件：fastestmirror
base                                                                                                   | 3.6 kB  00:00:00     


 One of the configured repositories failed (未知),
 and yum doesn&#39;t have enough cached data to continue. At this point the only
 safe thing yum can do is fail. There are a few ways to work &quot;fix&quot; this:

     1. Contact the upstream for the repository and get them to fix the problem.

     2. Reconfigure the baseurl/etc. for the repository, to point to a working
        upstream. This is most often useful if you are using a newer
        distribution release than is supported by the repository (and the
        packages for the previous distribution release still work).

     3. Disable the repository, so yum won&#39;t use it by default. Yum will then
        just ignore the repository until you permanently enable it again or use
        --enablerepo for temporary usage:

            yum-config-manager --disable &lt;repoid&gt;

     4. Configure the failing repository to be skipped, if it is unavailable.
        Note that yum will try to contact the repo. when it runs most commands,
        so will have to try and fail each time (and thus. yum will be be much
        slower). If it is a very temporary problem though, this is often a nice
        compromise:

            yum-config-manager --save --setopt=&lt;repoid&gt;.skip_if_unavailable=true

Cannot retrieve metalink for repository: epel/x86_64. Please verify its path and try again</code></pre>
<p>网上找了种解决方法:</p>
<pre><code>vim /etc/yum.repos.d/epel.repo
修改,让baseurl生效,注释掉metalink
baseurl=http://download.fedoraproject.org/pub/epel/7/$basearch
#metalink=https://mirrors.fedoraproject.org/metalink?repo=epel-7&amp;arch=$basearch</code></pre>
<p>然后,就可以了:</p>
<pre><code>[root@localhost ~]# stress
`stress&#39; imposes certain types of compute stress on your system

Usage: stress [OPTION [ARG]] ...
 -?, --help         show this help statement        显示帮助信息
     --version      show version statement            显示版本号
 -v, --verbose      be verbose
 -q, --quiet        be quiet                        不显示运行信息
 -n, --dry-run      show what would have been done    显示已完成的指令情况
 -t, --timeout N    timeout after N seconds            指定运行N秒后停止
     --backoff N    wait factor of N microseconds before work starts    等待N微妙后开始运行
 -c, --cpu N        spawn N workers spinning on sqrt()                    产生n个进程 每个进程都反复不停的计算随机数的平方根
 -i, --io N         spawn N workers spinning on sync()                    产生n个进程 每个进程反复调用sync()，sync()用于将内存上的内容写到硬盘上
 -m, --vm N         spawn N workers spinning on malloc()/free()    产生n个进程,每个进程不断调用内存分配malloc和内存释放free函数
     --vm-bytes B   malloc B bytes per vm worker (default is 256MB)    指定malloc时内存的字节数 （默认256MB）
     --vm-stride B  touch a byte every B bytes (default is 4096)    
     --vm-hang N    sleep N secs before free (default none, 0 is inf)    指定在free时的秒数
     --vm-keep      redirty memory instead of freeing and reallocating
 -d, --hdd N        spawn N workers spinning on write()/unlink()
     --hdd-bytes B  write B bytes per hdd worker (default is 1GB)

Example: stress --cpu 8 --io 4 --vm 2 --vm-bytes 128M --timeout 10s

Note: Numbers may be suffixed with s,m,h,d,y (time) or B,K,M,G (size).</code></pre>
<p>安装sysstat:</p>
<pre><code>yum install sysstat</code></pre>
<p>安装完后可以用到这个包的两个命令: mpstat pidstat</p>
<p><code>mpstat</code></p>
<blockquote>
<p>mpstat是Multiprocessor Statistics的缩写，是实时监控工具，报告与cpu的一些统计信息这些信息都存在/proc/stat文件中，在多CPU系统里，其不但能查看所有的CPU的平均状况的信息，而且能够有查看特定的cpu信息，mpstat最大的特点是:可以查看多核心的cpu中每个计算核心的统计数据；而且类似工具vmstat只能查看系统的整体cpu情况。</p>
</blockquote>
<p><a href="https://blog.csdn.net/qq_39591494/article/details/78418162">详解mpstat、iostat、sar、vmstat命令的使用</a></p>
<pre><code>[root@localhost ~]# mpstat
Linux 3.10.0-123.el7.x86_64 (localhost.localdomain)     2019年08月01日     _x86_64_    (1 CPU)

[root@localhost ~]# mpstat --help
用法: mpstat [ 选项 ] [ &lt;时间间隔&gt; [ &lt;次数&gt; ] ]
选项:
[ -A ] [ -u ] [ -V ] [ -I &#123; SUM | CPU | SCPU | ALL &#125; ]
[ -P &#123; &lt;cpu&gt; [,...] | ON | ALL &#125; ]</code></pre>
<p><code>pidstat</code></p>
<blockquote>
<p>pidstat主要用于监控全部或指定进程占用系统资源的情况，如CPU，内存、设备IO、任务切换、线程等。pidstat首次运行时显示自系统启动开始的各项统计信息，之后运行pidstat将显示自上次运行该命令以后的统计信息。用户可以通过指定统计的次数和时间来获得所需的统计信息</p>
</blockquote>
<p><a href="http://www.voidcn.com/article/p-mmlimmar-bpx.html">linux命令—pidstat</a></p>
<pre><code>[root@localhost ~]# pidstat
Linux 3.10.0-123.el7.x86_64 (localhost.localdomain)     2019年08月01日     _x86_64_    (1 CPU)

06时58分02秒   UID       PID    %usr %system  %guest    %CPU   CPU  Command
06时58分02秒     0         1    0.01    0.05    0.00    0.06     0  systemd
06时58分02秒     0         2    0.00    0.00    0.00    0.00     0  kthreadd
06时58分02秒     0         3    0.00    0.00    0.00    0.00     0  ksoftirqd/0
06时58分02秒     0         6    0.00    0.01    0.00    0.01     0  kworker/u256:0
06时58分02秒     0       137    0.00    0.02    0.00    0.02     0  rcu_sched
06时58分02秒     0       138    0.00    0.04    0.00    0.04     0  rcuos/0
06时58分02秒     0       266    0.00    0.00    0.00    0.00     0  watchdog/0
06时58分02秒     0       274    0.00    0.00    0.00    0.00     0  khubd
06时58分02秒     0       280    0.00    0.02    0.00    0.02     0  khugepaged
06时58分02秒     0       292    0.00    0.00    0.00    0.00     0  kworker/u256:1
06时58分02秒     0       812    0.00    0.00    0.00    0.00     0  scsi_eh_0
06时58分02秒     0      2024    0.00    0.01    0.00    0.01     0  kworker/0:1H
06时58分02秒     0      2025    0.00    0.02    0.00    0.02     0  xfsaild/dm-1
06时58分02秒     0      2098    0.00    0.00    0.00    0.00     0  systemd-journal
06时58分02秒     0      2133    0.01    0.00    0.00    0.01     0  systemd-udevd
06时58分02秒     0      3729    0.00    0.00    0.00    0.00     0  auditd
06时58分02秒    81      3762    0.00    0.00    0.00    0.00     0  dbus-daemon
06时58分02秒     0      3763    0.00    0.00    0.00    0.00     0  systemd-logind
06时58分02秒     0      3769    0.00    0.00    0.00    0.00     0  rsyslogd
06时58分02秒    70      3770    0.00    0.00    0.00    0.00     0  avahi-daemon
06时58分02秒     0      3771    0.01    0.01    0.00    0.02     0  tuned
06时58分02秒     0      4633    0.00    0.00    0.00    0.00     0  iprinit
06时58分02秒     0      4635    0.00    0.00    0.00    0.00     0  iprupdate
06时58分02秒     0      5078    0.00    0.00    0.00    0.00     0  login
06时58分02秒     0      5171    0.00    0.00    0.00    0.00     0  master
06时58分02秒     0      5727    0.00    0.01    0.00    0.01     0  sshd
06时58分02秒     0      8944    0.00    0.01    0.00    0.01     0  sshd
06时58分02秒     0      8946    0.00    0.00    0.00    0.00     0  bash
06时58分02秒   999     15236    0.00    0.00    0.00    0.00     0  polkitd
06时58分02秒     0     15644    0.00    0.01    0.00    0.01     0  kworker/0:0
06时58分02秒     0     15901    0.00    0.01    0.00    0.01     0  kworker/0:1
06时58分02秒     0     16170    0.00    0.00    0.00    0.00     0  kworker/0:2
06时58分02秒     0     16346    0.00    0.00    0.00    0.00     0  pidstat</code></pre>
<h2 id="CPU密集型进程-大量使用CPU进程"><a href="#CPU密集型进程-大量使用CPU进程" class="headerlink" title="CPU密集型进程/大量使用CPU进程"></a>CPU密集型进程/大量使用CPU进程</h2><p><code>stress</code>：</p>
<pre><code>[root@localhost ~]# stress -c 1 -t 600
stress: info: [17214] dispatching hogs: 1 cpu, 0 io, 0 vm, 0 hdd</code></pre>
<p><code>uptime</code>：</p>
<pre><code>[root@localhost ~]# uptime
 07:17:32 up  1:05,  6 users,  load average: 1.05, 0.54, 0.42</code></pre>
<p><code>mpstat</code>：</p>
<pre><code>[root@localhost ~]# mpstat -P ALL 5 3
Linux 3.10.0-123.el7.x86_64 (localhost.localdomain)     2019年08月01日     _x86_64_    (1 CPU)

07时16分51秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
07时16分56秒  all   99.40    0.00    0.60    0.00    0.00    0.00    0.00    0.00    0.00    0.00
07时16分56秒    0   99.40    0.00    0.60    0.00    0.00    0.00    0.00    0.00    0.00    0.00

07时16分56秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
07时17分01秒  all   99.60    0.00    0.40    0.00    0.00    0.00    0.00    0.00    0.00    0.00
07时17分01秒    0   99.60    0.00    0.40    0.00    0.00    0.00    0.00    0.00    0.00    0.00

07时17分01秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
07时17分06秒  all   99.20    0.00    0.80    0.00    0.00    0.00    0.00    0.00    0.00    0.00
07时17分06秒    0   99.20    0.00    0.80    0.00    0.00    0.00    0.00    0.00    0.00    0.00

平均时间:  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
平均时间:  all   99.40    0.00    0.60    0.00    0.00    0.00    0.00    0.00    0.00    0.00
平均时间:    0   99.40    0.00    0.60    0.00    0.00    0.00    0.00    0.00    0.00    0.00</code></pre>
<p><code>pidstat</code>：</p>
<pre><code>[root@localhost ~]# pidstat -u 5 3
Linux 3.10.0-123.el7.x86_64 (localhost.localdomain)     2019年08月01日     _x86_64_    (1 CPU)

07时16分54秒   UID       PID    %usr %system  %guest    %CPU   CPU  Command
07时16分59秒     0      2025    0.00    0.20    0.00    0.20     0  xfsaild/dm-1
07时16分59秒     0     16706    0.00    0.20    0.00    0.20     0  sshd
07时16分59秒     0     17215   98.61    0.00    0.00   98.61     0  stress
07时16分59秒     0     17429    0.00    0.20    0.00    0.20     0  top
07时16分59秒     0     17532    0.00    0.20    0.00    0.20     0  pidstat

07时16分59秒   UID       PID    %usr %system  %guest    %CPU   CPU  Command
07时17分04秒     0     17215   99.20    0.00    0.00   99.20     0  stress
07时17分04秒     0     17532    0.00    0.40    0.00    0.40     0  pidstat

07时17分04秒   UID       PID    %usr %system  %guest    %CPU   CPU  Command
07时17分09秒     0         1    0.00    0.20    0.00    0.20     0  systemd
07时17分09秒     0     17215   98.80    0.00    0.00   98.80     0  stress
07时17分09秒     0     17429    0.20    0.20    0.00    0.40     0  top
07时17分09秒     0     17532    0.00    0.20    0.00    0.20     0  pidstat

平均时间:   UID       PID    %usr %system  %guest    %CPU   CPU  Command
平均时间:     0         1    0.00    0.07    0.00    0.07     -  systemd
平均时间:     0      2025    0.00    0.07    0.00    0.07     -  xfsaild/dm-1
平均时间:     0     16706    0.00    0.07    0.00    0.07     -  sshd
平均时间:     0     17215   98.87    0.00    0.00   98.87     -  stress
平均时间:     0     17429    0.07    0.13    0.00    0.20     -  top
平均时间:     0     17532    0.00    0.27    0.00    0.27     -  pidstat</code></pre>
<table>
    <thead align="center">
        <tr>
            <th style="text-align:center">选项</th>
            <th style="text-align:center">说明</th>
        </tr>
    </thead>
    <tbody align="center">
        <tr>
            <td>%usr</td>
            <td>在统计周期内，用户态任务和其子任务耗时统计（ms），包括或者不包括调优时间，注意不包括运行虚拟处理器时间</td>
        </tr>
        <tr>
            <td>%system</td>
            <td>在统计周期内，内核态任务和其子任务耗时统计（ms）</td>
        </tr>
        <tr>
            <td>%guest</td>
            <td>在统计周期内，虚拟态任务和其子任务耗时统计（ms）</td>
        </tr>
    </tbody>
</table>


<p><code>top</code>：</p>
<pre><code>Tasks: 349 total,   3 running, 346 sleeping,   0 stopped,   0 zombie
%Cpu(s):100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem:   3869020 total,   775460 used,  3093560 free,     1232 buffers
KiB Swap:  4079612 total,        0 used,  4079612 free.   563764 cached Mem

   PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                                  
 17215 root      20   0    7260     96      0 R 99.4  0.0   3:17.02 stress                                                   
     1 root      20   0   49904   4180   2472 S  0.0  0.1   0:01.68 systemd</code></pre>
<p>CPU密集型进程:使用大量CPU导致平均负载升高</p>
<h2 id="IO密集型"><a href="#IO密集型" class="headerlink" title="IO密集型"></a>IO密集型</h2><p><code>stress</code></p>
<pre><code>[root@localhost ~]# stress -i 1 --hdd 1 -t 600
stress: info: [23947] dispatching hogs: 0 cpu, 1 io, 0 vm, 1 hdd</code></pre>
<p><code>uptime</code></p>
<pre><code>[root@localhost ~]# uptime
 08:09:24 up  1:57,  9 users,  load average: 2.78, 1.84, 1.80</code></pre>
<p><code>mpstat</code></p>
<pre><code>[root@localhost sysstat-12.1.5]# mpstat -P ALL 5 3
Linux 3.10.0-123.el7.x86_64 (localhost.localdomain)     2019年08月01日     _x86_64_    (1 CPU)

08时07分33秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
08时07分38秒  all    0.21    0.00   35.48   50.83    0.00   13.49    0.00    0.00    0.00    0.00
08时07分38秒    0    0.21    0.00   35.48   50.83    0.00   13.49    0.00    0.00    0.00    0.00

08时07分38秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
08时07分43秒  all    0.21    0.00   25.51   61.73    0.00   12.55    0.00    0.00    0.00    0.00
08时07分43秒    0    0.21    0.00   25.51   61.73    0.00   12.55    0.00    0.00    0.00    0.00

08时07分43秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
08时07分48秒  all    0.21    0.00   25.47   68.63    0.00    5.68    0.00    0.00    0.00    0.00
08时07分48秒    0    0.21    0.00   25.47   68.63    0.00    5.68    0.00    0.00    0.00    0.00

平均时间:  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
平均时间:  all    0.21    0.00   28.83   60.36    0.00   10.60    0.00    0.00    0.00    0.00
平均时间:    0    0.21    0.00   28.83   60.36    0.00   10.60    0.00    0.00    0.00    0.00</code></pre>
<p><code>pidstat</code></p>
<pre><code>[root@localhost wang]# pidstat -u 5 3
Linux 3.10.0-123.el7.x86_64 (localhost.localdomain)     2019年08月01日     _x86_64_    (1 CPU)

08时07分35秒   UID       PID    %usr %system  %guest    %CPU   CPU  Command
08时07分40秒     0         3    0.00    0.83    0.00    0.83     0  ksoftirqd/0
08时07分40秒     0       137    0.00    0.21    0.00    0.21     0  rcu_sched
08时07分40秒     0      2024    0.00    0.21    0.00    0.21     0  kworker/0:1H
08时07分40秒     0     23777    0.00    0.21    0.00    0.21     0  kworker/0:1
08时07分40秒     0     23805    0.00    0.41    0.00    0.41     0  kworker/0:3
08时07分40秒     0     23807    0.00   11.41    0.00   11.41     0  kworker/u256:2
08时07分40秒     0     23942    0.21    0.21    0.00    0.41     0  top
08时07分40秒     0     23948    0.00    2.49    0.00    2.49     0  stress
08时07分40秒     0     23949    0.00   25.73    0.00   25.73     0  stress
08时07分40秒     0     24011    0.00    0.41    0.00    0.41     0  pidstat

08时07分40秒   UID       PID    %usr %system  %guest    %CPU   CPU  Command
08时07分45秒     0         3    0.00    0.61    0.00    0.61     0  ksoftirqd/0
08时07分45秒     0       266    0.00    0.20    0.00    0.20     0  watchdog/0
08时07分45秒     0     23777    0.00    0.61    0.00    0.61     0  kworker/0:1
08时07分45秒     0     23805    0.00    0.41    0.00    0.41     0  kworker/0:3
08时07分45秒     0     23806    0.00    0.82    0.00    0.82     0  kworker/0:4
08时07分45秒     0     23807    0.00   15.95    0.00   15.95     0  kworker/u256:2
08时07分45秒     0     23942    0.61    0.82    0.00    1.43     0  top
08时07分45秒     0     23948    0.00    6.13    0.00    6.13     0  stress
08时07分45秒     0     23949    0.00   36.40    0.00   36.40     0  stress
08时07分45秒     0     24011    0.20    0.20    0.00    0.41     0  pidstat

08时07分45秒   UID       PID    %usr %system  %guest    %CPU   CPU  Command
08时07分50秒     0         3    0.00    0.21    0.00    0.21     0  ksoftirqd/0
08时07分50秒     0       138    0.00    0.21    0.00    0.21     0  rcuos/0
08时07分50秒     0     23806    0.00    0.42    0.00    0.42     0  kworker/0:4
08时07分50秒     0     23807    0.00    1.49    0.00    1.49     0  kworker/u256:2
08时07分50秒     0     23942    0.21    0.00    0.00    0.21     0  top
08时07分50秒     0     23948    0.00    0.21    0.00    0.21     0  stress
08时07分50秒     0     23949    0.00    4.67    0.00    4.67     0  stress
08时07分50秒     0     23955    0.21    0.00    0.00    0.21     0  watch
08时07分50秒     0     24011    0.00    0.21    0.00    0.21     0  pidstat

平均时间:   UID       PID    %usr %system  %guest    %CPU   CPU  Command
平均时间:     0         3    0.00    0.55    0.00    0.55     -  ksoftirqd/0
平均时间:     0       137    0.00    0.07    0.00    0.07     -  rcu_sched
平均时间:     0       138    0.00    0.07    0.00    0.07     -  rcuos/0
平均时间:     0       266    0.00    0.07    0.00    0.07     -  watchdog/0
平均时间:     0      2024    0.00    0.07    0.00    0.07     -  kworker/0:1H
平均时间:     0     23777    0.00    0.28    0.00    0.28     -  kworker/0:1
平均时间:     0     23805    0.00    0.28    0.00    0.28     -  kworker/0:3
平均时间:     0     23806    0.00    0.42    0.00    0.42     -  kworker/0:4
平均时间:     0     23807    0.00    9.71    0.00    9.71     -  kworker/u256:2
平均时间:     0     23942    0.35    0.35    0.00    0.69     -  top
平均时间:     0     23948    0.00    2.98    0.00    2.98     -  stress
平均时间:     0     23949    0.00   22.47    0.00   22.47     -  stress
平均时间:     0     23955    0.07    0.00    0.00    0.07     -  watch
平均时间:     0     24011    0.07    0.28    0.00    0.35     -  pidstat

[root@localhost wang]# pidstat -d 5 3
Linux 3.10.0-123.el7.x86_64 (localhost.localdomain)     2019年08月01日     _x86_64_    (1 CPU)

08时08分32秒   UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s  Command
08时08分37秒     0     23948      0.00      0.00  33647.20  stress
08时08分37秒     0     23949      0.00 838860.80 150474.40  stress

08时08分37秒   UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s  Command
08时08分42秒     0       292      0.00   6036.21      0.00  kworker/u256:1
08时08分42秒     0     23949      0.00 441505.68 236369.68  stress

08时08分42秒   UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s  Command
08时08分47秒     0       292      0.00  34784.07      0.00  kworker/u256:1
08时08分47秒     0     23948      0.00      0.00  60896.44  stress
08时08分47秒     0     23949      0.00 439654.51 112327.88  stress

平均时间:   UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s  Command
平均时间:     0       292      0.00  13401.65      0.00  kworker/u256:1
平均时间:     0     23948      0.00      0.00  31591.74  stress
平均时间:     0     23949      0.00 577727.82 166042.15  stress</code></pre>
<p><code>top</code></p>
<pre><code>[root@localhost ~]# top
top - 08:09:12 up  1:57,  9 users,  load average: 2.74, 1.80, 1.79
Tasks: 361 total,   2 running, 359 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.3 us, 28.2 sy,  0.0 ni,  0.0 id, 59.9 wa,  0.0 hi, 11.5 si,  0.0 st
KiB Mem:   3869020 total,  1910484 used,  1958536 free,     1232 buffers
KiB Swap:  4079612 total,        0 used,  4079612 free.  1653112 cached Mem

   PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                                  
 23949 root      20   0    8164   1124     32 D 21.6  0.0   0:35.57 stress                                                   
   292 root      20   0       0      0      0 D  9.6  0.0   0:10.20 kworker/u256:1      </code></pre>
<p>以上大量IO导致平均负载升高，cpu占用并不高</p>
<h2 id="大量等待CPU的进程"><a href="#大量等待CPU的进程" class="headerlink" title="大量等待CPU的进程"></a>大量等待CPU的进程</h2><p><code>stress</code></p>
<pre><code>[root@localhost ~]# stress -c 8 -t 600
stress: info: [24363] dispatching hogs: 8 cpu, 0 io, 0 vm, 0 hdd</code></pre>
<p><code>uptime</code></p>
<pre><code>[root@localhost ~]# uptime
 08:15:23 up  2:03,  9 users,  load average: 7.63, 4.09, 2.59</code></pre>
<p><code>mpstat</code></p>
<pre><code>[root@localhost sysstat-12.1.5]# mpstat -P ALL 5 3
Linux 3.10.0-123.el7.x86_64 (localhost.localdomain)     2019年08月01日     _x86_64_    (1 CPU)

08时15分27秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
08时15分32秒  all   99.80    0.00    0.20    0.00    0.00    0.00    0.00    0.00    0.00    0.00
08时15分32秒    0   99.80    0.00    0.20    0.00    0.00    0.00    0.00    0.00    0.00    0.00

08时15分32秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
08时15分37秒  all   99.40    0.00    0.60    0.00    0.00    0.00    0.00    0.00    0.00    0.00
08时15分37秒    0   99.40    0.00    0.60    0.00    0.00    0.00    0.00    0.00    0.00    0.00

08时15分37秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
08时15分42秒  all   99.60    0.00    0.40    0.00    0.00    0.00    0.00    0.00    0.00    0.00
08时15分42秒    0   99.60    0.00    0.40    0.00    0.00    0.00    0.00    0.00    0.00    0.00

平均时间:  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
平均时间:  all   99.60    0.00    0.40    0.00    0.00    0.00    0.00    0.00    0.00    0.00
平均时间:    0   99.60    0.00    0.40    0.00    0.00    0.00    0.00    0.00    0.00    0.00</code></pre>
<p><code>pidstat</code></p>
<pre><code>wait值为0，明天再定位
-c 40，wait也是0,不知道什么原因.cpu性能太好?先不管了,以后再说.</code></pre>
<p><code>top</code></p>
<pre><code>[root@localhost ~]# top
top - 08:21:56 up  2:10,  4 users,  load average: 7.72, 5.76, 3.78
Tasks: 355 total,  10 running, 345 sleeping,   0 stopped,   0 zombie
%Cpu(s):100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem:   3869020 total,   820136 used,  3048884 free,     1232 buffers
KiB Swap:  4079612 total,        0 used,  4079612 free.   604588 cached Mem

   PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                                  
 25022 root      20   0    7260     92      0 R 12.6  0.0   0:19.44 stress                                                   
 25023 root      20   0    7260     92      0 R 12.6  0.0   0:19.44 stress                                                   
 25024 root      20   0    7260     92      0 R 12.6  0.0   0:19.44 stress                                                   
 25025 root      20   0    7260     92      0 R 12.6  0.0   0:19.44 stress                                                   
 25026 root      20   0    7260     92      0 R 12.6  0.0   0:19.44 stress                                                   
 25020 root      20   0    7260     92      0 R 12.3  0.0   0:19.43 stress                                                   
 25021 root      20   0    7260     92      0 R 12.3  0.0   0:19.43 stress                                                   
 25027 root      20   0    7260     92      0 R 12.3  0.0   0:19.43 stress   </code></pre>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li>pidstat不显示%wait</li>
</ul>
<p>安装新版本的sysstat:<a href="http://sebastien.godard.pagesperso-orange.fr/download.html">下载地址</a></p>
<ul>
<li>iowait无法升高</li>
</ul>
<p>stress -i 时刷新内存缓冲区数据到磁盘,新装的虚拟机缓冲区比较小,没有那么大的压力.只是系统调用导致的cpu升高<br><br>可以用stress -i 1 –hdd 1 -t 600 //–hdd表示读写临时文件</p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2019/08/03/SpsqcOVwnW8dxUN.jpg"></p>
]]></content>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx源码分析-内存池</title>
    <url>/2019-12-16-nginx%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%86%85%E5%AD%98%E6%B1%A0/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://bbs.chinaunix.net/thread-3626006-1-1.html">Nginx源代码情景分析（3）——Nginx内存管理-1</a> <br><br><a href="https://blog.csdn.net/v_JULY_v/article/details/7040425">Nginx源码剖析之内存池，与内存管理</a> <br><br><a href="https://github.com/chronolaw/annotated_nginx/blob/master/nginx/src/core/ngx_palloc.c">chronolaw/annotated_nginx</a> <br></p>
<hr>
<a id="more"></a>

<p><img src="https://i.loli.net/2019/12/16/asGF4HLkCPv7yzZ.jpg" alt="nginx_pool_t.jpg"></p>
<hr>
<h3 id="ngx-pool-t"><a href="#ngx-pool-t" class="headerlink" title="ngx_pool_t"></a><code>ngx_pool_t</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 内存池链表结构体 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span>            <span class="title">ngx_pool_t</span>;</span>	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> &#123;</span></span><br><span class="line">	<span class="keyword">ngx_pool_data_t</span>       d;</span><br><span class="line">	<span class="keyword">size_t</span>                max;</span><br><span class="line">	<span class="keyword">ngx_pool_t</span>           *current;</span><br><span class="line">	<span class="keyword">ngx_chain_t</span>          *chain;</span><br><span class="line">	<span class="keyword">ngx_pool_large_t</span>     *large;</span><br><span class="line">	<span class="keyword">ngx_pool_cleanup_t</span>   *cleanup;</span><br><span class="line">	<span class="keyword">ngx_log_t</span>            *<span class="built_in">log</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 小块内存的数据区结构体 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    u_char               *last;</span><br><span class="line">    u_char               *end;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>           *next;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            failed;</span><br><span class="line">&#125; <span class="keyword">ngx_pool_data_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 大块内存的链表结构体 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_large_s</span>  <span class="title">ngx_pool_large_t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_large_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>     *next;</span><br><span class="line">    <span class="keyword">void</span>                 *alloc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="ngx-create-pool"><a href="#ngx-create-pool" class="headerlink" title="ngx_create_pool"></a><code>ngx_create_pool</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//创建ngx_pool_t内存链表的函数</span></span><br><span class="line"><span class="keyword">ngx_pool_t</span> *</span><br><span class="line">ngx_create_pool(<span class="keyword">size_t</span> size, <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>  *p;</span><br><span class="line"></span><br><span class="line">    p = ngx_memalign(NGX_POOL_ALIGNMENT, size, <span class="built_in">log</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p-&gt;d.last = (u_char *) p + <span class="keyword">sizeof</span>(<span class="keyword">ngx_pool_t</span>);</span><br><span class="line">    p-&gt;d.end = (u_char *) p + size;</span><br><span class="line">    p-&gt;d.next = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    size = size - <span class="keyword">sizeof</span>(<span class="keyword">ngx_pool_t</span>);</span><br><span class="line">	<span class="comment">//内存页大小，4096字节</span></span><br><span class="line">    p-&gt;max = (size &lt; NGX_MAX_ALLOC_FROM_POOL) ? size : NGX_MAX_ALLOC_FROM_POOL;</span><br><span class="line"></span><br><span class="line">    p-&gt;current = p;</span><br><span class="line">    p-&gt;chain = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;large = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;cleanup = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;<span class="built_in">log</span> = <span class="built_in">log</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在main函数中 </span></span><br><span class="line"><span class="keyword">ngx_cycle_t</span>      *cycle, init_cycle;</span><br><span class="line">init_cycle.pool = ngx_create_pool(<span class="number">1024</span>, <span class="built_in">log</span>)</span><br><span class="line"><span class="comment">//进程启动阶段init_cycle中保存了最早申请的内存池,这时候ngx_poll_t中的date的last的值应该还是没有申请后未使用的.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ngx_memalign函数用于申请小块内存,内部也是调用memalign,具体见下面对此函数的解释</span></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">ngx_memalign(<span class="keyword">size_t</span> alignment, <span class="keyword">size_t</span> size, <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span>  *p;</span><br><span class="line"></span><br><span class="line">    p = memalign(alignment, size);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ngx_log_error(NGX_LOG_EMERG, <span class="built_in">log</span>, ngx_errno,</span><br><span class="line">                      <span class="string">&quot;memalign(%uz, %uz) failed&quot;</span>, alignment, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngx_log_debug3(NGX_LOG_DEBUG_ALLOC, <span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                   <span class="string">&quot;memalign: %p:%uz @%uz&quot;</span>, p, size, alignment);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">init_cycle.pool = (<span class="keyword">ngx_pool_t</span> *) <span class="number">0x6d2420</span></span><br><span class="line">init_cycle.pool.d = &#123;last = <span class="number">0x6d2470</span> <span class="string">&quot;&quot;</span>, end = <span class="number">0x6d2820</span> <span class="string">&quot;&quot;</span>, next = <span class="number">0x0</span>, failed = <span class="number">0</span>&#125;</span><br><span class="line">init_cycle.pool = </span><br><span class="line">		&#123;	d = &#123;last = <span class="number">0x6d2470</span> <span class="string">&quot;&quot;</span>, end = <span class="number">0x6d2820</span> <span class="string">&quot;&quot;</span>, next = <span class="number">0x0</span>, failed = <span class="number">0</span>&#125;, </span><br><span class="line">			max = <span class="number">944</span>, </span><br><span class="line">  			current = <span class="number">0x6d2420</span>, </span><br><span class="line">			chain = <span class="number">0x0</span>, </span><br><span class="line">			large = <span class="number">0x0</span>, </span><br><span class="line">			cleanup = <span class="number">0x0</span>, </span><br><span class="line">			<span class="built_in">log</span> = <span class="number">0x6afe60</span> &lt;ngx_log&gt;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">last - pool = <span class="number">80</span> = <span class="keyword">sizeof</span>(<span class="keyword">ngx_pool_t</span>)</span><br><span class="line">end - pool = <span class="number">1024</span> = size  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>和ngx_create_pool函数是一致的，end指向pool+size的位置，而ngx_pool_t这80个字节是1024的前80字节，也是堆中的内存。所以实际可用的内存只有1024-80 = 944 = max。</p>
<hr>
<h3 id="memalign"><a href="#memalign" class="headerlink" title="memalign"></a><code>memalign</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memalign</span><span class="params">(<span class="keyword">size_t</span> alignment, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>The memalign() function returns a block of memory of size bytes aligned to blocksize. The blocksize must be given as a power of two. It sets errno and returns a null pointer upon failure.</p>
</blockquote>
<blockquote>
<p>函数 memalign返回按alignment个字节对齐的内存。alignment必须是2的幂。</p>
</blockquote>
<blockquote>
<p>Pointers returned by memalign() may be passed to free(). Pointers passed to realloc() are checked and if not aligned to the system, the realloc() fails and returns NULL.</p>
</blockquote>
<hr>
<h3 id="ngx-destroy-pool"><a href="#ngx-destroy-pool" class="headerlink" title="ngx_destroy_pool"></a><code>ngx_destroy_pool</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_free          free</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类似c++的析构函数，这里要释放小块，大块内存，还有自定义的&quot;文件&quot;</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">ngx_destroy_pool(<span class="keyword">ngx_pool_t</span> *pool)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>          *p, *n;</span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>    *l;</span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>  *c;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放自定义的内存，可能是文件或者套接字之类的</span></span><br><span class="line">	<span class="comment">//handle是需要自定义实现的释放函数</span></span><br><span class="line">    <span class="keyword">for</span> (c = pool-&gt;cleanup; c; c = c-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;handler) &#123;</span><br><span class="line">            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                           <span class="string">&quot;run cleanup: %p&quot;</span>, c);</span><br><span class="line">            c-&gt;handler(c-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (NGX_DEBUG)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * we could allocate the pool-&gt;log from this pool</span></span><br><span class="line"><span class="comment">     * so we cannot use this log while free()ing the pool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>, <span class="string">&quot;free: %p&quot;</span>, l-&gt;alloc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p = pool, n = pool-&gt;d.next; <span class="comment">/* void */</span>; p = n, n = n-&gt;d.next) &#123;</span><br><span class="line">        ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                       <span class="string">&quot;free: %p, unused: %uz&quot;</span>, p, p-&gt;d.end - p-&gt;d.last);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放大块内存</span></span><br><span class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l-&gt;alloc) &#123;</span><br><span class="line">            ngx_free(l-&gt;alloc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//先释放大块内存的数据库，然后释放pool，意味着既释放了小块内存的数据区，又把结构体本身释放掉了.</span></span><br><span class="line">	<span class="comment">//释放小块内存</span></span><br><span class="line">    <span class="keyword">for</span> (p = pool, n = pool-&gt;d.next; <span class="comment">/* void */</span>; p = n, n = n-&gt;d.next) &#123;</span><br><span class="line">		<span class="comment">//申请的时候malloc的返回值就是p,申请的1024个字节在这里就都释放了</span></span><br><span class="line">        ngx_free(p);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="ngx-reset-pool"><a href="#ngx-reset-pool" class="headerlink" title="ngx_reset_pool"></a><code>ngx_reset_pool</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//重置内存池，恢复到创建的初始阶段</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">ngx_reset_pool(<span class="keyword">ngx_pool_t</span> *pool)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>        *p;</span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>  *l;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除大块内存</span></span><br><span class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l-&gt;alloc) &#123;</span><br><span class="line">            ngx_free(l-&gt;alloc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//置last为create时的位置，即小块内存数据区的起始位置</span></span><br><span class="line">    <span class="keyword">for</span> (p = pool; p; p = p-&gt;d.next) &#123;</span><br><span class="line">        p-&gt;d.last = (u_char *) p + <span class="keyword">sizeof</span>(<span class="keyword">ngx_pool_t</span>);</span><br><span class="line">        p-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pool-&gt;current = pool;</span><br><span class="line">    pool-&gt;chain = <span class="literal">NULL</span>;</span><br><span class="line">    pool-&gt;large = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="ngx-palloc-ngx-pnalloc"><a href="#ngx-palloc-ngx-pnalloc" class="headerlink" title="ngx_palloc/ngx_pnalloc"></a><code>ngx_palloc/ngx_pnalloc</code></h3><pre><code>ngx_palloc         按照字节对齐 
ngx_pnalloc     不按照字节对齐
即ngx_palloc_small的第三个参数不同，大块内存都是不考虑对齐的</code></pre>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 如果编译时指定宏NGX_DEBUG_PALLOC</span></span><br><span class="line"><span class="comment">// 则不会启用内存池机制，都使用malloc分配内存</span></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">ngx_palloc(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果小块内存够用就申请小块内存,否则申请大块内存</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !(NGX_DEBUG_PALLOC)</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= pool-&gt;max) &#123;</span><br><span class="line">        <span class="keyword">return</span> ngx_palloc_small(pool, size, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ngx_palloc_large(pool, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">ngx_pnalloc(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !(NGX_DEBUG_PALLOC)</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= pool-&gt;max) &#123;</span><br><span class="line">        <span class="keyword">return</span> ngx_palloc_small(pool, size, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ngx_palloc_large(pool, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="ngx-pcalloc"><a href="#ngx-pcalloc" class="headerlink" title="ngx_pcalloc"></a><code>ngx_pcalloc</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//申请内存并初始化,类似cmalloc </span></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">ngx_pcalloc(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> *p;</span><br><span class="line"></span><br><span class="line">    p = ngx_palloc(pool, size);</span><br><span class="line">    <span class="keyword">if</span> (p) &#123;</span><br><span class="line">        ngx_memzero(p, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="ngx-palloc-small"><a href="#ngx-palloc-small" class="headerlink" title="ngx_palloc_small"></a><code>ngx_palloc_small</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> ngx_inline <span class="keyword">void</span> *<span class="title">ngx_palloc_small</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size, <span class="keyword">ngx_uint_t</span> align)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">static</span> ngx_inline <span class="keyword">void</span> *</span><br><span class="line">ngx_palloc_small(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size, <span class="keyword">ngx_uint_t</span> align)</span><br><span class="line">&#123;</span><br><span class="line">    u_char      *m;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>  *p;</span><br><span class="line"></span><br><span class="line">    p = pool-&gt;current;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        m = p-&gt;d.last;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//后面补充</span></span><br><span class="line">        <span class="keyword">if</span> (align) &#123;</span><br><span class="line">            m = ngx_align_ptr(m, NGX_ALIGNMENT);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//遍历链表找到空闲区域</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">size_t</span>) (p-&gt;d.end - m) &gt;= size) &#123;</span><br><span class="line">            p-&gt;d.last = m + size;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p = p-&gt;d.next;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ngx_palloc_block(pool, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="ngx-align-ptr"><a href="#ngx-align-ptr" class="headerlink" title="ngx_align_ptr"></a><code>ngx_align_ptr</code></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_align(d, a)     (((d) + (a - 1)) &amp; ~(a - 1))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_align_ptr(p, a)                                                   \</span></span><br><span class="line">    (u_char *) (((<span class="keyword">uintptr_t</span>) (p) + ((<span class="keyword">uintptr_t</span>) a - <span class="number">1</span>)) &amp; ~((<span class="keyword">uintptr_t</span>) a - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//ngx_config.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">intptr_t</span>        <span class="keyword">ngx_int_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uintptr_t</span>       <span class="keyword">ngx_uint_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面intptr_t，uintptr_t的定义在linux系统的文件/usr/include/stdint.h</span></span><br><span class="line"><span class="comment">/* Types for `void *&#x27; pointers.  */</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line">	<span class="meta"># <span class="meta-keyword">ifndef</span> __intptr_t_defined</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">int</span>                <span class="keyword">intptr_t</span>;</span><br><span class="line">	<span class="meta">#  <span class="meta-keyword">define</span> __intptr_t_defined</span></span><br><span class="line">	<span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>       <span class="keyword">uintptr_t</span>;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="meta"># <span class="meta-keyword">ifndef</span> __intptr_t_defined</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">int</span>                     <span class="keyword">intptr_t</span>;</span><br><span class="line">	<span class="meta">#  <span class="meta-keyword">define</span> __intptr_t_defined</span></span><br><span class="line">	<span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>            <span class="keyword">uintptr_t</span>;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">64位系统下uintptr_t是unsigned long in</span></span><br><span class="line"><span class="comment">32位系统下uintptr_t是unsinged int</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">再看(((d) + (a - 1)) &amp; ~(a - 1))这个表达式</span></span><br><span class="line"><span class="comment">a是2的幂(memalign返回按alignment个字节对齐的内存。alignment必须是2的幂),所以(a-1)就是二进制位右边为1，左边原来1的那位为0，再取反，然后按位与，就是把a原来右边为0的位清除掉了。保留d在a原来1的那位左边的，并且保证了这个值最小是a。所以肯定是a的倍数.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="ngx-palloc-large"><a href="#ngx-palloc-large" class="headerlink" title="ngx_palloc_large"></a><code>ngx_palloc_large</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">ngx_palloc_large</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">ngx_palloc_large(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span>              *p;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>         n;</span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>  *large;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//大块内存直接malloc</span></span><br><span class="line">    p = ngx_alloc(size, pool-&gt;<span class="built_in">log</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将malloc的地址存于大块内存链表	</span></span><br><span class="line">    <span class="keyword">for</span> (large = pool-&gt;large; large; large = large-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (large-&gt;alloc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            large-&gt;alloc = p;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//超过三次放弃，避免便利链表效率太低</span></span><br><span class="line">	<span class="comment">//3可能是作者的经验值吧</span></span><br><span class="line">        <span class="keyword">if</span> (n++ &gt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//找不到就重新申请结构体，加入内存池链表</span></span><br><span class="line">    large = ngx_palloc_small(pool, <span class="keyword">sizeof</span>(<span class="keyword">ngx_pool_large_t</span>), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (large == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ngx_free(p);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//新申请的存于链表头,头插法</span></span><br><span class="line">    large-&gt;alloc = p;</span><br><span class="line">    large-&gt;next = pool-&gt;large;</span><br><span class="line">    pool-&gt;large = large;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="ngx-palloc-block"><a href="#ngx-palloc-block" class="headerlink" title="ngx_palloc_block"></a><code>ngx_palloc_block</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">ngx_palloc_block</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="comment">//注意这个函数是在ngx_palloc_small函数中便利小块内存链表后没有找到空闲链表的情况下调用的，是用来申请新的空间挂接到链表尾的。</span></span><br><span class="line"><span class="comment">//不同于ngx_create_pool函数，本函数申请小块内存后last指向要+size大小</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">ngx_palloc_block(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    u_char      *m;</span><br><span class="line">    <span class="keyword">size_t</span>       psize;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>  *p, *<span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">    psize = (<span class="keyword">size_t</span>) (pool-&gt;d.end - (u_char *) pool);</span><br><span class="line"></span><br><span class="line">    m = ngx_memalign(NGX_POOL_ALIGNMENT, psize, pool-&gt;<span class="built_in">log</span>);</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> = (<span class="keyword">ngx_pool_t</span> *) m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span>-&gt;d.end = m + psize;</span><br><span class="line">    <span class="keyword">new</span>-&gt;d.next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">new</span>-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    m += <span class="keyword">sizeof</span>(<span class="keyword">ngx_pool_data_t</span>);</span><br><span class="line">    m = ngx_align_ptr(m, NGX_ALIGNMENT);</span><br><span class="line">    <span class="keyword">new</span>-&gt;d.last = m + size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//因为之前create函数已经遍历过没有找到，所以这里给failed+1</span></span><br><span class="line">	<span class="comment">//这里应该也是经验值吧，达到5次这里把pool-&gt;current更新为p-&gt;d.next</span></span><br><span class="line">    <span class="keyword">for</span> (p = pool-&gt;current; p-&gt;d.next; p = p-&gt;d.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;d.failed++ &gt; <span class="number">4</span>) &#123;</span><br><span class="line">            pool-&gt;current = p-&gt;d.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//新申请的内存挂到链表尾部，尾插法(和大块内存不同)</span></span><br><span class="line">    p-&gt;d.next = <span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="ngx-pmemalign"><a href="#ngx-pmemalign" class="headerlink" title="ngx_pmemalign"></a><code>ngx_pmemalign</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//申请大块内存，并且字节对齐</span></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">ngx_pmemalign(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> alignment)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span>              *p;</span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>  *large;</span><br><span class="line"></span><br><span class="line">    p = ngx_memalign(alignment, size, pool-&gt;<span class="built_in">log</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    large = ngx_palloc_small(pool, <span class="keyword">sizeof</span>(<span class="keyword">ngx_pool_large_t</span>), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (large == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ngx_free(p);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    large-&gt;alloc = p;</span><br><span class="line">    large-&gt;next = pool-&gt;large;</span><br><span class="line">    pool-&gt;large = large;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="ngx-pfree"><a href="#ngx-pfree" class="headerlink" title="ngx_pfree"></a><code>ngx_pfree</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//释放指定的大块内存</span></span><br><span class="line"><span class="keyword">ngx_int_t</span></span><br><span class="line">ngx_pfree(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">void</span> *p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>  *l;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == l-&gt;alloc) &#123;</span><br><span class="line">            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                           <span class="string">&quot;free: %p&quot;</span>, l-&gt;alloc);</span><br><span class="line">            ngx_free(l-&gt;alloc);</span><br><span class="line">            l-&gt;alloc = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> NGX_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NGX_DECLINED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="ngx-pool-cleanup-add"><a href="#ngx-pool-cleanup-add" class="headerlink" title="ngx_pool_cleanup_add"></a><code>ngx_pool_cleanup_add</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">ngx_pool_cleanup_t</span> *</span><br><span class="line">ngx_pool_cleanup_add(<span class="keyword">ngx_pool_t</span> *p, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>  *c;</span><br><span class="line"></span><br><span class="line">    c = ngx_palloc(p, <span class="keyword">sizeof</span>(<span class="keyword">ngx_pool_cleanup_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size) &#123;</span><br><span class="line">        c-&gt;data = ngx_palloc(p, size);</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        c-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c-&gt;handler = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;next = p-&gt;cleanup;</span><br><span class="line"></span><br><span class="line">    p-&gt;cleanup = c;</span><br><span class="line"></span><br><span class="line">    ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, p-&gt;<span class="built_in">log</span>, <span class="number">0</span>, <span class="string">&quot;add cleanup: %p&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="ngx-pool-run-cleanup-file"><a href="#ngx-pool-run-cleanup-file" class="headerlink" title="ngx_pool_run_cleanup_file"></a><code>ngx_pool_run_cleanup_file</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">ngx_pool_run_cleanup_file(<span class="keyword">ngx_pool_t</span> *p, <span class="keyword">ngx_fd_t</span> fd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>       *c;</span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_file_t</span>  *cf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (c = p-&gt;cleanup; c; c = c-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;handler == ngx_pool_cleanup_file) &#123;</span><br><span class="line"></span><br><span class="line">            cf = c-&gt;data;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cf-&gt;fd == fd) &#123;</span><br><span class="line">                c-&gt;handler(cf);</span><br><span class="line">                c-&gt;handler = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="ngx-pool-cleanup-file"><a href="#ngx-pool-cleanup-file" class="headerlink" title="ngx_pool_cleanup_file"></a><code>ngx_pool_cleanup_file</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">ngx_pool_cleanup_file(<span class="keyword">void</span> *data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_file_t</span>  *c = data;</span><br><span class="line"></span><br><span class="line">    ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, c-&gt;<span class="built_in">log</span>, <span class="number">0</span>, <span class="string">&quot;file cleanup: fd:%d&quot;</span>,</span><br><span class="line">                   c-&gt;fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ngx_close_file(c-&gt;fd) == NGX_FILE_ERROR) &#123;</span><br><span class="line">        ngx_log_error(NGX_LOG_ALERT, c-&gt;<span class="built_in">log</span>, ngx_errno,</span><br><span class="line">                      ngx_close_file_n <span class="string">&quot; \&quot;%s\&quot; failed&quot;</span>, c-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="ngx-pool-delete-file"><a href="#ngx-pool-delete-file" class="headerlink" title="ngx_pool_delete_file"></a><code>ngx_pool_delete_file</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">ngx_pool_delete_file(<span class="keyword">void</span> *data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_file_t</span>  *c = data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_err_t</span>  err;</span><br><span class="line"></span><br><span class="line">    ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, c-&gt;<span class="built_in">log</span>, <span class="number">0</span>, <span class="string">&quot;file cleanup: fd:%d %s&quot;</span>,</span><br><span class="line">                   c-&gt;fd, c-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ngx_delete_file(c-&gt;name) == NGX_FILE_ERROR) &#123;</span><br><span class="line">        err = ngx_errno;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err != NGX_ENOENT) &#123;</span><br><span class="line">            ngx_log_error(NGX_LOG_CRIT, c-&gt;<span class="built_in">log</span>, err,</span><br><span class="line">                          ngx_delete_file_n <span class="string">&quot; \&quot;%s\&quot; failed&quot;</span>, c-&gt;name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ngx_close_file(c-&gt;fd) == NGX_FILE_ERROR) &#123;</span><br><span class="line">        ngx_log_error(NGX_LOG_ALERT, c-&gt;<span class="built_in">log</span>, ngx_errno,</span><br><span class="line">                      ngx_close_file_n <span class="string">&quot; \&quot;%s\&quot; failed&quot;</span>, c-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h3><p>ngx_align_ptr和memalign的区别 <br><br>cleanup函数的使用</p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2019/12/22/sKrbnRSvOaUu7j3.jpg" alt="young-woman-enjoying-freedom-at-wheat-field-picjumbo-com_lit.jpg"></p>
]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>select-poll的源码</title>
    <url>/2020-03-09-select-poll/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://gityuan.com/2015/12/06/linux_epoll/">select/poll/epoll对比分析</a></p>
<p><a href="http://gityuan.com/2017/07/30/linux-process/">Linux进程管理(一)</a></p>
<p><a href="https://blog.csdn.net/dog250/article/details/50528373">Linux内核中网络数据包的接收-第二部分 select/poll/epoll</a></p>
<a id="more"></a>

<h2 id="select介绍"><a href="#select介绍" class="headerlink" title="select介绍"></a>select介绍</h2><p><a href="http://man7.org/linux/man-pages/man2/select.2.html">man page</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="function"><span class="params">                  fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>RETURN VALUE</code></p>
<p> On success, select() and pselect() return the number of file<br>descriptors contained in the three returned descriptor sets (that is,<br>the total number of bits that are set in readfds, writefds,<br>exceptfds) which may be zero if the timeout expires before anything<br>interesting happens.  On error, -1 is returned, and errno is set to<br>indicate the error; the file descriptor sets are unmodified, and<br>timeout becomes undefined.</p>
<ul>
<li>成功返回三种类型的总的句柄数</li>
<li>超时返回0</li>
<li>异常返回-1</li>
</ul>
<p><code>nfds</code></p>
<p>nfds should be set to the highest-numbered file descriptor in any of<br>       the three sets, plus 1.  The indicated file descriptors in each set<br>       are checked, up to this limit (but see BUGS).</p>
<p><code>timeout</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">	<span class="keyword">__kernel_time_t</span>		tv_sec;		<span class="comment">/* seconds */</span></span><br><span class="line">	<span class="keyword">__kernel_suseconds_t</span>	tv_usec;	<span class="comment">/* microseconds 微妙*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>timeout = NULL  //永久阻塞 <br><br>timeout.tv_sec = 0 &amp;&amp; tv_sec.tv_usec = 0    //不阻塞，直接返回结果 <br><br>timeout.tv_sec &gt; 0 &amp;&amp; tv_sec.tv_usec &gt; 0    //等待超时时间后返回</p>
<p><code>readfds/writefds/exceptfds</code></p>
<p>Three independent sets of file descriptors are watched. <br><br>The file descriptors listed in <code>readfds</code> will be watched to see if characters<br>become available for reading (more precisely, to see if a read will<br>not block; in particular, a file descriptor is also ready on end-of-<br>file).  <br><br>The file descriptors in <code>writefds</code> will be watched to see if<br>space is available for write (though a large write may still block). <br><br>The file descriptors in <code>exceptfds</code> will be watched for exceptional<br>conditions.  (For examples of some exceptional conditions, see the<br>discussion of POLLPRI in poll(2).)</p>
<p><code>FD_SET</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __FD_SETSIZE	1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> fds_bits[__FD_SETSIZE / (<span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="keyword">long</span>))];</span><br><span class="line">&#125; __kernel_fd_set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __kernel_fd_set		fd_set;</span><br></pre></td></tr></table></figure>

<p>64位系统中long是8字节。__FD_SETSIZE表示最大可以监控的句柄数，那么一位可以保存一个，数组大小是多少？__FD_SETSIZE / (8 * sizeof(unsigned long)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.oracle.com/cd/E36784_01/html/E36874/fd-clr-3c.html">引用自这里</a></p>
<p><strong>FD_CLR(fd, &amp;fdset)</strong> <br><br>Clears the bit for the file descriptor fd in the file descriptor set fdset.</p>
<p><strong>FD_ISSET(fd, &amp;fdset)</strong> <br><br>Returns a non-zero value if the bit for the file descriptor fd is set in the file descriptor set pointed to by fdset, and 0 otherwise.</p>
<p><strong>FD_SET(fd, &amp;fdset)</strong> <br><br>Sets the bit for the file descriptor fd in the file descriptor set fdset.</p>
<p><strong>FD_ZERO(&amp;fdset)</strong> <br><br>Initializes the file descriptor set fdset to have zero bits for all file descriptors.</p>
<h2 id="select源码"><a href="#select源码" class="headerlink" title="select源码"></a>select源码</h2><p><code>SYSCALL_DEFINE5</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE5(select, <span class="keyword">int</span>, n, fd_set __user *, inp, fd_set __user *, outp,</span><br><span class="line">		fd_set __user *, <span class="built_in">exp</span>, struct timeval __user *, tvp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">end_time</span>, *<span class="title">to</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tvp) &#123;</span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(&amp;tv, tvp, <span class="keyword">sizeof</span>(tv)))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">		to = &amp;end_time;</span><br><span class="line">		<span class="keyword">if</span> (poll_select_set_timeout(to,</span><br><span class="line">				tv.tv_sec + (tv.tv_usec / USEC_PER_SEC),</span><br><span class="line">				(tv.tv_usec % USEC_PER_SEC) * NSEC_PER_USEC))</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = core_sys_select(n, inp, outp, <span class="built_in">exp</span>, to);</span><br><span class="line">	ret = poll_select_copy_remaining(&amp;end_time, tvp, <span class="number">1</span>, ret);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要把时间格式转换了timeval-&gt;timespec</p>
<hr>
<p><code>core_sys_select</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We can actually return ERESTARTSYS instead of EINTR, but I&#x27;d</span></span><br><span class="line"><span class="comment"> * like to be certain this leads to no problems. So I return</span></span><br><span class="line"><span class="comment"> * EINTR just for safety.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Update: ERESTARTSYS breaks at least the xview clock binary, so</span></span><br><span class="line"><span class="comment"> * I&#x27;m trying ERESTARTNOHAND which restart only when you want to.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">core_sys_select</span><span class="params">(<span class="keyword">int</span> n, fd_set __user *inp, fd_set __user *outp,</span></span></span><br><span class="line"><span class="function"><span class="params">			   fd_set __user *<span class="built_in">exp</span>, struct timespec *end_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fd_set_bits fds;</span><br><span class="line">	<span class="keyword">void</span> *bits;</span><br><span class="line">	<span class="keyword">int</span> ret, max_fds;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> size;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span>;</span></span><br><span class="line">	<span class="comment">/* Allocate small arguments on the stack to save memory and be faster */</span></span><br><span class="line">	<span class="keyword">long</span> stack_fds[SELECT_STACK_ALLOC/<span class="keyword">sizeof</span>(<span class="keyword">long</span>)];</span><br><span class="line"></span><br><span class="line">	ret = -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out_nofds;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* max_fds can increase, so grab it once to avoid race */</span></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	fdt = files_fdtable(current-&gt;files);</span><br><span class="line">	max_fds = fdt-&gt;max_fds;</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">if</span> (n &gt; max_fds)</span><br><span class="line">		n = max_fds;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We need 6 bitmaps (in/out/ex for both incoming and outgoing),</span></span><br><span class="line"><span class="comment">	 * since we used fdset we need to allocate memory in units of</span></span><br><span class="line"><span class="comment">	 * long-words. </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	size = FDS_BYTES(n);</span><br><span class="line">	bits = stack_fds;</span><br><span class="line">	<span class="keyword">if</span> (size &gt; <span class="keyword">sizeof</span>(stack_fds) / <span class="number">6</span>) &#123;</span><br><span class="line">		<span class="comment">/* Not enough space in on-stack array; must use kmalloc */</span></span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		bits = kmalloc(<span class="number">6</span> * size, GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!bits)</span><br><span class="line">			<span class="keyword">goto</span> out_nofds;</span><br><span class="line">	&#125;</span><br><span class="line">	fds.in      = bits;</span><br><span class="line">	fds.out     = bits +   size;</span><br><span class="line">	fds.ex      = bits + <span class="number">2</span>*size;</span><br><span class="line">	fds.res_in  = bits + <span class="number">3</span>*size;</span><br><span class="line">	fds.res_out = bits + <span class="number">4</span>*size;</span><br><span class="line">	fds.res_ex  = bits + <span class="number">5</span>*size;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((ret = get_fd_set(n, inp, fds.in)) ||</span><br><span class="line">	    (ret = get_fd_set(n, outp, fds.out)) ||</span><br><span class="line">	    (ret = get_fd_set(n, <span class="built_in">exp</span>, fds.ex)))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	zero_fd_set(n, fds.res_in);</span><br><span class="line">	zero_fd_set(n, fds.res_out);</span><br><span class="line">	zero_fd_set(n, fds.res_ex);</span><br><span class="line"></span><br><span class="line">	ret = do_select(n, &amp;fds, end_time);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	<span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">		ret = -ERESTARTNOHAND;</span><br><span class="line">		<span class="keyword">if</span> (signal_pending(current))</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		ret = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (set_fd_set(n, inp, fds.res_in) ||</span><br><span class="line">	    set_fd_set(n, outp, fds.res_out) ||</span><br><span class="line">	    set_fd_set(n, <span class="built_in">exp</span>, fds.res_ex))</span><br><span class="line">		ret = -EFAULT;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (bits != stack_fds)</span><br><span class="line">		kfree(bits);</span><br><span class="line">out_nofds:</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p><code>do_select</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_select</span><span class="params">(<span class="keyword">int</span> n, fd_set_bits *fds, struct timespec *end_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">ktime_t</span> expire, *to = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> <span class="title">table</span>;</span></span><br><span class="line">	poll_table *wait;</span><br><span class="line">	<span class="keyword">int</span> retval, i, timed_out = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> slack = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	retval = max_select_fd(n, fds);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">	n = retval;</span><br><span class="line"></span><br><span class="line">	poll_initwait(&amp;table);</span><br><span class="line">	wait = &amp;table.pt;</span><br><span class="line">	<span class="keyword">if</span> (end_time &amp;&amp; !end_time-&gt;tv_sec &amp;&amp; !end_time-&gt;tv_nsec) &#123;</span><br><span class="line">		wait-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line">		timed_out = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (end_time &amp;&amp; !timed_out)</span><br><span class="line">		slack = select_estimate_accuracy(end_time);</span><br><span class="line"></span><br><span class="line">	retval = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> *rinp, *routp, *rexp, *inp, *outp, *<span class="built_in">exp</span>;</span><br><span class="line"></span><br><span class="line">		inp = fds-&gt;in; outp = fds-&gt;out; <span class="built_in">exp</span> = fds-&gt;ex;</span><br><span class="line">		rinp = fds-&gt;res_in; routp = fds-&gt;res_out; rexp = fds-&gt;res_ex;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++rinp, ++routp, ++rexp) &#123;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> in, out, ex, all_bits, bit = <span class="number">1</span>, mask, j;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> res_in = <span class="number">0</span>, res_out = <span class="number">0</span>, res_ex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">			in = *inp++; out = *outp++; ex = *<span class="built_in">exp</span>++;</span><br><span class="line">			all_bits = in | out | ex;</span><br><span class="line">			<span class="keyword">if</span> (all_bits == <span class="number">0</span>) &#123;</span><br><span class="line">				i += BITS_PER_LONG;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; BITS_PER_LONG; ++j, ++i, bit &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line">				<span class="keyword">if</span> (i &gt;= n)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">if</span> (!(bit &amp; all_bits))</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				f = fdget(i);</span><br><span class="line">				<span class="keyword">if</span> (f.file) &#123;</span><br><span class="line">					<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">f_op</span>;</span></span><br><span class="line">					f_op = f.file-&gt;f_op;</span><br><span class="line">					mask = DEFAULT_POLLMASK;</span><br><span class="line">					<span class="keyword">if</span> (f_op &amp;&amp; f_op-&gt;poll) &#123;</span><br><span class="line">						wait_key_set(wait, in, out, bit);</span><br><span class="line">						<span class="comment">//核心函数</span></span><br><span class="line">						mask = (*f_op-&gt;poll)(f.file, wait);</span><br><span class="line">					&#125;</span><br><span class="line">					fdput(f);</span><br><span class="line">					<span class="keyword">if</span> ((mask &amp; POLLIN_SET) &amp;&amp; (in &amp; bit)) &#123;</span><br><span class="line">						res_in |= bit;</span><br><span class="line">						retval++;</span><br><span class="line">						wait-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> ((mask &amp; POLLOUT_SET) &amp;&amp; (out &amp; bit)) &#123;</span><br><span class="line">						res_out |= bit;</span><br><span class="line">						retval++;</span><br><span class="line">						wait-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> ((mask &amp; POLLEX_SET) &amp;&amp; (ex &amp; bit)) &#123;</span><br><span class="line">						res_ex |= bit;</span><br><span class="line">						retval++;</span><br><span class="line">						wait-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (res_in)</span><br><span class="line">				*rinp = res_in;</span><br><span class="line">			<span class="keyword">if</span> (res_out)</span><br><span class="line">				*routp = res_out;</span><br><span class="line">			<span class="keyword">if</span> (res_ex)</span><br><span class="line">				*rexp = res_ex;</span><br><span class="line">			cond_resched();</span><br><span class="line">		&#125;</span><br><span class="line">		wait-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">if</span> (retval || timed_out || signal_pending(current))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (table.error) &#123;</span><br><span class="line">			retval = table.error;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If this is the first loop and we have a timeout</span></span><br><span class="line"><span class="comment">		 * given, then we convert to ktime_t and set the to</span></span><br><span class="line"><span class="comment">		 * pointer to the expiry value.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (end_time &amp;&amp; !to) &#123;</span><br><span class="line">			expire = timespec_to_ktime(*end_time);</span><br><span class="line">			to = &amp;expire;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!poll_schedule_timeout(&amp;table, TASK_INTERRUPTIBLE,</span><br><span class="line">					   to, slack))</span><br><span class="line">			timed_out = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	poll_freewait(&amp;table);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">poll_initwait</span><span class="params">(struct poll_wqueues *pwq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	init_poll_funcptr(&amp;pwq-&gt;pt, __pollwait);</span><br><span class="line">	pwq-&gt;polling_task = current;</span><br><span class="line">	pwq-&gt;triggered = <span class="number">0</span>;</span><br><span class="line">	pwq-&gt;error = <span class="number">0</span>;</span><br><span class="line">	pwq-&gt;table = <span class="literal">NULL</span>;</span><br><span class="line">	pwq-&gt;inline_index = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Add a new entry */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __pollwait(struct file *filp, <span class="keyword">wait_queue_head_t</span> *wait_address,</span><br><span class="line">				poll_table *p)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> *<span class="title">pwq</span> =</span> container_of(p, struct poll_wqueues, pt);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">poll_table_entry</span> *<span class="title">entry</span> =</span> poll_get_entry(pwq);</span><br><span class="line">	<span class="keyword">if</span> (!entry)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	entry-&gt;filp = get_file(filp);</span><br><span class="line">	entry-&gt;wait_address = wait_address;</span><br><span class="line">	entry-&gt;key = p-&gt;_key;</span><br><span class="line">	init_waitqueue_func_entry(&amp;entry-&gt;wait, pollwake);</span><br><span class="line">	entry-&gt;wait.<span class="keyword">private</span> = pwq;</span><br><span class="line">	add_wait_queue(wait_address, &amp;entry-&gt;wait);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pollwake</span><span class="params">(<span class="keyword">wait_queue_t</span> *wait, <span class="keyword">unsigned</span> mode, <span class="keyword">int</span> sync, <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">poll_table_entry</span> *<span class="title">entry</span>;</span></span><br><span class="line"></span><br><span class="line">	entry = container_of(wait, struct poll_table_entry, wait);</span><br><span class="line">	<span class="keyword">if</span> (key &amp;&amp; !((<span class="keyword">unsigned</span> <span class="keyword">long</span>)key &amp; entry-&gt;key))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> __pollwake(wait, mode, sync, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __pollwake(<span class="keyword">wait_queue_t</span> *wait, <span class="keyword">unsigned</span> mode, <span class="keyword">int</span> sync, <span class="keyword">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> *<span class="title">pwq</span> =</span> wait-&gt;<span class="keyword">private</span>;</span><br><span class="line">	DECLARE_WAITQUEUE(dummy_wait, pwq-&gt;polling_task);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Although this function is called under waitqueue lock, LOCK</span></span><br><span class="line"><span class="comment">	 * doesn&#x27;t imply write barrier and the users expect write</span></span><br><span class="line"><span class="comment">	 * barrier semantics on wakeup functions.  The following</span></span><br><span class="line"><span class="comment">	 * smp_wmb() is equivalent to smp_wmb() in try_to_wake_up()</span></span><br><span class="line"><span class="comment">	 * and is paired with set_mb() in poll_schedule_timeout.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	smp_wmb();</span><br><span class="line">	pwq-&gt;triggered = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Perform the default wake up operation using a dummy</span></span><br><span class="line"><span class="comment">	 * waitqueue.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">TODO:</span> This is hacky but there currently is no interface to</span></span><br><span class="line"><span class="comment">	 * pass in @sync.  @sync is scheduled to be removed and once</span></span><br><span class="line"><span class="comment">	 * that happens, wake_up_process() can be used directly.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> default_wake_function(&amp;dummy_wait, mode, sync, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>图片来自:</strong><a href="http://gityuan.com/2017/07/30/linux-process/">Linux进程管理(一)</a><br><img src="https://i.loli.net/2020/03/26/wVCOcFtGU6z4MmJ.jpg" alt="task_struct.jpg"></p>
<hr>
<pre><code>SYSCALL_DEFINE5
    |-&gt;core_sys_select
        |-&gt;do_select
            |-&gt;poll_initwait
                |-&gt;init_poll_funcptr(&amp;pwq-&gt;pt, __pollwait)
                    |-&gt;pollwake
                        |-&gt;__pollwake
                            |-&gt;default_wake_function
            |-&gt;f_op-&gt;poll
            |-&gt;poll_freewait</code></pre>
<h2 id="poll源码"><a href="#poll源码" class="headerlink" title="poll源码"></a>poll源码</h2><p><code>SYSCALL_DEFINE3</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE3(poll, struct pollfd __user *, ufds, <span class="keyword">unsigned</span> <span class="keyword">int</span>, nfds,</span><br><span class="line">		<span class="keyword">int</span>, timeout_msecs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">end_time</span>, *<span class="title">to</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (timeout_msecs &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		to = &amp;end_time;</span><br><span class="line">		poll_select_set_timeout(to, timeout_msecs / MSEC_PER_SEC,</span><br><span class="line">			NSEC_PER_MSEC * (timeout_msecs % MSEC_PER_SEC));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = do_sys_poll(ufds, nfds, to);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret == -EINTR) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">restart_block</span> *<span class="title">restart_block</span>;</span></span><br><span class="line"></span><br><span class="line">		restart_block = &amp;current_thread_info()-&gt;restart_block;</span><br><span class="line">		restart_block-&gt;fn = do_restart_poll;</span><br><span class="line">		restart_block-&gt;poll.ufds = ufds;</span><br><span class="line">		restart_block-&gt;poll.nfds = nfds;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (timeout_msecs &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			restart_block-&gt;poll.tv_sec = end_time.tv_sec;</span><br><span class="line">			restart_block-&gt;poll.tv_nsec = end_time.tv_nsec;</span><br><span class="line">			restart_block-&gt;poll.has_timeout = <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			restart_block-&gt;poll.has_timeout = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		ret = -ERESTART_RESTARTBLOCK;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p><code>do_sys_poll</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_sys_poll</span><span class="params">(struct pollfd __user *ufds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds,</span></span></span><br><span class="line"><span class="function"><span class="params">		struct timespec *end_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> <span class="title">table</span>;</span></span><br><span class="line"> 	<span class="keyword">int</span> err = -EFAULT, fdcount, len, size;</span><br><span class="line">	<span class="comment">/* Allocate small arguments on the stack to save memory and be</span></span><br><span class="line"><span class="comment">	   faster - use long to make sure the buffer is aligned properly</span></span><br><span class="line"><span class="comment">	   on 64 bit archs to avoid unaligned access */</span></span><br><span class="line">	<span class="keyword">long</span> stack_pps[POLL_STACK_ALLOC/<span class="keyword">sizeof</span>(<span class="keyword">long</span>)];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">poll_list</span> *<span class="title">const</span> <span class="title">head</span> =</span> (struct poll_list *)stack_pps;</span><br><span class="line"> 	<span class="class"><span class="keyword">struct</span> <span class="title">poll_list</span> *<span class="title">walk</span> =</span> head;</span><br><span class="line"> 	<span class="keyword">unsigned</span> <span class="keyword">long</span> todo = nfds;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nfds &gt; rlimit(RLIMIT_NOFILE))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	len = <span class="keyword">min_t</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>, nfds, N_STACK_PPS);</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		walk-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		walk-&gt;len = len;</span><br><span class="line">		<span class="keyword">if</span> (!len)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(walk-&gt;entries, ufds + nfds-todo,</span><br><span class="line">					<span class="keyword">sizeof</span>(struct pollfd) * walk-&gt;len))</span><br><span class="line">			<span class="keyword">goto</span> out_fds;</span><br><span class="line"></span><br><span class="line">		todo -= walk-&gt;len;</span><br><span class="line">		<span class="keyword">if</span> (!todo)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		len = min(todo, POLLFD_PER_PAGE);</span><br><span class="line">		size = <span class="keyword">sizeof</span>(struct poll_list) + <span class="keyword">sizeof</span>(struct pollfd) * len;</span><br><span class="line">		walk = walk-&gt;next = kmalloc(size, GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!walk) &#123;</span><br><span class="line">			err = -ENOMEM;</span><br><span class="line">			<span class="keyword">goto</span> out_fds;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	poll_initwait(&amp;table);</span><br><span class="line">	fdcount = do_poll(nfds, head, &amp;table, end_time);</span><br><span class="line">	poll_freewait(&amp;table);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (walk = head; walk; walk = walk-&gt;next) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> *<span class="title">fds</span> =</span> walk-&gt;entries;</span><br><span class="line">		<span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; walk-&gt;len; j++, ufds++)</span><br><span class="line">			<span class="keyword">if</span> (__put_user(fds[j].revents, &amp;ufds-&gt;revents))</span><br><span class="line">				<span class="keyword">goto</span> out_fds;</span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">	err = fdcount;</span><br><span class="line">out_fds:</span><br><span class="line">	walk = head-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (walk) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">poll_list</span> *<span class="title">pos</span> =</span> walk;</span><br><span class="line">		walk = walk-&gt;next;</span><br><span class="line">		kfree(pos);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p><code>do_poll</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_poll</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> nfds,  struct poll_list *<span class="built_in">list</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">		   struct poll_wqueues *wait, struct timespec *end_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	poll_table* pt = &amp;wait-&gt;pt;</span><br><span class="line">	<span class="keyword">ktime_t</span> expire, *to = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> timed_out = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> slack = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Optimise the no-wait case */</span></span><br><span class="line">	<span class="keyword">if</span> (end_time &amp;&amp; !end_time-&gt;tv_sec &amp;&amp; !end_time-&gt;tv_nsec) &#123;</span><br><span class="line">		pt-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line">		timed_out = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (end_time &amp;&amp; !timed_out)</span><br><span class="line">		slack = select_estimate_accuracy(end_time);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">poll_list</span> *<span class="title">walk</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (walk = <span class="built_in">list</span>; walk != <span class="literal">NULL</span>; walk = walk-&gt;next) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> * <span class="title">pfd</span>, * <span class="title">pfd_end</span>;</span></span><br><span class="line"></span><br><span class="line">			pfd = walk-&gt;entries;</span><br><span class="line">			pfd_end = pfd + walk-&gt;len;</span><br><span class="line">			<span class="keyword">for</span> (; pfd != pfd_end; pfd++) &#123;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * Fish for events. If we found one, record it</span></span><br><span class="line"><span class="comment">				 * and kill poll_table-&gt;_qproc, so we don&#x27;t</span></span><br><span class="line"><span class="comment">				 * needlessly register any other waiters after</span></span><br><span class="line"><span class="comment">				 * this. They&#x27;ll get immediately deregistered</span></span><br><span class="line"><span class="comment">				 * when we break out and return.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				<span class="keyword">if</span> (do_pollfd(pfd, pt)) &#123;</span><br><span class="line">					count++;</span><br><span class="line">					pt-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * All waiters have already been registered, so don&#x27;t provide</span></span><br><span class="line"><span class="comment">		 * a poll_table-&gt;_qproc to them on the next loop iteration.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		pt-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">if</span> (!count) &#123;</span><br><span class="line">			count = wait-&gt;error;</span><br><span class="line">			<span class="keyword">if</span> (signal_pending(current))</span><br><span class="line">				count = -EINTR;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (count || timed_out)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If this is the first loop and we have a timeout</span></span><br><span class="line"><span class="comment">		 * given, then we convert to ktime_t and set the to</span></span><br><span class="line"><span class="comment">		 * pointer to the expiry value.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (end_time &amp;&amp; !to) &#123;</span><br><span class="line">			expire = timespec_to_ktime(*end_time);</span><br><span class="line">			to = &amp;expire;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!poll_schedule_timeout(wait, TASK_INTERRUPTIBLE, to, slack))</span><br><span class="line">			timed_out = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p><code>do_pollfd</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Fish for pollable events on the pollfd-&gt;fd file descriptor. We&#x27;re only</span></span><br><span class="line"><span class="comment"> * interested in events matching the pollfd-&gt;events mask, and the result</span></span><br><span class="line"><span class="comment"> * matching that mask is both recorded in pollfd-&gt;revents and returned. The</span></span><br><span class="line"><span class="comment"> * pwait poll_table will be used by the fd-provided poll handler for waiting,</span></span><br><span class="line"><span class="comment"> * if pwait-&gt;_qproc is non-NULL.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">do_pollfd</span><span class="params">(struct pollfd *pollfd, poll_table *pwait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> mask;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">	mask = <span class="number">0</span>;</span><br><span class="line">	fd = pollfd-&gt;fd;</span><br><span class="line">	<span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span> =</span> fdget(fd);</span><br><span class="line">		mask = POLLNVAL;</span><br><span class="line">		<span class="keyword">if</span> (f.file) &#123;</span><br><span class="line">			mask = DEFAULT_POLLMASK;</span><br><span class="line">			<span class="keyword">if</span> (f.file-&gt;f_op &amp;&amp; f.file-&gt;f_op-&gt;poll) &#123;</span><br><span class="line">				pwait-&gt;_key = pollfd-&gt;events|POLLERR|POLLHUP;</span><br><span class="line">				mask = f.file-&gt;f_op-&gt;poll(f.file, pwait);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/* Mask out unneeded events. */</span></span><br><span class="line">			mask &amp;= pollfd-&gt;events | POLLERR | POLLHUP;</span><br><span class="line">			fdput(f);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pollfd-&gt;revents = mask;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<pre><code>SYSCALL_DEFINE3
|-&gt;do_sys_poll
    |-&gt;poll_initwait
    |-&gt;do_poll
        |-&gt;do_pollfd
            |-&gt;f.file-&gt;f_op-&gt;poll</code></pre>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*poll)</span> <span class="params">(struct file *, struct poll_table_struct *)</span></span>;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/03/27/8JkvKNdOCqpGIf1.jpg" alt="59069747_p0_master1200.jpg"></p>
]]></content>
      <tags>
        <tag>IO复用</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-posix信号量</title>
    <url>/2020-04-07-linux-posix%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="">UNP</a></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>信号量（英语：semaphore）又称为信号标，是一个同步对象，用于保持在0至指定最大值之间的一个计数值。当线程完成一次对该semaphore对象的等待（wait）时，该计数值减一；当线程完成一次对semaphore对象的释放（release）时，计数值加一。当计数值为0，则线程等待该semaphore对象不再能成功直至该semaphore对象变成signaled状态。semaphore对象的计数值大于0，为signaled状态；计数值等于0，为nonsignaled状态.</p>
<a id="more"></a>

<p>semaphore对象适用于控制一个仅支持有限个用户的共享资源，是一种不需要使用忙碌等待（busy waiting）的方法。</p>
<p>信号量的概念是由荷兰计算机科学家艾兹赫尔·戴克斯特拉（Edsger W. Dijkstra）发明的，广泛的应用于不同的操作系统中。在系统中，给予每一个进程一个信号量，代表每个进程当前的状态，未得到控制权的进程会在特定地方被强迫停下来，等待可以继续进行的信号到来。如果信号量是一个任意的整数，通常被称为计数信号量（Counting semaphore），或一般信号量（general semaphore）；如果信号量只有二进制的0或1，称为二进制信号量（binary semaphore）。在linux系统中，二进制信号量（binary semaphore）又称互斥锁</p>
<h2 id="信号量的分类"><a href="#信号量的分类" class="headerlink" title="信号量的分类"></a>信号量的分类</h2><ul>
<li>POSIX有名信号量(基于文件的信号量)</li>
<li>POSIX无名信号量(基于内存的信号量)</li>
<li>System V信号量(暂时不研究)</li>
</ul>
<p><img src="https://i.loli.net/2020/04/11/wevuGzncNp3l6xo.png" alt="有名信号量.png"></p>
<p><img src="https://i.loli.net/2020/04/11/45zLVExSDvpqmn6.png" alt="无名信号量.png"></p>
<p>如果信号量的实现用到了映射文件,那么信号量的真正值确实出现在某个文件中，而该文件是映射到所有让该信号量打开着的进程的地址空间的.</p>
<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p><img src="https://i.loli.net/2020/04/11/bzFJtTv9HGWgUI7.png" alt="信号量函数调用.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Initialize semaphore object SEM to VALUE.  If PSHARED then share it</span></span><br><span class="line"><span class="comment">   with other processes.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">sem_init</span> <span class="params">(<span class="keyword">sem_t</span> *__sem, <span class="keyword">int</span> __pshared, <span class="keyword">unsigned</span> <span class="keyword">int</span> __value)</span></span></span><br><span class="line"><span class="function">     __THROW</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Free resources associated with semaphore object SEM.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">sem_destroy</span> <span class="params">(<span class="keyword">sem_t</span> *__sem)</span> __THROW</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Open a named semaphore NAME with open flags OFLAG.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">sem_t</span> *<span class="title">sem_open</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *__name, <span class="keyword">int</span> __oflag, ...)</span> __THROW</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Close descriptor for named semaphore SEM.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">sem_close</span> <span class="params">(<span class="keyword">sem_t</span> *__sem)</span> __THROW</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Remove named semaphore NAME.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">sem_unlink</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *__name)</span> __THROW</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wait for SEM being posted.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This function is a cancellation point and therefore not marked with</span></span><br><span class="line"><span class="comment">   __THROW.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">sem_wait</span> <span class="params">(<span class="keyword">sem_t</span> *__sem)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __USE_XOPEN2K</span></span><br><span class="line"><span class="comment">/* Similar to `sem_wait&#x27; but wait only until ABSTIME.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This function is a cancellation point and therefore not marked with</span></span><br><span class="line"><span class="comment">   __THROW.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">sem_timedwait</span> <span class="params">(<span class="keyword">sem_t</span> *__restrict __sem,</span></span></span><br><span class="line"><span class="function"><span class="params">			  <span class="keyword">const</span> struct timespec *__restrict __abstime)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Test whether SEM is posted.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">sem_trywait</span> <span class="params">(<span class="keyword">sem_t</span> *__sem)</span> __THROWNL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Post SEM.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">sem_post</span> <span class="params">(<span class="keyword">sem_t</span> *__sem)</span> __THROWNL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get current value of SEM and store it in *SVAL.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">sem_getvalue</span> <span class="params">(<span class="keyword">sem_t</span> *__restrict __sem, <span class="keyword">int</span> *__restrict __sval)</span></span></span><br><span class="line"><span class="function">     __THROW</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SIZEOF_SEM_T	16</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Value returned if `sem_open&#x27; failed.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEM_FAILED      ((sem_t *) 0)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> __size[__SIZEOF_SEM_T];</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> __align;</span><br><span class="line">&#125; <span class="keyword">sem_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Semaphore variable structure.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">new_sem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> value;</span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">private</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> nwaiters;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="sem-init"><a href="#sem-init" class="headerlink" title="sem_init"></a>sem_init</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__new_sem_init (sem, pshared, value)</span><br><span class="line">     <span class="keyword">sem_t</span> *sem;</span><br><span class="line">     <span class="keyword">int</span> pshared;</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">int</span> value;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Parameter sanity check.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (value &gt; SEM_VALUE_MAX, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      __set_errno (EINVAL);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Map to the internal type.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">new_sem</span> *<span class="title">isem</span> =</span> (struct new_sem *) sem;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Use the values the user provided.  */</span></span><br><span class="line">  isem-&gt;value = value;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __ASSUME_PRIVATE_FUTEX</span></span><br><span class="line">  isem-&gt;<span class="keyword">private</span> = pshared ? <span class="number">0</span> : FUTEX_PRIVATE_FLAG;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  isem-&gt;<span class="keyword">private</span> = pshared ? <span class="number">0</span> : THREAD_GETMEM (THREAD_SELF,</span><br><span class="line">					       header.private_futex);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  isem-&gt;nwaiters = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">versioned_symbol (libpthread, __new_sem_init, sem_init, GLIBC_2_1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SHLIB_COMPAT(libpthread, GLIBC_2_0, GLIBC_2_1)</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">attribute_compat_text_section</span><br><span class="line">__old_sem_init (sem, pshared, value)</span><br><span class="line">     <span class="keyword">sem_t</span> *sem;</span><br><span class="line">     <span class="keyword">int</span> pshared;</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">int</span> value;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Parameter sanity check.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (value &gt; SEM_VALUE_MAX, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      __set_errno (EINVAL);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Map to the internal type.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">old_sem</span> *<span class="title">isem</span> =</span> (struct old_sem *) sem;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Use the value the user provided.  */</span></span><br><span class="line">  isem-&gt;value = value;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We cannot store the PSHARED attribute.  So we always use the</span></span><br><span class="line"><span class="comment">     operations needed for shared semaphores.  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">compat_symbol (libpthread, __old_sem_init, sem_init, GLIBC_2_0);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="sem-destroy"><a href="#sem-destroy" class="headerlink" title="sem_destroy"></a>sem_destroy</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__new_sem_destroy (sem)</span><br><span class="line">     <span class="keyword">sem_t</span> *sem;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* XXX Check for valid parameter.  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Nothing to do.  */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="sem-open"><a href="#sem-open" class="headerlink" title="sem_open"></a>sem_open</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sem_t</span> *</span><br><span class="line">sem_open (<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> oflag, ...)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> *finalname;</span><br><span class="line">  <span class="keyword">sem_t</span> *result = SEM_FAILED;</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Determine where the shmfs is mounted.  */</span></span><br><span class="line">  __pthread_once (&amp;__namedsem_once, __where_is_shmfs);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we don&#x27;t know the mount points there is nothing we can do.  Ever.  */</span></span><br><span class="line">  <span class="keyword">if</span> (mountpoint.dir == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      __set_errno (ENOSYS);</span><br><span class="line">      <span class="keyword">return</span> SEM_FAILED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Construct the filename.  */</span></span><br><span class="line">  <span class="keyword">while</span> (name[<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    ++name;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (name[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* The name &quot;/&quot; is not supported.  */</span></span><br><span class="line">      __set_errno (EINVAL);</span><br><span class="line">      <span class="keyword">return</span> SEM_FAILED;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">size_t</span> namelen = <span class="built_in">strlen</span> (name) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Create the name of the final file.  */</span></span><br><span class="line">  finalname = (<span class="keyword">char</span> *) alloca (mountpoint.dirlen + namelen);</span><br><span class="line">  __mempcpy (__mempcpy (finalname, mountpoint.dir, mountpoint.dirlen),</span><br><span class="line">	     name, namelen);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If the semaphore object has to exist simply open it.  */</span></span><br><span class="line">  <span class="keyword">if</span> ((oflag &amp; O_CREAT) == <span class="number">0</span> || (oflag &amp; O_EXCL) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    try_again:</span><br><span class="line">      fd = __libc_open (finalname,</span><br><span class="line">			(oflag &amp; ~(O_CREAT|O_ACCMODE)) | O_NOFOLLOW | O_RDWR);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* If we are supposed to create the file try this next.  */</span></span><br><span class="line">	  <span class="keyword">if</span> ((oflag &amp; O_CREAT) != <span class="number">0</span> &amp;&amp; errno == ENOENT)</span><br><span class="line">	    <span class="keyword">goto</span> try_create;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Return.  errno is already set.  */</span></span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	<span class="comment">/* Check whether we already have this semaphore mapped and</span></span><br><span class="line"><span class="comment">	   create one if necessary.  */</span></span><br><span class="line">	result = check_add_mapping (name, namelen, fd, SEM_FAILED);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We have to open a temporary file first since it must have the</span></span><br><span class="line"><span class="comment">	 correct form before we can start using it.  */</span></span><br><span class="line">      <span class="keyword">char</span> *tmpfname;</span><br><span class="line">      <span class="keyword">mode_t</span> mode;</span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span> value;</span><br><span class="line">      va_list ap;</span><br><span class="line"></span><br><span class="line">    try_create:</span><br><span class="line">      va_start (ap, oflag);</span><br><span class="line"></span><br><span class="line">      mode = va_arg (ap, <span class="keyword">mode_t</span>);</span><br><span class="line">      value = va_arg (ap, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">      va_end (ap);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (value &gt; SEM_VALUE_MAX)</span><br><span class="line">	&#123;</span><br><span class="line">	  __set_errno (EINVAL);</span><br><span class="line">	  <span class="keyword">return</span> SEM_FAILED;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Create the initial file content.  */</span></span><br><span class="line">      <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line">	<span class="keyword">sem_t</span> initsem;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">new_sem</span> <span class="title">newsem</span>;</span></span><br><span class="line">      &#125; sem;</span><br><span class="line"></span><br><span class="line">      sem.newsem.value = value;</span><br><span class="line">      sem.newsem.<span class="keyword">private</span> = <span class="number">0</span>;</span><br><span class="line">      sem.newsem.nwaiters = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Initialize the remaining bytes as well.  */</span></span><br><span class="line">      <span class="built_in">memset</span> ((<span class="keyword">char</span> *) &amp;sem.initsem + <span class="keyword">sizeof</span> (struct new_sem), <span class="string">&#x27;\0&#x27;</span>,</span><br><span class="line">	      <span class="keyword">sizeof</span> (<span class="keyword">sem_t</span>) - <span class="keyword">sizeof</span> (struct new_sem));</span><br><span class="line"></span><br><span class="line">      tmpfname = (<span class="keyword">char</span> *) alloca (mountpoint.dirlen + <span class="number">6</span> + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">char</span> *xxxxxx = __mempcpy (tmpfname, mountpoint.dir, mountpoint.dirlen);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> retries = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NRETRIES 50</span></span><br><span class="line">      <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* Add the suffix for mktemp.  */</span></span><br><span class="line">	  <span class="built_in">strcpy</span> (xxxxxx, <span class="string">&quot;XXXXXX&quot;</span>);</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* We really want to use mktemp here.  We cannot use mkstemp</span></span><br><span class="line"><span class="comment">	     since the file must be opened with a specific mode.  The</span></span><br><span class="line"><span class="comment">	     mode cannot later be set since then we cannot apply the</span></span><br><span class="line"><span class="comment">	     file create mask.  */</span></span><br><span class="line">	  <span class="keyword">if</span> (mktemp (tmpfname) == <span class="literal">NULL</span>)</span><br><span class="line">	    <span class="keyword">return</span> SEM_FAILED;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Open the file.  Make sure we do not overwrite anything.  */</span></span><br><span class="line">	  fd = __libc_open (tmpfname, O_RDWR | O_CREAT | O_EXCL, mode);</span><br><span class="line">	  <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">if</span> (errno == EEXIST)</span><br><span class="line">		&#123;</span><br><span class="line">		  <span class="keyword">if</span> (++retries &lt; NRETRIES)</span><br><span class="line">		    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		  __set_errno (EAGAIN);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	      <span class="keyword">return</span> SEM_FAILED;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* We got a file.  */</span></span><br><span class="line">	  <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (TEMP_FAILURE_RETRY (__libc_write (fd, &amp;sem.initsem, <span class="keyword">sizeof</span> (<span class="keyword">sem_t</span>)))</span><br><span class="line">	  == <span class="keyword">sizeof</span> (<span class="keyword">sem_t</span>)</span><br><span class="line">	  <span class="comment">/* Map the sem_t structure from the file.  */</span></span><br><span class="line">	  &amp;&amp; (result = (<span class="keyword">sem_t</span> *) mmap (<span class="literal">NULL</span>, <span class="keyword">sizeof</span> (<span class="keyword">sem_t</span>),</span><br><span class="line">				       PROT_READ | PROT_WRITE, MAP_SHARED,</span><br><span class="line">				       fd, <span class="number">0</span>)) != MAP_FAILED)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* Create the file.  Don&#x27;t overwrite an existing file.  */</span></span><br><span class="line">	  <span class="keyword">if</span> (link (tmpfname, finalname) != <span class="number">0</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="comment">/* Undo the mapping.  */</span></span><br><span class="line">	      (<span class="keyword">void</span>) munmap (result, <span class="keyword">sizeof</span> (<span class="keyword">sem_t</span>));</span><br><span class="line"></span><br><span class="line">	      <span class="comment">/* Reinitialize &#x27;result&#x27;.  */</span></span><br><span class="line">	      result = SEM_FAILED;</span><br><span class="line"></span><br><span class="line">	      <span class="comment">/* This failed.  If O_EXCL is not set and the problem was</span></span><br><span class="line"><span class="comment">		 that the file exists, try again.  */</span></span><br><span class="line">	      <span class="keyword">if</span> ((oflag &amp; O_EXCL) == <span class="number">0</span> &amp;&amp; errno == EEXIST)</span><br><span class="line">		&#123;</span><br><span class="line">		  <span class="comment">/* Remove the file.  */</span></span><br><span class="line">		  (<span class="keyword">void</span>) unlink (tmpfname);</span><br><span class="line"></span><br><span class="line">		  <span class="comment">/* Close the file.  */</span></span><br><span class="line">		  (<span class="keyword">void</span>) __libc_close (fd);</span><br><span class="line"></span><br><span class="line">		  <span class="keyword">goto</span> try_again;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	  <span class="keyword">else</span></span><br><span class="line">	    <span class="comment">/* Insert the mapping into the search tree.  This also</span></span><br><span class="line"><span class="comment">	       determines whether another thread sneaked by and already</span></span><br><span class="line"><span class="comment">	       added such a mapping despite the fact that we created it.  */</span></span><br><span class="line">	    result = check_add_mapping (name, namelen, fd, result);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now remove the temporary name.  This should never fail.  If</span></span><br><span class="line"><span class="comment">	 it fails we leak a file name.  Better fix the kernel.  */</span></span><br><span class="line">      (<span class="keyword">void</span>) unlink (tmpfname);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Map the mmap error to the error we need.  */</span></span><br><span class="line">  <span class="keyword">if</span> (MAP_FAILED != (<span class="keyword">void</span> *) SEM_FAILED &amp;&amp; result == MAP_FAILED)</span><br><span class="line">    result = SEM_FAILED;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We don&#x27;t need the file descriptor anymore.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fd != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Do not disturb errno.  */</span></span><br><span class="line">      INTERNAL_SYSCALL_DECL (err);</span><br><span class="line">      INTERNAL_SYSCALL (close, err, <span class="number">1</span>, fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="sem-close"><a href="#sem-close" class="headerlink" title="sem_close"></a>sem_close</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">sem_close (sem)</span><br><span class="line">     <span class="keyword">sem_t</span> *sem;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get the lock.  */</span></span><br><span class="line">  lll_lock (__sem_mappings_lock, LLL_PRIVATE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Locate the entry for the mapping the caller provided.  */</span></span><br><span class="line">  rec = <span class="literal">NULL</span>;</span><br><span class="line">  the_sem = sem;</span><br><span class="line">  twalk (__sem_mappings, walker);</span><br><span class="line">  <span class="keyword">if</span>  (rec != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Check the reference counter.  If it is going to be zero, free</span></span><br><span class="line"><span class="comment">	 all the resources.  */</span></span><br><span class="line">      <span class="keyword">if</span> (--rec-&gt;refcnt == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* Remove the record from the tree.  */</span></span><br><span class="line">	  (<span class="keyword">void</span>) tdelete (rec, &amp;__sem_mappings, __sem_search);</span><br><span class="line"></span><br><span class="line">	  result = munmap (rec-&gt;sem, <span class="keyword">sizeof</span> (<span class="keyword">sem_t</span>));</span><br><span class="line"></span><br><span class="line">	  <span class="built_in">free</span> (rec);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* This is no valid semaphore.  */</span></span><br><span class="line">      result = <span class="number">-1</span>;</span><br><span class="line">      __set_errno (EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Release the lock.  */</span></span><br><span class="line">  lll_unlock (__sem_mappings_lock, LLL_PRIVATE);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="sem-unlink"><a href="#sem-unlink" class="headerlink" title="sem_unlink"></a>sem_unlink</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">sem_unlink (name)</span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> *fname;</span><br><span class="line">  <span class="keyword">size_t</span> namelen;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Determine where the shmfs is mounted.  */</span></span><br><span class="line">  __pthread_once (&amp;__namedsem_once, __where_is_shmfs);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we don&#x27;t know the mount points there is nothing we can do.  Ever.  */</span></span><br><span class="line">  <span class="keyword">if</span> (mountpoint.dir == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      __set_errno (ENOSYS);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Construct the filename.  */</span></span><br><span class="line">  <span class="keyword">while</span> (name[<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    ++name;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (name[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* The name &quot;/&quot; is not supported.  */</span></span><br><span class="line">      __set_errno (ENOENT);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  namelen = <span class="built_in">strlen</span> (name);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Create the name of the file.  */</span></span><br><span class="line">  fname = (<span class="keyword">char</span> *) alloca (mountpoint.dirlen + namelen + <span class="number">1</span>);</span><br><span class="line">  __mempcpy (__mempcpy (fname, mountpoint.dir, mountpoint.dirlen),</span><br><span class="line">	     name, namelen + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Now try removing it.  */</span></span><br><span class="line">  <span class="keyword">int</span> ret = unlink (fname);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span> &amp;&amp; errno == EPERM)</span><br><span class="line">    __set_errno (EACCES);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="sem-wait"><a href="#sem-wait" class="headerlink" title="sem_wait"></a>sem_wait</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__new_sem_wait (<span class="keyword">sem_t</span> *sem)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sparc_new_sem</span> *<span class="title">isem</span> =</span> (struct sparc_new_sem *) sem;</span><br><span class="line">  <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (atomic_decrement_if_positive (&amp;isem-&gt;value) &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  atomic_increment (&amp;isem-&gt;nwaiters);</span><br><span class="line"></span><br><span class="line">  pthread_cleanup_push (__sem_wait_cleanup, isem);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      err = do_futex_wait(isem);</span><br><span class="line">      <span class="keyword">if</span> (err != <span class="number">0</span> &amp;&amp; err != -EWOULDBLOCK)</span><br><span class="line">	&#123;</span><br><span class="line">	  __set_errno (-err);</span><br><span class="line">	  err = <span class="number">-1</span>;</span><br><span class="line">	  <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (atomic_decrement_if_positive (&amp;isem-&gt;value) &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  err = <span class="number">0</span>;</span><br><span class="line">	  <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  pthread_cleanup_pop (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  atomic_decrement (&amp;isem-&gt;nwaiters);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line">versioned_symbol (libpthread, __new_sem_wait, sem_wait, GLIBC_2_1);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="sem-timedwait"><a href="#sem-timedwait" class="headerlink" title="sem_timedwait"></a>sem_timedwait</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">sem_timedwait (<span class="keyword">sem_t</span> *sem, <span class="keyword">const</span> struct timespec *abstime)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">new_sem</span> *<span class="title">isem</span> =</span> (struct new_sem *) sem;</span><br><span class="line">  <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (atomic_decrement_if_positive (&amp;isem-&gt;value) &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (abstime-&gt;tv_nsec &lt; <span class="number">0</span> || abstime-&gt;tv_nsec &gt;= <span class="number">1000000000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      __set_errno (EINVAL);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  atomic_increment (&amp;isem-&gt;nwaiters);</span><br><span class="line"></span><br><span class="line">  pthread_cleanup_push (__sem_wait_cleanup, isem);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">rt</span>;</span></span><br><span class="line">      <span class="keyword">int</span> sec, nsec;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Get the current time.  */</span></span><br><span class="line">      __gettimeofday (&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Compute relative timeout.  */</span></span><br><span class="line">      sec = abstime-&gt;tv_sec - tv.tv_sec;</span><br><span class="line">      nsec = abstime-&gt;tv_nsec - tv.tv_usec * <span class="number">1000</span>;</span><br><span class="line">      <span class="keyword">if</span> (nsec &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  nsec += <span class="number">1000000000</span>;</span><br><span class="line">	  --sec;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Already timed out?  */</span></span><br><span class="line">      <span class="keyword">if</span> (sec &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  __set_errno (ETIMEDOUT);</span><br><span class="line">	  err = <span class="number">-1</span>;</span><br><span class="line">	  <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Do wait.  */</span></span><br><span class="line">      rt.tv_sec = sec;</span><br><span class="line">      rt.tv_nsec = nsec;</span><br><span class="line">      err = do_futex_timed_wait(isem, &amp;rt);</span><br><span class="line">      <span class="keyword">if</span> (err != <span class="number">0</span> &amp;&amp; err != -EWOULDBLOCK)</span><br><span class="line">	&#123;</span><br><span class="line">	  __set_errno (-err);</span><br><span class="line">	  err = <span class="number">-1</span>;</span><br><span class="line">	  <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (atomic_decrement_if_positive (&amp;isem-&gt;value) &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  err = <span class="number">0</span>;</span><br><span class="line">	  <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  pthread_cleanup_pop (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  atomic_decrement (&amp;isem-&gt;nwaiters);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="sem-trywait"><a href="#sem-trywait" class="headerlink" title="sem_trywait"></a>sem_trywait</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__new_sem_trywait (<span class="keyword">sem_t</span> *sem)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> *futex = (<span class="keyword">int</span> *) sem;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (*futex &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      val = atomic_decrement_if_positive (futex);</span><br><span class="line">      <span class="keyword">if</span> (val &gt; <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __set_errno (EAGAIN);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">versioned_symbol (libpthread, __new_sem_trywait, sem_trywait, GLIBC_2_1);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="sem-post"><a href="#sem-post" class="headerlink" title="sem_post"></a>sem_post</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__new_sem_post (<span class="keyword">sem_t</span> *sem)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">new_sem</span> *<span class="title">isem</span> =</span> (struct new_sem *) sem;</span><br><span class="line"></span><br><span class="line">  __typeof (isem-&gt;value) cur;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      cur = isem-&gt;value;</span><br><span class="line">      <span class="keyword">if</span> (isem-&gt;value == SEM_VALUE_MAX)</span><br><span class="line">	&#123;</span><br><span class="line">	  __set_errno (EOVERFLOW);</span><br><span class="line">	  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">while</span> (atomic_compare_and_exchange_bool_rel (&amp;isem-&gt;value, cur + <span class="number">1</span>, cur));</span><br><span class="line"></span><br><span class="line">  atomic_full_barrier ();</span><br><span class="line">  <span class="keyword">if</span> (isem-&gt;nwaiters &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> err = lll_futex_wake (&amp;isem-&gt;value, <span class="number">1</span>,</span><br><span class="line">				isem-&gt;<span class="keyword">private</span> ^ FUTEX_PRIVATE_FLAG);</span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (err, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  __set_errno (-err);</span><br><span class="line">	  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">versioned_symbol (libpthread, __new_sem_post, sem_post, GLIBC_2_1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SHLIB_COMPAT (libpthread, GLIBC_2_0, GLIBC_2_1)</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">attribute_compat_text_section</span><br><span class="line">__old_sem_post (<span class="keyword">sem_t</span> *sem)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> *futex = (<span class="keyword">int</span> *) sem;</span><br><span class="line"></span><br><span class="line">  (<span class="keyword">void</span>) atomic_increment_val (futex);</span><br><span class="line">  <span class="comment">/* We always have to assume it is a shared semaphore.  */</span></span><br><span class="line">  <span class="keyword">int</span> err = lll_futex_wake (futex, <span class="number">1</span>, LLL_SHARED);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (err, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      __set_errno (-err);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">compat_symbol (libpthread, __old_sem_post, sem_post, GLIBC_2_0);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="sem-getvalue"><a href="#sem-getvalue" class="headerlink" title="sem_getvalue"></a>sem_getvalue</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__new_sem_getvalue (sem, sval)</span><br><span class="line">     <span class="keyword">sem_t</span> *sem;</span><br><span class="line">     <span class="keyword">int</span> *sval;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">new_sem</span> *<span class="title">isem</span> =</span> (struct new_sem *) sem;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* XXX Check for valid SEM parameter.  */</span></span><br><span class="line"></span><br><span class="line">  *sval = isem-&gt;value;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">versioned_symbol (libpthread, __new_sem_getvalue, sem_getvalue, GLIBC_2_1);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p><code>P wait</code></p>
<p>P操作，荷兰语，尝试的意思</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (semaphore_value &lt;= <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line">semaphore_value--;</span><br></pre></td></tr></table></figure>

<p><code>V post</code></p>
<p>V操作，荷兰语增加的意思</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore_value++;</span><br></pre></td></tr></table></figure>

<h2 id="互斥锁and条件变量and信号量de差异"><a href="#互斥锁and条件变量and信号量de差异" class="headerlink" title="互斥锁and条件变量and信号量de差异"></a>互斥锁and条件变量and信号量de差异</h2><ul>
<li>信号量增加和减少必须是原子操作atomic</li>
<li>互斥锁必须总是由给它上锁的线程解锁，信号量的挂出却不必由执行过它的等待操作的同一线程执行</li>
<li>互斥锁是二值信号量，要么锁住，要么解开，只有0和1的值，计数信号量的值可以很大</li>
<li>当向一个条件变量发送信号，如果没有线程等待在条件变量的队列，则信号会丢失。但是信号量的计数值会保存计数状态，不会丢失</li>
<li>当持有某个记录锁的进程没有释放它就终止时，内核自动释放锁。但内核不对信号量解锁（内核持续期间有效）</li>
<li>条件变量不是异步信号安全的，能够从信号处理程序中安全调用的唯一函数是sem_post</li>
<li>互斥锁也可以用于进程间，信号量也可以用于线程间，应该使用适合具体应用的那组原语</li>
<li>互斥锁是为上锁而优化的，条件变量是为等待而优化的，信号量既可以用于上锁，也可用于等待，因而可能导致更多的开销和更高的复杂性</li>
</ul>
<h2 id="有名信号量实现代码"><a href="#有名信号量实现代码" class="headerlink" title="有名信号量实现代码"></a>有名信号量实现代码</h2><p>TODO</p>
<h2 id="无名信号量实现代码"><a href="#无名信号量实现代码" class="headerlink" title="无名信号量实现代码"></a>无名信号量实现代码</h2><p>TODO</p>
<hr>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/04/11/fVro5qemNcBIYGE.jpg" alt="69494078_p0_master1200.jpg"></p>
]]></content>
      <tags>
        <tag>ipc</tag>
      </tags>
  </entry>
  <entry>
    <title>协程</title>
    <url>/2020-04-19-%E5%8D%8F%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhihu.com/question/20511233">协程的好处有哪些</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/52061644">协程原理解析(1)</a></p>
<p><a href="https://github.com/cloudwu/coroutine/blob/master/coroutine.c">云风的coroutine实现</a></p>
<p><a href="http://www.ilovecpp.com/2018/12/19/coroutine/">协程那些事儿</a></p>
<a id="more"></a>

<h2 id="context族函数"><a href="#context族函数" class="headerlink" title="context族函数"></a>context族函数</h2><h3 id="ucontext-t"><a href="#ucontext-t" class="headerlink" title="ucontext_t"></a>ucontext_t</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Userlevel context.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ucontext_t</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> __ctx(uc_flags);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ucontext_t</span> *<span class="title">uc_link</span>;</span></span><br><span class="line">    <span class="keyword">stack_t</span> uc_stack;</span><br><span class="line">    <span class="keyword">mcontext_t</span> uc_mcontext;</span><br><span class="line">    <span class="keyword">sigset_t</span> uc_sigmask;</span><br><span class="line">  &#125; <span class="keyword">ucontext_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Structure describing a signal stack.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *ss_sp;</span><br><span class="line">    <span class="keyword">int</span> ss_flags;</span><br><span class="line">    <span class="keyword">size_t</span> ss_size;</span><br><span class="line">  &#125; <span class="keyword">stack_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Context to describe whole processor state.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">gregset_t</span> __ctx(gregs);</span><br><span class="line">    <span class="comment">/* Note that fpregs is a pointer.  */</span></span><br><span class="line">    <span class="keyword">fpregset_t</span> __ctx(fpregs);</span><br><span class="line">    __extension__ <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> __reserved1 [<span class="number">8</span>];</span><br><span class="line">&#125; <span class="keyword">mcontext_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">greg_t</span> <span class="keyword">gregset_t</span>[<span class="number">23</span>];</span><br><span class="line">__extension__ <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="keyword">greg_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">libc_fpstate</span> *<span class="title">fpregset_t</span>;</span></span><br></pre></td></tr></table></figure>

<h3 id="getcontext"><a href="#getcontext" class="headerlink" title="getcontext"></a>getcontext</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Get user context and store it in variable pointed to by UCP.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">getcontext</span> <span class="params">(<span class="keyword">ucontext_t</span> *__ucp)</span> __THROWNL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Save current context.</span></span><br><span class="line"><span class="comment">   Copyright (C) 2002-2019 Free Software Foundation, Inc.</span></span><br><span class="line"><span class="comment">   This file is part of the GNU C Library.</span></span><br><span class="line"><span class="comment">   Contributed by Andreas Jaeger &lt;aj@suse.de&gt;, 2002.</span></span><br><span class="line"><span class="comment">   The GNU C Library is free software; you can redistribute it and/or</span></span><br><span class="line"><span class="comment">   modify it under the terms of the GNU Lesser General Public</span></span><br><span class="line"><span class="comment">   License as published by the Free Software Foundation; either</span></span><br><span class="line"><span class="comment">   version 2.1 of the License, or (at your option) any later version.</span></span><br><span class="line"><span class="comment">   The GNU C Library is distributed in the hope that it will be useful,</span></span><br><span class="line"><span class="comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span></span><br><span class="line"><span class="comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span></span><br><span class="line"><span class="comment">   Lesser General Public License for more details.</span></span><br><span class="line"><span class="comment">   You should have received a copy of the GNU Lesser General Public</span></span><br><span class="line"><span class="comment">   License along with the GNU C Library; if not, see</span></span><br><span class="line"><span class="comment">   &lt;http://www.gnu.org/licenses/&gt;.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sysdep.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ucontext_i.h&quot;</span></span></span><br><span class="line"><span class="comment">/*  int __getcontext (ucontext_t *ucp)</span></span><br><span class="line"><span class="comment">  Saves the machine context in UCP such that when it is activated,</span></span><br><span class="line"><span class="comment">  it appears as if __getcontext() returned again.</span></span><br><span class="line"><span class="comment">  This implementation is intended to be used for *synchronous* context</span></span><br><span class="line"><span class="comment">  switches only.  Therefore, it does not have to save anything</span></span><br><span class="line"><span class="comment">  other than the PRESERVED state.  */</span></span><br><span class="line">ENTRY(__getcontext)</span><br><span class="line">        <span class="comment">/* Save the preserved registers, the registers used for passing</span></span><br><span class="line"><span class="comment">           args, and the return address.  */</span></span><br><span class="line">        movq        %rbx, oRBX(%rdi)</span><br><span class="line">        movq        %rbp, oRBP(%rdi)</span><br><span class="line">        movq        %r12, oR12(%rdi)</span><br><span class="line">        movq        %r13, oR13(%rdi)</span><br><span class="line">        movq        %r14, oR14(%rdi)</span><br><span class="line">        movq        %r15, oR15(%rdi)</span><br><span class="line">        movq        %rdi, oRDI(%rdi)</span><br><span class="line">        movq        %rsi, oRSI(%rdi)</span><br><span class="line">        movq        %rdx, oRDX(%rdi)</span><br><span class="line">        movq        %rcx, oRCX(%rdi)</span><br><span class="line">        movq        %r8, oR8(%rdi)</span><br><span class="line">        movq        %r9, oR9(%rdi)</span><br><span class="line">        movq        (%rsp), %rcx</span><br><span class="line">        movq        %rcx, oRIP(%rdi)</span><br><span class="line">        leaq        <span class="number">8</span>(%rsp), %rcx                <span class="comment">/* Exclude the return address.  */</span></span><br><span class="line">        movq        %rcx, oRSP(%rdi)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SHSTK_ENABLED</span></span><br><span class="line">        <span class="comment">/* Check if shadow stack is enabled.  */</span></span><br><span class="line">        testl        $X86_FEATURE_1_SHSTK, %fs:FEATURE_1_OFFSET</span><br><span class="line">        <span class="function">jz        <span class="title">L</span><span class="params">(no_shstk)</span></span></span><br><span class="line"><span class="function">        <span class="comment">/* Save RDI in RDX which won&#x27;t be clobbered by syscall.  */</span></span></span><br><span class="line">        movq        %rdi, %rdx</span><br><span class="line">        xorl        %eax, %eax</span><br><span class="line">        cmpq        %fs:SSP_BASE_OFFSET, %rax</span><br><span class="line">        <span class="function">jnz        <span class="title">L</span><span class="params">(shadow_stack_bound_recorded)</span></span></span><br><span class="line"><span class="function">        <span class="comment">/* Get the base address and size of the default shadow stack</span></span></span><br><span class="line"><span class="function"><span class="comment">           which must be the current shadow stack since nothing has</span></span></span><br><span class="line"><span class="function"><span class="comment">           been recorded yet.  */</span></span></span><br><span class="line">        sub        $24, %RSP_LP</span><br><span class="line">        mov        %RSP_LP, %RSI_LP</span><br><span class="line">        movl        $ARCH_CET_STATUS, %edi</span><br><span class="line">        movl        $__NR_arch_prctl, %eax</span><br><span class="line">        syscall</span><br><span class="line">        testq        %rax, %rax</span><br><span class="line">        <span class="function">jz        <span class="title">L</span><span class="params">(continue_no_err)</span></span></span><br><span class="line"><span class="function">        <span class="comment">/* This should never happen.  */</span></span></span><br><span class="line"><span class="function">        hlt</span></span><br><span class="line"><span class="function"><span class="title">L</span><span class="params">(continue_no_err)</span>:</span></span><br><span class="line"><span class="function">        <span class="comment">/* Record the base of the current shadow stack.  */</span></span></span><br><span class="line">        movq        8(%rsp), %rax</span><br><span class="line">        movq        %rax, %fs:SSP_BASE_OFFSET</span><br><span class="line">        add        $<span class="number">24</span>, %RSP_LP</span><br><span class="line">        <span class="comment">/* Restore RDI.  */</span></span><br><span class="line">        movq        %rdx, %rdi</span><br><span class="line">L(shadow_stack_bound_recorded):</span><br><span class="line">        <span class="comment">/* Get the current shadow stack pointer.  */</span></span><br><span class="line">        rdsspq        %rax</span><br><span class="line">        <span class="comment">/* NB: Save the caller&#x27;s shadow stack so that we can jump back</span></span><br><span class="line"><span class="comment">           to the caller directly.  */</span></span><br><span class="line">        addq        $<span class="number">8</span>, %rax</span><br><span class="line">        movq        %rax, oSSP(%rdx)</span><br><span class="line">        <span class="comment">/* Save the current shadow stack base in ucontext.  */</span></span><br><span class="line">        movq        %fs:SSP_BASE_OFFSET, %rax</span><br><span class="line">        movq        %rax, (oSSP + <span class="number">8</span>)(%rdi)</span><br><span class="line">L(no_shstk):</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">/* We have separate floating-point register content memory on the</span></span><br><span class="line"><span class="comment">           stack.  We use the __fpregs_mem block in the context.  Set the</span></span><br><span class="line"><span class="comment">           links up correctly.  */</span></span><br><span class="line">        leaq        oFPREGSMEM(%rdi), %rcx</span><br><span class="line">        movq        %rcx, oFPREGS(%rdi)</span><br><span class="line">        <span class="comment">/* Save the floating-point environment.  */</span></span><br><span class="line">        fnstenv        (%rcx)</span><br><span class="line">        fldenv        (%rcx)</span><br><span class="line">        <span class="function">stmxcsr <span class="title">oMXCSR</span><span class="params">(%rdi)</span></span></span><br><span class="line"><span class="function">        <span class="comment">/* Save the current signal mask with</span></span></span><br><span class="line"><span class="function"><span class="comment">           rt_sigprocmask (SIG_BLOCK, NULL, set,_NSIG/8).  */</span></span></span><br><span class="line">        leaq        oSIGMASK(%rdi), %rdx</span><br><span class="line">        xorl        %esi,%esi</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SIG_BLOCK == 0</span></span><br><span class="line">        xorl        %edi, %edi</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        movl        $SIG_BLOCK, %edi</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        movl        $_NSIG8,%r10d</span><br><span class="line">        movl        $__NR_rt_sigprocmask, %eax</span><br><span class="line">        syscall</span><br><span class="line">        cmpq        $<span class="number">-4095</span>, %rax                <span class="comment">/* Check %rax for error.  */</span></span><br><span class="line">        jae        SYSCALL_ERROR_LABEL        <span class="comment">/* Jump to error handler if error.  */</span></span><br><span class="line">        <span class="comment">/* All done, return 0 for success.  */</span></span><br><span class="line">        xorl        %eax, %eax</span><br><span class="line">        ret</span><br><span class="line">PSEUDO_END(__getcontext)</span><br><span class="line">weak_alias (__getcontext, getcontext)</span><br></pre></td></tr></table></figure>

<h3 id="makecontext"><a href="#makecontext" class="headerlink" title="makecontext"></a>makecontext</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Manipulate user context UCP to continue with calling functions FUNC</span></span><br><span class="line"><span class="comment">   and the ARGC-1 parameters following ARGC when the context is used</span></span><br><span class="line"><span class="comment">   the next time in `setcontext&#x27; or `swapcontext&#x27;.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   We cannot say anything about the parameters FUNC takes; `void&#x27;</span></span><br><span class="line"><span class="comment">   is as good as any other choice.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">makecontext</span> <span class="params">(<span class="keyword">ucontext_t</span> *__ucp, <span class="keyword">void</span> (*__func) (<span class="keyword">void</span>),</span></span></span><br><span class="line"><span class="function"><span class="params">			 <span class="keyword">int</span> __argc, ...)</span> __THROW</span>;</span><br><span class="line">             </span><br><span class="line"><span class="comment">/* This implementation can handle any ARGC value but only</span></span><br><span class="line"><span class="comment">   normal integer parameters.</span></span><br><span class="line"><span class="comment">   makecontext sets up a stack and the registers for the</span></span><br><span class="line"><span class="comment">   user context. The stack looks like this:</span></span><br><span class="line"><span class="comment">               +-----------------------+</span></span><br><span class="line"><span class="comment">               | next context          |</span></span><br><span class="line"><span class="comment">               +-----------------------+</span></span><br><span class="line"><span class="comment">               | parameter 7-n         |</span></span><br><span class="line"><span class="comment">	       +-----------------------+</span></span><br><span class="line"><span class="comment">	       | trampoline address    |</span></span><br><span class="line"><span class="comment">    %rsp -&gt;    +-----------------------+</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The registers are set up like this:</span></span><br><span class="line"><span class="comment">     %rdi,%rsi,%rdx,%rcx,%r8,%r9: parameter 1 to 6</span></span><br><span class="line"><span class="comment">     %rbx   : address of next context</span></span><br><span class="line"><span class="comment">     %rsp   : stack pointer.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* <span class="doctag">XXX:</span> This implementation currently only handles integer arguments.</span></span><br><span class="line"><span class="comment">   To handle long int and pointer arguments the va_arg arguments needs</span></span><br><span class="line"><span class="comment">   to be changed to long and also the stdlib/tst-setcontext.c file needs</span></span><br><span class="line"><span class="comment">   to be changed to pass long arguments to makecontext.  */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">__makecontext (<span class="keyword">ucontext_t</span> *ucp, <span class="keyword">void</span> (*func) (<span class="keyword">void</span>), <span class="keyword">int</span> argc, ...)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">void</span> __start_context (<span class="keyword">void</span>) attribute_hidden;</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">void</span> __push___start_context (<span class="keyword">ucontext_t</span> *)</span><br><span class="line">    attribute_hidden;</span><br><span class="line">  <span class="keyword">greg_t</span> *sp;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> idx_uc_link;</span><br><span class="line">  va_list ap;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Generate room on stack for parameter if needed and uc_link.  */</span></span><br><span class="line">  sp = (<span class="keyword">greg_t</span> *) ((<span class="keyword">uintptr_t</span>) ucp-&gt;uc_stack.ss_sp</span><br><span class="line">		   + ucp-&gt;uc_stack.ss_size);</span><br><span class="line">  sp -= (argc &gt; <span class="number">6</span> ? argc - <span class="number">6</span> : <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">  <span class="comment">/* Align stack and make space for trampoline address.  */</span></span><br><span class="line">  sp = (<span class="keyword">greg_t</span> *) ((((<span class="keyword">uintptr_t</span>) sp) &amp; <span class="number">-16L</span>) - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">  idx_uc_link = (argc &gt; <span class="number">6</span> ? argc - <span class="number">6</span> : <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Setup context ucp.  */</span></span><br><span class="line">  <span class="comment">/* Address to jump to.  */</span></span><br><span class="line">  ucp-&gt;uc_mcontext.gregs[REG_RIP] = (<span class="keyword">uintptr_t</span>) func;</span><br><span class="line">  <span class="comment">/* Setup rbx.*/</span></span><br><span class="line">  ucp-&gt;uc_mcontext.gregs[REG_RBX] = (<span class="keyword">uintptr_t</span>) &amp;sp[idx_uc_link];</span><br><span class="line">  ucp-&gt;uc_mcontext.gregs[REG_RSP] = (<span class="keyword">uintptr_t</span>) sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Setup stack.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SHSTK_ENABLED</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pthread</span> *<span class="title">self</span> =</span> THREAD_SELF;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> feature_1 = THREAD_GETMEM (self, header.feature_1);</span><br><span class="line">  <span class="comment">/* NB: We must check feature_1 before accessing __ssp since caller</span></span><br><span class="line"><span class="comment">	 may be compiled against ucontext_t without __ssp.  */</span></span><br><span class="line">  <span class="keyword">if</span> ((feature_1 &amp; X86_FEATURE_1_SHSTK) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Shadow stack is enabled.  We need to allocate a new shadow</span></span><br><span class="line"><span class="comment">         stack.  */</span></span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">long</span> ssp_size = (((<span class="keyword">uintptr_t</span>) sp</span><br><span class="line">				 - (<span class="keyword">uintptr_t</span>) ucp-&gt;uc_stack.ss_sp)</span><br><span class="line">				&gt;&gt; STACK_SIZE_TO_SHADOW_STACK_SIZE_SHIFT);</span><br><span class="line">      <span class="comment">/* Align shadow stack to 8 bytes.  */</span></span><br><span class="line">      ssp_size = ALIGN_UP (ssp_size, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">      ucp-&gt;__ssp[<span class="number">1</span>] = ssp_size;</span><br><span class="line">      ucp-&gt;__ssp[<span class="number">2</span>] = ssp_size;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Call __push___start_context to allocate a new shadow stack,</span></span><br><span class="line"><span class="comment">	 push __start_context onto the new stack as well as the new</span></span><br><span class="line"><span class="comment">	 shadow stack.  NB: After __push___start_context returns,</span></span><br><span class="line"><span class="comment">	   ucp-&gt;__ssp[0]: The new shadow stack pointer.</span></span><br><span class="line"><span class="comment">	   ucp-&gt;__ssp[1]: The base address of the new shadow stack.</span></span><br><span class="line"><span class="comment">	   ucp-&gt;__ssp[2]: The size of the new shadow stack.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      __push___start_context (ucp);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    sp[<span class="number">0</span>] = (<span class="keyword">uintptr_t</span>) &amp;__start_context;</span><br><span class="line">  sp[idx_uc_link] = (<span class="keyword">uintptr_t</span>) ucp-&gt;uc_link;</span><br><span class="line"></span><br><span class="line">  va_start (ap, argc);</span><br><span class="line">  <span class="comment">/* Handle arguments.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     The standard says the parameters must all be int values.  This is</span></span><br><span class="line"><span class="comment">     an historic accident and would be done differently today.  For</span></span><br><span class="line"><span class="comment">     x86-64 all integer values are passed as 64-bit values and</span></span><br><span class="line"><span class="comment">     therefore extending the API to copy 64-bit values instead of</span></span><br><span class="line"><span class="comment">     32-bit ints makes sense.  It does not break existing</span></span><br><span class="line"><span class="comment">     functionality and it does not violate the standard which says</span></span><br><span class="line"><span class="comment">     that passing non-int values means undefined behavior.  */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; ++i)</span><br><span class="line">    <span class="keyword">switch</span> (i)</span><br><span class="line">      &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">	ucp-&gt;uc_mcontext.gregs[REG_RDI] = va_arg (ap, <span class="keyword">greg_t</span>);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">	ucp-&gt;uc_mcontext.gregs[REG_RSI] = va_arg (ap, <span class="keyword">greg_t</span>);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">	ucp-&gt;uc_mcontext.gregs[REG_RDX] = va_arg (ap, <span class="keyword">greg_t</span>);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">	ucp-&gt;uc_mcontext.gregs[REG_RCX] = va_arg (ap, <span class="keyword">greg_t</span>);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">	ucp-&gt;uc_mcontext.gregs[REG_R8] = va_arg (ap, <span class="keyword">greg_t</span>);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">	ucp-&gt;uc_mcontext.gregs[REG_R9] = va_arg (ap, <span class="keyword">greg_t</span>);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">	<span class="comment">/* Put value on stack.  */</span></span><br><span class="line">	sp[i - <span class="number">5</span>] = va_arg (ap, <span class="keyword">greg_t</span>);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  va_end (ap);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>uc_link存放的是下一个要执行的上下文的地址，如果uc_link为NULL,则当前ucontext执行完，线程就退出了</li>
<li>uc_stack是即将运行的func使用的堆栈空间，不同于函数递归使用一个栈可能引起的栈溢出，这里栈空间可以自行分配</li>
</ul>
<h3 id="setcontext"><a href="#setcontext" class="headerlink" title="setcontext"></a>setcontext</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Set user context from information of variable pointed to by UCP.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">setcontext</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">ucontext_t</span> *__ucp)</span> __THROWNL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Install given context.</span></span><br><span class="line"><span class="comment">   Copyright (C) 2002-2019 Free Software Foundation, Inc.</span></span><br><span class="line"><span class="comment">   This file is part of the GNU C Library.</span></span><br><span class="line"><span class="comment">   Contributed by Andreas Jaeger &lt;aj@suse.de&gt;, 2002.</span></span><br><span class="line"><span class="comment">   The GNU C Library is free software; you can redistribute it and/or</span></span><br><span class="line"><span class="comment">   modify it under the terms of the GNU Lesser General Public</span></span><br><span class="line"><span class="comment">   License as published by the Free Software Foundation; either</span></span><br><span class="line"><span class="comment">   version 2.1 of the License, or (at your option) any later version.</span></span><br><span class="line"><span class="comment">   The GNU C Library is distributed in the hope that it will be useful,</span></span><br><span class="line"><span class="comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span></span><br><span class="line"><span class="comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span></span><br><span class="line"><span class="comment">   Lesser General Public License for more details.</span></span><br><span class="line"><span class="comment">   You should have received a copy of the GNU Lesser General Public</span></span><br><span class="line"><span class="comment">   License along with the GNU C Library; if not, see</span></span><br><span class="line"><span class="comment">   &lt;http://www.gnu.org/licenses/&gt;.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sysdep.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ucontext_i.h&quot;</span></span></span><br><span class="line"><span class="comment">/*  int __setcontext (const ucontext_t *ucp)</span></span><br><span class="line"><span class="comment">  Restores the machine context in UCP and thereby resumes execution</span></span><br><span class="line"><span class="comment">  in that context.</span></span><br><span class="line"><span class="comment">  This implementation is intended to be used for *synchronous* context</span></span><br><span class="line"><span class="comment">  switches only.  Therefore, it does not have to restore anything</span></span><br><span class="line"><span class="comment">  other than the PRESERVED state.  */</span></span><br><span class="line">ENTRY(__setcontext)</span><br><span class="line">        <span class="comment">/* Save argument since syscall will destroy it.  */</span></span><br><span class="line">        pushq        %rdi</span><br><span class="line">        cfi_adjust_cfa_offset(<span class="number">8</span>)</span><br><span class="line">        <span class="comment">/* Set the signal mask with</span></span><br><span class="line"><span class="comment">           rt_sigprocmask (SIG_SETMASK, mask, NULL, _NSIG/8).  */</span></span><br><span class="line">        leaq        oSIGMASK(%rdi), %rsi</span><br><span class="line">        xorl        %edx, %edx</span><br><span class="line">        movl        $SIG_SETMASK, %edi</span><br><span class="line">        movl        $_NSIG8,%r10d</span><br><span class="line">        movl        $__NR_rt_sigprocmask, %eax</span><br><span class="line">        syscall</span><br><span class="line">        <span class="comment">/* Pop the pointer into RDX. The choice is arbitrary, but</span></span><br><span class="line"><span class="comment">           leaving RDI and RSI available for use later can avoid</span></span><br><span class="line"><span class="comment">           shuffling values.  */</span></span><br><span class="line">        popq        %rdx</span><br><span class="line">        cfi_adjust_cfa_offset(<span class="number">-8</span>)</span><br><span class="line">        cmpq        $<span class="number">-4095</span>, %rax                <span class="comment">/* Check %rax for error.  */</span></span><br><span class="line">        jae        SYSCALL_ERROR_LABEL        <span class="comment">/* Jump to error handler if error.  */</span></span><br><span class="line">        <span class="comment">/* Restore the floating-point context.  Not the registers, only the</span></span><br><span class="line"><span class="comment">           rest.  */</span></span><br><span class="line">        movq        oFPREGS(%rdx), %rcx</span><br><span class="line">        fldenv        (%rcx)</span><br><span class="line">        <span class="function">ldmxcsr <span class="title">oMXCSR</span><span class="params">(%rdx)</span></span></span><br><span class="line"><span class="function">        <span class="comment">/* Load the new stack pointer, the preserved registers and</span></span></span><br><span class="line"><span class="function"><span class="comment">           registers used for passing args.  */</span></span></span><br><span class="line"><span class="function">        <span class="title">cfi_def_cfa</span><span class="params">(%rdx, <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">        <span class="title">cfi_offset</span><span class="params">(%rbx,oRBX)</span></span></span><br><span class="line"><span class="function">        <span class="title">cfi_offset</span><span class="params">(%rbp,oRBP)</span></span></span><br><span class="line"><span class="function">        <span class="title">cfi_offset</span><span class="params">(%r12,oR12)</span></span></span><br><span class="line"><span class="function">        <span class="title">cfi_offset</span><span class="params">(%r13,oR13)</span></span></span><br><span class="line"><span class="function">        <span class="title">cfi_offset</span><span class="params">(%r14,oR14)</span></span></span><br><span class="line"><span class="function">        <span class="title">cfi_offset</span><span class="params">(%r15,oR15)</span></span></span><br><span class="line"><span class="function">        <span class="title">cfi_offset</span><span class="params">(%rsp,oRSP)</span></span></span><br><span class="line"><span class="function">        <span class="title">cfi_offset</span><span class="params">(%rip,oRIP)</span></span></span><br><span class="line">        movq        oRSP(%rdx), %rsp</span><br><span class="line">        movq        oRBX(%rdx), %rbx</span><br><span class="line">        movq        oRBP(%rdx), %rbp</span><br><span class="line">        movq        oR12(%rdx), %r12</span><br><span class="line">        movq        oR13(%rdx), %r13</span><br><span class="line">        movq        oR14(%rdx), %r14</span><br><span class="line">        movq        oR15(%rdx), %r15</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SHSTK_ENABLED</span></span><br><span class="line">        <span class="comment">/* Check if shadow stack is enabled.  */</span></span><br><span class="line">        testl        $X86_FEATURE_1_SHSTK, %fs:FEATURE_1_OFFSET</span><br><span class="line">        <span class="function">jz        <span class="title">L</span><span class="params">(no_shstk)</span></span></span><br><span class="line"><span class="function">        <span class="comment">/* If the base of the target shadow stack is the same as the</span></span></span><br><span class="line"><span class="function"><span class="comment">           base of the current shadow stack, we unwind the shadow</span></span></span><br><span class="line"><span class="function"><span class="comment">           stack.  Otherwise it is a stack switch and we look for a</span></span></span><br><span class="line"><span class="function"><span class="comment">           restore token.  */</span></span></span><br><span class="line">        movq        oSSP(%rdx), %rsi</span><br><span class="line">        movq        %rsi, %rdi</span><br><span class="line">        <span class="comment">/* Get the base of the target shadow stack.  */</span></span><br><span class="line">        movq        (oSSP + <span class="number">8</span>)(%rdx), %rcx</span><br><span class="line">        cmpq        %fs:SSP_BASE_OFFSET, %rcx</span><br><span class="line">        <span class="function">je        <span class="title">L</span><span class="params">(unwind_shadow_stack)</span></span></span><br><span class="line"><span class="function"><span class="title">L</span><span class="params">(find_restore_token_loop)</span>:</span></span><br><span class="line"><span class="function">        <span class="comment">/* Look for a restore token.  */</span></span></span><br><span class="line">        movq        -8(%rsi), %rax</span><br><span class="line">        andq        $<span class="number">-8</span>, %rax</span><br><span class="line">        cmpq        %rsi, %rax</span><br><span class="line">        <span class="function">je        <span class="title">L</span><span class="params">(restore_shadow_stack)</span></span></span><br><span class="line"><span class="function">        <span class="comment">/* Try the next slot.  */</span></span></span><br><span class="line">        subq        $8, %rsi</span><br><span class="line">        <span class="function">jmp        <span class="title">L</span><span class="params">(find_restore_token_loop)</span></span></span><br><span class="line"><span class="function"><span class="title">L</span><span class="params">(restore_shadow_stack)</span>:</span></span><br><span class="line"><span class="function">        <span class="comment">/* Pop return address from the shadow stack since setcontext</span></span></span><br><span class="line"><span class="function"><span class="comment">           will not return.  */</span></span></span><br><span class="line">        movq        $1, %rax</span><br><span class="line">        incsspq        %rax</span><br><span class="line">        <span class="comment">/* Use the restore stoken to restore the target shadow stack.  */</span></span><br><span class="line">        rstorssp <span class="number">-8</span>(%rsi)</span><br><span class="line">        <span class="comment">/* Save the restore token on the old shadow stack.  NB: This</span></span><br><span class="line"><span class="comment">           restore token may be checked by setcontext or swapcontext</span></span><br><span class="line"><span class="comment">           later.  */</span></span><br><span class="line">        saveprevssp</span><br><span class="line">        <span class="comment">/* Record the new shadow stack base that was switched to.  */</span></span><br><span class="line">        movq        (oSSP + <span class="number">8</span>)(%rdx), %rax</span><br><span class="line">        movq        %rax, %fs:SSP_BASE_OFFSET</span><br><span class="line">L(unwind_shadow_stack):</span><br><span class="line">        rdsspq        %rcx</span><br><span class="line">        subq        %rdi, %rcx</span><br><span class="line">        <span class="function">je        <span class="title">L</span><span class="params">(skip_unwind_shadow_stack)</span></span></span><br><span class="line">        negq        %rcx</span><br><span class="line">        shrq        $<span class="number">3</span>, %rcx</span><br><span class="line">        movl        $<span class="number">255</span>, %esi</span><br><span class="line">L(loop):</span><br><span class="line">        cmpq        %rsi, %rcx</span><br><span class="line">        cmovb        %rcx, %rsi</span><br><span class="line">        incsspq        %rsi</span><br><span class="line">        subq        %rsi, %rcx</span><br><span class="line">        <span class="function">ja        <span class="title">L</span><span class="params">(loop)</span></span></span><br><span class="line"><span class="function"><span class="title">L</span><span class="params">(skip_unwind_shadow_stack)</span>:</span></span><br><span class="line">        movq        oRSI(%rdx), %rsi</span><br><span class="line">        movq        oRDI(%rdx), %rdi</span><br><span class="line">        movq        oRCX(%rdx), %rcx</span><br><span class="line">        movq        oR8(%rdx), %r8</span><br><span class="line">        movq        oR9(%rdx), %r9</span><br><span class="line">        <span class="comment">/* Get the return address set with getcontext.  */</span></span><br><span class="line">        movq        oRIP(%rdx), %r10</span><br><span class="line">        <span class="comment">/* Setup finally %rdx.  */</span></span><br><span class="line">        movq        oRDX(%rdx), %rdx</span><br><span class="line">        <span class="comment">/* Check if return address is valid for the case when setcontext</span></span><br><span class="line"><span class="comment">           is invoked from __start_context with linked context.  */</span></span><br><span class="line">        rdsspq        %rax</span><br><span class="line">        cmpq        (%rax), %r10</span><br><span class="line">        <span class="comment">/* Clear RAX to indicate success.  NB: Don&#x27;t use xorl to keep</span></span><br><span class="line"><span class="comment">           EFLAGS for jne.  */</span></span><br><span class="line">        movl        $<span class="number">0</span>, %eax</span><br><span class="line">        <span class="function">jne        <span class="title">L</span><span class="params">(jmp)</span></span></span><br><span class="line"><span class="function">        <span class="comment">/* Return to the new context if return address valid.  */</span></span></span><br><span class="line">        pushq        %r10</span><br><span class="line">        ret</span><br><span class="line">L(jmp):</span><br><span class="line">        <span class="comment">/* Jump to the new context directly.  */</span></span><br><span class="line">        jmp        *%r10</span><br><span class="line">L(no_shstk):</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">/* The following ret should return to the address set with</span></span><br><span class="line"><span class="comment">        getcontext.  Therefore push the address on the stack.  */</span></span><br><span class="line">        movq        oRIP(%rdx), %rcx</span><br><span class="line">        pushq        %rcx</span><br><span class="line">        movq        oRSI(%rdx), %rsi</span><br><span class="line">        movq        oRDI(%rdx), %rdi</span><br><span class="line">        movq        oRCX(%rdx), %rcx</span><br><span class="line">        movq        oR8(%rdx), %r8</span><br><span class="line">        movq        oR9(%rdx), %r9</span><br><span class="line">        <span class="comment">/* Setup finally %rdx.  */</span></span><br><span class="line">        movq        oRDX(%rdx), %rdx</span><br><span class="line">        <span class="comment">/* End FDE here, we fall into another context.  */</span></span><br><span class="line">        cfi_endproc</span><br><span class="line">        cfi_startproc</span><br><span class="line">        <span class="comment">/* Clear rax to indicate success.  */</span></span><br><span class="line">        xorl        %eax, %eax</span><br><span class="line">        ret</span><br><span class="line">PSEUDO_END(__setcontext)</span><br><span class="line">weak_alias (__setcontext, setcontext)</span><br></pre></td></tr></table></figure>

<h3 id="swapcontext"><a href="#swapcontext" class="headerlink" title="swapcontext"></a>swapcontext</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Save current context in context variable pointed to by OUCP and set</span></span><br><span class="line"><span class="comment">   context from variable pointed to by UCP.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">swapcontext</span> <span class="params">(<span class="keyword">ucontext_t</span> *__restrict __oucp,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">const</span> <span class="keyword">ucontext_t</span> *__restrict __ucp)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//hppa实现</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function">__<span class="title">swapcontext</span> <span class="params">(<span class="keyword">ucontext_t</span> *oucp, <span class="keyword">const</span> <span class="keyword">ucontext_t</span> *ucp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Save the current machine context to oucp.  */</span></span><br><span class="line">  __getcontext (oucp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* mark sc_sar flag to skip the setcontext call on reactivation.  */</span></span><br><span class="line">  <span class="keyword">if</span> (oucp-&gt;uc_mcontext.sc_sar == <span class="number">0</span>) &#123;</span><br><span class="line">	oucp-&gt;uc_mcontext.sc_sar++;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Restore the machine context in ucp.  */</span></span><br><span class="line">	__setcontext (ucp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//ia64实现</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">__swapcontext (<span class="keyword">ucontext_t</span> *oucp, <span class="keyword">const</span> <span class="keyword">ucontext_t</span> *ucp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rv</span> <span class="title">rv</span> =</span> __getcontext (oucp);</span><br><span class="line">  <span class="keyword">if</span> (rv.first_return)</span><br><span class="line">    __setcontext (ucp);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="云风源码研读"><a href="#云风源码研读" class="headerlink" title="云风源码研读"></a>云风源码研读</h2><p>TODO</p>
<h3 id="coroutine-c"><a href="#coroutine-c" class="headerlink" title="coroutine.c"></a>coroutine.c</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;coroutine.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __APPLE__ &amp;&amp; __MACH__</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ucontext.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> </span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ucontext.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE (1024*1024)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_COROUTINE 16</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">coroutine</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">schedule</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> <span class="built_in">stack</span>[STACK_SIZE];</span><br><span class="line">	<span class="keyword">ucontext_t</span> main;</span><br><span class="line">	<span class="keyword">int</span> nco;</span><br><span class="line">	<span class="keyword">int</span> cap;</span><br><span class="line">	<span class="keyword">int</span> running;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">coroutine</span> **<span class="title">co</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">coroutine</span> &#123;</span></span><br><span class="line">	coroutine_func func;</span><br><span class="line">	<span class="keyword">void</span> *ud;</span><br><span class="line">	<span class="keyword">ucontext_t</span> ctx;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">schedule</span> * <span class="title">sch</span>;</span></span><br><span class="line">	<span class="keyword">ptrdiff_t</span> cap;</span><br><span class="line">	<span class="keyword">ptrdiff_t</span> size;</span><br><span class="line">	<span class="keyword">int</span> status;</span><br><span class="line">	<span class="keyword">char</span> *<span class="built_in">stack</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">coroutine</span> * </span></span><br><span class="line"><span class="class">_<span class="title">co_new</span>(<span class="keyword">struct</span> <span class="title">schedule</span> *<span class="title">S</span> , <span class="title">coroutine_func</span> <span class="title">func</span>, <span class="title">void</span> *<span class="title">ud</span>) &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">coroutine</span> * <span class="title">co</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*co));</span><br><span class="line">	co-&gt;func = func;</span><br><span class="line">	co-&gt;ud = ud;</span><br><span class="line">	co-&gt;sch = S;</span><br><span class="line">	co-&gt;cap = <span class="number">0</span>;</span><br><span class="line">	co-&gt;size = <span class="number">0</span>;</span><br><span class="line">	co-&gt;status = COROUTINE_READY;</span><br><span class="line">	co-&gt;<span class="built_in">stack</span> = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> co;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_co_delete(struct coroutine *co) &#123;</span><br><span class="line">	<span class="built_in">free</span>(co-&gt;<span class="built_in">stack</span>);</span><br><span class="line">	<span class="built_in">free</span>(co);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">schedule</span> * </span></span><br><span class="line"><span class="class"><span class="title">coroutine_open</span>(<span class="title">void</span>) &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">schedule</span> *<span class="title">S</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*S));</span><br><span class="line">	S-&gt;nco = <span class="number">0</span>;</span><br><span class="line">	S-&gt;cap = DEFAULT_COROUTINE;</span><br><span class="line">	S-&gt;running = <span class="number">-1</span>;</span><br><span class="line">	S-&gt;co = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct coroutine *) * S-&gt;cap);</span><br><span class="line">	<span class="built_in">memset</span>(S-&gt;co, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct coroutine *) * S-&gt;cap);</span><br><span class="line">	<span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">coroutine_close(struct schedule *S) &#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;S-&gt;cap;i++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">coroutine</span> * <span class="title">co</span> =</span> S-&gt;co[i];</span><br><span class="line">		<span class="keyword">if</span> (co) &#123;</span><br><span class="line">			_co_delete(co);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(S-&gt;co);</span><br><span class="line">	S-&gt;co = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">free</span>(S);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> </span><br><span class="line">coroutine_new(struct schedule *S, coroutine_func func, <span class="keyword">void</span> *ud) &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">coroutine</span> *<span class="title">co</span> =</span> _co_new(S, func , ud);</span><br><span class="line">	<span class="keyword">if</span> (S-&gt;nco &gt;= S-&gt;cap) &#123;</span><br><span class="line">		<span class="keyword">int</span> id = S-&gt;cap;</span><br><span class="line">		S-&gt;co = <span class="built_in">realloc</span>(S-&gt;co, S-&gt;cap * <span class="number">2</span> * <span class="keyword">sizeof</span>(struct coroutine *));</span><br><span class="line">		<span class="built_in">memset</span>(S-&gt;co + S-&gt;cap , <span class="number">0</span> , <span class="keyword">sizeof</span>(struct coroutine *) * S-&gt;cap);</span><br><span class="line">		S-&gt;co[S-&gt;cap] = co;</span><br><span class="line">		S-&gt;cap *= <span class="number">2</span>;</span><br><span class="line">		++S-&gt;nco;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;S-&gt;cap;i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> id = (i+S-&gt;nco) % S-&gt;cap;</span><br><span class="line">			<span class="keyword">if</span> (S-&gt;co[id] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">				S-&gt;co[id] = co;</span><br><span class="line">				++S-&gt;nco;</span><br><span class="line">				<span class="keyword">return</span> id;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	assert(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">mainfunc(<span class="keyword">uint32_t</span> low32, <span class="keyword">uint32_t</span> hi32) &#123;</span><br><span class="line">	<span class="keyword">uintptr_t</span> ptr = (<span class="keyword">uintptr_t</span>)low32 | ((<span class="keyword">uintptr_t</span>)hi32 &lt;&lt; <span class="number">32</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">schedule</span> *<span class="title">S</span> =</span> (struct schedule *)ptr;</span><br><span class="line">	<span class="keyword">int</span> id = S-&gt;running;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">coroutine</span> *<span class="title">C</span> =</span> S-&gt;co[id];</span><br><span class="line">	C-&gt;func(S,C-&gt;ud);</span><br><span class="line">	_co_delete(C);</span><br><span class="line">	S-&gt;co[id] = <span class="literal">NULL</span>;</span><br><span class="line">	--S-&gt;nco;</span><br><span class="line">	S-&gt;running = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">coroutine_resume(struct schedule * S, <span class="keyword">int</span> id) &#123;</span><br><span class="line">	assert(S-&gt;running == <span class="number">-1</span>);</span><br><span class="line">	assert(id &gt;=<span class="number">0</span> &amp;&amp; id &lt; S-&gt;cap);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">coroutine</span> *<span class="title">C</span> =</span> S-&gt;co[id];</span><br><span class="line">	<span class="keyword">if</span> (C == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> status = C-&gt;status;</span><br><span class="line">	<span class="keyword">switch</span>(status) &#123;</span><br><span class="line">	<span class="keyword">case</span> COROUTINE_READY:</span><br><span class="line">		getcontext(&amp;C-&gt;ctx);</span><br><span class="line">		C-&gt;ctx.uc_stack.ss_sp = S-&gt;<span class="built_in">stack</span>;</span><br><span class="line">		C-&gt;ctx.uc_stack.ss_size = STACK_SIZE;</span><br><span class="line">		C-&gt;ctx.uc_link = &amp;S-&gt;main;</span><br><span class="line">		S-&gt;running = id;</span><br><span class="line">		C-&gt;status = COROUTINE_RUNNING;</span><br><span class="line">		<span class="keyword">uintptr_t</span> ptr = (<span class="keyword">uintptr_t</span>)S;</span><br><span class="line">		makecontext(&amp;C-&gt;ctx, (<span class="keyword">void</span> (*)(<span class="keyword">void</span>)) mainfunc, <span class="number">2</span>, (<span class="keyword">uint32_t</span>)ptr, (<span class="keyword">uint32_t</span>)(ptr&gt;&gt;<span class="number">32</span>));</span><br><span class="line">		swapcontext(&amp;S-&gt;main, &amp;C-&gt;ctx);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> COROUTINE_SUSPEND:</span><br><span class="line">		<span class="built_in">memcpy</span>(S-&gt;<span class="built_in">stack</span> + STACK_SIZE - C-&gt;size, C-&gt;<span class="built_in">stack</span>, C-&gt;size);</span><br><span class="line">		S-&gt;running = id;</span><br><span class="line">		C-&gt;status = COROUTINE_RUNNING;</span><br><span class="line">		swapcontext(&amp;S-&gt;main, &amp;C-&gt;ctx);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		assert(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_save_stack(struct coroutine *C, <span class="keyword">char</span> *top) &#123;</span><br><span class="line">	<span class="keyword">char</span> dummy = <span class="number">0</span>;</span><br><span class="line">	assert(top - &amp;dummy &lt;= STACK_SIZE);</span><br><span class="line">	<span class="keyword">if</span> (C-&gt;cap &lt; top - &amp;dummy) &#123;</span><br><span class="line">		<span class="built_in">free</span>(C-&gt;<span class="built_in">stack</span>);</span><br><span class="line">		C-&gt;cap = top-&amp;dummy;</span><br><span class="line">		C-&gt;<span class="built_in">stack</span> = <span class="built_in">malloc</span>(C-&gt;cap);</span><br><span class="line">	&#125;</span><br><span class="line">	C-&gt;size = top - &amp;dummy;</span><br><span class="line">	<span class="built_in">memcpy</span>(C-&gt;<span class="built_in">stack</span>, &amp;dummy, C-&gt;size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">coroutine_yield(struct schedule * S) &#123;</span><br><span class="line">	<span class="keyword">int</span> id = S-&gt;running;</span><br><span class="line">	assert(id &gt;= <span class="number">0</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">coroutine</span> * <span class="title">C</span> =</span> S-&gt;co[id];</span><br><span class="line">	assert((<span class="keyword">char</span> *)&amp;C &gt; S-&gt;<span class="built_in">stack</span>);</span><br><span class="line">	_save_stack(C,S-&gt;<span class="built_in">stack</span> + STACK_SIZE);</span><br><span class="line">	C-&gt;status = COROUTINE_SUSPEND;</span><br><span class="line">	S-&gt;running = <span class="number">-1</span>;</span><br><span class="line">	swapcontext(&amp;C-&gt;ctx , &amp;S-&gt;main);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> </span><br><span class="line">coroutine_status(struct schedule * S, <span class="keyword">int</span> id) &#123;</span><br><span class="line">	assert(id&gt;=<span class="number">0</span> &amp;&amp; id &lt; S-&gt;cap);</span><br><span class="line">	<span class="keyword">if</span> (S-&gt;co[id] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> COROUTINE_DEAD;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> S-&gt;co[id]-&gt;status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> </span><br><span class="line">coroutine_running(struct schedule * S) &#123;</span><br><span class="line">	<span class="keyword">return</span> S-&gt;running;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="coroutine-h"><a href="#coroutine-h" class="headerlink" title="coroutine.h"></a>coroutine.h</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> C_COROUTINE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> C_COROUTINE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COROUTINE_DEAD 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COROUTINE_READY 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COROUTINE_RUNNING 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COROUTINE_SUSPEND 3</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">schedule</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*coroutine_func)</span><span class="params">(struct schedule *, <span class="keyword">void</span> *ud)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">struct schedule * <span class="title">coroutine_open</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">coroutine_close</span><span class="params">(struct schedule *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coroutine_new</span><span class="params">(struct schedule *, coroutine_func, <span class="keyword">void</span> *ud)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">coroutine_resume</span><span class="params">(struct schedule *, <span class="keyword">int</span> id)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coroutine_status</span><span class="params">(struct schedule *, <span class="keyword">int</span> id)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coroutine_running</span><span class="params">(struct schedule *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">coroutine_yield</span><span class="params">(struct schedule *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;coroutine.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">args</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">foo(struct schedule * S, <span class="keyword">void</span> *ud) &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">args</span> * <span class="title">arg</span> =</span> ud;</span><br><span class="line">	<span class="keyword">int</span> start = arg-&gt;n;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;coroutine %d : %d\n&quot;</span>,coroutine_running(S) , start + i);</span><br><span class="line">		coroutine_yield(S);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">test(struct schedule *S) &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">args</span> <span class="title">arg1</span> =</span> &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">args</span> <span class="title">arg2</span> =</span> &#123; <span class="number">100</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> co1 = coroutine_new(S, foo, &amp;arg1);</span><br><span class="line">	<span class="keyword">int</span> co2 = coroutine_new(S, foo, &amp;arg2);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;main start\n&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> (coroutine_status(S,co1) &amp;&amp; coroutine_status(S,co2)) &#123;</span><br><span class="line">		coroutine_resume(S,co1);</span><br><span class="line">		coroutine_resume(S,co2);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;main end\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> </span><br><span class="line">main() &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">schedule</span> * <span class="title">S</span> =</span> coroutine_open();</span><br><span class="line">	test(S);</span><br><span class="line">	coroutine_close(S);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/04/18/lCEQqdyD5ASJwXu.jpg" alt="78601467_p0.jpg"></p>
]]></content>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql 自增主键</title>
    <url>/2020-08-20-mysql%20%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="">MySQL实战45讲</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这里只考虑Innodb的情况。</p>
<a id="more"></a>

<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>自增主键的创建：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">MySQL [mysql]&gt; show create table t;</span><br><span class="line">+-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Table | Create Table                                                                                                                                                                                                            |</span><br><span class="line">+-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| t     | CREATE TABLE `t` (</span><br><span class="line">  `id` <span class="built_in"><span class="keyword">int</span></span>(<span class="number">11</span>) NOT <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `c` <span class="built_in"><span class="keyword">int</span></span>(<span class="number">11</span>) DEFAULT <span class="literal">NULL</span>,</span><br><span class="line">  `d` <span class="built_in"><span class="keyword">int</span></span>(<span class="number">11</span>) DEFAULT <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="built_in">KEY</span> (`id`),</span><br><span class="line">  UNIQUE KEY `c` (`c`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=<span class="number">4</span> DEFAULT CHARSET=latin1 |</span><br><span class="line">+-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line"><span class="number">1</span> row in <span class="built_in">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p>插入：</p>
<p>null, 0, 不指定，指定， 都可以使用自增id</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MySQL [mysql]&gt; select * from t;</span><br><span class="line"><span class="function">Empty <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">MySQL [mysql]&gt; insert into t select null,1,1;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="function">row <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br><span class="line"><span class="function">Records: <span class="number">1</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">MySQL [mysql]&gt; insert into t select <span class="number">0</span>,<span class="number">2</span>,<span class="number">2</span>;</span>   </span><br><span class="line">Query OK, <span class="number">1</span> <span class="function">row <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br><span class="line"><span class="function">Records: <span class="number">1</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">MySQL [mysql]&gt; insert into t(c,d) select <span class="number">3</span>,<span class="number">3</span>;</span></span><br><span class="line">Query OK, <span class="number">1</span> <span class="function">row <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br><span class="line"><span class="function">Records: <span class="number">1</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">MySQL [mysql]&gt; insert into t select <span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>;</span></span><br><span class="line">Query OK, <span class="number">1</span> <span class="function">row <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br><span class="line"><span class="function">Records: <span class="number">1</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">MySQL [mysql]&gt; select * from t;</span></span><br><span class="line">+----+------+------+</span><br><span class="line">| id | c    | d    |</span><br><span class="line">+----+------+------+</span><br><span class="line">|  <span class="number">1</span> |    <span class="number">1</span> |    <span class="number">1</span> |</span><br><span class="line">|  <span class="number">2</span> |    <span class="number">2</span> |    <span class="number">2</span> |</span><br><span class="line">|  <span class="number">3</span> |    <span class="number">3</span> |    <span class="number">3</span> |</span><br><span class="line">|  <span class="number">4</span> |    <span class="number">4</span> |    <span class="number">4</span> |</span><br><span class="line">+----+------+------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="乱序"><a href="#乱序" class="headerlink" title="乱序"></a>乱序</h2><h3 id="case1-唯一键冲突"><a href="#case1-唯一键冲突" class="headerlink" title="case1 唯一键冲突"></a>case1 唯一键冲突</h3><p>AUTO_INCREMENT表示下一个记录默认会取的自增主键的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MySQL [mysql]&gt; show create table t;</span><br><span class="line">+-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Table | Create Table                                                                                                                                                                                                            |</span><br><span class="line">+-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| t     | CREATE TABLE `t` (</span><br><span class="line">  `id` <span class="built_in"><span class="keyword">int</span></span>(<span class="number">11</span>) NOT <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `c` <span class="built_in"><span class="keyword">int</span></span>(<span class="number">11</span>) DEFAULT <span class="literal">NULL</span>,</span><br><span class="line">  `d` <span class="built_in"><span class="keyword">int</span></span>(<span class="number">11</span>) DEFAULT <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="built_in">KEY</span> (`id`),</span><br><span class="line">  UNIQUE KEY `c` (`c`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=<span class="number">5</span> DEFAULT CHARSET=latin1 |</span><br><span class="line">+-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line"><span class="number">1</span> row in <span class="built_in">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">MySQL [mysql]&gt; select * from t;</span><br><span class="line">+----+------+------+</span><br><span class="line">| id | c    | d    |</span><br><span class="line">+----+------+------+</span><br><span class="line">|  <span class="number">1</span> |    <span class="number">1</span> |    <span class="number">1</span> |</span><br><span class="line">|  <span class="number">2</span> |    <span class="number">2</span> |    <span class="number">2</span> |</span><br><span class="line">|  <span class="number">3</span> |    <span class="number">3</span> |    <span class="number">3</span> |</span><br><span class="line">|  <span class="number">4</span> |    <span class="number">4</span> |    <span class="number">4</span> |</span><br><span class="line">+----+------+------+</span><br><span class="line"><span class="number">4</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">MySQL [mysql]&gt; insert into t(c,d) select 4,5;</span><br><span class="line">ERROR <span class="number">1062</span> (<span class="number">23000</span>): Duplicate entry <span class="string">&#x27;4&#x27;</span> <span class="keyword">for</span> key <span class="string">&#x27;c&#x27;</span></span><br><span class="line">MySQL [mysql]&gt; show create table t;</span><br><span class="line">+-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Table | Create Table                                                                                                                                                                                                            |</span><br><span class="line">+-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| t     | CREATE TABLE `t` (</span><br><span class="line">  `id` <span class="built_in"><span class="keyword">int</span></span>(<span class="number">11</span>) NOT <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `c` <span class="built_in"><span class="keyword">int</span></span>(<span class="number">11</span>) DEFAULT <span class="literal">NULL</span>,</span><br><span class="line">  `d` <span class="built_in"><span class="keyword">int</span></span>(<span class="number">11</span>) DEFAULT <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="built_in">KEY</span> (`id`),</span><br><span class="line">  UNIQUE KEY `c` (`c`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=<span class="number">6</span> DEFAULT CHARSET=latin1 |</span><br><span class="line">+-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line"><span class="number">1</span> row in <span class="built_in">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h3 id="case2-事务回滚"><a href="#case2-事务回滚" class="headerlink" title="case2 事务回滚"></a>case2 事务回滚</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MySQL [mysql]&gt; begin;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">MySQL [mysql]&gt; insert into t(c,d) select 5,5;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="function">row <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function">Records: <span class="number">1</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">MySQL [mysql]&gt; select * from t;</span></span><br><span class="line">+----+------+------+</span><br><span class="line">| id | c    | d    |</span><br><span class="line">+----+------+------+</span><br><span class="line">|  <span class="number">1</span> |    <span class="number">1</span> |    <span class="number">1</span> |</span><br><span class="line">|  <span class="number">2</span> |    <span class="number">2</span> |    <span class="number">2</span> |</span><br><span class="line">|  <span class="number">3</span> |    <span class="number">3</span> |    <span class="number">3</span> |</span><br><span class="line">|  <span class="number">4</span> |    <span class="number">4</span> |    <span class="number">4</span> |</span><br><span class="line">|  <span class="number">6</span> |    <span class="number">5</span> |    <span class="number">5</span> |</span><br><span class="line">+----+------+------+</span><br><span class="line"><span class="number">5</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">MySQL [mysql]&gt; rollback;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">MySQL [mysql]&gt; select * from t;</span><br><span class="line">+----+------+------+</span><br><span class="line">| id | c    | d    |</span><br><span class="line">+----+------+------+</span><br><span class="line">|  <span class="number">1</span> |    <span class="number">1</span> |    <span class="number">1</span> |</span><br><span class="line">|  <span class="number">2</span> |    <span class="number">2</span> |    <span class="number">2</span> |</span><br><span class="line">|  <span class="number">3</span> |    <span class="number">3</span> |    <span class="number">3</span> |</span><br><span class="line">|  <span class="number">4</span> |    <span class="number">4</span> |    <span class="number">4</span> |</span><br><span class="line">+----+------+------+</span><br><span class="line"><span class="number">4</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">MySQL [mysql]&gt; commit;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">MySQL [mysql]&gt; show create table t;</span><br><span class="line">+-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Table | Create Table                                                                                                                                                                                                            |</span><br><span class="line">+-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| t     | CREATE TABLE `t` (</span><br><span class="line">  `id` <span class="built_in"><span class="keyword">int</span></span>(<span class="number">11</span>) NOT <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `c` <span class="built_in"><span class="keyword">int</span></span>(<span class="number">11</span>) DEFAULT <span class="literal">NULL</span>,</span><br><span class="line">  `d` <span class="built_in"><span class="keyword">int</span></span>(<span class="number">11</span>) DEFAULT <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="built_in">KEY</span> (`id`),</span><br><span class="line">  UNIQUE KEY `c` (`c`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=<span class="number">7</span> DEFAULT CHARSET=latin1 |</span><br><span class="line">+-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line"><span class="number">1</span> row in <span class="built_in">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h3 id="case3-批量插入"><a href="#case3-批量插入" class="headerlink" title="case3 批量插入"></a>case3 批量插入</h3><p>批量语句：insert … select、replace … select 和 load data 语句</p>
<p>这里的逻辑是，申请主键id的方法如下：</p>
<ul>
<li>申请1</li>
<li>申请2，3</li>
<li>申请4，5，6，7</li>
</ul>
<p>每次2的倍数的申请，所以会存在浪费的现象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MySQL [mysql]&gt; create table tt like t;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.04</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">MySQL [mysql]&gt; show create table tt;</span><br><span class="line">+-------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Table | Create Table                                                                                                                                                                                            |</span><br><span class="line">+-------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| tt    | CREATE TABLE `tt` (</span><br><span class="line">  `id` <span class="built_in"><span class="keyword">int</span></span>(<span class="number">11</span>) NOT <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `c` <span class="built_in"><span class="keyword">int</span></span>(<span class="number">11</span>) DEFAULT <span class="literal">NULL</span>,</span><br><span class="line">  `d` <span class="built_in"><span class="keyword">int</span></span>(<span class="number">11</span>) DEFAULT <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="built_in">KEY</span> (`id`),</span><br><span class="line">  UNIQUE KEY `c` (`c`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=latin1 |</span><br><span class="line">+-------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line"><span class="number">1</span> row in <span class="built_in">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">MySQL [mysql]&gt; insert into <span class="built_in">tt</span>(c,d) select c,d from t;</span><br><span class="line">Query OK, <span class="number">4</span> rows affected, <span class="number">1</span> <span class="built_in">warning</span> (<span class="number">0.00</span> sec)</span><br><span class="line">Records: <span class="number">4</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">MySQL [mysql]&gt; select * from tt;    </span><br><span class="line">+----+------+------+</span><br><span class="line">| id | c    | d    |</span><br><span class="line">+----+------+------+</span><br><span class="line">|  <span class="number">1</span> |    <span class="number">1</span> |    <span class="number">1</span> |</span><br><span class="line">|  <span class="number">2</span> |    <span class="number">2</span> |    <span class="number">2</span> |</span><br><span class="line">|  <span class="number">3</span> |    <span class="number">3</span> |    <span class="number">3</span> |</span><br><span class="line">|  <span class="number">4</span> |    <span class="number">4</span> |    <span class="number">4</span> |</span><br><span class="line">+----+------+------+</span><br><span class="line"><span class="number">4</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">MySQL [mysql]&gt; show create table tt;</span><br><span class="line">+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Table | Create Table                                                                                                                                                                                                             |</span><br><span class="line">+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| tt    | CREATE TABLE `tt` (</span><br><span class="line">  `id` <span class="built_in"><span class="keyword">int</span></span>(<span class="number">11</span>) NOT <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `c` <span class="built_in"><span class="keyword">int</span></span>(<span class="number">11</span>) DEFAULT <span class="literal">NULL</span>,</span><br><span class="line">  `d` <span class="built_in"><span class="keyword">int</span></span>(<span class="number">11</span>) DEFAULT <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="built_in">KEY</span> (`id`),</span><br><span class="line">  UNIQUE KEY `c` (`c`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=<span class="number">8</span> DEFAULT CHARSET=latin1 |</span><br><span class="line">+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line"><span class="number">1</span> row in <span class="built_in">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h3 id="case4-update自增主键"><a href="#case4-update自增主键" class="headerlink" title="case4 update自增主键"></a>case4 update自增主键</h3><p>update并不改变AUTO_INCREMENT的值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MySQL [mysql]&gt; select * from tt;    </span><br><span class="line">+----+------+------+</span><br><span class="line">| id | c    | d    |</span><br><span class="line">+----+------+------+</span><br><span class="line">|  <span class="number">1</span> |    <span class="number">1</span> |    <span class="number">1</span> |</span><br><span class="line">|  <span class="number">2</span> |    <span class="number">2</span> |    <span class="number">2</span> |</span><br><span class="line">|  <span class="number">3</span> |    <span class="number">3</span> |    <span class="number">3</span> |</span><br><span class="line">|  <span class="number">4</span> |    <span class="number">4</span> |    <span class="number">4</span> |</span><br><span class="line">+----+------+------+</span><br><span class="line"><span class="number">4</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">MySQL [mysql]&gt; show create table tt;</span><br><span class="line">+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Table | Create Table                                                                                                                                                                                                             |</span><br><span class="line">+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| tt    | CREATE TABLE `tt` (</span><br><span class="line">  `id` <span class="built_in"><span class="keyword">int</span></span>(<span class="number">11</span>) NOT <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `c` <span class="built_in"><span class="keyword">int</span></span>(<span class="number">11</span>) DEFAULT <span class="literal">NULL</span>,</span><br><span class="line">  `d` <span class="built_in"><span class="keyword">int</span></span>(<span class="number">11</span>) DEFAULT <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="built_in">KEY</span> (`id`),</span><br><span class="line">  UNIQUE KEY `c` (`c`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=<span class="number">8</span> DEFAULT CHARSET=latin1 |</span><br><span class="line">+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line"><span class="number">1</span> row in <span class="built_in">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">MySQL [mysql]&gt; update tt set id=<span class="number">20</span> where c = <span class="number">4</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="function">row <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br><span class="line"><span class="function">Rows matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">MySQL [mysql]&gt; select * from tt;</span></span><br><span class="line">+----+------+------+</span><br><span class="line">| id | c    | d    |</span><br><span class="line">+----+------+------+</span><br><span class="line">|  <span class="number">1</span> |    <span class="number">1</span> |    <span class="number">1</span> |</span><br><span class="line">|  <span class="number">2</span> |    <span class="number">2</span> |    <span class="number">2</span> |</span><br><span class="line">|  <span class="number">3</span> |    <span class="number">3</span> |    <span class="number">3</span> |</span><br><span class="line">| <span class="number">20</span> |    <span class="number">4</span> |    <span class="number">4</span> |</span><br><span class="line">+----+------+------+</span><br><span class="line"><span class="number">4</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">MySQL [mysql]&gt; show create table tt;</span><br><span class="line">+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Table | Create Table                                                                                                                                                                                                             |</span><br><span class="line">+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| tt    | CREATE TABLE `tt` (</span><br><span class="line">  `id` <span class="built_in"><span class="keyword">int</span></span>(<span class="number">11</span>) NOT <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `c` <span class="built_in"><span class="keyword">int</span></span>(<span class="number">11</span>) DEFAULT <span class="literal">NULL</span>,</span><br><span class="line">  `d` <span class="built_in"><span class="keyword">int</span></span>(<span class="number">11</span>) DEFAULT <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="built_in">KEY</span> (`id`),</span><br><span class="line">  UNIQUE KEY `c` (`c`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=<span class="number">8</span> DEFAULT CHARSET=latin1 |</span><br><span class="line">+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line"><span class="number">1</span> row in <span class="built_in">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h3 id="case5-删除自增主键"><a href="#case5-删除自增主键" class="headerlink" title="case5 删除自增主键"></a>case5 删除自增主键</h3><p>delete并不改变的AUTO_INCREMENT值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MySQL [mysql]&gt; select * from tt;</span><br><span class="line">+----+------+------+</span><br><span class="line">| id | c    | d    |</span><br><span class="line">+----+------+------+</span><br><span class="line">|  <span class="number">1</span> |    <span class="number">1</span> |    <span class="number">1</span> |</span><br><span class="line">|  <span class="number">2</span> |    <span class="number">2</span> |    <span class="number">2</span> |</span><br><span class="line">|  <span class="number">3</span> |    <span class="number">3</span> |    <span class="number">3</span> |</span><br><span class="line">|  <span class="number">8</span> |    <span class="number">5</span> |    <span class="number">5</span> |</span><br><span class="line">| <span class="number">20</span> |    <span class="number">4</span> |    <span class="number">4</span> |</span><br><span class="line">+----+------+------+</span><br><span class="line"><span class="number">5</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">MySQL [mysql]&gt; show create table tt;</span><br><span class="line">+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Table | Create Table                                                                                                                                                                                                             |</span><br><span class="line">+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| tt    | CREATE TABLE `tt` (</span><br><span class="line">  `id` <span class="built_in"><span class="keyword">int</span></span>(<span class="number">11</span>) NOT <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `c` <span class="built_in"><span class="keyword">int</span></span>(<span class="number">11</span>) DEFAULT <span class="literal">NULL</span>,</span><br><span class="line">  `d` <span class="built_in"><span class="keyword">int</span></span>(<span class="number">11</span>) DEFAULT <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="built_in">KEY</span> (`id`),</span><br><span class="line">  UNIQUE KEY `c` (`c`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=<span class="number">9</span> DEFAULT CHARSET=latin1 |</span><br><span class="line">+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line"><span class="number">1</span> row in <span class="built_in">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">MySQL [mysql]&gt; <span class="keyword">delete</span> from tt where id = <span class="number">8</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="function">row <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">MySQL [mysql]&gt; select * from tt;</span><br><span class="line">+----+------+------+</span><br><span class="line">| id | c    | d    |</span><br><span class="line">+----+------+------+</span><br><span class="line">|  <span class="number">1</span> |    <span class="number">1</span> |    <span class="number">1</span> |</span><br><span class="line">|  <span class="number">2</span> |    <span class="number">2</span> |    <span class="number">2</span> |</span><br><span class="line">|  <span class="number">3</span> |    <span class="number">3</span> |    <span class="number">3</span> |</span><br><span class="line">| <span class="number">20</span> |    <span class="number">4</span> |    <span class="number">4</span> |</span><br><span class="line">+----+------+------+</span><br><span class="line"><span class="number">4</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">MySQL [mysql]&gt; show create table tt;</span><br><span class="line">+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Table | Create Table                                                                                                                                                                                                             |</span><br><span class="line">+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| tt    | CREATE TABLE `tt` (</span><br><span class="line">  `id` <span class="built_in"><span class="keyword">int</span></span>(<span class="number">11</span>) NOT <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `c` <span class="built_in"><span class="keyword">int</span></span>(<span class="number">11</span>) DEFAULT <span class="literal">NULL</span>,</span><br><span class="line">  `d` <span class="built_in"><span class="keyword">int</span></span>(<span class="number">11</span>) DEFAULT <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="built_in">KEY</span> (`id`),</span><br><span class="line">  UNIQUE KEY `c` (`c`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=<span class="number">9</span> DEFAULT CHARSET=latin1 |</span><br><span class="line">+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line"><span class="number">1</span> row in <span class="built_in">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h2 id="自增主键的存放"><a href="#自增主键的存放" class="headerlink" title="自增主键的存放"></a>自增主键的存放</h2><ul>
<li>MyISAM的自增值保存在数据文件中</li>
<li>Innodb的自增值AUTO_INCREMENT保存在内存中(mysql重启后找到表内max(id),然后让AUTO_INCREMENT=max(id)+1),mysql8.0版本后，才有了自增值的持久化能力</li>
</ul>
<h2 id="innodb-autoinc-lock-mode"><a href="#innodb-autoinc-lock-mode" class="headerlink" title="innodb_autoinc_lock_mode"></a>innodb_autoinc_lock_mode</h2><p>innodb_autoinc_lock_mode是mysql5.1版本引入的，可以控制自增锁的释放时机</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MySQL [mysql]&gt; show variables like &#x27;innodb_autoinc_lock_mode&#x27;;</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">| Variable_name            | Value |</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">| innodb_autoinc_lock_mode | <span class="number">1</span>     |</span><br><span class="line">+--------------------------+-------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure>

<p>默认值是1，不同取值含义如下：</p>
<p>0 保持mysql5.0版本策略，语句执行完成释放自增锁</p>
<p>1 分两种情况</p>
<ul>
<li>普通insert语句(包括insert … values(),(),())，自增锁在申请之后就释放</li>
<li>批量插入语句，还是要等到语句执行结束才释放</li>
</ul>
<p>2 所有申请自增主键的动作都是申请后就释放锁</p>
<p>对于批量插入，考虑到并发性，建议innodb_autoinc_lock_mode = 2, 加上binlog_format=row的用法。=2的模式可以尽早释放锁，row记录的是实际的所有列的值(full模式)，或者noblob模式也会记录主键的。从库备份的时候拿到的就是主库插入的主键的值，如果是statement就会乱套，对于这种情况：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line">sessionA                        sessionB</span><br><span class="line"></span><br><span class="line"><span class="function">insert into t <span class="title">values</span><span class="params">()</span></span></span><br><span class="line"><span class="function">insert into t <span class="title">values</span><span class="params">()</span></span></span><br><span class="line"><span class="function">insert into t <span class="title">values</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                                create table tt like t</span>;</span><br><span class="line"><span class="function">insert into tt <span class="title">vaules</span><span class="params">()</span>         insert tt select .. from t</span>;</span><br></pre></td></tr></table></figure>

<p>如果insert select获取自增锁然后释放锁，只insert了部分记录，然后sesiionA获取锁，插入了一条导致自增主键值加1，然后sesisionB继续执行，对于sesiionB来说和预期的会不同，t的数据拷贝到tt中间有一条的主键值跃了一次，但是statement的binlog只记录了两条语句，insert select(sesiionB), insert vaules(sessionA),从库备份的时候结果是不能准确预计的。</p>
<p>书上的补充：</p>
<p><img src="https://i.loli.net/2020/08/20/W47M9LrXN6RsADJ.jpg" alt="2020082002.jpg"></p>
<p><img src="https://i.loli.net/2020/08/20/BOA5aF9DPuhjeoN.jpg" alt="2020082003.jpg"></p>
<h2 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h2><p>其他值得注意的地方以后补充</p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>golang reflect</title>
    <url>/2020-10-19-golang-reflect/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">author</th>
<th align="center">title</th>
<th align="center">version</th>
</tr>
</thead>
<tbody><tr>
<td align="center">TheRiver</td>
<td align="center">golang reflect</td>
<td align="center">go version go1.15.2 darwin/amd64</td>
</tr>
</tbody></table>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>在计算机学中，反射（英语：reflection）是指计算机程序在运行时（runtime）可以访问、检测和修改它本身状态或行为的一种能力。[1]用比喻来说，反射就是程序在运行的时候能够“观察”并且修改自己的行为。</p>
</blockquote>
<p>反射主要的两个类型：<strong>Type</strong>和<strong>Value</strong>,结合函数<code>Typeof</code>，<code>Valueof</code>使用。看下代码是怎么实现的：</p>
<a id="more"></a>

<h2 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Type is the representation of a Go type.</span></span><br><span class="line"><span class="comment">// 并非所有方法都适用于所有类型。在每种方法的文档中都注明了限制（如有）</span></span><br><span class="line"><span class="comment">// Not all methods apply to all kinds of types. Restrictions,</span></span><br><span class="line"><span class="comment">// if any, are noted in the documentation for each method.</span></span><br><span class="line"><span class="comment">// 在调用特定于种类的方法之前，请使用Kind方法找出类型。调用不适合该类型的方法会导致运行时panic。</span></span><br><span class="line"><span class="comment">// Use the Kind method to find out the kind of type before</span></span><br><span class="line"><span class="comment">// calling kind-specific methods. Calling a method</span></span><br><span class="line"><span class="comment">// inappropriate to the kind of type causes a run-time panic.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Type values are comparable, such as with the == operator,</span></span><br><span class="line"><span class="comment">// so they can be used as map keys.</span></span><br><span class="line"><span class="comment">// Two Type values are equal if they represent identical types.</span></span><br><span class="line"><span class="keyword">type</span> Type <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Methods applicable to all types.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Align returns the alignment in bytes of a value of</span></span><br><span class="line">	<span class="comment">// this type when allocated in memory.</span></span><br><span class="line">	<span class="comment">//内存对齐字节数</span></span><br><span class="line">	Align() <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// FieldAlign returns the alignment in bytes of a value of</span></span><br><span class="line">	<span class="comment">// this type when used as a field in a struct.</span></span><br><span class="line">	<span class="comment">//结构体中对齐字节数</span></span><br><span class="line">	FieldAlign() <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Method returns the i&#x27;th method in the type&#x27;s method set.</span></span><br><span class="line">	<span class="comment">// It panics if i is not in the range [0, NumMethod()).</span></span><br><span class="line">	<span class="comment">//非接口类型，返回带接受者的方法</span></span><br><span class="line">	<span class="comment">// For a non-interface type T or *T, the returned Method&#x27;s Type and Func</span></span><br><span class="line">	<span class="comment">// fields describe a function whose first argument is the receiver.</span></span><br><span class="line">	<span class="comment">//接口类型，返回函数签名，不带接收者</span></span><br><span class="line">	<span class="comment">// For an interface type, the returned Method&#x27;s Type field gives the</span></span><br><span class="line">	<span class="comment">// method signature, without a receiver, and the Func field is nil.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Only exported methods are accessible and they are sorted in</span></span><br><span class="line">	<span class="comment">// lexicographic order.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回第i个method</span></span><br><span class="line">	Method(<span class="keyword">int</span>) Method</span><br><span class="line"></span><br><span class="line">	<span class="comment">// MethodByName returns the method with that name in the type&#x27;s</span></span><br><span class="line">	<span class="comment">// method set and a boolean indicating if the method was found.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// For a non-interface type T or *T, the returned Method&#x27;s Type and Func</span></span><br><span class="line">	<span class="comment">// fields describe a function whose first argument is the receiver.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// For an interface type, the returned Method&#x27;s Type field gives the</span></span><br><span class="line">	<span class="comment">// method signature, without a receiver, and the Func field is nil.</span></span><br><span class="line">	<span class="comment">//返回对应名字的method</span></span><br><span class="line">	MethodByName(<span class="keyword">string</span>) (Method, <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// NumMethod returns the number of exported methods in the type&#x27;s method set.</span></span><br><span class="line">	<span class="comment">//返回method的总数</span></span><br><span class="line">	NumMethod() <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Name returns the type&#x27;s name within its package for a defined type.</span></span><br><span class="line">	<span class="comment">// For other (non-defined) types it returns the empty string.</span></span><br><span class="line">	<span class="comment">//返回类型名</span></span><br><span class="line">	Name() <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// PkgPath returns a defined type&#x27;s package path, that is, the import path</span></span><br><span class="line">	<span class="comment">// that uniquely identifies the package, such as &quot;encoding/base64&quot;.</span></span><br><span class="line">	<span class="comment">// If the type was predeclared (string, error) or not defined (*T, struct&#123;&#125;,</span></span><br><span class="line">	<span class="comment">// []int, or A where A is an alias for a non-defined type), the package path</span></span><br><span class="line">	<span class="comment">// will be the empty string.</span></span><br><span class="line">	PkgPath() <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Size returns the number of bytes needed to store</span></span><br><span class="line">	<span class="comment">// a value of the given type; it is analogous to unsafe.Sizeof.</span></span><br><span class="line">	Size() <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// String returns a string representation of the type.</span></span><br><span class="line">	<span class="comment">// The string representation may use shortened package names</span></span><br><span class="line">	<span class="comment">// (e.g., base64 instead of &quot;encoding/base64&quot;) and is not</span></span><br><span class="line">	<span class="comment">// guaranteed to be unique among types. To test for type identity,</span></span><br><span class="line">	<span class="comment">// compare the Types directly.</span></span><br><span class="line">	<span class="comment">//返回字符串的类型描述，比较类型的话直接用Type别用这个</span></span><br><span class="line">	String() <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Kind returns the specific kind of this type.</span></span><br><span class="line">	<span class="comment">//返回特定的类型</span></span><br><span class="line">	Kind() Kind</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Implements reports whether the type implements the interface type u.</span></span><br><span class="line">	Implements(u Type) <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// AssignableTo reports whether a value of the type is assignable to type u.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	AssignableTo(u Type) <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// ConvertibleTo reports whether a value of the type is convertible to type u.</span></span><br><span class="line">	ConvertibleTo(u Type) <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Comparable reports whether values of this type are comparable.</span></span><br><span class="line">	Comparable() <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Methods applicable only to some types, depending on Kind.</span></span><br><span class="line">	<span class="comment">// The methods allowed for each kind are:</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//	Int*, Uint*, Float*, Complex*: Bits</span></span><br><span class="line">	<span class="comment">//	Array: Elem, Len</span></span><br><span class="line">	<span class="comment">//	Chan: ChanDir, Elem</span></span><br><span class="line">	<span class="comment">//	Func: In, NumIn, Out, NumOut, IsVariadic.</span></span><br><span class="line">	<span class="comment">//	Map: Key, Elem</span></span><br><span class="line">	<span class="comment">//	Ptr: Elem</span></span><br><span class="line">	<span class="comment">//	Slice: Elem</span></span><br><span class="line">	<span class="comment">//	Struct: Field, FieldByIndex, FieldByName, FieldByNameFunc, NumField</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Bits returns the size of the type in bits.</span></span><br><span class="line">	<span class="comment">// It panics if the type&#x27;s Kind is not one of the</span></span><br><span class="line">	<span class="comment">// sized or unsized Int, Uint, Float, or Complex kinds.</span></span><br><span class="line">	Bits() <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// ChanDir returns a channel type&#x27;s direction.</span></span><br><span class="line">	<span class="comment">// It panics if the type&#x27;s Kind is not Chan.</span></span><br><span class="line">	ChanDir() ChanDir</span><br><span class="line"></span><br><span class="line">	<span class="comment">// IsVariadic reports whether a function type&#x27;s final input parameter</span></span><br><span class="line">	<span class="comment">// is a &quot;...&quot; parameter. If so, t.In(t.NumIn() - 1) returns the parameter&#x27;s</span></span><br><span class="line">	<span class="comment">// implicit actual type []T.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// For concreteness, if t represents func(x int, y ... float64), then</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//	t.NumIn() == 2</span></span><br><span class="line">	<span class="comment">//	t.In(0) is the reflect.Type for &quot;int&quot;</span></span><br><span class="line">	<span class="comment">//	t.In(1) is the reflect.Type for &quot;[]float64&quot;</span></span><br><span class="line">	<span class="comment">//	t.IsVariadic() == true</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// IsVariadic panics if the type&#x27;s Kind is not Func.</span></span><br><span class="line">	IsVariadic() <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Elem returns a type&#x27;s element type.</span></span><br><span class="line">	<span class="comment">// It panics if the type&#x27;s Kind is not Array, Chan, Map, Ptr, or Slice.</span></span><br><span class="line">	<span class="comment">//返回元素类型</span></span><br><span class="line">	Elem() Type</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Field returns a struct type&#x27;s i&#x27;th field.</span></span><br><span class="line">	<span class="comment">// It panics if the type&#x27;s Kind is not Struct.</span></span><br><span class="line">	<span class="comment">// It panics if i is not in the range [0, NumField()).</span></span><br><span class="line">	<span class="comment">//返回第i个字段</span></span><br><span class="line">	Field(i <span class="keyword">int</span>) StructField</span><br><span class="line"></span><br><span class="line">	<span class="comment">// FieldByIndex returns the nested field corresponding</span></span><br><span class="line">	<span class="comment">// to the index sequence. It is equivalent to calling Field</span></span><br><span class="line">	<span class="comment">// successively for each index i.</span></span><br><span class="line">	<span class="comment">// It panics if the type&#x27;s Kind is not Struct.</span></span><br><span class="line">	FieldByIndex(index []<span class="keyword">int</span>) StructField</span><br><span class="line"></span><br><span class="line">	<span class="comment">// FieldByName returns the struct field with the given name</span></span><br><span class="line">	<span class="comment">// and a boolean indicating if the field was found.</span></span><br><span class="line">	<span class="comment">//返回对应名称的字段</span></span><br><span class="line">	FieldByName(name <span class="keyword">string</span>) (StructField, <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// FieldByNameFunc returns the struct field with a name</span></span><br><span class="line">	<span class="comment">// that satisfies the match function and a boolean indicating if</span></span><br><span class="line">	<span class="comment">// the field was found.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// FieldByNameFunc considers the fields in the struct itself</span></span><br><span class="line">	<span class="comment">// and then the fields in any embedded structs, in breadth first order,</span></span><br><span class="line">	<span class="comment">// stopping at the shallowest nesting depth containing one or more</span></span><br><span class="line">	<span class="comment">// fields satisfying the match function. If multiple fields at that depth</span></span><br><span class="line">	<span class="comment">// satisfy the match function, they cancel each other</span></span><br><span class="line">	<span class="comment">// and FieldByNameFunc returns no match.</span></span><br><span class="line">	<span class="comment">// This behavior mirrors Go&#x27;s handling of name lookup in</span></span><br><span class="line">	<span class="comment">// structs containing embedded fields.</span></span><br><span class="line">	FieldByNameFunc(match <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>)</span> <span class="title">bool</span>) <span class="params">(StructField, <span class="keyword">bool</span>)</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// In returns the type of a function type&#x27;s i&#x27;th input parameter.</span></span><br><span class="line">	<span class="comment">// It panics if the type&#x27;s Kind is not Func.</span></span><br><span class="line">	<span class="comment">// It panics if i is not in the range [0, NumIn()).</span></span><br><span class="line">	<span class="comment">//第i个入参</span></span><br><span class="line">	In(i <span class="keyword">int</span>) Type</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Key returns a map type&#x27;s key type.</span></span><br><span class="line">	<span class="comment">// It panics if the type&#x27;s Kind is not Map.</span></span><br><span class="line">	Key() Type</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Len returns an array type&#x27;s length.</span></span><br><span class="line">	<span class="comment">// It panics if the type&#x27;s Kind is not Array.</span></span><br><span class="line">	Len() <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// NumField returns a struct type&#x27;s field count.</span></span><br><span class="line">	<span class="comment">// It panics if the type&#x27;s Kind is not Struct.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//字段数量</span></span><br><span class="line">	NumField() <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// NumIn returns a function type&#x27;s input parameter count.</span></span><br><span class="line">	<span class="comment">// It panics if the type&#x27;s Kind is not Func.</span></span><br><span class="line">	<span class="comment">//函数入参个数</span></span><br><span class="line">	NumIn() <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// NumOut returns a function type&#x27;s output parameter count.</span></span><br><span class="line">	<span class="comment">// It panics if the type&#x27;s Kind is not Func.</span></span><br><span class="line">	<span class="comment">//函数出参个数</span></span><br><span class="line">	NumOut() <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Out returns the type of a function type&#x27;s i&#x27;th output parameter.</span></span><br><span class="line">	<span class="comment">// It panics if the type&#x27;s Kind is not Func.</span></span><br><span class="line">	<span class="comment">// It panics if i is not in the range [0, NumOut()).</span></span><br><span class="line">	<span class="comment">//第i个出参</span></span><br><span class="line">	Out(i <span class="keyword">int</span>) Type</span><br><span class="line"></span><br><span class="line">	common() *rtype</span><br><span class="line">	uncommon() *uncommonType</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单测试下常用的函数：</p>
<h3 id="Name"><a href="#Name" class="headerlink" title="Name"></a>Name</h3><blockquote>
<p>Name() string, Name returns the type’s name within its package for a defined type.For other (non-defined) types it returns the empty string.</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = <span class="keyword">struct</span> &#123;</span><br><span class="line">	name   <span class="keyword">string</span></span><br><span class="line">	id     <span class="keyword">int</span></span><br><span class="line">	family []<span class="keyword">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">	name:   <span class="string">&quot;river&quot;</span>,</span><br><span class="line">	id:     <span class="number">1</span>,</span><br><span class="line">	family: []<span class="keyword">string</span>&#123;<span class="string">&quot;me&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;we&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> data2 <span class="keyword">struct</span> &#123;</span><br><span class="line">	name   <span class="keyword">string</span></span><br><span class="line">	id     <span class="keyword">int</span></span><br><span class="line">	family []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	t := reflect.TypeOf(data)</span><br><span class="line">	fmt.Println(t.Name()) <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">	t2 := reflect.TypeOf(data2&#123;&#125;)</span><br><span class="line">	fmt.Println(t2.Name()) <span class="comment">//data2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><blockquote>
<p>String() string, String returns a string representation of the type.</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">	name   <span class="keyword">string</span></span><br><span class="line">	id     <span class="keyword">int</span></span><br><span class="line">	family []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	t := reflect.TypeOf(data&#123;&#125;)</span><br><span class="line">	fmt.Println(t.String()) <span class="comment">//main.data</span></span><br><span class="line">	fmt.Println(t.Name())	<span class="comment">//data</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Len"><a href="#Len" class="headerlink" title="Len"></a>Len</h3><blockquote>
<p>Len() int, Len returns an array type’s length.</p>
</blockquote>
<blockquote>
<p>It panics if the type’s Kind is not Array.</p>
</blockquote>
<p>demo:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">	name   <span class="keyword">string</span></span><br><span class="line">	id     <span class="keyword">int</span></span><br><span class="line">	family []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	t := reflect.TypeOf([<span class="number">10</span>]data&#123;&#125;)</span><br><span class="line">	fmt.Println(t.Len()) <span class="comment">//10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Elem"><a href="#Elem" class="headerlink" title="Elem"></a>Elem</h3><blockquote>
<p>Elem() Type ,Elem returns a type’s element type.</p>
<p>It panics if the type’s Kind is not Array, Chan, Map, Ptr, or Slice.</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">	name   <span class="keyword">string</span></span><br><span class="line">	id     <span class="keyword">int</span></span><br><span class="line">	family []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//t := reflect.TypeOf(data&#123;name: &quot;river&quot;&#125;)  panic</span></span><br><span class="line">	t := reflect.TypeOf(&amp;data&#123;name: <span class="string">&quot;river&quot;</span>&#125;)</span><br><span class="line">	fmt.Println(t.Elem()) <span class="comment">//main.data</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Kind"><a href="#Kind" class="headerlink" title="Kind"></a>Kind</h3><blockquote>
<p>Kind() Kind, Kind returns the specific kind of this type.</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">	name   <span class="keyword">string</span></span><br><span class="line">	id     <span class="keyword">int</span></span><br><span class="line">	family []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	t := reflect.TypeOf(data&#123;name: <span class="string">&quot;river&quot;</span>&#125;)</span><br><span class="line">	fmt.Println(t.Kind()) <span class="comment">//struct</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kind返回的值类型：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * These data structures are known to the compiler (../../cmd/internal/gc/reflect.go).</span></span><br><span class="line"><span class="comment"> * A few are known to ../runtime/type.go to convey to debuggers.</span></span><br><span class="line"><span class="comment"> * They are also known to ../runtime/type.go.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A Kind represents the specific kind of type that a Type represents.</span></span><br><span class="line"><span class="comment">// The zero Kind is not a valid kind.</span></span><br><span class="line"><span class="keyword">type</span> Kind <span class="keyword">uint</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Invalid Kind = <span class="literal">iota</span></span><br><span class="line">	Bool</span><br><span class="line">	Int</span><br><span class="line">	Int8</span><br><span class="line">	Int16</span><br><span class="line">	Int32</span><br><span class="line">	Int64</span><br><span class="line">	Uint</span><br><span class="line">	Uint8</span><br><span class="line">	Uint16</span><br><span class="line">	Uint32</span><br><span class="line">	Uint64</span><br><span class="line">	Uintptr</span><br><span class="line">	Float32</span><br><span class="line">	Float64</span><br><span class="line">	Complex64</span><br><span class="line">	Complex128</span><br><span class="line">	Array</span><br><span class="line">	Chan</span><br><span class="line">	Func</span><br><span class="line">	Interface</span><br><span class="line">	Map</span><br><span class="line">	Ptr</span><br><span class="line">	Slice</span><br><span class="line">	String</span><br><span class="line">	Struct</span><br><span class="line">	UnsafePointer</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><pre><code>Method(int) Method
MethodByName(string) (Method, bool)
NumMethod() int</code></pre>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">	name   <span class="keyword">string</span></span><br><span class="line">	id     <span class="keyword">int</span></span><br><span class="line">	family []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d data)</span> <span class="title">Func1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d data)</span> <span class="title">Func2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *data)</span> <span class="title">Func3</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d data)</span> <span class="title">func4</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	t := reflect.TypeOf(data&#123;name: <span class="string">&quot;river&quot;</span>&#125;)</span><br><span class="line">	t2 := reflect.TypeOf(&amp;data&#123;name: <span class="string">&quot;river&quot;</span>&#125;)</span><br><span class="line">	fmt.Println(t.NumMethod())           <span class="comment">//2</span></span><br><span class="line">	fmt.Println(t2.NumMethod())          <span class="comment">//3</span></span><br><span class="line">	fmt.Println(t.Method(<span class="number">0</span>).Name)        <span class="comment">//Func1</span></span><br><span class="line">	fmt.Println(t.MethodByName(<span class="string">&quot;Func2&quot;</span>)) <span class="comment">//&#123;Func2  func(main.data) &lt;func(main.data) Value&gt; 1&#125; true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数名要大写，不然num不增加。绑定到指针类型的方法和绑定到对象的方法对于指针的NUM和对象的NUM的计数是不同的</p>
<h3 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h3><pre><code>NumField() int
Field(i int) StructField
FieldByIndex(index []int) StructField
FieldByName(name string) (StructField, bool)</code></pre>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id   <span class="keyword">int</span></span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Log <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id   <span class="keyword">int</span></span><br><span class="line">	Time <span class="keyword">string</span></span><br><span class="line">	User <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Manager <span class="keyword">struct</span> &#123;</span><br><span class="line">	User User</span><br><span class="line">	Log  Log</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	m := Manager&#123;User: User&#123;<span class="number">1</span>, <span class="string">&quot;Jack&quot;</span>, <span class="number">12</span>&#125;, Log: Log&#123;<span class="number">1</span>, <span class="string">&quot;20:01:01&quot;</span>, <span class="number">10000</span>&#125;&#125;</span><br><span class="line">	t := reflect.TypeOf(m)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, t.Field(<span class="number">0</span>))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%#v \n&quot;</span>, t.Field(<span class="number">1</span>))</span><br><span class="line">	fmt.Println(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// use of FieldByIndex() method</span></span><br><span class="line">	fmt.Println(t.FieldByIndex([]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">0</span>&#125;).Name)</span><br><span class="line">	fmt.Println(t.FieldByIndex([]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>&#125;).Name)</span><br><span class="line">	fmt.Println(t.FieldByIndex([]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">2</span>&#125;).Name)</span><br><span class="line">	fmt.Println(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(t.FieldByIndex([]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">0</span>&#125;).Name)</span><br><span class="line">	fmt.Println(t.FieldByIndex([]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">1</span>&#125;).Name)</span><br><span class="line">	fmt.Println(t.FieldByIndex([]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;).Name)</span><br><span class="line">	fmt.Println(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(t.FieldByName(<span class="string">&quot;User&quot;</span>))</span><br><span class="line">	fmt.Println(t.FieldByName(<span class="string">&quot;Name&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reflect.StructField&#123;Name:&quot;User&quot;, PkgPath:&quot;&quot;, Type:(*reflect.rtype)(0x10bfd20), Tag:&quot;&quot;, Offset:0x0, Index:[]int&#123;0&#125;, Anonymous:false&#125;</span><br><span class="line">reflect.StructField&#123;Name:&quot;Log&quot;, PkgPath:&quot;&quot;, Type:(*reflect.rtype)(0x10bfc60), Tag:&quot;&quot;, Offset:0x20, Index:[]int&#123;1&#125;, Anonymous:false&#125; </span><br><span class="line"></span><br><span class="line">Id</span><br><span class="line">Name</span><br><span class="line">Age</span><br><span class="line"></span><br><span class="line">Id</span><br><span class="line">Time</span><br><span class="line">User</span><br><span class="line"></span><br><span class="line">&#123;User  main.User  0 [0] false&#125; true</span><br><span class="line">&#123;  &lt;nil&gt;  0 [] false&#125; false</span><br></pre></td></tr></table></figure>

<h3 id="In-Out"><a href="#In-Out" class="headerlink" title="In Out"></a>In Out</h3><pre><code>In(i int) Type
NumIn() int
Out(i int) Type
NumOut() int</code></pre>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func1</span><span class="params">(In1 <span class="keyword">int</span>, In2 <span class="keyword">string</span>)</span> <span class="params">(Out1 <span class="keyword">int</span>, Out2 <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HHello <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HHello)</span> <span class="title">Hello</span><span class="params">(req <span class="keyword">string</span>, rep *<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	*rep = <span class="string">&quot;hello:&quot;</span> + req</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//函数</span></span><br><span class="line">	t := reflect.TypeOf(func1)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumIn(); i++ &#123;</span><br><span class="line">		fmt.Println(t.In(i))</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;-------------&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumOut(); i++ &#123;</span><br><span class="line">		fmt.Println(t.Out(i))</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;-------------&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//方法</span></span><br><span class="line">	typ := reflect.TypeOf(<span class="built_in">new</span>(HHello))</span><br><span class="line">	fmt.Println(typ.NumMethod())</span><br><span class="line">	m := typ.Method(<span class="number">0</span>)</span><br><span class="line">	mt := m.Type</span><br><span class="line">	fmt.Println(mt.NumIn())</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; mt.NumIn(); i++ &#123;</span><br><span class="line">		fmt.Println(mt.In(i))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int</span><br><span class="line">string</span><br><span class="line">-------------</span><br><span class="line">int</span><br><span class="line">int</span><br><span class="line">-------------</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">*main.HHello</span><br><span class="line">string</span><br><span class="line">*string</span><br></pre></td></tr></table></figure>

<p>方法的入参个数是算接受者的.</p>
<hr>
<h2 id="Value"><a href="#Value" class="headerlink" title="Value"></a>Value</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Value is the reflection interface to a Go value.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Not all methods apply to all kinds of values. Restrictions,</span></span><br><span class="line"><span class="comment">// if any, are noted in the documentation for each method.</span></span><br><span class="line"><span class="comment">// Use the Kind method to find out the kind of value before</span></span><br><span class="line"><span class="comment">// calling kind-specific methods. Calling a method</span></span><br><span class="line"><span class="comment">// inappropriate to the kind of type causes a run time panic.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The zero Value represents no value.</span></span><br><span class="line"><span class="comment">// Its IsValid method returns false, its Kind method returns Invalid,</span></span><br><span class="line"><span class="comment">// its String method returns &quot;&lt;invalid Value&gt;&quot;, and all other methods panic.</span></span><br><span class="line"><span class="comment">// Most functions and methods never return an invalid value.</span></span><br><span class="line"><span class="comment">// If one does, its documentation states the conditions explicitly.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A Value can be used concurrently by multiple goroutines provided that</span></span><br><span class="line"><span class="comment">// the underlying Go value can be used concurrently for the equivalent</span></span><br><span class="line"><span class="comment">// direct operations.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// To compare two Values, compare the results of the Interface method.</span></span><br><span class="line"><span class="comment">// Using == on two Values does not compare the underlying values</span></span><br><span class="line"><span class="comment">// they represent.</span></span><br><span class="line"><span class="keyword">type</span> Value <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// typ holds the type of the value represented by a Value.</span></span><br><span class="line">    <span class="comment">//指向类型的指针</span></span><br><span class="line">	typ *rtype</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Pointer-valued data or, if flagIndir is set, pointer to data.</span></span><br><span class="line">    <span class="comment">// Valid when either flagIndir is set or typ.pointers() is true.</span></span><br><span class="line">    <span class="comment">//指向值得指针</span></span><br><span class="line">	ptr unsafe.Pointer</span><br><span class="line"></span><br><span class="line">	<span class="comment">// flag holds metadata about the value.</span></span><br><span class="line">	<span class="comment">// The lowest bits are flag bits:</span></span><br><span class="line">	<span class="comment">//	- flagStickyRO: obtained via unexported not embedded field, so read-only</span></span><br><span class="line">	<span class="comment">//	- flagEmbedRO: obtained via unexported embedded field, so read-only</span></span><br><span class="line">	<span class="comment">//	- flagIndir: val holds a pointer to the data</span></span><br><span class="line">	<span class="comment">//	- flagAddr: v.CanAddr is true (implies flagIndir)</span></span><br><span class="line">	<span class="comment">//	- flagMethod: v is a method value.</span></span><br><span class="line">	<span class="comment">// The next five bits give the Kind of the value.</span></span><br><span class="line">	<span class="comment">// This repeats typ.Kind() except for method values.</span></span><br><span class="line">	<span class="comment">// The remaining 23+ bits give a method number for method values.</span></span><br><span class="line">	<span class="comment">// If flag.kind() != Func, code can assume that flagMethod is unset.</span></span><br><span class="line">	<span class="comment">// If ifaceIndir(typ), code can assume that flagIndir is set.</span></span><br><span class="line">	flag</span><br><span class="line"></span><br><span class="line">	<span class="comment">// A method value represents a curried method invocation</span></span><br><span class="line">	<span class="comment">// like r.Read for some receiver r. The typ+val+flag bits describe</span></span><br><span class="line">	<span class="comment">// the receiver r, but the flag&#x27;s Kind bits say Func (methods are</span></span><br><span class="line">	<span class="comment">// functions), and the top bits of the flag give the method number</span></span><br><span class="line">	<span class="comment">// in r&#x27;s type&#x27;s method table.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">//func (v Value) pointer() unsafe.Pointer &#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Addr</span><span class="params">()</span> <span class="title">Value</span></span> &#123;&#125;</span><br><span class="line"><span class="comment">//func (v Value) Bool() bool &#123;&#125;</span></span><br><span class="line"><span class="comment">//func (v Value) Bytes() []byte &#123;&#125;</span></span><br><span class="line"><span class="comment">//func (v Value) runes() []rune &#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">CanAddr</span><span class="params">()</span> <span class="title">bool</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">CanSet</span><span class="params">()</span> <span class="title">bool</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Set</span><span class="params">(x Value)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Call</span><span class="params">(in []Value)</span> []<span class="title">Value</span></span> &#123;&#125;</span><br><span class="line"><span class="comment">//func (v Value) CallSlice(in []Value) []Value &#123;&#125;</span></span><br><span class="line"><span class="comment">//func (v Value) call(op string, in []Value) []Value &#123;&#125;</span></span><br><span class="line"><span class="comment">//func (v Value) Cap() int &#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Elem</span><span class="params">()</span> <span class="title">Value</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Field</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">Value</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">NumField</span><span class="params">()</span> <span class="title">int</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">FieldByIndex</span><span class="params">(index []<span class="keyword">int</span>)</span> <span class="title">Value</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">FieldByName</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">Value</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">FieldByNameFunc</span><span class="params">(match <span class="keyword">func</span>(<span class="keyword">string</span>)</span> <span class="title">bool</span>) <span class="title">Value</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Index</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">Value</span></span> &#123;&#125;</span><br><span class="line"><span class="comment">//func (v Value) Int() int64 &#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Interface</span><span class="params">()</span> <span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;&#125;</span><br><span class="line"><span class="comment">//func (v Value) IsValid() bool &#123;&#125;</span></span><br><span class="line"><span class="comment">//func (v Value) IsZero() bool &#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Kind</span><span class="params">()</span> <span class="title">Kind</span></span> &#123;&#125;</span><br><span class="line"><span class="comment">//func (v Value) Len() int &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Method</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">Value</span></span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">NumMethod</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">MethodByName</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">Value</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Type</span><span class="params">()</span> <span class="title">Type</span></span> &#123;&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="String-1"><a href="#String-1" class="headerlink" title="String"></a>String</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id   <span class="keyword">int</span></span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v := reflect.ValueOf(User&#123;Id: <span class="number">1</span>, Name: <span class="string">&quot;river&quot;</span>, Age: <span class="number">26</span>&#125;)</span><br><span class="line">	fmt.Println(v.String()) <span class="comment">//&lt;main.User Value&gt;</span></span><br><span class="line"></span><br><span class="line">	t := reflect.TypeOf(User&#123;Id: <span class="number">1</span>, Name: <span class="string">&quot;river&quot;</span>, Age: <span class="number">26</span>&#125;)</span><br><span class="line">	fmt.Println(t.String()) <span class="comment">//main.User</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Type-1"><a href="#Type-1" class="headerlink" title="Type"></a>Type</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id   <span class="keyword">int</span></span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v := reflect.ValueOf(User&#123;Id: <span class="number">1</span>, Name: <span class="string">&quot;river&quot;</span>, Age: <span class="number">26</span>&#125;)</span><br><span class="line">	fmt.Println(v.Type()) <span class="comment">//main.User</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h3><blockquote>
<p>Index returns v’s i’th element.</p>
</blockquote>
<blockquote>
<p>It panics if v’s Kind is not Array, Slice, or String or i is out of range.</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := [<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">	s := []<span class="keyword">int</span>&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">	str := <span class="string">&quot;abcd&quot;</span></span><br><span class="line"></span><br><span class="line">	v := reflect.ValueOf(a)</span><br><span class="line">	fmt.Println(v.Index(<span class="number">1</span>)) <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">	v = reflect.ValueOf(s)</span><br><span class="line">	fmt.Println(v.Index(<span class="number">1</span>)) <span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">	v = reflect.ValueOf(str)</span><br><span class="line">	fmt.Println(v.Index(<span class="number">1</span>)) <span class="comment">//98</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Elem-1"><a href="#Elem-1" class="headerlink" title="Elem"></a>Elem</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Elem returns the value that the interface v contains</span></span><br><span class="line"><span class="comment">// or that the pointer v points to.</span></span><br><span class="line"><span class="comment">// It panics if v&#x27;s Kind is not Interface or Ptr.</span></span><br><span class="line"><span class="comment">// It returns the zero Value if v is nil.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id   <span class="keyword">int</span></span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//v := reflect.ValueOf(User&#123;Id: 1, Name: &quot;river&quot;, Age: 26&#125;)</span></span><br><span class="line">	<span class="comment">//fmt.Println(v.Elem()) //panic</span></span><br><span class="line"></span><br><span class="line">	v := reflect.ValueOf(&amp;User&#123;Id: <span class="number">1</span>, Name: <span class="string">&quot;river&quot;</span>, Age: <span class="number">26</span>&#125;)</span><br><span class="line">	fmt.Println(v.Elem()) <span class="comment">//&#123;1 river 26&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// var vv reflect.Value</span></span><br><span class="line">	<span class="comment">// fmt.Println(vv.Elem()) //panic</span></span><br><span class="line"></span><br><span class="line">	v = reflect.ValueOf(&amp;User&#123;&#125;)</span><br><span class="line">	fmt.Println(v.Elem()) <span class="comment">//&#123;0  0&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Call"><a href="#Call" class="headerlink" title="Call"></a>Call</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id   <span class="keyword">int</span></span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span> <span class="title">Printt</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;yes&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v := reflect.ValueOf(User&#123;Id: <span class="number">1</span>, Name: <span class="string">&quot;river&quot;</span>, Age: <span class="number">26</span>&#125;)</span><br><span class="line">	<span class="keyword">var</span> r []reflect.Value</span><br><span class="line">	v.Method(<span class="number">0</span>).Call(r) <span class="comment">//yes</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Kind-1"><a href="#Kind-1" class="headerlink" title="Kind"></a>Kind</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id   <span class="keyword">int</span></span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ff</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v := reflect.ValueOf(User&#123;Id: <span class="number">1</span>, Name: <span class="string">&quot;river&quot;</span>, Age: <span class="number">26</span>&#125;)</span><br><span class="line">	fmt.Println(v.Kind()) <span class="comment">//struct</span></span><br><span class="line"></span><br><span class="line">	v = reflect.ValueOf(<span class="number">1</span>)</span><br><span class="line">	fmt.Println(v.Kind()) <span class="comment">//int</span></span><br><span class="line"></span><br><span class="line">	v = reflect.ValueOf(<span class="string">&quot;2222&quot;</span>)</span><br><span class="line">	fmt.Println(v.Kind()) <span class="comment">//string</span></span><br><span class="line"></span><br><span class="line">	v = reflect.ValueOf([]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;)</span><br><span class="line">	fmt.Println(v.Kind()) <span class="comment">//slice</span></span><br><span class="line"></span><br><span class="line">	v = reflect.ValueOf(ff)</span><br><span class="line">	fmt.Println(v.Kind()) <span class="comment">//func</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>感觉和Type的Kind没啥区别</p>
<h3 id="Set-Addr"><a href="#Set-Addr" class="headerlink" title="Set Addr"></a>Set Addr</h3><blockquote>
<p>CanAddr reports whether the value’s address can be obtained with Addr. Such values are called addressable. A value is addressable if it is an element of a slice, an element of an addressable array, a field of an addressable struct, or the result of dereferencing a pointer. If CanAddr returns false, calling Addr will panic.</p>
</blockquote>
<p>反射中这几种值可以寻址：</p>
<ul>
<li>切片的一个元素(ValueOf().Index())</li>
<li>可寻址数组的一个元素</li>
<li>可寻址结构体的一个字段</li>
<li>解引用的结果</li>
</ul>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id   <span class="keyword">int</span></span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">	pi   *<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v := reflect.ValueOf(User&#123;Id: <span class="number">1</span>, Name: <span class="string">&quot;river&quot;</span>, Age: <span class="number">26</span>&#125;)</span><br><span class="line">	fmt.Println(<span class="string">&quot;1: &quot;</span>, v.CanAddr(), v.CanSet()) <span class="comment">//false false</span></span><br><span class="line"></span><br><span class="line">	v = reflect.ValueOf(&amp;User&#123;Id: <span class="number">1</span>, Name: <span class="string">&quot;river&quot;</span>, Age: <span class="number">26</span>&#125;)</span><br><span class="line">	fmt.Println(<span class="string">&quot;2: &quot;</span>, v.CanAddr(), v.CanSet()) <span class="comment">//false false</span></span><br><span class="line"></span><br><span class="line">	p := <span class="number">10</span></span><br><span class="line">	u := User&#123;Id: <span class="number">1</span>, Name: <span class="string">&quot;river&quot;</span>, Age: <span class="number">26</span>, pi: &amp;p&#125;</span><br><span class="line">	v = reflect.ValueOf(&amp;u.pi)</span><br><span class="line">	fmt.Println(<span class="string">&quot;3: &quot;</span>, v.CanAddr(), v.CanSet()) <span class="comment">//false false</span></span><br><span class="line"></span><br><span class="line">	s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	v = reflect.ValueOf(s)</span><br><span class="line">	fmt.Println(<span class="string">&quot;4: &quot;</span>, v.CanAddr(), v.CanSet()) <span class="comment">//false false</span></span><br><span class="line"></span><br><span class="line">	s = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	v = reflect.ValueOf(s[<span class="number">0</span>])</span><br><span class="line">	fmt.Println(<span class="string">&quot;5: &quot;</span>, v.CanAddr(), v.CanSet()) <span class="comment">//false false</span></span><br><span class="line"></span><br><span class="line">	s = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	v = reflect.ValueOf(&amp;s[<span class="number">1</span>])</span><br><span class="line">	fmt.Println(<span class="string">&quot;6: &quot;</span>, v.CanAddr(), v.CanSet()) <span class="comment">//false false</span></span><br><span class="line"></span><br><span class="line">	s = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	v = reflect.ValueOf(s).Index(<span class="number">0</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;7: &quot;</span>, v.CanAddr(), v.CanSet()) <span class="comment">//true true</span></span><br><span class="line"></span><br><span class="line">	v = reflect.ValueOf(&amp;p)</span><br><span class="line">	fmt.Println(<span class="string">&quot;8: &quot;</span>, v.CanAddr(), v.CanSet()) <span class="comment">//false false</span></span><br><span class="line"></span><br><span class="line">	v = reflect.ValueOf(&amp;p).Elem()</span><br><span class="line">	fmt.Println(<span class="string">&quot;9: &quot;</span>, v.CanAddr(), v.CanSet()) <span class="comment">//true true</span></span><br><span class="line"></span><br><span class="line">	v = reflect.Indirect(reflect.ValueOf(&amp;p))</span><br><span class="line">	fmt.Println(<span class="string">&quot;10: &quot;</span>, v.CanAddr(), v.CanSet()) <span class="comment">//true true</span></span><br><span class="line"></span><br><span class="line">	ss := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	v = reflect.ValueOf(ss).Index(<span class="number">0</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;11: &quot;</span>, v.CanAddr(), v.CanSet()) <span class="comment">//false false</span></span><br><span class="line"></span><br><span class="line">	v = reflect.ValueOf(User&#123;Id: <span class="number">1</span>, Name: <span class="string">&quot;river&quot;</span>, Age: <span class="number">26</span>&#125;).Field(<span class="number">0</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;12: &quot;</span>, v.CanAddr(), v.CanSet()) <span class="comment">//false false</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个寻址可以说非常严格了，4条规则我也是没搞懂太含糊了。只能说解引用是最保险的了。</p>
<h3 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h3><p>类型转换成interface(),还原到ValueOf的入参。结合addr可以修改值</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main function</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i := <span class="number">10</span></span><br><span class="line">	add := reflect.ValueOf(&amp;i).Elem()</span><br><span class="line">	pi := add.Addr().Interface().(*<span class="keyword">int</span>)</span><br><span class="line">	*pi = <span class="number">20</span></span><br><span class="line">	fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i := <span class="number">10</span></span><br><span class="line">	add := reflect.ValueOf(&amp;i).Elem()</span><br><span class="line">	<span class="keyword">if</span> add.CanSet() &#123;</span><br><span class="line">		add.Set(reflect.ValueOf(<span class="number">20</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Method-1"><a href="#Method-1" class="headerlink" title="Method"></a>Method</h3><p>参考Type的函数</p>
<h3 id="Field-1"><a href="#Field-1" class="headerlink" title="Field"></a>Field</h3><p>参考Type的函数</p>
<hr>
<h2 id="Elem-and-Indirect"><a href="#Elem-and-Indirect" class="headerlink" title="Elem and Indirect"></a>Elem and Indirect</h2><p><a href="https://stackoverflow.com/questions/24318389/golang-elem-vs-indirect-in-the-reflect-package">golang - Elem Vs Indirect in the reflect package</a></p>
<p>If a reflect.Value is a pointer, then v.Elem() is equivalent to reflect.Indirect(v). If it is not a pointer, then they are not equivalent:</p>
<ul>
<li>If the value is an interface then reflect.Indirect(v) will return the same value, while v.Elem() will return the contained dynamic value.</li>
<li>If the value is something else, then v.Elem() will panic.</li>
</ul>
<p>The reflect.Indirect helper is intended for cases where you want to accept either a particular type, or a pointer to that type. One example is the database/sql conversion routines: by using reflect.Indirect, it can use the same code paths to handle the various types and pointers to those types.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Type是接口，Value是结构体和方法</li>
<li>函数名要大写，不然num不增加。绑定到指针类型的方法和绑定到对象的方法对于指针的NUM和对象的NUM的计数是不同的</li>
<li>可寻址的条件是很苛刻的</li>
<li>canset比canaddr多了一个限制，即内部是exported的</li>
<li>结合addr和interface可以修改值,或者set</li>
<li>Elem和Indirect在都是指针的时候没有区别</li>
<li>东西挺多的，以后遇到了再补充</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://stackoverflow.com/questions/24318389/golang-elem-vs-indirect-in-the-reflect-package">golang - Elem Vs Indirect in the reflect package</a></p>
<p><a href="https://colobu.com/2018/02/27/go-addressable/">go addressable 详解</a></p>
<p><a href="https://www.geeksforgeeks.org/reflect-elem-function-in-golang-with-examples/">https://www.geeksforgeeks.org/</a></p>
<p><a href="https://juejin.im/post/6844903965448994829">深入理解Golang之interface和reflect</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>skip-list in redis</title>
    <url>/2020-11-06-skip-list%20in%20redis/</url>
    <content><![CDATA[<div class="note info">
            <p>在计算机科学中，跳跃列表是一种数据结构。它使得包含n个元素的有序序列的查找和插入操作的平均时间复杂度都是O(log n)，优于数组的O(n)复杂度。</p><p>快速的查询效果是通过维护一个多层次的链表实现的，且与前一层（下面一层）链表元素的数量相比，每一层链表中的元素的数量更少（见右下角示意图）。一开始时，算法在最稀疏的层次进行搜索，直至需要查找的元素在该层两个相邻的元素中间。这时，算法将跳转到下一个层次，重复刚才的搜索，直到找到需要查找的元素为止。跳过的元素的方法可以是随机性选择[2]或确定性选择[3]，其中前者更为常见。</p>
          </div>

<a id="more"></a>

<p><img src="https://i.loli.net/2020/11/06/DG1hTkBzWs6rLal.gif" alt="2020-11-06_skiplist_gif.gif"></p>
<p>跳表就是有序链表加上多层索引的实现，实现上比红黑树要简单，比红黑树要的一点是可以快速找到一个有序的区间，但是总体上的平衡性是比不上红黑树的，下面主要看看redis中sorted set里面是怎么使用跳表的。</p>
<p><img src="https://i.loli.net/2020/11/07/JvGPy4YuTCow51E.png" alt="2020-11-07-redis_skiplist_pic.png"></p>
<p>第一次费时间画如此精细的图，画完很满意，看图就很好理解了。</p>
<h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ZSETs use a specialized version of Skiplists */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    sds ele;                                <span class="comment">//对象指针</span></span><br><span class="line">    <span class="keyword">double</span> score;                           <span class="comment">//分数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span>         <span class="comment">//指向前驱结点，前指针不指向表头</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span>      <span class="comment">//指向后继结点</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> span;                 <span class="comment">//对应层级的步长，用来计算排位的</span></span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span>    <span class="comment">//链表的头和尾</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;                   <span class="comment">//原始链表的长度</span></span><br><span class="line">    <span class="keyword">int</span> level;                              <span class="comment">//最大的层级(不算表头节点)</span></span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>


<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><h3 id="zslCreate"><a href="#zslCreate" class="headerlink" title="zslCreate"></a>zslCreate</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Create a new skiplist. */</span></span><br><span class="line"><span class="function">zskiplist *<span class="title">zslCreate</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line"></span><br><span class="line">    zsl = zmalloc(<span class="keyword">sizeof</span>(*zsl));</span><br><span class="line">    zsl-&gt;level = <span class="number">1</span>;</span><br><span class="line">    zsl-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//ZSKIPLIST_MAXLEVEL=64</span></span><br><span class="line">    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].forward = <span class="literal">NULL</span>;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].span = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    zsl-&gt;header-&gt;backward = <span class="literal">NULL</span>;</span><br><span class="line">    zsl-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> zsl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建zskiplist结构体，保存全局信息，一开始创建的时候会顺带创建一个表头节点，包含64层</p>
<h3 id="zslCreateNode"><a href="#zslCreateNode" class="headerlink" title="zslCreateNode"></a>zslCreateNode</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Create a skiplist node with the specified number of levels.</span></span><br><span class="line"><span class="comment"> * The SDS string &#x27;ele&#x27; is referenced by the node after the call. */</span></span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslCreateNode</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">double</span> score, sds ele)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *zn =</span><br><span class="line">        zmalloc(<span class="keyword">sizeof</span>(*zn)+level*<span class="keyword">sizeof</span>(struct zskiplistLevel));</span><br><span class="line">    zn-&gt;score = score;</span><br><span class="line">    zn-&gt;ele = ele;</span><br><span class="line">    <span class="keyword">return</span> zn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建zskiplistNode结构，保存节点信息</p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><h3 id="zslInsert"><a href="#zslInsert" class="headerlink" title="zslInsert"></a>zslInsert</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Insert a new node in the skiplist. Assumes the element does not already</span></span><br><span class="line"><span class="comment"> * exist (up to the caller to enforce that). The skiplist takes ownership</span></span><br><span class="line"><span class="comment"> * of the passed SDS string &#x27;ele&#x27;. */</span></span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslInsert</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, sds ele)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rank[ZSKIPLIST_MAXLEVEL];</span><br><span class="line">    <span class="keyword">int</span> i, level;</span><br><span class="line"></span><br><span class="line">    serverAssert(!isnan(score));</span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">/* store rank that is crossed to reach the insert position */</span></span><br><span class="line">        rank[i] = i == (zsl-&gt;level<span class="number">-1</span>) ? <span class="number">0</span> : rank[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                    sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="number">0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            rank[i] += x-&gt;level[i].span;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* we assume the element is not already inside, since we allow duplicated</span></span><br><span class="line"><span class="comment">     * scores, reinserting the same element should never happen since the</span></span><br><span class="line"><span class="comment">     * caller of zslInsert() should test in the hash table if the element is</span></span><br><span class="line"><span class="comment">     * already inside or not. */</span></span><br><span class="line">    <span class="comment">//返回1-maxlevel的随机数</span></span><br><span class="line">    level = zslRandomLevel();</span><br><span class="line">    <span class="keyword">if</span> (level &gt; zsl-&gt;level) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;</span><br><span class="line">            rank[i] = <span class="number">0</span>;</span><br><span class="line">            update[i] = zsl-&gt;header;</span><br><span class="line">            update[i]-&gt;level[i].span = zsl-&gt;length;</span><br><span class="line">        &#125;</span><br><span class="line">        zsl-&gt;level = level;</span><br><span class="line">    &#125;</span><br><span class="line">    x = zslCreateNode(level,score,ele);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</span><br><span class="line">        update[i]-&gt;level[i].forward = x;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* update span covered by update[i] as x is inserted here */</span></span><br><span class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="number">0</span>] - rank[i]);</span><br><span class="line">        update[i]-&gt;level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* increment span for untouched levels */</span></span><br><span class="line">    <span class="keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">        update[i]-&gt;level[i].span++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x-&gt;backward = (update[<span class="number">0</span>] == zsl-&gt;header) ? <span class="literal">NULL</span> : update[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward)</span><br><span class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        zsl-&gt;tail = x;</span><br><span class="line">    zsl-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是update和rank这两个值，update保存每一层的x，即要插入的节点的每一层的左边的节点。后续farwork指针修改用到。然后rank是保存每一层x对应到头结点的位置，而rank[0]是第一层中要插入节点的左边的节点，rank[0]-rank[i]就是插入位置左边的节点到i层对应节点的距离，i的span减去这个值就是插入节点的spn.i的新的span就是rank[0]-rank[i]向右再挪动1位。</p>
<p>然后这里的层级是随机数，随机生成一个1-max level的层级。就是0-max-1的数组索引</p>
<h3 id="zsetAdd"><a href="#zsetAdd" class="headerlink" title="zsetAdd"></a>zsetAdd</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Add a new element or update the score of an existing element in a sorted</span></span><br><span class="line"><span class="comment"> * set, regardless of its encoding.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The set of flags change the command behavior. They are passed with an integer</span></span><br><span class="line"><span class="comment"> * pointer since the function will clear the flags and populate them with</span></span><br><span class="line"><span class="comment"> * other flags to indicate different conditions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The input flags are the following:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ZADD_INCR: Increment the current element score by &#x27;score&#x27; instead of updating</span></span><br><span class="line"><span class="comment"> *            the current element score. If the element does not exist, we</span></span><br><span class="line"><span class="comment"> *            assume 0 as previous score.</span></span><br><span class="line"><span class="comment"> * ZADD_NX:   Perform the operation only if the element does not exist.</span></span><br><span class="line"><span class="comment"> * ZADD_XX:   Perform the operation only if the element already exist.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When ZADD_INCR is used, the new score of the element is stored in</span></span><br><span class="line"><span class="comment"> * &#x27;*newscore&#x27; if &#x27;newscore&#x27; is not NULL.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The returned flags are the following:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ZADD_NAN:     The resulting score is not a number.</span></span><br><span class="line"><span class="comment"> * ZADD_ADDED:   The element was added (not present before the call).</span></span><br><span class="line"><span class="comment"> * ZADD_UPDATED: The element score was updated.</span></span><br><span class="line"><span class="comment"> * ZADD_NOP:     No operation was performed because of NX or XX.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return value:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function returns 1 on success, and sets the appropriate flags</span></span><br><span class="line"><span class="comment"> * ADDED or UPDATED to signal what happened during the operation (note that</span></span><br><span class="line"><span class="comment"> * none could be set if we re-added an element using the same score it used</span></span><br><span class="line"><span class="comment"> * to have, or in the case a zero increment is used).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function returns 0 on erorr, currently only when the increment</span></span><br><span class="line"><span class="comment"> * produces a NAN condition, or when the &#x27;score&#x27; value is NAN since the</span></span><br><span class="line"><span class="comment"> * start.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The commad as a side effect of adding a new element may convert the sorted</span></span><br><span class="line"><span class="comment"> * set internal encoding from ziplist to hashtable+skiplist.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Memory managemnet of &#x27;ele&#x27;:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function does not take ownership of the &#x27;ele&#x27; SDS string, but copies</span></span><br><span class="line"><span class="comment"> * it if needed. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zsetAdd</span><span class="params">(robj *zobj, <span class="keyword">double</span> score, sds ele, <span class="keyword">int</span> *flags, <span class="keyword">double</span> *newscore)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Turn options into simple to check vars. */</span></span><br><span class="line">    <span class="keyword">int</span> incr = (*flags &amp; ZADD_INCR) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> nx = (*flags &amp; ZADD_NX) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> xx = (*flags &amp; ZADD_XX) != <span class="number">0</span>;</span><br><span class="line">    *flags = <span class="number">0</span>; <span class="comment">/* We&#x27;ll return our response flags. */</span></span><br><span class="line">    <span class="keyword">double</span> curscore;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* NaN as input is an error regardless of all the other parameters. */</span></span><br><span class="line">    <span class="keyword">if</span> (isnan(score)) &#123;</span><br><span class="line">        *flags = ZADD_NAN;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Update the sorted set according to its encoding. */</span></span><br><span class="line">    <span class="comment">//压缩列表，暂时不看</span></span><br><span class="line">    <span class="keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *eptr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((eptr = zzlFind(zobj-&gt;ptr,ele,&amp;curscore)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* NX? Return, same element already exists. */</span></span><br><span class="line">            <span class="keyword">if</span> (nx) &#123;</span><br><span class="line">                *flags |= ZADD_NOP;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Prepare the score for the increment if needed. */</span></span><br><span class="line">            <span class="keyword">if</span> (incr) &#123;</span><br><span class="line">                score += curscore;</span><br><span class="line">                <span class="keyword">if</span> (isnan(score)) &#123;</span><br><span class="line">                    *flags |= ZADD_NAN;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (newscore) *newscore = score;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Remove and re-insert when score changed. */</span></span><br><span class="line">            <span class="keyword">if</span> (score != curscore) &#123;</span><br><span class="line">                zobj-&gt;ptr = zzlDelete(zobj-&gt;ptr,eptr);</span><br><span class="line">                zobj-&gt;ptr = zzlInsert(zobj-&gt;ptr,ele,score);</span><br><span class="line">                *flags |= ZADD_UPDATED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!xx) &#123;</span><br><span class="line">            <span class="comment">/* Optimize: check if the element is too large or the list</span></span><br><span class="line"><span class="comment">             * becomes too long *before* executing zzlInsert. */</span></span><br><span class="line">            zobj-&gt;ptr = zzlInsert(zobj-&gt;ptr,ele,score);</span><br><span class="line">            <span class="keyword">if</span> (zzlLength(zobj-&gt;ptr) &gt; server.zset_max_ziplist_entries ||</span><br><span class="line">                sdslen(ele) &gt; server.zset_max_ziplist_value)</span><br><span class="line">                zsetConvert(zobj,OBJ_ENCODING_SKIPLIST);</span><br><span class="line">            <span class="keyword">if</span> (newscore) *newscore = score;</span><br><span class="line">            *flags |= ZADD_ADDED;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *flags |= ZADD_NOP;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//跳表</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) &#123;</span><br><span class="line">        zset *zs = zobj-&gt;ptr;</span><br><span class="line">        zskiplistNode *znode;</span><br><span class="line">        dictEntry *de;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先从hash找，这里相当于是hash+skip list的结合，hash在其他post另外整理</span></span><br><span class="line">        de = dictFind(zs-&gt;dict,ele);</span><br><span class="line">        <span class="comment">//ele原来就存在</span></span><br><span class="line">        <span class="keyword">if</span> (de != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* NX? Return, same element already exists. */</span></span><br><span class="line">            <span class="comment">//nx是只新增，不更新 所以就ret</span></span><br><span class="line">            <span class="keyword">if</span> (nx) &#123;</span><br><span class="line">                *flags |= ZADD_NOP;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curscore = *(<span class="keyword">double</span>*)dictGetVal(de);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Prepare the score for the increment if needed. */</span></span><br><span class="line">            <span class="keyword">if</span> (incr) &#123;</span><br><span class="line">                score += curscore;</span><br><span class="line">                <span class="keyword">if</span> (isnan(score)) &#123;</span><br><span class="line">                    *flags |= ZADD_NAN;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (newscore) *newscore = score;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Remove and re-insert when score changes. */</span></span><br><span class="line">            <span class="comment">//更新分数</span></span><br><span class="line">            <span class="keyword">if</span> (score != curscore) &#123;</span><br><span class="line">                <span class="comment">//更新跳表的分值</span></span><br><span class="line">                znode = zslUpdateScore(zs-&gt;zsl,curscore,ele,score);</span><br><span class="line">                <span class="comment">/* Note that we did not removed the original element from</span></span><br><span class="line"><span class="comment">                 * the hash table representing the sorted set, so we just</span></span><br><span class="line"><span class="comment">                 * update the score. */</span></span><br><span class="line">                <span class="comment">//更新hash的分值</span></span><br><span class="line">                dictGetVal(de) = &amp;znode-&gt;score; <span class="comment">/* Update score ptr. */</span></span><br><span class="line">                *flags |= ZADD_UPDATED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//插入的是新的元素 xx是只更新不新增，所以这里过滤下</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!xx) &#123;</span><br><span class="line">            ele = sdsdup(ele);</span><br><span class="line">            <span class="comment">//插入</span></span><br><span class="line">            znode = zslInsert(zs-&gt;zsl,score,ele);</span><br><span class="line">            serverAssert(dictAdd(zs-&gt;dict,ele,&amp;znode-&gt;score) == DICT_OK);</span><br><span class="line">            *flags |= ZADD_ADDED;</span><br><span class="line">            <span class="keyword">if</span> (newscore) *newscore = score;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *flags |= ZADD_NOP;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown sorted set encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* Never reached. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><h3 id="zslUpdateScore"><a href="#zslUpdateScore" class="headerlink" title="zslUpdateScore"></a>zslUpdateScore</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Update the score of an elmenent inside the sorted set skiplist.</span></span><br><span class="line"><span class="comment"> * Note that the element must exist and must match &#x27;score&#x27;.</span></span><br><span class="line"><span class="comment"> * This function does not update the score in the hash table side, the</span></span><br><span class="line"><span class="comment"> * caller should take care of it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that this function attempts to just update the node, in case after</span></span><br><span class="line"><span class="comment"> * the score update, the node would be exactly at the same position.</span></span><br><span class="line"><span class="comment"> * Otherwise the skiplist is modified by removing and re-adding a new</span></span><br><span class="line"><span class="comment"> * element, which is more costly.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function returns the updated element skiplist node pointer. */</span></span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslUpdateScore</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> curscore, sds ele, <span class="keyword">double</span> newscore)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need to seek to element to update to start: this is useful anyway,</span></span><br><span class="line"><span class="comment">     * we&#x27;ll have to update or remove it. */</span></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score &lt; curscore ||</span><br><span class="line">                    (x-&gt;level[i].forward-&gt;score == curscore &amp;&amp;</span><br><span class="line">                     sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="number">0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存放左边的位置，删除用到</span></span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Jump to our element: note that this function assumes that the</span></span><br><span class="line"><span class="comment">     * element with the matching score exists. */</span></span><br><span class="line">    <span class="comment">//x=current的位置</span></span><br><span class="line">    x = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">    serverAssert(x &amp;&amp; curscore == x-&gt;score &amp;&amp; sdscmp(x-&gt;ele,ele) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the node, after the score update, would be still exactly</span></span><br><span class="line"><span class="comment">     * at the same position, we can just update the score without</span></span><br><span class="line"><span class="comment">     * actually removing and re-inserting the element in the skiplist. */</span></span><br><span class="line">    <span class="comment">//case1 x-&gt;backward == NULL &amp;&amp; x-&gt;level[0].forward == NULL </span></span><br><span class="line">    <span class="comment">//只有一个节点直接更新</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//case2 x-&gt;backward == NULL &amp;&amp; x-&gt;level[0].forward-&gt;score &gt; newscore</span></span><br><span class="line">    <span class="comment">//原来是level0的第一个节点(不算表头节点)，并且右边的分数大于新的分数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//case3 x-&gt;backward-&gt;score &lt; newscore &amp;&amp; x-&gt;level[0].forward == NULL</span></span><br><span class="line">    <span class="comment">//左边的分数小于新的分数并且右边为空</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//case4 x-&gt;backward-&gt;score &lt; newscore &amp;&amp; x-&gt;level[0].forward-&gt;score &gt; newscore</span></span><br><span class="line">    <span class="comment">//左边的分数小于新的分数并且右边的分数大于新的分数</span></span><br><span class="line">    <span class="keyword">if</span> ((x-&gt;backward == <span class="literal">NULL</span> || x-&gt;backward-&gt;score &lt; newscore) &amp;&amp;</span><br><span class="line">        (x-&gt;level[<span class="number">0</span>].forward == <span class="literal">NULL</span> || x-&gt;level[<span class="number">0</span>].forward-&gt;score &gt; newscore))</span><br><span class="line">    &#123;</span><br><span class="line">        x-&gt;score = newscore;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* No way to reuse the old node: we need to remove and insert a new</span></span><br><span class="line"><span class="comment">     * one at a different place. */</span></span><br><span class="line">    zslDeleteNode(zsl, x, update);</span><br><span class="line">    zskiplistNode *newnode = zslInsert(zsl,newscore,x-&gt;ele);</span><br><span class="line">    <span class="comment">/* We reused the old node x-&gt;ele SDS string, free the node now</span></span><br><span class="line"><span class="comment">     * since zslInsert created a new one. */</span></span><br><span class="line">    x-&gt;ele = <span class="literal">NULL</span>;</span><br><span class="line">    zslFreeNode(x);</span><br><span class="line">    <span class="keyword">return</span> newnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先判断如果新的分值更新后如果跳表规则不变，就直接更新在原来的位置。否则，先删除，再插入。</p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h3 id="zslDeleteNode"><a href="#zslDeleteNode" class="headerlink" title="zslDeleteNode"></a>zslDeleteNode</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Internal function used by zslDelete, zslDeleteByScore and zslDeleteByRank */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zslDeleteNode</span><span class="params">(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (update[i]-&gt;level[i].forward == x) &#123;</span><br><span class="line">            <span class="comment">//左边元素到x的步长更新为到x的右边元素的步长</span></span><br><span class="line">            update[i]-&gt;level[i].span += x-&gt;level[i].span - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//更新后继指针</span></span><br><span class="line">            update[i]-&gt;level[i].forward = x-&gt;level[i].forward;</span><br><span class="line">        <span class="comment">//else的情况没有想到</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            update[i]-&gt;level[i].span -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward) &#123;</span><br><span class="line">        <span class="comment">//更新前驱指针</span></span><br><span class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x-&gt;backward;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//更新尾指针</span></span><br><span class="line">        zsl-&gt;tail = x-&gt;backward;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从最高层遍历获取新的层级</span></span><br><span class="line">    <span class="keyword">while</span>(zsl-&gt;level &gt; <span class="number">1</span> &amp;&amp; zsl-&gt;header-&gt;level[zsl-&gt;level<span class="number">-1</span>].forward == <span class="literal">NULL</span>)</span><br><span class="line">        zsl-&gt;level--;</span><br><span class="line">    zsl-&gt;length--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="zslDelete"><a href="#zslDelete" class="headerlink" title="zslDelete"></a>zslDelete</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Delete an element with matching score/element from the skiplist.</span></span><br><span class="line"><span class="comment"> * The function returns 1 if the node was found and deleted, otherwise</span></span><br><span class="line"><span class="comment"> * 0 is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If &#x27;node&#x27; is NULL the deleted node is freed by zslFreeNode(), otherwise</span></span><br><span class="line"><span class="comment"> * it is not freed (but just unlinked) and *node is set to the node pointer,</span></span><br><span class="line"><span class="comment"> * so that it is possible for the caller to reuse the node (including the</span></span><br><span class="line"><span class="comment"> * referenced SDS string at node-&gt;ele). */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslDelete</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, sds ele, zskiplistNode **node)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                     sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="number">0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* We may have multiple elements with the same score, what we need</span></span><br><span class="line"><span class="comment">     * is to find the element with both the right score and object. */</span></span><br><span class="line">    x = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">    <span class="keyword">if</span> (x &amp;&amp; score == x-&gt;score &amp;&amp; sdscmp(x-&gt;ele,ele) == <span class="number">0</span>) &#123;</span><br><span class="line">        zslDeleteNode(zsl, x, update);</span><br><span class="line">        <span class="keyword">if</span> (!node)</span><br><span class="line">            zslFreeNode(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            *node = x;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* not found */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>hash in redis</title>
    <url>/2020-11-07-hash%20in%20redis/</url>
    <content><![CDATA[<div class="note info">
            <p>以前整理过一篇hash,后来git rebase不小心给丢了，重新补一下，part1是基础概念，part2是redis里面的字典实现，对照分析</p>
          </div>

<a id="more"></a>

<h2 id="part1-hash"><a href="#part1-hash" class="headerlink" title="part1 hash"></a>part1 hash</h2><hr>
<h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p><strong>加密函数</strong></p>
<p>可用于数据加密，比如vpn代理传输就常见aes。其他加密函数:md5,sha</p>
<p><strong>唯一标识 数据校验</strong></p>
<p>利用哈希函数<code>相同的key hash后的值是相同的</code>这一特性可用于作为元素的唯一标识，比如Md5标记一个版本，文件。</p>
<p><strong>散列函数</strong></p>
<p>java中hashmap的散列函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = key.hashCode()；</span><br><span class="line">    <span class="comment">//无符号右移</span></span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; (capitity -<span class="number">1</span>); <span class="comment">//capicity 表示散列表的大小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> var1 = <span class="keyword">this</span>.hash;</span><br><span class="line">  <span class="keyword">if</span>(var1 == <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">char</span>[] var2 = <span class="keyword">this</span>.value;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> var3 = <span class="number">0</span>; var3 &lt; <span class="keyword">this</span>.value.length; ++var3) &#123;</span><br><span class="line">      var1 = <span class="number">31</span> * var1 + var2[var3];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.hash = var1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> var1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hashcode就是对字符进行进制计算得到整数。hash函数生成对应桶的索引。h是int,32位，这里右移16位然后异或是为了更加随机吧左右参合在一起增加点随机性()，然后桶的大小是2的倍数，所以capitity-1就是桶的大小，&amp;就类似%，效率更高。</p>
<p><strong>负载均衡</strong></p>
<p>利用hash函数的随机性和唯一性去映射一个端，作为负载均衡的策略。</p>
<h3 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h3><p>就是用一个环来让扩容或者恢复影响变小，可以参考这篇文章：<a href="https://yikun.github.io/2016/06/09/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E8%B7%B5/">一致性哈希算法的理解与实践</a>以后有时间单独分析下。</p>
<h3 id="装载因子"><a href="#装载因子" class="headerlink" title="装载因子"></a>装载因子</h3><p>装载因子=哈希表的元素个数/桶的大小</p>
<ul>
<li>如果是开放寻址法，装载因子要小于1</li>
<li>拉链法装载因子大于1很正常，也不宜太大</li>
</ul>
<p>java中hashmap的装载因子是0.75</p>
<p>可以用红黑树(java hashmap中链表长度大于n就用红黑树，小于m退化成链表)或者跳表去拉链，避免链表过长效率太低。</p>
<h3 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h3><p><strong>开放寻址法</strong></p>
<div class="note success">
            <p>易序列化，利于cpu缓存<br>删除麻烦，冲突代价高，装载因子不能太大浪费时间&lt;1</p>
          </div>

<p><strong>拉链法</strong></p>
<div class="note success">
            <p>装载因子高&gt;10也ok，额外存放指针对小对象来说就有点浪费内存,cpu不友好</p>
          </div>


<h3 id="扩容迁移"><a href="#扩容迁移" class="headerlink" title="扩容迁移"></a>扩容迁移</h3><p>装载因子过大的时候就要考虑扩容了，一般都是扩成原来的2倍大小。像redis本来就是2个ht.扩容就是给ht[1]申请空间，赋地址。然后慢慢迁移。</p>
<p>分批次迁移,redis里面增删改查操作都会让rehash右移一个桶，这样慢慢迁移。并且还有定时函数(这部分就不看了)处理，保证在没有操作的时候，迁移也会进行。</p>
<h3 id="LRU-缓存淘汰算法"><a href="#LRU-缓存淘汰算法" class="headerlink" title="LRU 缓存淘汰算法"></a>LRU 缓存淘汰算法</h3><p>Lru缓存淘汰可以用双链表实现，但是双链表查找是O(n),速度太慢了，可以将hash和双链表结合起来实现。</p>
<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/lrucache_rgb.png"></p>
<hr>
<h2 id="part2-redis-dict"><a href="#part2-redis-dict" class="headerlink" title="part2 redis dict"></a>part2 redis dict</h2><p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/redis_dict_rgb.png"></p>
<h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> (*hashFunction)(<span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哈希表结构，新旧各一个</span></span><br><span class="line"><span class="comment">/* This is our hash table structure. Every dictionary has two of this as we</span></span><br><span class="line"><span class="comment"> * implement incremental rehashing, for the old to the new table. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask; <span class="comment">//size-1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>


<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Create a new hash table */</span></span><br><span class="line"><span class="function">dict *<span class="title">dictCreate</span><span class="params">(dictType *type,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span> *privDataPtr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dict *d = zmalloc(<span class="keyword">sizeof</span>(*d));</span><br><span class="line"></span><br><span class="line">    _dictInit(d,type,privDataPtr);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize the hash table */</span></span><br><span class="line"><span class="keyword">int</span> _dictInit(dict *d, dictType *type,</span><br><span class="line">        <span class="keyword">void</span> *privDataPtr)</span><br><span class="line">&#123;</span><br><span class="line">    _dictReset(&amp;d-&gt;ht[<span class="number">0</span>]);</span><br><span class="line">    _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">    d-&gt;type = type;</span><br><span class="line">    d-&gt;privdata = privDataPtr;</span><br><span class="line">    d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">    d-&gt;iterators = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reset a hash table already initialized with ht_init().</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> This function should only be called by ht_destroy(). */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dictReset(dictht *ht)</span><br><span class="line">&#123;</span><br><span class="line">    ht-&gt;table = <span class="literal">NULL</span>;</span><br><span class="line">    ht-&gt;size = <span class="number">0</span>;</span><br><span class="line">    ht-&gt;sizemask = <span class="number">0</span>;</span><br><span class="line">    ht-&gt;used = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较简单，没啥说的</p>
<h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Add an element to the target hash table */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictAdd</span><span class="params">(dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictEntry *entry = dictAddRaw(d,key,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!entry) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    dictSetVal(d, entry, val);</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Low level add or find:</span></span><br><span class="line"><span class="comment"> * This function adds the entry but instead of setting a value returns the</span></span><br><span class="line"><span class="comment"> * dictEntry structure to the user, that will make sure to fill the value</span></span><br><span class="line"><span class="comment"> * field as he wishes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is also directly exposed to the user API to be called</span></span><br><span class="line"><span class="comment"> * mainly in order to store non-pointers inside the hash value, example:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * entry = dictAddRaw(dict,mykey,NULL);</span></span><br><span class="line"><span class="comment"> * if (entry != NULL) dictSetSignedIntegerVal(entry,1000);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return values:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If key already exists NULL is returned, and &quot;*existing&quot; is populated</span></span><br><span class="line"><span class="comment"> * with the existing entry if existing is not NULL.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If key was added, the hash entry is returned to be manipulated by the caller.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">dictEntry *<span class="title">dictAddRaw</span><span class="params">(dict *d, <span class="keyword">void</span> *key, dictEntry **existing)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    dictEntry *entry;</span><br><span class="line">    dictht *ht;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//rehash未完成，添加的时候step一步 分批次迁移</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get the index of the new element, or -1 if</span></span><br><span class="line"><span class="comment">     * the element already exists. */</span></span><br><span class="line">    <span class="comment">//计算桶的索引，如果key已经存在了返回-1，冲突的情况不返回-1</span></span><br><span class="line">    <span class="keyword">if</span> ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate the memory and store the new entry.</span></span><br><span class="line"><span class="comment">     * Insert the element in top, with the assumption that in a database</span></span><br><span class="line"><span class="comment">     * system it is more likely that recently added entries are accessed</span></span><br><span class="line"><span class="comment">     * more frequently. */</span></span><br><span class="line">    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class="number">1</span>] : &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">    entry = zmalloc(<span class="keyword">sizeof</span>(*entry));</span><br><span class="line">    <span class="comment">//如果没有冲突，则next指向的是Null,否则指向的是原来的头结点</span></span><br><span class="line">    entry-&gt;next = ht-&gt;table[index];</span><br><span class="line">    ht-&gt;table[index] = entry;</span><br><span class="line">    ht-&gt;used++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the hash entry fields. */</span></span><br><span class="line">    dictSetKey(d, entry, key);</span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This function performs just a step of rehashing, and only if there are</span></span><br><span class="line"><span class="comment"> * no safe iterators bound to our hash table. When we have iterators in the</span></span><br><span class="line"><span class="comment"> * middle of a rehashing we can&#x27;t mess with the two hash tables otherwise</span></span><br><span class="line"><span class="comment"> * some element can be missed or duplicated.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is called by common lookup or update operations in the</span></span><br><span class="line"><span class="comment"> * dictionary so that the hash table automatically migrates from H1 to H2</span></span><br><span class="line"><span class="comment"> * while it is actively used. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dictRehashStep(dict *d) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;iterators == <span class="number">0</span>) dictRehash(d,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns the index of a free slot that can be populated with</span></span><br><span class="line"><span class="comment"> * a hash entry for the given &#x27;key&#x27;.</span></span><br><span class="line"><span class="comment"> * If the key already exists, -1 is returned</span></span><br><span class="line"><span class="comment"> * and the optional output parameter may be filled.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that if we are in the process of rehashing the hash table, the</span></span><br><span class="line"><span class="comment"> * index is always returned in the context of the second (new) hash table. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> _dictKeyIndex(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">uint64_t</span> hash, dictEntry **existing)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> idx, table;</span><br><span class="line">    dictEntry *he;</span><br><span class="line">    <span class="keyword">if</span> (existing) *existing = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Expand the hash table if needed */</span></span><br><span class="line">    <span class="keyword">if</span> (_dictExpandIfNeeded(d) == DICT_ERR)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">        idx = hash &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">        <span class="comment">/* Search if this slot does not already contain the given key */</span></span><br><span class="line">        he = d-&gt;ht[table].table[idx];</span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (existing) *existing = he;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictSetKey(d, entry, _key_) do &#123; \</span></span><br><span class="line">    <span class="keyword">if</span> ((d)-&gt;type-&gt;keyDup) \</span><br><span class="line">        (entry)-&gt;key = (d)-&gt;type-&gt;keyDup((d)-&gt;privdata, _key_); \</span><br><span class="line">    <span class="keyword">else</span> \</span><br><span class="line">        (entry)-&gt;key = (_key_); \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<div class="note info">
            <p>dictAddRaw<br>  _dictKeyIndex<br>    _dictExpandIfNeeded</p><p>插入的时候会判断是否需要扩容</p>
          </div>

<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Expand the hash table if needed */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _dictExpandIfNeeded(dict *d)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Incremental rehashing already in progress. Return. */</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) <span class="keyword">return</span> DICT_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the hash table is empty expand it to the initial size. */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> dictExpand(d, DICT_HT_INITIAL_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we reached the 1:1 ratio, and we are allowed to resize the hash</span></span><br><span class="line"><span class="comment">     * table (global setting) or we should avoid it but the ratio between</span></span><br><span class="line"><span class="comment">     * elements/buckets is over the &quot;safe&quot; threshold, we resize doubling</span></span><br><span class="line"><span class="comment">     * the number of buckets. */</span></span><br><span class="line">    <span class="comment">//因为是链表法所以装载因子比较大 dict_force_resize_ratio=5</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used &gt;= d-&gt;ht[<span class="number">0</span>].size &amp;&amp;</span><br><span class="line">        (dict_can_resize ||</span><br><span class="line">         d-&gt;ht[<span class="number">0</span>].used/d-&gt;ht[<span class="number">0</span>].size &gt; dict_force_resize_ratio))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dictExpand(d, d-&gt;ht[<span class="number">0</span>].used*<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Expand or create the hash table */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictExpand</span><span class="params">(dict *d, <span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* the size is invalid if it is smaller than the number of</span></span><br><span class="line"><span class="comment">     * elements already inside the hash table */</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d) || d-&gt;ht[<span class="number">0</span>].used &gt; size)</span><br><span class="line">        <span class="keyword">return</span> DICT_ERR;</span><br><span class="line"></span><br><span class="line">    dictht n; <span class="comment">/* the new hash table */</span></span><br><span class="line">    <span class="comment">//基于初始化大小，每次2倍增长</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> realsize = _dictNextPower(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Rehashing to the same table size is not useful. */</span></span><br><span class="line">    <span class="keyword">if</span> (realsize == d-&gt;ht[<span class="number">0</span>].size) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate the new hash table and initialize all pointers to NULL */</span></span><br><span class="line">    n.size = realsize;</span><br><span class="line">    n.sizemask = realsize<span class="number">-1</span>;  <span class="comment">//2的倍数，可以进制取模</span></span><br><span class="line">    n.table = zcalloc(realsize*<span class="keyword">sizeof</span>(dictEntry*));</span><br><span class="line">    n.used = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Is this the first initialization? If so it&#x27;s not really a rehashing</span></span><br><span class="line"><span class="comment">     * we just set the first hash table so that it can accept keys. */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].table == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = n;</span><br><span class="line">        <span class="keyword">return</span> DICT_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Prepare a second hash table for incremental rehashing */</span></span><br><span class="line">    d-&gt;ht[<span class="number">1</span>] = n;</span><br><span class="line">    d-&gt;rehashidx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缩容"><a href="#缩容" class="headerlink" title="缩容"></a>缩容</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">htNeedsResize</span><span class="params">(dict *dict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> size, used;</span><br><span class="line"></span><br><span class="line">    size = dictSlots(dict);</span><br><span class="line">    used = dictSize(dict);</span><br><span class="line">    <span class="comment">//DICT_HT_INITIAL_SIZE=4 HASHTABLE_MIN_FILL=10</span></span><br><span class="line">    <span class="keyword">return</span> (size &gt; DICT_HT_INITIAL_SIZE &amp;&amp;</span><br><span class="line">            (used*<span class="number">100</span>/size &lt; HASHTABLE_MIN_FILL));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Resize the table to the minimal size that contains all the elements,</span></span><br><span class="line"><span class="comment"> * but with the invariant of a USED/BUCKETS ratio near to &lt;= 1 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictResize</span><span class="params">(dict *d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minimal;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dict_can_resize || dictIsRehashing(d)) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    minimal = d-&gt;ht[<span class="number">0</span>].used;</span><br><span class="line">    <span class="keyword">if</span> (minimal &lt; DICT_HT_INITIAL_SIZE)</span><br><span class="line">        minimal = DICT_HT_INITIAL_SIZE;</span><br><span class="line">    <span class="keyword">return</span> dictExpand(d, minimal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>size&gt;DICT_HT_INITIAL_SIZE说明已经扩容过，并且装载因子也小于0.1的话，就缩容</p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">dictEntry *<span class="title">dictFind</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictEntry *he;</span><br><span class="line">    <span class="keyword">uint64_t</span> h, idx, table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新旧哈希表都为空</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used + d-&gt;ht[<span class="number">1</span>].used == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/* dict is empty */</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line">    <span class="comment">//哈希函数计算</span></span><br><span class="line">    h = dictHashKey(d, key);</span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">      <span class="comment">//取模，计算插入的桶的索引</span></span><br><span class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">        he = d-&gt;ht[table].table[idx];</span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key))</span><br><span class="line">                <span class="keyword">return</span> he;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Performs N steps of incremental rehashing. Returns 1 if there are still</span></span><br><span class="line"><span class="comment"> * keys to move from the old to the new hash table, otherwise 0 is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that a rehashing step consists in moving a bucket (that may have more</span></span><br><span class="line"><span class="comment"> * than one key as we use chaining) from the old to the new hash table, however</span></span><br><span class="line"><span class="comment"> * since part of the hash table may be composed of empty spaces, it is not</span></span><br><span class="line"><span class="comment"> * guaranteed that this function will rehash even a single bucket, since it</span></span><br><span class="line"><span class="comment"> * will visit at max N*10 empty buckets in total, otherwise the amount of</span></span><br><span class="line"><span class="comment"> * work it does would be unbound and the function may block for a long time. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> empty_visits = n*<span class="number">10</span>; <span class="comment">/* Max number of empty buckets to visit. */</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note that rehashidx can&#x27;t overflow as we are sure there are more</span></span><br><span class="line"><span class="comment">         * elements because ht[0].used != 0 */</span></span><br><span class="line">        assert(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)d-&gt;rehashidx);</span><br><span class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</span><br><span class="line">        <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT */</span></span><br><span class="line">        <span class="keyword">while</span>(de) &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> h;</span><br><span class="line"></span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line">            <span class="comment">/* Get the index in the new hash table */</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line">            <span class="comment">//头插法</span></span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//所有桶都迁移完成了</span></span><br><span class="line">    <span class="comment">/* Check if we already rehashed the whole table... */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</span><br><span class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table);</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More to rehash... */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rehashidx是ht[0]迁移的桶的索引，进度。dictRehash函数的参数n是一次rehash需要迁移几个桶，链表的所有节点都一次迁移掉。</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Remove an element, returning DICT_OK on success or DICT_ERR if the</span></span><br><span class="line"><span class="comment"> * element was not found. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictDelete</span><span class="params">(dict *ht, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dictGenericDelete(ht,key,<span class="number">0</span>) ? DICT_OK : DICT_ERR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Search and remove an element. This is an helper function for</span></span><br><span class="line"><span class="comment"> * dictDelete() and dictUnlink(), please check the top comment</span></span><br><span class="line"><span class="comment"> * of those functions. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> dictEntry *<span class="title">dictGenericDelete</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">int</span> nofree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> h, idx;</span><br><span class="line">    dictEntry *he, *prevHe;</span><br><span class="line">    <span class="keyword">int</span> table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span> &amp;&amp; d-&gt;ht[<span class="number">1</span>].used == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除也rehash一个桶</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line">    h = dictHashKey(d, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">        he = d-&gt;ht[table].table[idx];</span><br><span class="line">        <span class="comment">//单链表的删除</span></span><br><span class="line">        prevHe = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key)) &#123;</span><br><span class="line">                <span class="comment">/* Unlink the element from the list */</span></span><br><span class="line">                <span class="keyword">if</span> (prevHe)</span><br><span class="line">                    prevHe-&gt;next = he-&gt;next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    d-&gt;ht[table].table[idx] = he-&gt;next;</span><br><span class="line">                <span class="keyword">if</span> (!nofree) &#123;</span><br><span class="line">                    dictFreeKey(d, he);</span><br><span class="line">                    dictFreeVal(d, he);</span><br><span class="line">                    zfree(he);</span><br><span class="line">                &#125;</span><br><span class="line">                d-&gt;ht[table].used--;</span><br><span class="line">                <span class="keyword">return</span> he;</span><br><span class="line">            &#125;</span><br><span class="line">            prevHe = he;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/* not found */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Add or Overwrite:</span></span><br><span class="line"><span class="comment"> * Add an element, discarding the old value if the key already exists.</span></span><br><span class="line"><span class="comment"> * Return 1 if the key was added from scratch, 0 if there was already an</span></span><br><span class="line"><span class="comment"> * element with such key and dictReplace() just performed a value update</span></span><br><span class="line"><span class="comment"> * operation. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictReplace</span><span class="params">(dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictEntry *entry, *existing, auxentry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Try to add the element. If the key</span></span><br><span class="line"><span class="comment">     * does not exists dictAdd will succeed. */</span></span><br><span class="line">    entry = dictAddRaw(d,key,&amp;existing);</span><br><span class="line">    <span class="keyword">if</span> (entry) &#123;</span><br><span class="line">        dictSetVal(d, entry, val);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the new value and free the old one. Note that it is important</span></span><br><span class="line"><span class="comment">     * to do that in this order, as the value may just be exactly the same</span></span><br><span class="line"><span class="comment">     * as the previous one. In this context, think to reference counting,</span></span><br><span class="line"><span class="comment">     * you want to increment (set), and then decrement (free), and not the</span></span><br><span class="line"><span class="comment">     * reverse. */</span></span><br><span class="line">    auxentry = *existing;</span><br><span class="line">    dictSetVal(d, existing, val);</span><br><span class="line">    dictFreeVal(d, &amp;auxentry);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链表存的是地址，auxentry是原始数据，需要删掉。新的数据还在原来的位置existing插入。</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>[译文]Paxos Made Simple</title>
    <url>/2021-02-20-Paxos-Made-Simple/</url>
    <content><![CDATA[<div class="note primary">
            <p><a href="https://lamport.azurewebsites.net/pubs/paxos-simple.pdf">original paper here</a></p>
          </div>

<a id="more"></a>

<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><p>The Paxos algorithm for implementing a fault-tolerant distributed system has been regarded as difficult to understand perhaps because the original presentation was Greek to many readers [5]. In fact, it is among the simplest and most obvious of distributed algorithms. At its heart is a consensus algorithm—the “synod” algorithm of [5]. The next section shows that this consensus algorithm follows almost unavoidably from the properties we want it to satisfy. The last section explains the complete Paxos algorithm, which is obtained by the straightforward application of consensus to the state machine approach for building a distributed system—an approach that should be well-known, since it is the subject of what is probably the most often-cited article on the theory of distributed systems [4].</p>
<div class="note info">
            <p>todo</p>
          </div>

<hr>
<h2 id="2-The-Consensus-Algorithm"><a href="#2-The-Consensus-Algorithm" class="headerlink" title="2 The Consensus Algorithm"></a>2 The Consensus Algorithm</h2><h3 id="2-1-The-Problem"><a href="#2-1-The-Problem" class="headerlink" title="2.1 The Problem"></a>2.1 The Problem</h3><p>Assume a collection of processes that can propose values. A consensus algorithm ensures that a single one among the proposed values is chosen. If no value is proposed, then no value should be chosen. If a value has been chosen, then processes should be able to learn the chosen value. The safety requirements for consensus are:</p>
<div class="note info">
            <p>todo</p>
          </div>

<ul>
<li>Only a value that has been proposed may be chosen,</li>
<li>Only a single value is chosen, and</li>
<li>A process never learns that a value has been chosen unless it actually has been.</li>
</ul>
<div class="note info">
            <p>todo</p>
          </div>


<p>We won’t try to specify precise liveness requirements. However, the goal is to ensure that some proposed value is eventually chosen and, if a value has been chosen, then a process can eventually learn the value.</p>
<div class="note info">
            <p>todo</p>
          </div>

<p>We let the three roles in the consensus algorithm be performed by three classes of agents: proposers, acceptors, and learners. In an implementation, a single process may act as more than one agent, but the mapping from agents to processes does not concern us here.</p>
<div class="note info">
            <p>todo</p>
          </div>

<p>Assume that agents can communicate with one another by sending messages. We use the customary asynchronous, non-Byzantine model, in which:</p>
<div class="note info">
            <p>todo</p>
          </div>

<ul>
<li>Agents operate at arbitrary speed, may fail by stopping, and may restart. Since all agents may fail after a value is chosen and then restart, a solution is impossible unless some information can be remembered by an agent that has failed and restarted.</li>
</ul>
<div class="note info">
            <p>todo</p>
          </div>

<ul>
<li>Messages can take arbitrarily long to be delivered, can be duplicated, and can be lost, but they are not corrupted.</li>
</ul>
<div class="note info">
            <p>todo</p>
          </div>


<hr>
<h3 id="2-2-Choosing-a-Value"><a href="#2-2-Choosing-a-Value" class="headerlink" title="2.2 Choosing a Value"></a>2.2 Choosing a Value</h3><p>The easiest way to choose a value is to have a single acceptor agent. A proposer sends a proposal to the acceptor, who chooses the first proposed value that it receives. Although simple, this solution is unsatisfactory because the failure of the acceptor makes any further progress impossible. So, let’s try another way of choosing a value. Instead of a single acceptor, let’s use multiple acceptor agents. A proposer sends a proposed value to a set of acceptors. An acceptor may accept the proposed value. The value is chosen when a large enough set of acceptors have accepted it. How large is<br>large enough? To ensure that only a single value is chosen, we can let a large enough set consist of any majority of the agents. Because any two majorities have at least one acceptor in common, this works if an acceptor can accept at most one value. (There is an obvious generalization of a majority that has been observed in numerous papers, apparently starting with [3].) In the absence of failure or message loss, we want a value to be chosen even if only one value is proposed by a single proposer. This suggests the requirement:</p>
<div class="note info">
            <p>todo</p>
          </div>

<p><strong>P1. An acceptor must accept the first proposal that it receives.</strong></p>
<div class="note info">
            <p>todo</p>
          </div>

<p>But this requirement raises a problem. Several values could be proposed by different proposers at about the same time, leading to a situation in which every acceptor has accepted a value, but no single value is accepted by a majority of them. Even with just two proposed values, if each is accepted by about half the acceptors, failure of a single acceptor could make it impossible to learn which of the values was chosen. P1 and the requirement that a value is chosen only when it is accepted<br>by a majority of acceptors imply that an acceptor must be allowed to accept more than one proposal. We keep track of the different proposals that an acceptor may accept by assigning a (natural) number to each proposal, so a proposal consists of a proposal number and a value. To prevent confusion, we require that different proposals have different numbers. How this is<br>2 achieved depends on the implementation, so for now we just assume it. A value is chosen when a single proposal with that value has been accepted by a majority of the acceptors. In that case, we say that the proposal (as well as its value) has been chosen. We can allow multiple proposals to be chosen, but we must guarantee that all chosen proposals have the same value. By induction on the proposal number, it suffices to guarantee:</p>
<div class="note info">
            <p>todo</p>
          </div>

<p><strong>P2. If a proposal with value v is chosen, then every higher-numbered proposal that is chosen has value v.</strong></p>
<div class="note info">
            <p>todo</p>
          </div>

<p>Since numbers are totally ordered, condition P2 guarantees the crucial safety property that only a single value is chosen.</p>
<div class="note info">
            <p>todo</p>
          </div>

<p>To be chosen, a proposal must be accepted by at least one acceptor. So, we can satisfy P2 by satisfying:</p>
<div class="note info">
            <p>todo</p>
          </div>

<p><strong>P2a. If a proposal with value v is chosen, then every higher-numbered proposal accepted by any acceptor has value v.</strong></p>
<div class="note info">
            <p>todo</p>
          </div>

<p>We still maintain P1 to ensure that some proposal is chosen. Because communication is asynchronous, a proposal could be chosen with some particular acceptor c never having received any proposal. Suppose a new proposer “wakes up” and issues a higher-numbered proposal with a different value. P1 requires c to accept this proposal, violating P2a. Maintaining both P1<br>and P2a requires strengthening P2a to:</p>
<div class="note info">
            <p>todo</p>
          </div>

<p><strong>P2b. If a proposal with value v is chosen, then every higher-numbered proposal issued by any proposer has value v.</strong></p>
<div class="note info">
            <p>todo</p>
          </div>

<p>Since a proposal must be issued by a proposer before it can be accepted by an acceptor, P2b implies P2a, which in turn implies P2.</p>
<div class="note info">
            <p>todo</p>
          </div>

<p>To discover how to satisfy P2b, let’s consider how we would prove that it holds. We would assume that some proposal with number m and value v is chosen and show that any proposal issued with number n &gt; m also has value v. We would make the proof easier by using induction on n, so we can prove that proposal number n has value v under the additional assumption that every proposal issued with a number in m . .(n − 1) has value v, where i . . j denotes the set of numbers from i through j. For the proposal numbered m to be chosen, there must be some set C consisting of a majority of acceptors such that every acceptor in C accepted it. Combining this with the induction assumption, the hypothesis that m is chosen implies: 3 Every acceptor in C has accepted a proposal with number in m . .(n − 1), and every proposal with number in m . .(n − 1) accepted by any acceptor has value v.</p>
<div class="note info">
            <p>todo</p>
          </div>

<p>Since any set S consisting of a majority of acceptors contains at least one member of C , we can conclude that a proposal numbered n has value v by ensuring that the following invariant is maintained:</p>
<div class="note info">
            <p>todo</p>
          </div>

<p><strong>P2c. For any v and n, if a proposal with value v and number n is issued, then there is a set S consisting of a majority of acceptors such that either (a) no acceptor in S has accepted any proposal numbered less than n, or (b) v is the value of the highest-numbered proposal among all proposals numbered less than n accepted by the acceptors in S.</strong></p>
<div class="note info">
            <p>todo</p>
          </div>

<p>We can therefore satisfy P2b by maintaining the invariance of P2c.</p>
<div class="note info">
            <p>todo</p>
          </div>

<p>To maintain the invariance of P2c , a proposer that wants to issue a proposal numbered n must learn the highest-numbered proposal with number less than n, if any, that has been or will be accepted by each acceptor in some majority of acceptors. Learning about proposals already accepted is easy enough; predicting future acceptances is hard. Instead of trying to predict the future, the proposer controls it by extracting a promise that there won’t be any such acceptances. In other words, the proposer requests that the acceptors not accept any more proposals numbered less than n. This leads to the following algorithm for issuing proposals.</p>
<div class="note info">
            <p>todo</p>
          </div>

<ol>
<li>A proposer chooses a new proposal number n and sends a request to each member of some set of acceptors, asking it to respond with:</li>
</ol>
<p>(a) A promise never again to accept a proposal numbered less than n, and<br>(b) The proposal with the highest number less than n that it has accepted, if any.</p>
<p>I will call such a request a prepare request with number n</p>
<div class="note info">
            <p>todo</p>
          </div>

<ol>
<li>If the proposer receives the requested responses from a majority of the acceptors, then it can issue a proposal with number n and value v, where v is the value of the highest-numbered proposal among the responses, or is any value selected by the proposer if the responders reported no proposals.</li>
</ol>
<div class="note info">
            <p>todo</p>
          </div>

<p>A proposer issues a proposal by sending, to some set of acceptors, a request that the proposal be accepted. (This need not be the same set of acceptors that responded to the initial requests.) Let’s call this an accept request.</p>
<div class="note info">
            <p>todo</p>
          </div>

<p>This describes a proposer’s algorithm. What about an acceptor? It can receive two kinds of requests from proposers: prepare requests and accept requests. An acceptor can ignore any request without compromising safety. So, we need to say only when it is allowed to respond to a request. It can always respond to a prepare request. It can respond to an accept request,<br>accepting the proposal, iff it has not promised not to. In other words:</p>
<div class="note info">
            <p>todo</p>
          </div>

<p><strong>P1a. An acceptor can accept a proposal numbered n iff it has not responded to a prepare request having a number greater than n.</strong></p>
<div class="note info">
            <p>todo</p>
          </div>

<p>Observe that P1a subsumes P1.</p>
<p>We now have a complete algorithm for choosing a value that satisfies the required safety properties—assuming unique proposal numbers. The final algorithm is obtained by making one small optimization.</p>
<p>Suppose an acceptor receives a prepare request numbered n, but it has already responded to a prepare request numbered greater than n, thereby promising not to accept any new proposal numbered n. There is then no reason for the acceptor to respond to the new prepare request, since it will not accept the proposal numbered n that the proposer wants to issue. So<br>we have the acceptor ignore such a prepare request. We also have it ignore a prepare request for a proposal it has already accepted.</p>
<p>With this optimization, an acceptor needs to remember only the highestnumbered proposal that it has ever accepted and the number of the highestnumbered prepare request to which it has responded. Because P2c must be kept invariant regardless of failures, an acceptor must remember this information even if it fails and then restarts. Note that the proposer can<br>always abandon a proposal and forget all about it—as long as it never tries to issue another proposal with the same number.</p>
<p>Putting the actions of the proposer and acceptor together, we see that the algorithm operates in the following two phases.</p>
<p>Phase 1.</p>
<p>(a) A proposer selects a proposal number n and sends a prepare request with number n to a majority of acceptors.</p>
<p>(b) If an acceptor receives a prepare request with number n greater than that of any prepare request to which it has already responded, then it responds to the request with a promise not to accept any more proposals numbered less than n and with the highest-numbered proposal (if any) that it has accepted.</p>
<p>Phase 2.</p>
<p>(a) If the proposer receives a response to its prepare requests (numbered n) from a majority of acceptors, then it sends an accept request to each of those acceptors for a proposal numbered n with a value v, where v is the value of the highest-numbered proposal among the responses, or is any value if the responses reported no proposals.</p>
<p>(b) If an acceptor receives an accept request for a proposal numbered n, it accepts the proposal unless it has already responded to a prepare request having a number greater than n.</p>
<p>A proposer can make multiple proposals, so long as it follows the algorithm for each one. It can abandon a proposal in the middle of the protocol at any time. (Correctness is maintained, even though requests and/or responses for the proposal may arrive at their destinations long after the proposal was abandoned.) It is probably a good idea to abandon a proposal if some<br>proposer has begun trying to issue a higher-numbered one. Therefore, if an acceptor ignores a prepare or accept request because it has already received a prepare request with a higher number, then it should probably inform the proposer, who should then abandon its proposal. This is a performance optimization that does not affect correctness.</p>
<hr>
<h3 id="2-3-Learning-a-Chosen-Value"><a href="#2-3-Learning-a-Chosen-Value" class="headerlink" title="2.3 Learning a Chosen Value"></a>2.3 Learning a Chosen Value</h3><p>To learn that a value has been chosen, a learner must find out that a proposal has been accepted by a majority of acceptors. The obvious algorithm is to have each acceptor, whenever it accepts a proposal, respond to all learners, sending them the proposal. This allows learners to find out about a chosen value as soon as possible, but it requires each acceptor to respond<br>to each learner—a number of responses equal to the product of the number of acceptors and the number of learners.</p>
<p>The assumption of non-Byzantine failures makes it easy for one learner to find out from another learner that a value has been accepted. We can have the acceptors respond with their acceptances to a distinguished learner, which in turn informs the other learners when a value has been chosen. This approach requires an extra round for all the learners to discover the chosen value. It is also less reliable, since the distinguished learner could fail. But it requires a number of responses equal only to the sum of the number of acceptors and the number of learners.</p>
<p>More generally, the acceptors could respond with their acceptances to some set of distinguished learners, each of which can then inform all the learners when a value has been chosen. Using a larger set of distinguished learners provides greater reliability at the cost of greater communication complexity.</p>
<p>Because of message loss, a value could be chosen with no learner ever finding out. The learner could ask the acceptors what proposals they have accepted, but failure of an acceptor could make it impossible to know whether or not a majority had accepted a particular proposal. In that case, learners will find out what value is chosen only when a new proposal is chosen. If a learner needs to know whether a value has been chosen, it can have a proposer issue a proposal, using the algorithm described above.</p>
<hr>
<h3 id="2-4-Progress"><a href="#2-4-Progress" class="headerlink" title="2.4 Progress"></a>2.4 Progress</h3><p>It’s easy to construct a scenario in which two proposers each keep issuing a sequence of proposals with increasing numbers, none of which are ever chosen. Proposer p completes phase 1 for a proposal number n1. Another proposer q then completes phase 1 for a proposal number n2 &gt; n1. Proposer p’s phase 2 accept requests for a proposal numbered n1 are ignored because<br>the acceptors have all promised not to accept any new proposal numbered less than n2. So, proposer p then begins and completes phase 1 for a new proposal number n3 &gt; n2, causing the second phase 2 accept requests of proposer q to be ignored. And so on.</p>
<p>To guarantee progress, a distinguished proposer must be selected as the only one to try issuing proposals. If the distinguished proposer can communicate successfully with a majority of acceptors, and if it uses a proposal with number greater than any already used, then it will succeed in issuing a proposal that is accepted. By abandoning a proposal and trying again if it learns about some request with a higher proposal number, the distinguished proposer will eventually choose a high enough proposal number.</p>
<p>If enough of the system (proposer, acceptors, and communication network) is working properly, liveness can therefore be achieved by electing a single distinguished proposer. The famous result of Fischer, Lynch, and Patterson [1] implies that a reliable algorithm for electing a proposer must use either randomness or real time—for example, by using timeouts. However,<br>safety is ensured regardless of the success or failure of the election.</p>
<hr>
<h3 id="2-5-The-Implementation"><a href="#2-5-The-Implementation" class="headerlink" title="2.5 The Implementation"></a>2.5 The Implementation</h3><p>The Paxos algorithm [5] assumes a network of processes. In its consensus algorithm, each process plays the role of proposer, acceptor, and learner. The algorithm chooses a leader, which plays the roles of the distinguished proposer and the distinguished learner. The Paxos consensus algorithm is precisely the one described above, where requests and responses are sent as ordinary messages. (Response messages are tagged with the corresponding proposal number to prevent confusion.) Stable storage, preserved during failures, is used to maintain the information that the acceptor must remember. An acceptor records its intended response in stable storage before actually sending the response.</p>
<p>All that remains is to describe the mechanism for guaranteeing that no two proposals are ever issued with the same number. Different proposers choose their numbers from disjoint sets of numbers, so two different proposers never issue a proposal with the same number. Each proposer remembers (in stable storage) the highest-numbered proposal it has tried to issue,<br>and begins phase 1 with a higher proposal number than any it has already used.</p>
<hr>
<h2 id="3-Implementing-a-State-Machine"><a href="#3-Implementing-a-State-Machine" class="headerlink" title="3 Implementing a State Machine"></a>3 Implementing a State Machine</h2><p>A simple way to implement a distributed system is as a collection of clients that issue commands to a central server. The server can be described as a deterministic state machine that performs client commands in some sequence. The state machine has a current state; it performs a step by taking as input a command and producing an output and a new state. For example, the clients of a distributed banking system might be tellers, and the state-machine state might consist of the account balances of all users. A withdrawal would be performed by executing a state machine command that decreases an account’s balance if and only if the balance is greater than the amount withdrawn, producing as output the old and new balances.</p>
<p>An implementation that uses a single central server fails if that server fails. We therefore instead use a collection of servers, each one independently implementing the state machine. Because the state machine is deterministic, all the servers will produce the same sequences of states and outputs if they all execute the same sequence of commands. A client issuing a command can then use the output generated for it by any server.</p>
<p>To guarantee that all servers execute the same sequence of state machine commands, we implement a sequence of separate instances of the Paxos consensus algorithm, the value chosen by the i th instance being the ith state machine command in the sequence. Each server plays all the roles (proposer, acceptor, and learner) in each instance of the algorithm. For now, I assume that the set of servers is fixed, so all instances of the consensus algorithm use the same sets of agents.</p>
<p>In normal operation, a single server is elected to be the leader, which acts as the distinguished proposer (the only one that tries to issue proposals) in all instances of the consensus algorithm. Clients send commands to the leader, who decides where in the sequence each command should appear. If the leader decides that a certain client command should be the 135th<br>command, it tries to have that command chosen as the value of the 135th instance of the consensus algorithm. It will usually succeed. It might fail because of failures, or because another server also believes itself to be the leader and has a different idea of what the 135th command should be. But the consensus algorithm ensures that at most one command can be chosen as the 135th one.</p>
<p>Key to the efficiency of this approach is that, in the Paxos consensus algorithm, the value to be proposed is not chosen until phase 2. Recall that, after completing phase 1 of the proposer’s algorithm, either the value to be proposed is determined or else the proposer is free to propose any value. I will now describe how the Paxos state machine implementation works during normal operation. Later, I will discuss what can go wrong. I consider what happens when the previous leader has just failed and a new leader has been selected. (System startup is a special case in which no commands have yet been proposed.)</p>
<p>The new leader, being a learner in all instances of the consensus algorithm, should know most of the commands that have already been chosen. Suppose it knows commands 1–134, 138, and 139—that is, the values chosen in instances 1–134, 138, and 139 of the consensus algorithm. (We will see later how such a gap in the command sequence could arise.) It then executes phase 1 of instances 135–137 and of all instances greater than 139. (I describe below how this is done.) Suppose that the outcome of these executions determine the value to be proposed in instances 135 and 140, but leaves the proposed value unconstrained in all other instances. The leader then executes phase 2 for instances 135 and 140, thereby choosing commands<br>135 and 140.</p>
<p>The leader, as well as any other server that learns all the commands the leader knows, can now execute commands 1–135. However, it can’t execute commands 138–140, which it also knows, because commands 136 and 137 have yet to be chosen. The leader could take the next two commands requested by clients to be commands 136 and 137. Instead, we let it fill the gap immediately by proposing, as commands 136 and 137, a special “noop” command that leaves the state unchanged. (It does this by executing phase 2 of instances 136 and 137 of the consensus algorithm.) Once these no-op commands have been chosen commands 138–140 can be executed.</p>
<p>Commands 1–140 have now been chosen. The leader has also completed phase 1 for all instances greater than 140 of the consensus algorithm, and it is free to propose any value in phase 2 of those instances. It assigns command number 141 to the next command requested by a client, proposing it as the value in phase 2 of instance 141 of the consensus algorithm. It proposes the next client command it receives as command 142, and so on.</p>
<p>The leader can propose command 142 before it learns that its proposed command 141 has been chosen. It’s possible for all the messages it sent in proposing command 141 to be lost, and for command 142 to be chosen before any other server has learned what the leader proposed as command 141. When the leader fails to receive the expected response to its phase 2 messages in instance 141, it will retransmit those messages. If all goes well, its proposed command will be chosen. However, it could fail first, leaving a gap in the sequence of chosen commands. In general, suppose a leader can get α commands ahead—that is, it can propose commands i + 1 through i +α after commands 1 through i are chosen. A gap of up to α−1 commands could then arise.</p>
<p>A newly chosen leader executes phase 1 for infinitely many instances of the consensus algorithm—in the scenario above, for instances 135–137 and all instances greater than 139. Using the same proposal number for all instances, it can do this by sending a single reasonably short message to the other servers. In phase 1, an acceptor responds with more than a simple OK only if it has already received a phase 2 message from some proposer. (In the scenario, this was the case only for instances 135 and 140.) Thus, a server (acting as acceptor) can respond for all instances with a single reasonably short message. Executing these infinitely many instances of phase 1 therefore poses no problem.</p>
<p>Since failure of the leader and election of a new one should be rare events, the effective cost of executing a state machine command—that is, of achieving consensus on the command/value—is the cost of executing only phase 2 of the consensus algorithm. It can be shown that phase 2 of the Paxos consensus algorithm has the minimum possible cost of any algorithm<br>for reaching agreement in the presence of faults [2]. Hence, the Paxos algorithm is essentially optimal.</p>
<p>This discussion of the normal operation of the system assumes that there is always a single leader, except for a brief period between the failure of the current leader and the election of a new one. In abnormal circumstances, the leader election might fail. If no server is acting as leader, then no new commands will be proposed. If multiple servers think they are leaders, then they can all propose values in the same instance of the consensus algorithm, which could prevent any value from being chosen. However, safety is preserved—two different servers will never disagree on the value chosen as the ith state machine command. Election of a single leader is needed only to ensure progress.</p>
<p>If the set of servers can change, then there must be some way of determining what servers implement what instances of the consensus algorithm. The easiest way to do this is through the state machine itself. The current set of servers can be made part of the state and can be changed with ordinary state-machine commands. We can allow a leader to get α commands ahead by letting the set of servers that execute instance i + α of the consensus algorithm be specified by the state after execution of the i th state machine command. This permits a simple implementation of an arbitrarily sophisticated reconfiguration algorithm.</p>
<p>References<br>[1] Michael J. Fischer, Nancy Lynch, and Michael S. Paterson. Impossibility of distributed consensus with one faulty process. Journal of the ACM, 32(2):374–382, April 1985.</p>
<p>[2] Idit Keidar and Sergio Rajsbaum. On the cost of fault-tolerant consensus when there are no faults—a tutorial.TechnicalReport MIT-LCS-TR-821, Laboratory for Computer Science, Massachusetts Institute Technology, Cambridge, MA, 02139, May 2001. also published in SIGACT News 32(2) (June 2001).</p>
<p>[3] Leslie Lamport. The implementation of reliable distributed multiprocess systems. Computer Networks, 2:95–114, 1978.</p>
<p>[4] Leslie Lamport. Time, clocks, and the ordering of events in a distributed system. Communications of the ACM, 21(7 :558–565, July 1978.</p>
<p>[5] Leslie Lamport. The part-time parliament. ACM Transactions on Computer Systems, 16(2):133–169, May 1998.</p>
<hr>
<p>其他资料</p>
<div class="pdfobject-container" data-target="https://blog-1254238374.cos.ap-hongkong.myqcloud.com/blog/Nitzan.pdf" data-height="1000px"></div>
]]></content>
  </entry>
  <entry>
    <title>epoll的源码</title>
    <url>/2020-03-07-epoll%E7%9A%84%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://my.oschina.net/alchemystar/blog/3008840">从linux源码看epoll</a></p>
<p><a href="https://www.cnblogs.com/l2017/p/10830391.html">epoll源码解析翻译——说使用了mmap的都是骗子</a></p>
<p>–是否使用了mmap还存疑，源码分析中有看到mmap的函数，todo</p>
<p><a href="https://github.com/torvalds/linux/tree/master/fs">linux内核源码</a></p>
<hr>
<a id="more"></a>

<p><img src="https://i.loli.net/2020/03/07/WO65XHJTV7S4iMl.png" alt="eventpoll结构.png"></p>
<hr>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">SYSCALL_DEFINE1(epoll_create, <span class="keyword">int</span>, size)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> do_epoll_create(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_epoll_create</span><span class="params">(<span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> error, fd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check the EPOLL_* constant for consistency.  */</span></span><br><span class="line">	BUILD_BUG_ON(EPOLL_CLOEXEC != O_CLOEXEC);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; ~EPOLL_CLOEXEC)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Create the internal data structure (&quot;struct eventpoll&quot;).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	error = ep_alloc(&amp;ep); <span class="comment">/* 在内核空间申请eventpoll内存 */</span></span><br><span class="line">	<span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Creates all the items needed to setup an eventpoll file. That is,</span></span><br><span class="line"><span class="comment">	 * a file structure and a free file descriptor.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	fd = get_unused_fd_flags(O_RDWR | (flags &amp; O_CLOEXEC)); <span class="comment">/* 获取一个可用的文件描述符 */</span></span><br><span class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		error = fd;</span><br><span class="line">		<span class="keyword">goto</span> out_free_ep;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 在匿名inode文件系统中分配一个inode,并得到其file结构体 */</span></span><br><span class="line">	<span class="comment">/* file-&gt;private_data = ep; */</span></span><br><span class="line">	<span class="comment">/* file-&gt;f_op = &amp;eventpoll_fops */</span></span><br><span class="line">	file = anon_inode_getfile(<span class="string">&quot;[eventpoll]&quot;</span>, &amp;eventpoll_fops, ep,</span><br><span class="line">				 O_RDWR | (flags &amp; O_CLOEXEC));</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(file)) &#123;</span><br><span class="line">		error = PTR_ERR(file);</span><br><span class="line">		<span class="keyword">goto</span> out_free_fd;</span><br><span class="line">	&#125;</span><br><span class="line">	ep-&gt;file = file;</span><br><span class="line">	<span class="comment">/* 将file填入文件描述符数组 */</span></span><br><span class="line">	fd_install(fd, file);</span><br><span class="line">	<span class="keyword">return</span> fd;</span><br><span class="line"></span><br><span class="line">out_free_fd:</span><br><span class="line">	put_unused_fd(fd);</span><br><span class="line">out_free_ep:</span><br><span class="line">	ep_free(ep);</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p><code>eventpoll_fops</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">eventpoll_fops</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="keyword">loff_t</span> (*llseek) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*read) (struct file *, <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*write) (struct file *, <span class="keyword">const</span> <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*read_iter) (struct kiocb *, struct iov_iter *);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*write_iter) (struct kiocb *, struct iov_iter *);</span><br><span class="line">	<span class="keyword">int</span> (*iopoll)(struct kiocb *kiocb, <span class="keyword">bool</span> spin);</span><br><span class="line">	<span class="keyword">int</span> (*iterate) (struct file *, struct dir_context *);</span><br><span class="line">	<span class="keyword">int</span> (*iterate_shared) (struct file *, struct dir_context *);</span><br><span class="line">	<span class="keyword">__poll_t</span> (*poll) (struct file *, struct poll_table_struct *);</span><br><span class="line">	<span class="keyword">long</span> (*unlocked_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">	<span class="keyword">long</span> (*compat_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">	<span class="keyword">int</span> (*mmap) (struct file *, struct vm_area_struct *);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> mmap_supported_flags;</span><br><span class="line">	<span class="keyword">int</span> (*open) (struct inode *, struct file *);</span><br><span class="line">	<span class="keyword">int</span> (*flush) (struct file *, <span class="keyword">fl_owner_t</span> id);</span><br><span class="line">	<span class="keyword">int</span> (*release) (struct inode *, struct file *);</span><br><span class="line">	<span class="keyword">int</span> (*fsync) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">loff_t</span>, <span class="keyword">int</span> datasync);</span><br><span class="line">	<span class="keyword">int</span> (*fasync) (<span class="keyword">int</span>, struct file *, <span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">int</span> (*lock) (struct file *, <span class="keyword">int</span>, struct file_lock *);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*sendpage) (struct file *, struct page *, <span class="keyword">int</span>, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *, <span class="keyword">int</span>);</span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(struct file *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> (*check_flags)(<span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">int</span> (*flock) (struct file *, <span class="keyword">int</span>, struct file_lock *);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*splice_write)(struct pipe_inode_info *, struct file *, <span class="keyword">loff_t</span> *, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*splice_read)(struct file *, <span class="keyword">loff_t</span> *, struct pipe_inode_info *, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">int</span> (*setlease)(struct file *, <span class="keyword">long</span>, struct file_lock **, <span class="keyword">void</span> **);</span><br><span class="line">	<span class="keyword">long</span> (*fallocate)(struct file *file, <span class="keyword">int</span> mode, <span class="keyword">loff_t</span> offset,</span><br><span class="line">			  <span class="keyword">loff_t</span> len);</span><br><span class="line">	<span class="keyword">void</span> (*show_fdinfo)(struct seq_file *m, struct file *f);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">	<span class="keyword">unsigned</span> (*mmap_capabilities)(struct file *);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">ssize_t</span> (*copy_file_range)(struct file *, <span class="keyword">loff_t</span>, struct file *,</span><br><span class="line">			<span class="keyword">loff_t</span>, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">loff_t</span> (*remap_file_range)(struct file *file_in, <span class="keyword">loff_t</span> pos_in,</span><br><span class="line">				   struct file *file_out, <span class="keyword">loff_t</span> pos_out,</span><br><span class="line">				   <span class="keyword">loff_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> remap_flags);</span><br><span class="line">	<span class="keyword">int</span> (*fadvise)(struct file *, <span class="keyword">loff_t</span>, <span class="keyword">loff_t</span>, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<pre><code>epoll_create
|-&gt;do_epoll_create
    |-&gt;file-&gt;private_data = ep
    |-&gt;fd_install</code></pre>
<ul>
<li>epoll_create最主要创建一个eventpoll结构体 </li>
<li>epfd-&gt;file-&gt;private_date = eventpoll</li>
<li>epfd-&gt;file-&gt;f_op = eventpoll_fops</li>
<li>epoll_create的函数参数，在内核某个版本后已经没什么用了，只需要填入大于0的数即可。</li>
<li>eventpoll的rdllink链表节点是epitem的rdllink成员，哪个epitem就绪了就把自己的rdllink加到双向链表rdllink中</li>
<li>eventpoll的rbr红黑树节点是epitem的rbn成员，每个监控的epitem都要加到红黑树中</li>
</ul>
<p>epoll_create执行后的主要结构：</p>
<p><strong>图片来源:</strong> </p>
<p><a href="https://my.oschina.net/alchemystar/blog/3008840">从linux源码看epoll</a></p>
<p><img src="https://i.loli.net/2020/03/07/4wuARDdPa2fzQxB.png" alt="epoll_creat.jpg"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * anon_inode_getfile - creates a new file instance by hooking it up to an</span></span><br><span class="line"><span class="comment"> *                      anonymous inode, and a dentry that describe the &quot;class&quot;</span></span><br><span class="line"><span class="comment"> *                      of the file</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @name:    [in]    name of the &quot;class&quot; of the new file</span></span><br><span class="line"><span class="comment"> * @fops:    [in]    file operations for the new file</span></span><br><span class="line"><span class="comment"> * @priv:    [in]    private data for the new file (will be file&#x27;s private_data)</span></span><br><span class="line"><span class="comment"> * @flags:   [in]    flags</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Creates a new file by hooking it on a single inode. This is useful for files</span></span><br><span class="line"><span class="comment"> * that do not need to have a full-fledged inode in order to operate correctly.</span></span><br><span class="line"><span class="comment"> * All the files created with anon_inode_getfile() will share a single inode,</span></span><br><span class="line"><span class="comment"> * hence saving memory and avoiding code duplication for the file/inode/dentry</span></span><br><span class="line"><span class="comment"> * setup.  Returns the newly created file* or an error pointer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通过将其挂接到单个inode 上来创建一个新文件。这对于文件*不需要完整的inode才能正常运行</span></span><br><span class="line"><span class="comment">非常有用。*使用anon_inode_getfile（）创建的所有文件将共享一个inode，从而节省内存并避免文件</span></span><br><span class="line"><span class="comment">/ inode / dentry的代码重复 */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct file *<span class="title">anon_inode_getfile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">const</span> struct file_operations *fops,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">void</span> *priv, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(anon_inode_inode))</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENODEV);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fops-&gt;owner &amp;&amp; !try_module_get(fops-&gt;owner))</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOENT);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We know the anon_inode inode count is always greater than zero,</span></span><br><span class="line"><span class="comment">	 * so ihold() is safe.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ihold(anon_inode_inode);</span><br><span class="line">	file = alloc_file_pseudo(anon_inode_inode, anon_inode_mnt, name,</span><br><span class="line">				 flags &amp; (O_ACCMODE | O_NONBLOCK), fops);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(file))</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">	file-&gt;f_mapping = anon_inode_inode-&gt;i_mapping;</span><br><span class="line"></span><br><span class="line">	file-&gt;private_data = priv;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> file;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">	iput(anon_inode_inode);</span><br><span class="line">	module_put(fops-&gt;owner);</span><br><span class="line">	<span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct file *<span class="title">alloc_file_pseudo</span><span class="params">(struct inode *inode, struct vfsmount *mnt,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">const</span> struct file_operations *fops)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> <span class="title">anon_ops</span> =</span> &#123;</span><br><span class="line">		.d_dname = simple_dname</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">this</span> =</span> QSTR_INIT(name, <span class="built_in">strlen</span>(name));</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">path</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line"></span><br><span class="line">	path.dentry = d_alloc_pseudo(mnt-&gt;mnt_sb, &amp;<span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">if</span> (!path.dentry)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">	<span class="keyword">if</span> (!mnt-&gt;mnt_sb-&gt;s_d_op)</span><br><span class="line">		d_set_d_op(path.dentry, &amp;anon_ops);</span><br><span class="line">	path.mnt = mntget(mnt);</span><br><span class="line">	d_instantiate(path.dentry, inode);</span><br><span class="line">	file = alloc_file(&amp;path, flags, fops);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(file)) &#123;</span><br><span class="line">		ihold(inode);</span><br><span class="line">		path_put(&amp;path);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * alloc_file - allocate and initialize a &#x27;struct file&#x27;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @path: the (dentry, vfsmount) pair for the new file</span></span><br><span class="line"><span class="comment"> * @flags: O_... flags with which the new file will be opened</span></span><br><span class="line"><span class="comment"> * @fop: the &#x27;struct file_operations&#x27; for the new file</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct file *<span class="title">alloc_file</span><span class="params">(<span class="keyword">const</span> struct path *path, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">const</span> struct file_operations *fop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line"></span><br><span class="line">	file = alloc_empty_file(flags, current_cred());</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(file))</span><br><span class="line">		<span class="keyword">return</span> file;</span><br><span class="line"></span><br><span class="line">	file-&gt;f_path = *path;</span><br><span class="line">	file-&gt;f_inode = path-&gt;dentry-&gt;d_inode;</span><br><span class="line">	file-&gt;f_mapping = path-&gt;dentry-&gt;d_inode-&gt;i_mapping;</span><br><span class="line">	file-&gt;f_wb_err = filemap_sample_wb_err(file-&gt;f_mapping);</span><br><span class="line">	<span class="keyword">if</span> ((file-&gt;f_mode &amp; FMODE_READ) &amp;&amp;</span><br><span class="line">	     likely(fop-&gt;read || fop-&gt;read_iter))</span><br><span class="line">		file-&gt;f_mode |= FMODE_CAN_READ;</span><br><span class="line">	<span class="keyword">if</span> ((file-&gt;f_mode &amp; FMODE_WRITE) &amp;&amp;</span><br><span class="line">	     likely(fop-&gt;write || fop-&gt;write_iter))</span><br><span class="line">		file-&gt;f_mode |= FMODE_CAN_WRITE;</span><br><span class="line">	file-&gt;f_mode |= FMODE_OPENED;</span><br><span class="line">	file-&gt;f_op = fop;</span><br><span class="line">	<span class="keyword">if</span> ((file-&gt;f_mode &amp; (FMODE_READ | FMODE_WRITE)) == FMODE_READ)</span><br><span class="line">		i_readcount_inc(path-&gt;dentry-&gt;d_inode);</span><br><span class="line">	<span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p><img src="https://i.loli.net/2020/03/07/BUrIsdH9ARptzJu.png" alt="eventpoll.png"></p>
<hr>
<p><code>epoll_event</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">	<span class="keyword">__poll_t</span> events; <span class="comment">//事件</span></span><br><span class="line">	__u64 data;		 <span class="comment">//fd</span></span><br><span class="line">&#125; EPOLL_PACKED;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p><code>struct epitem</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Each file descriptor added to the eventpoll interface will</span></span><br><span class="line"><span class="comment"> * have an entry of this type linked to the &quot;rbr&quot; RB tree.</span></span><br><span class="line"><span class="comment"> * Avoid increasing the size of this struct, there can be many thousands</span></span><br><span class="line"><span class="comment"> * of these on a server and we do not want this to take another cache line.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//每一个添加到eventpoll的文件描述符都有一个epitem这样的条目链接到红黑树节点</span></span><br><span class="line"><span class="comment">//避免增加此结构的大小，服务器上可能有成千上万个这样的结构，我们不希望这占用另一个缓存行。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="comment">/* RB tree node links this structure to the eventpoll RB tree */</span></span><br><span class="line">		<span class="comment">//RB树节点将此结构链接到eventpoll RB树</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rbn</span>;</span></span><br><span class="line">		<span class="comment">/* Used to free the struct epitem */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* List header used to link this structure to the eventpoll ready list */</span></span><br><span class="line">	<span class="comment">//用来连接到eventpoll的就绪队列链表头</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllink</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Works together &quot;struct eventpoll&quot;-&gt;ovflist in keeping the</span></span><br><span class="line"><span class="comment">	 * single linked chain of items.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//和eventpoll结构体的ovflist成员一起工作保持连接所有item成员</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The file descriptor information this item refers to */</span></span><br><span class="line">	<span class="comment">//引用文件描述符信息</span></span><br><span class="line">	<span class="comment">//epoll_ctrl add时候在红黑树中查找是否存在就是通过这个值</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span> <span class="title">ffd</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Number of active wait queue attached to poll operations */</span></span><br><span class="line">	<span class="comment">//附加到轮询操作的活跃等待队列数</span></span><br><span class="line">	<span class="keyword">int</span> nwait;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* List containing poll wait queues */</span></span><br><span class="line">	<span class="comment">//poll 等待队列的链表头</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pwqlist</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The &quot;container&quot; of this item */</span></span><br><span class="line">	<span class="comment">//指向eventpoll</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* List header used to link this item to the &quot;struct file&quot; items list */</span></span><br><span class="line">	<span class="comment">//file结构链表的链表头</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">fllink</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* wakeup_source used when EPOLLWAKEUP is set */</span></span><br><span class="line">	<span class="comment">//设置EPOLLWAKEUP时使用</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wakeup_source</span> __<span class="title">rcu</span> *<span class="title">ws</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The structure that describe the interested events and the source fd */</span></span><br><span class="line">	<span class="comment">//保存被触发的事件和相应的fd的值</span></span><br><span class="line">	<span class="comment">//EPOLLIN：表示对应的文件描述符可以读；</span></span><br><span class="line">    <span class="comment">//EPOLLOUT：表示对应的文件描述符可以写；</span></span><br><span class="line">    <span class="comment">//EPOLLPRI：表示对应的文件描述符有紧急的数可读；</span></span><br><span class="line">    <span class="comment">//EPOLLERR：表示对应的文件描述符发生错误；</span></span><br><span class="line">    <span class="comment">//EPOLLHUP：表示对应的文件描述符被挂断；</span></span><br><span class="line">    <span class="comment">//EPOLLET： 表示ET的epoll工作模式；</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p><code>struct eventpoll</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This structure is stored inside the &quot;private_data&quot; member of the file</span></span><br><span class="line"><span class="comment"> * structure and represents the main data structure for the eventpoll</span></span><br><span class="line"><span class="comment"> * interface.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This mutex is used to ensure that files are not removed</span></span><br><span class="line"><span class="comment">	 * while epoll is using them. This is held during the event</span></span><br><span class="line"><span class="comment">	 * collection loop, the file cleanup path, the epoll file exit</span></span><br><span class="line"><span class="comment">	 * code and the ctl operations.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// 这个互斥锁是为了保证在eventloop使用对应的文件描述符的时候，文件描述符不会被移除掉</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mtx</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Wait queue used by sys_epoll_wait() */</span></span><br><span class="line">	<span class="comment">// epoll_wait使用的等待队列，和进程唤醒有关</span></span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> wq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Wait queue used by file-&gt;poll() */</span></span><br><span class="line">	<span class="comment">// file-&gt;poll使用的等待队列，和进程唤醒有关</span></span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> poll_wait;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* List of ready file descriptors */</span></span><br><span class="line">	<span class="comment">/* 就绪队列，双向链表 */</span></span><br><span class="line">	<span class="comment">//链表中每个节点都是基于epitem中的rdllink</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllist</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Lock which protects rdllist and ovflist */</span></span><br><span class="line">	<span class="comment">//保护rdllist和ovflist的读写锁</span></span><br><span class="line">	<span class="keyword">rwlock_t</span> lock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* RB tree root used to store monitored fd structs */</span></span><br><span class="line">	<span class="comment">/* 存储fd的红黑树的root节点 */</span></span><br><span class="line">	<span class="comment">//红黑树中每个节点都是基于epitm中的rbn</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root_cached</span> <span class="title">rbr</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This is a single linked list that chains all the &quot;struct epitem&quot; that</span></span><br><span class="line"><span class="comment">	 * happened while transferring ready events to userspace w/out</span></span><br><span class="line"><span class="comment">	 * holding -&gt;lock.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* 这是一个单链表，链接了在向用户空间传输就绪事件的时候的所有eptem结构体 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">ovflist</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* wakeup_source used when ep_scan_ready_list is running */</span></span><br><span class="line">	<span class="comment">//ep_scan_ready_list运行时wakeup_source被使用</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wakeup_source</span> *<span class="title">ws</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The user that created the eventpoll descriptor */</span></span><br><span class="line">	<span class="comment">//用户</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//文件指针，epoll_create创建的那个file,即epfd对应的file</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* used to optimize loop detection check */</span></span><br><span class="line">	<span class="comment">//用于优化回路检测检查</span></span><br><span class="line">	<span class="keyword">int</span> visited;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">visited_list_link</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NET_RX_BUSY_POLL</span></span><br><span class="line">	<span class="comment">/* used to track busy poll napi_id */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> napi_id;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The following function implements the controller interface for</span></span><br><span class="line"><span class="comment"> * the eventpoll file that enables the insertion/removal/change of</span></span><br><span class="line"><span class="comment"> * file descriptors inside the interest set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE4(epoll_ctl, <span class="keyword">int</span>, epfd, <span class="keyword">int</span>, op, <span class="keyword">int</span>, fd,</span><br><span class="line">		struct epoll_event __user *, event)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epds</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ep_op_has_event(op) &amp;&amp;</span><br><span class="line">	    copy_from_user(&amp;epds, event, <span class="keyword">sizeof</span>(struct epoll_event)))</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> do_epoll_ctl(epfd, op, fd, &amp;epds, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *epds,</span></span></span><br><span class="line"><span class="function"><span class="params">		 <span class="keyword">bool</span> nonblock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line">	<span class="keyword">int</span> full_check = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>, <span class="title">tf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">tep</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	error = -EBADF;</span><br><span class="line">	f = fdget(epfd);</span><br><span class="line">	<span class="keyword">if</span> (!f.file)</span><br><span class="line">		<span class="keyword">goto</span> error_return;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Get the &quot;struct file *&quot; for the target file */</span></span><br><span class="line">	tf = fdget(fd);</span><br><span class="line">	<span class="keyword">if</span> (!tf.file)</span><br><span class="line">		<span class="keyword">goto</span> error_fput;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The target file descriptor must support poll */</span></span><br><span class="line">	error = -EPERM;</span><br><span class="line">	<span class="keyword">if</span> (!file_can_poll(tf.file))</span><br><span class="line">		<span class="keyword">goto</span> error_tgt_fput;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check if EPOLLWAKEUP is allowed */</span></span><br><span class="line">	<span class="keyword">if</span> (ep_op_has_event(op))</span><br><span class="line">		ep_take_care_of_epollwakeup(epds);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We have to check that the file structure underneath the file descriptor</span></span><br><span class="line"><span class="comment">	 * the user passed to us _is_ an eventpoll file. And also we do not permit</span></span><br><span class="line"><span class="comment">	 * adding an epoll file descriptor inside itself.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	error = -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (f.file == tf.file || !is_file_epoll(f.file))</span><br><span class="line">		<span class="keyword">goto</span> error_tgt_fput;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * epoll adds to the wakeup queue at EPOLL_CTL_ADD time only,</span></span><br><span class="line"><span class="comment">	 * so EPOLLEXCLUSIVE is not allowed for a EPOLL_CTL_MOD operation.</span></span><br><span class="line"><span class="comment">	 * Also, we do not currently supported nested exclusive wakeups.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (ep_op_has_event(op) &amp;&amp; (epds-&gt;events &amp; EPOLLEXCLUSIVE)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (op == EPOLL_CTL_MOD)</span><br><span class="line">			<span class="keyword">goto</span> error_tgt_fput;</span><br><span class="line">		<span class="keyword">if</span> (op == EPOLL_CTL_ADD &amp;&amp; (is_file_epoll(tf.file) ||</span><br><span class="line">				(epds-&gt;events &amp; ~EPOLLEXCLUSIVE_OK_BITS)))</span><br><span class="line">			<span class="keyword">goto</span> error_tgt_fput;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * At this point it is safe to assume that the &quot;private_data&quot; contains</span></span><br><span class="line"><span class="comment">	 * our own data structure.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ep = f.file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * When we insert an epoll file descriptor, inside another epoll file</span></span><br><span class="line"><span class="comment">	 * descriptor, there is the change of creating closed loops, which are</span></span><br><span class="line"><span class="comment">	 * better be handled here, than in more critical paths. While we are</span></span><br><span class="line"><span class="comment">	 * checking for loops we also determine the list of files reachable</span></span><br><span class="line"><span class="comment">	 * and hang them on the tfile_check_list, so we can check that we</span></span><br><span class="line"><span class="comment">	 * haven&#x27;t created too many possible wakeup paths.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * We do not need to take the global &#x27;epumutex&#x27; on EPOLL_CTL_ADD when</span></span><br><span class="line"><span class="comment">	 * the epoll file descriptor is attaching directly to a wakeup source,</span></span><br><span class="line"><span class="comment">	 * unless the epoll file descriptor is nested. The purpose of taking the</span></span><br><span class="line"><span class="comment">	 * &#x27;epmutex&#x27; on add is to prevent complex toplogies such as loops and</span></span><br><span class="line"><span class="comment">	 * deep wakeup paths from forming in parallel through multiple</span></span><br><span class="line"><span class="comment">	 * EPOLL_CTL_ADD operations.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	error = epoll_mutex_lock(&amp;ep-&gt;mtx, <span class="number">0</span>, nonblock);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> error_tgt_fput;</span><br><span class="line">	<span class="keyword">if</span> (op == EPOLL_CTL_ADD) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!list_empty(&amp;f.file-&gt;f_ep_links) ||</span><br><span class="line">						is_file_epoll(tf.file)) &#123;</span><br><span class="line">			mutex_unlock(&amp;ep-&gt;mtx);</span><br><span class="line">			error = epoll_mutex_lock(&amp;epmutex, <span class="number">0</span>, nonblock);</span><br><span class="line">			<span class="keyword">if</span> (error)</span><br><span class="line">				<span class="keyword">goto</span> error_tgt_fput;</span><br><span class="line">			full_check = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (is_file_epoll(tf.file)) &#123;</span><br><span class="line">				error = -ELOOP;</span><br><span class="line">				<span class="keyword">if</span> (ep_loop_check(ep, tf.file) != <span class="number">0</span>) &#123;</span><br><span class="line">					clear_tfile_check_list();</span><br><span class="line">					<span class="keyword">goto</span> error_tgt_fput;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span></span><br><span class="line">				list_add(&amp;tf.file-&gt;f_tfile_llink,</span><br><span class="line">							&amp;tfile_check_list);</span><br><span class="line">			error = epoll_mutex_lock(&amp;ep-&gt;mtx, <span class="number">0</span>, nonblock);</span><br><span class="line">			<span class="keyword">if</span> (error) &#123;</span><br><span class="line">out_del:</span><br><span class="line">				list_del(&amp;tf.file-&gt;f_tfile_llink);</span><br><span class="line">				<span class="keyword">goto</span> error_tgt_fput;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (is_file_epoll(tf.file)) &#123;</span><br><span class="line">				tep = tf.file-&gt;private_data;</span><br><span class="line">				error = epoll_mutex_lock(&amp;tep-&gt;mtx, <span class="number">1</span>, nonblock);</span><br><span class="line">				<span class="keyword">if</span> (error) &#123;</span><br><span class="line">					mutex_unlock(&amp;ep-&gt;mtx);</span><br><span class="line">					<span class="keyword">goto</span> out_del;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Try to lookup the file inside our RB tree, Since we grabbed &quot;mtx&quot;</span></span><br><span class="line"><span class="comment">	 * above, we can be sure to be able to use the item looked up by</span></span><br><span class="line"><span class="comment">	 * ep_find() till we release the mutex.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	epi = ep_find(ep, tf.file, fd);</span><br><span class="line"></span><br><span class="line">	error = -EINVAL;</span><br><span class="line">	<span class="keyword">switch</span> (op) &#123;</span><br><span class="line">	<span class="keyword">case</span> EPOLL_CTL_ADD:</span><br><span class="line">		<span class="keyword">if</span> (!epi) &#123;</span><br><span class="line">			epds-&gt;events |= EPOLLERR | EPOLLHUP;</span><br><span class="line">			error = ep_insert(ep, epds, tf.file, fd, full_check);</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			error = -EEXIST;</span><br><span class="line">		<span class="keyword">if</span> (full_check)</span><br><span class="line">			clear_tfile_check_list();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> EPOLL_CTL_DEL:</span><br><span class="line">		<span class="keyword">if</span> (epi)</span><br><span class="line">			error = ep_remove(ep, epi);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			error = -ENOENT;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> EPOLL_CTL_MOD:</span><br><span class="line">		<span class="keyword">if</span> (epi) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!(epi-&gt;event.events &amp; EPOLLEXCLUSIVE)) &#123;</span><br><span class="line">				epds-&gt;events |= EPOLLERR | EPOLLHUP;</span><br><span class="line">				error = ep_modify(ep, epi, epds);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			error = -ENOENT;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (tep != <span class="literal">NULL</span>)</span><br><span class="line">		mutex_unlock(&amp;tep-&gt;mtx);</span><br><span class="line">	mutex_unlock(&amp;ep-&gt;mtx);</span><br><span class="line"></span><br><span class="line">error_tgt_fput:</span><br><span class="line">	<span class="keyword">if</span> (full_check)</span><br><span class="line">		mutex_unlock(&amp;epmutex);</span><br><span class="line"></span><br><span class="line">	fdput(tf);</span><br><span class="line">error_fput:</span><br><span class="line">	fdput(f);</span><br><span class="line">error_return:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p><code>ep_find</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Search the file inside the eventpoll tree. The RB tree operations</span></span><br><span class="line"><span class="comment"> * are protected by the &quot;mtx&quot; mutex, and ep_find() must be called with</span></span><br><span class="line"><span class="comment"> * &quot;mtx&quot; held.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct epitem *<span class="title">ep_find</span><span class="params">(struct eventpoll *ep, struct file *file, <span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> kcmp;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rbp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>, *<span class="title">epir</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span> <span class="title">ffd</span>;</span></span><br><span class="line"></span><br><span class="line">	ep_set_ffd(&amp;ffd, file, fd);</span><br><span class="line">	<span class="comment">//红黑树中查找节点是否已经存在</span></span><br><span class="line">	<span class="keyword">for</span> (rbp = ep-&gt;rbr.rb_root.rb_node; rbp; ) &#123;</span><br><span class="line">		epi = rb_entry(rbp, struct epitem, rbn);</span><br><span class="line">		kcmp = ep_cmp_ffd(&amp;ffd, &amp;epi-&gt;ffd);</span><br><span class="line">		<span class="keyword">if</span> (kcmp &gt; <span class="number">0</span>)</span><br><span class="line">			rbp = rbp-&gt;rb_right;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (kcmp &lt; <span class="number">0</span>)</span><br><span class="line">			rbp = rbp-&gt;rb_left;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			epir = epi;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> epir;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p><code>ep_pqueue</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Wrapper struct used by poll queueing */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ep_pqueue</span> &#123;</span></span><br><span class="line">	poll_table pt;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Do not touch the structure directly, use the access functions</span></span><br><span class="line"><span class="comment"> * poll_does_not_wait() and poll_requested_events() instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_struct</span> &#123;</span></span><br><span class="line">	poll_queue_proc _qproc;</span><br><span class="line">	<span class="keyword">__poll_t</span> _key;</span><br><span class="line">&#125; poll_table;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>ep_insert</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Must be called with &quot;mtx&quot; held.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_insert</span><span class="params">(struct eventpoll *ep, <span class="keyword">const</span> struct epoll_event *event,</span></span></span><br><span class="line"><span class="function"><span class="params">		     struct file *tfile, <span class="keyword">int</span> fd, <span class="keyword">int</span> full_check)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> error, pwake = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">__poll_t</span> revents;</span><br><span class="line">	<span class="keyword">long</span> user_watches;</span><br><span class="line">	<span class="comment">//初始化epitem</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ep_pqueue</span> <span class="title">epq</span>;</span></span><br><span class="line"></span><br><span class="line">	lockdep_assert_irqs_enabled();</span><br><span class="line"></span><br><span class="line">	user_watches = atomic_long_read(&amp;ep-&gt;user-&gt;epoll_watches);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(user_watches &gt;= max_user_watches))</span><br><span class="line">		<span class="keyword">return</span> -ENOSPC;</span><br><span class="line">	<span class="keyword">if</span> (!(epi = kmem_cache_alloc(epi_cache, GFP_KERNEL)))</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Item initialization follow here ... */</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;epi-&gt;rdllink);</span><br><span class="line">	INIT_LIST_HEAD(&amp;epi-&gt;fllink);</span><br><span class="line">	INIT_LIST_HEAD(&amp;epi-&gt;pwqlist);</span><br><span class="line">	epi-&gt;ep = ep;</span><br><span class="line">	ep_set_ffd(&amp;epi-&gt;ffd, tfile, fd);</span><br><span class="line">	epi-&gt;event = *event;</span><br><span class="line">	epi-&gt;nwait = <span class="number">0</span>;</span><br><span class="line">	epi-&gt;next = EP_UNACTIVE_PTR;</span><br><span class="line">	<span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLWAKEUP) &#123;</span><br><span class="line">		error = ep_create_wakeup_source(epi);</span><br><span class="line">		<span class="keyword">if</span> (error)</span><br><span class="line">			<span class="keyword">goto</span> error_create_wakeup_source;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		RCU_INIT_POINTER(epi-&gt;ws, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initialize the poll table using the queue callback */</span></span><br><span class="line">	epq.epi = epi;</span><br><span class="line">	<span class="comment">//*********************************************************************</span></span><br><span class="line">	<span class="comment">//初始化回调函数</span></span><br><span class="line">	<span class="comment">//(&amp;epq.pt)-&gt;_qproc = ep_ptable_queue_proc</span></span><br><span class="line">	<span class="comment">//(&amp;epq.pt)-&gt;_key   = ~(__poll_t)0	/* all events enabled */</span></span><br><span class="line">	init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Attach the item to the poll hooks and get current event bits.</span></span><br><span class="line"><span class="comment">	 * We can safely use the file* here because its usage count has</span></span><br><span class="line"><span class="comment">	 * been increased by the caller of this function. Note that after</span></span><br><span class="line"><span class="comment">	 * this operation completes, the poll callback can start hitting</span></span><br><span class="line"><span class="comment">	 * the new item.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//*********************************************************************</span></span><br><span class="line">	revents = ep_item_poll(epi, &amp;epq.pt, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We have to check if something went wrong during the poll wait queue</span></span><br><span class="line"><span class="comment">	 * install process. Namely an allocation for a wait queue failed due</span></span><br><span class="line"><span class="comment">	 * high memory pressure.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	error = -ENOMEM;</span><br><span class="line">	<span class="keyword">if</span> (epi-&gt;nwait &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> error_unregister;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Add the current item to the list of active epoll hook for this file */</span></span><br><span class="line">	spin_lock(&amp;tfile-&gt;f_lock);</span><br><span class="line">	list_add_tail_rcu(&amp;epi-&gt;fllink, &amp;tfile-&gt;f_ep_links);</span><br><span class="line">	spin_unlock(&amp;tfile-&gt;f_lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Add the current item to the RB tree. All RB tree operations are</span></span><br><span class="line"><span class="comment">	 * protected by &quot;mtx&quot;, and ep_insert() is called with &quot;mtx&quot; held.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//插入红黑树</span></span><br><span class="line">	ep_rbtree_insert(ep, epi);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* now check if we&#x27;ve created too many backpaths */</span></span><br><span class="line">	error = -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (full_check &amp;&amp; reverse_path_check())</span><br><span class="line">		<span class="keyword">goto</span> error_remove_epi;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We have to drop the new item inside our item list to keep track of it */</span></span><br><span class="line">	write_lock_irq(&amp;ep-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* record NAPI ID of new item if present */</span></span><br><span class="line">	ep_set_busy_poll_napi_id(epi);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If the file is already &quot;ready&quot; we drop it inside the ready list */</span></span><br><span class="line">	<span class="comment">//如果当前有事件已经就绪，那么一开始就会被加入到ready list</span></span><br><span class="line">	<span class="keyword">if</span> (revents &amp;&amp; !ep_is_linked(epi)) &#123;</span><br><span class="line">		<span class="comment">//将epitem插入就绪链表</span></span><br><span class="line">		list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">		ep_pm_stay_awake(epi);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Notify waiting tasks that events are available */</span></span><br><span class="line">		<span class="comment">//唤醒epoll wait</span></span><br><span class="line">		<span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">			wake_up(&amp;ep-&gt;wq);</span><br><span class="line">		<span class="comment">//唤醒file-&gt;poll</span></span><br><span class="line">		<span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">			pwake++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	write_unlock_irq(&amp;ep-&gt;lock);</span><br><span class="line"></span><br><span class="line">	atomic_long_inc(&amp;ep-&gt;user-&gt;epoll_watches);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We have to call this outside the lock */</span></span><br><span class="line">	<span class="keyword">if</span> (pwake)</span><br><span class="line">		ep_poll_safewake(&amp;ep-&gt;poll_wait);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">error_remove_epi:</span><br><span class="line">	spin_lock(&amp;tfile-&gt;f_lock);</span><br><span class="line">	list_del_rcu(&amp;epi-&gt;fllink);</span><br><span class="line">	spin_unlock(&amp;tfile-&gt;f_lock);</span><br><span class="line"></span><br><span class="line">	rb_erase_cached(&amp;epi-&gt;rbn, &amp;ep-&gt;rbr);</span><br><span class="line"></span><br><span class="line">error_unregister:</span><br><span class="line">	ep_unregister_pollwait(ep, epi);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We need to do this because an event could have been arrived on some</span></span><br><span class="line"><span class="comment">	 * allocated wait queue. Note that we don&#x27;t care about the ep-&gt;ovflist</span></span><br><span class="line"><span class="comment">	 * list, since that is used/cleaned only inside a section bound by &quot;mtx&quot;.</span></span><br><span class="line"><span class="comment">	 * And ep_insert() is called with &quot;mtx&quot; held.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	write_lock_irq(&amp;ep-&gt;lock);</span><br><span class="line">	<span class="keyword">if</span> (ep_is_linked(epi))</span><br><span class="line">		list_del_init(&amp;epi-&gt;rdllink);</span><br><span class="line">	write_unlock_irq(&amp;ep-&gt;lock);</span><br><span class="line"></span><br><span class="line">	wakeup_source_unregister(ep_wakeup_source(epi));</span><br><span class="line"></span><br><span class="line">error_create_wakeup_source:</span><br><span class="line">	kmem_cache_free(epi_cache, epi);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p><code>ep_item_poll</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Differs from ep_eventpoll_poll() in that internal callers already have</span></span><br><span class="line"><span class="comment"> * the ep-&gt;mtx so we need to start from depth=1, such that mutex_lock_nested()</span></span><br><span class="line"><span class="comment"> * is correctly annotated.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">__poll_t</span> <span class="title">ep_item_poll</span><span class="params">(<span class="keyword">const</span> struct epitem *epi, poll_table *pt,</span></span></span><br><span class="line"><span class="function"><span class="params">				 <span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line">	<span class="keyword">bool</span> locked;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//赋值pt-&gt;_key</span></span><br><span class="line">	pt-&gt;_key = epi-&gt;event.events;</span><br><span class="line">	<span class="keyword">if</span> (!is_file_epoll(epi-&gt;ffd.file))</span><br><span class="line">		<span class="keyword">return</span> vfs_poll(epi-&gt;ffd.file, pt) &amp; epi-&gt;event.events;</span><br><span class="line"></span><br><span class="line">	ep = epi-&gt;ffd.file-&gt;private_data;</span><br><span class="line">	<span class="comment">//poll_wait adds your device (represented by the &quot;struct file&quot;) to </span></span><br><span class="line">	<span class="comment">//the list of those that can wake the process up.</span></span><br><span class="line">	<span class="comment">//赋值pt-&gt;_qproc</span></span><br><span class="line">	<span class="comment">//***********************************************</span></span><br><span class="line">	poll_wait(epi-&gt;ffd.file, &amp;ep-&gt;poll_wait, pt);</span><br><span class="line">	locked = pt &amp;&amp; (pt-&gt;_qproc == ep_ptable_queue_proc);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ep_scan_ready_list(epi-&gt;ffd.file-&gt;private_data,</span><br><span class="line">				  ep_read_events_proc, &amp;depth, depth,</span><br><span class="line">				  locked) &amp; epi-&gt;event.events;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>poll_wait</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">poll_wait</span><span class="params">(struct file * filp, <span class="keyword">wait_queue_head_t</span> * wait_address, poll_table *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p &amp;&amp; p-&gt;_qproc &amp;&amp; wait_address)</span><br><span class="line">		p-&gt;_qproc(filp, wait_address, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>ep_ptable_queue_proc</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is the callback that is used to add our wait queue to the</span></span><br><span class="line"><span class="comment"> * target file wakeup lists.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//这是回调函数，用于将我们的等待队列添加到目标文件唤醒列表</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ep_ptable_queue_proc</span><span class="params">(struct file *file, <span class="keyword">wait_queue_head_t</span> *whead,</span></span></span><br><span class="line"><span class="function"><span class="params">				 poll_table *pt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span> =</span> ep_item_from_epqueue(pt);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">eppoll_entry</span> *<span class="title">pwq</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//nwait:附加到轮询操作的活跃等待队列数</span></span><br><span class="line">	<span class="keyword">if</span> (epi-&gt;nwait &gt;= <span class="number">0</span> &amp;&amp; (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) &#123;</span><br><span class="line">		<span class="comment">//&amp;pwq-&gt;wait-&gt;func=ep_poll_callback，用于回调唤醒</span></span><br><span class="line">		<span class="comment">//epoll_wait会被唤醒</span></span><br><span class="line">		init_waitqueue_func_entry(&amp;pwq-&gt;wait, ep_poll_callback);</span><br><span class="line">		pwq-&gt;whead = whead;</span><br><span class="line">		pwq-&gt;base = epi;</span><br><span class="line">		<span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLEXCLUSIVE)</span><br><span class="line">			add_wait_queue_exclusive(whead, &amp;pwq-&gt;wait);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="comment">//这边的whead是sk-&gt;sk_sleep,将当前的waitqueue链入到socket对应的sleep列表（如果是accept的话）</span></span><br><span class="line">			add_wait_queue(whead, &amp;pwq-&gt;wait);</span><br><span class="line">		list_add_tail(&amp;pwq-&gt;llink, &amp;epi-&gt;pwqlist);</span><br><span class="line">		epi-&gt;nwait++;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* We have to signal that an error occurred */</span></span><br><span class="line">		epi-&gt;nwait = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>总结</strong></p>
<pre><code>epoll_ctl
|-&gt;do_epoll_ctl
    |-&gt;ep_find
        |-&gt;ep_insert
            |-&gt;ep_item_poll
                |-&gt;poll_wait(epi-&gt;ffd.file, &amp;ep-&gt;poll_wait, pt)
                    |-&gt;ep_ptable_queue_proc
                        |-&gt;waitqueue中    //poll_table添加唤醒回调函数ep_poll_callback
                        |-&gt;add_wait_queue(将当前的waitqueue链入到epitem对应的等待列表)
                |-&gt;ep_scan_ready_list
        |-&gt;ep_remove
        |-&gt;ep_modify</code></pre>
<ul>
<li>ep_find的三个参数：epfd对应的eventpoll,epoll_ctrl参数中的fd对应的file结构，epoll_ctrl参数中的fd</li>
<li>ep_find的逻辑：将fd转换为epoll_filefd格式，找rbr红黑树中每个epitem的ffd成员进行比较</li>
<li>ep_insert新建一个epi(epitem),赋值然后插入红黑树</li>
<li>ep_insert创建epq(ep_pqueue),(&amp;epq.pt)-&gt;_qproc = ep_ptable_queue_proc poll队列回调函数</li>
<li>ep_insert创建epq(ep_pqueue),(&amp;epq.pt)-&gt;_key   = epi-&gt;event.events(初始化后在ep_item_poll中赋值)</li>
<li>poll_wait中执行回调函数ep_ptable_queue_proc</li>
<li>ep_ptable_queue_proc新建一个pwq(eppoll_entry),&amp;pwq-&gt;wait-&gt;func=ep_poll_callback(唤醒epoll_wait的函数)</li>
<li>ep_ptable_queue_proc中pwq-&gt;base = epi</li>
<li>ep_ptable_queue_proc中pwq-&gt;whead = &amp;ep-&gt;poll_wait(file-&gt;poll使用的等待队列，和进程唤醒有关)</li>
</ul>
<p><strong>图片来源:</strong> <a href="https://my.oschina.net/alchemystar/blog/3008840">从linux源码看epoll</a></p>
<p><img src="https://i.loli.net/2020/03/08/Z2YgHn7Af3L6R9c.png" alt="epoll_callback.jpg"></p>
<p><img src="https://i.loli.net/2020/03/08/jON9AlqWnVGeibJ.png" alt="epoll_ctrl.jpg"></p>
<hr>
<h3 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h3><p><code>epoll_wait</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//系统调用epoll_wait</span></span><br><span class="line">SYSCALL_DEFINE4(epoll_wait, <span class="keyword">int</span>, epfd, struct epoll_event __user *, events,</span><br><span class="line">		<span class="keyword">int</span>, maxevents, <span class="keyword">int</span>, timeout)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> do_epoll_wait(epfd, events, maxevents, timeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p><code>do_epoll_wait</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Implement the event wait interface for the eventpoll file. It is the kernel</span></span><br><span class="line"><span class="comment"> * part of the user space epoll_wait(2).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event __user *events,</span></span></span><br><span class="line"><span class="function"><span class="params">			 <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The maximum number of event must be greater than zero */</span></span><br><span class="line">	<span class="keyword">if</span> (maxevents &lt;= <span class="number">0</span> || maxevents &gt; EP_MAX_EVENTS)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Verify that the area passed by the user is writeable */</span></span><br><span class="line">	<span class="keyword">if</span> (!access_ok(events, maxevents * <span class="keyword">sizeof</span>(struct epoll_event)))</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Get the &quot;struct file *&quot; for the eventpoll file */</span></span><br><span class="line">	f = fdget(epfd);</span><br><span class="line">	<span class="keyword">if</span> (!f.file)</span><br><span class="line">		<span class="keyword">return</span> -EBADF;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We have to check that the file structure underneath the fd</span></span><br><span class="line"><span class="comment">	 * the user passed to us _is_ an eventpoll file.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	error = -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (!is_file_epoll(f.file))</span><br><span class="line">		<span class="keyword">goto</span> error_fput;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * At this point it is safe to assume that the &quot;private_data&quot; contains</span></span><br><span class="line"><span class="comment">	 * our own data structure.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//取epfd对于的eventpoll结构体</span></span><br><span class="line">	ep = f.file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Time to fish for events ... */</span></span><br><span class="line">	error = ep_poll(ep, events, maxevents, timeout);</span><br><span class="line"></span><br><span class="line">error_fput:</span><br><span class="line">	fdput(f);</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p><code>ep_poll</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ep_poll - Retrieves ready events, and delivers them to the caller supplied</span></span><br><span class="line"><span class="comment"> *           event buffer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @ep: Pointer to the eventpoll context.</span></span><br><span class="line"><span class="comment"> * @events: Pointer to the userspace buffer where the ready events should be</span></span><br><span class="line"><span class="comment"> *          stored.</span></span><br><span class="line"><span class="comment"> * @maxevents: Size (in terms of number of events) of the caller event buffer.</span></span><br><span class="line"><span class="comment"> * @timeout: Maximum timeout for the ready events fetch operation, in</span></span><br><span class="line"><span class="comment"> *           milliseconds. If the @timeout is zero, the function will not block,</span></span><br><span class="line"><span class="comment"> *           while if the @timeout is less than zero, the function will block</span></span><br><span class="line"><span class="comment"> *           until at least one event has been retrieved (or an error</span></span><br><span class="line"><span class="comment"> *           occurred).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns: Returns the number of ready events which have been fetched, or an</span></span><br><span class="line"><span class="comment"> *          error code, in case of error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_poll</span><span class="params">(struct eventpoll *ep, struct epoll_event __user *events,</span></span></span><br><span class="line"><span class="function"><span class="params">		   <span class="keyword">int</span> maxevents, <span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>, eavail, timed_out = <span class="number">0</span>;</span><br><span class="line">	u64 slack = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">bool</span> waiter = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">wait_queue_entry_t</span> wait;</span><br><span class="line">	<span class="keyword">ktime_t</span> expires, *to = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_irqs_enabled();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//大于0，设置超时</span></span><br><span class="line">	<span class="keyword">if</span> (timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span> <span class="title">end_time</span> =</span> ep_set_mstimeout(timeout);</span><br><span class="line"></span><br><span class="line">		slack = select_estimate_accuracy(&amp;end_time);</span><br><span class="line">		to = &amp;expires;</span><br><span class="line">		*to = timespec64_to_ktime(end_time);</span><br><span class="line">	<span class="comment">//等于0，立刻返回结果</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Avoid the unnecessary trip to the wait queue loop, if the</span></span><br><span class="line"><span class="comment">		 * caller specified a non blocking operation. We still need</span></span><br><span class="line"><span class="comment">		 * lock because we could race and not see an epi being added</span></span><br><span class="line"><span class="comment">		 * to the ready list while in irq callback. Thus incorrectly</span></span><br><span class="line"><span class="comment">		 * returning 0 back to userspace.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		timed_out = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		write_lock_irq(&amp;ep-&gt;lock);</span><br><span class="line">		<span class="comment">//检查是否有可用事件，rdllist就绪链表</span></span><br><span class="line">		<span class="comment">//return !list_empty_careful(&amp;ep-&gt;rdllist) ||READ_ONCE(ep-&gt;ovflist) != EP_UNACTIVE_PTR;</span></span><br><span class="line">		eavail = ep_events_available(ep);</span><br><span class="line">		write_unlock_irq(&amp;ep-&gt;lock);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">goto</span> send_events;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//小于0，无限期阻塞</span></span><br><span class="line"></span><br><span class="line">fetch_events:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ep_events_available(ep))</span><br><span class="line">		ep_busy_loop(ep, timed_out);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//检查是否有可用事件，rdllist就绪链表</span></span><br><span class="line">	<span class="comment">//return !list_empty_careful(&amp;ep-&gt;rdllist) ||READ_ONCE(ep-&gt;ovflist) != EP_UNACTIVE_PTR;</span></span><br><span class="line">	eavail = ep_events_available(ep);</span><br><span class="line">	<span class="keyword">if</span> (eavail)</span><br><span class="line">		<span class="keyword">goto</span> send_events;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Busy poll timed out.  Drop NAPI ID for now, we can add</span></span><br><span class="line"><span class="comment">	 * it back in when we have moved a socket with a valid NAPI</span></span><br><span class="line"><span class="comment">	 * ID onto the ready list.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ep_reset_busy_poll_napi_id(ep);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We don&#x27;t have any available event to return to the caller.  We need</span></span><br><span class="line"><span class="comment">	 * to sleep here, and we will be woken by ep_poll_callback() when events</span></span><br><span class="line"><span class="comment">	 * become available.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//我们没有任何可用的事件可返回给呼叫者。我们需要</span></span><br><span class="line">	<span class="comment">//睡眠，当事件发生时，我们会被ep_poll_callback（）唤醒变得可用。</span></span><br><span class="line">	<span class="keyword">if</span> (!waiter) &#123;</span><br><span class="line">		waiter = <span class="literal">true</span>;</span><br><span class="line">		<span class="comment">//初始化等待链表</span></span><br><span class="line">		init_waitqueue_entry(&amp;wait, current);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//自旋锁</span></span><br><span class="line">		spin_lock_irq(&amp;ep-&gt;wq.lock);</span><br><span class="line">		<span class="comment">//添加到等待链表</span></span><br><span class="line">		__add_wait_queue_exclusive(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line">		spin_unlock_irq(&amp;ep-&gt;wq.lock);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We don&#x27;t want to sleep if the ep_poll_callback() sends us</span></span><br><span class="line"><span class="comment">		 * a wakeup in between. That&#x27;s why we set the task state</span></span><br><span class="line"><span class="comment">		 * to TASK_INTERRUPTIBLE before doing the checks.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">// 设置当前进程状态为可打断</span></span><br><span class="line">		set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Always short-circuit for fatal signals to allow</span></span><br><span class="line"><span class="comment">		 * threads to make a timely exit without the chance of</span></span><br><span class="line"><span class="comment">		 * finding more events available and fetching</span></span><br><span class="line"><span class="comment">		 * repeatedly.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">// 检查当前线程是否有信号要处理，有则返回-EINTR</span></span><br><span class="line">		<span class="keyword">if</span> (fatal_signal_pending(current)) &#123;</span><br><span class="line">			res = -EINTR;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//检查是否有可用事件，rdllist就绪链表</span></span><br><span class="line">		<span class="comment">//return !list_empty_careful(&amp;ep-&gt;rdllist) ||READ_ONCE(ep-&gt;ovflist) != EP_UNACTIVE_PTR;</span></span><br><span class="line">		eavail = ep_events_available(ep);</span><br><span class="line">		<span class="keyword">if</span> (eavail)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">			res = -EINTR;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// sleep until timeout</span></span><br><span class="line">		<span class="comment">// 让出cpu</span></span><br><span class="line">		<span class="keyword">if</span> (!schedule_hrtimeout_range(to, slack, HRTIMER_MODE_ABS)) &#123;</span><br><span class="line">			timed_out = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//// 设置进程状态为running</span></span><br><span class="line">	__set_current_state(TASK_RUNNING);</span><br><span class="line"></span><br><span class="line">send_events:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Try to transfer events to user space. In case we get 0 events and</span></span><br><span class="line"><span class="comment">	 * there&#x27;s still timeout left over, we go trying again in search of</span></span><br><span class="line"><span class="comment">	 * more luck.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//尝试将事件转移到用户空间。如果我们收到0个事件，还有剩余的超时时间，我们将再次</span></span><br><span class="line">	<span class="comment">//尝试寻找来碰碰运气</span></span><br><span class="line">	<span class="keyword">if</span> (!res &amp;&amp; eavail &amp;&amp;</span><br><span class="line">		<span class="comment">//// 向用户空间拷贝就绪事件</span></span><br><span class="line">	    !(res = ep_send_events(ep, events, maxevents)) &amp;&amp; !timed_out)</span><br><span class="line">		<span class="keyword">goto</span> fetch_events;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (waiter) &#123;</span><br><span class="line">		spin_lock_irq(&amp;ep-&gt;wq.lock);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//wq_entry = wait</span></span><br><span class="line">		<span class="comment">//list_del(&amp;wq_entry-&gt;entry);</span></span><br><span class="line">		<span class="comment">//从等待链表移除</span></span><br><span class="line">		__remove_wait_queue(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line">		spin_unlock_irq(&amp;ep-&gt;wq.lock);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<pre><code>epoll_wait
    |-&gt;do_epoll_wait
        |-&gt;ep_poll
            |-&gt;send_events
            |-&gt;fetch_events</code></pre>
<ul>
<li>ep_poll根据超时时间执行不同策略</li>
<li>ep_poll中判断就绪队列rdllist不为空，则发送就绪事件到用户空间send_events</li>
<li>ep_poll没有事件则schedule_hrtimeout_range让出cpu,等待唤醒</li>
<li>ep-&gt;ovflist的作用：记录处理过程中新到来的事件(不是很明确)</li>
<li>中断处理程序执行回调函数唤醒epoll_wait(我的猜测)</li>
</ul>
<p><strong>图片来源:</strong> <a href="https://my.oschina.net/alchemystar/blog/3008840">从linux源码看epoll</a></p>
<p><img src="https://i.loli.net/2020/03/08/e5CgwRkFPQMBx9V.png" alt="epoll_wait.jpg"></p>
<hr>
<h3 id="ep-send-events"><a href="#ep-send-events" class="headerlink" title="ep_send_events"></a>ep_send_events</h3><p><code>ep_send_events</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_send_events</span><span class="params">(struct eventpoll *ep,</span></span></span><br><span class="line"><span class="function"><span class="params">			  struct epoll_event __user *events, <span class="keyword">int</span> maxevents)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ep_send_events_data</span> <span class="title">esed</span>;</span></span><br><span class="line"></span><br><span class="line">	esed.maxevents = maxevents;</span><br><span class="line">	esed.events = events;</span><br><span class="line"></span><br><span class="line">	ep_scan_ready_list(ep, ep_send_events_proc, &amp;esed, <span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">return</span> esed.res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p><code>ep_scan_ready_list</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ep_scan_ready_list - Scans the ready list in a way that makes possible for</span></span><br><span class="line"><span class="comment"> *                      the scan code, to call f_op-&gt;poll(). Also allows for</span></span><br><span class="line"><span class="comment"> *                      O(NumReady) performance.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @ep: Pointer to the epoll private data structure.</span></span><br><span class="line"><span class="comment"> * @sproc: Pointer to the scan callback.</span></span><br><span class="line"><span class="comment"> * @priv: Private opaque data passed to the @sproc callback.</span></span><br><span class="line"><span class="comment"> * @depth: The current depth of recursive f_op-&gt;poll calls.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns: The same integer error code returned by the @sproc callback.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_scan_ready_list</span><span class="params">(struct eventpoll *ep,</span></span></span><br><span class="line"><span class="function"><span class="params">			      <span class="keyword">int</span> (*sproc)(struct eventpoll *,</span></span></span><br><span class="line"><span class="function"><span class="params">					   struct list_head *, <span class="keyword">void</span> *),</span></span></span><br><span class="line"><span class="function"><span class="params">			      <span class="keyword">void</span> *priv,</span></span></span><br><span class="line"><span class="function"><span class="params">			      <span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> error, pwake = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>, *<span class="title">nepi</span>;</span></span><br><span class="line">	LIST_HEAD(txlist);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We need to lock this because we could be hit by</span></span><br><span class="line"><span class="comment">	 * eventpoll_release_file() and epoll_ctl().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mutex_lock_nested(&amp;ep-&gt;mtx, depth);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Steal the ready list, and re-init the original one to the</span></span><br><span class="line"><span class="comment">	 * empty list. Also, set ep-&gt;ovflist to NULL so that events</span></span><br><span class="line"><span class="comment">	 * happening while looping w/out locks, are not lost. We cannot</span></span><br><span class="line"><span class="comment">	 * have the poll callback to queue directly on ep-&gt;rdllist,</span></span><br><span class="line"><span class="comment">	 * because we want the &quot;sproc&quot; callback to be able to do it</span></span><br><span class="line"><span class="comment">	 * in a lockless way.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">	<span class="comment">//将rdllist链入到txlist</span></span><br><span class="line">	list_splice_init(&amp;ep-&gt;rdllist, &amp;txlist);</span><br><span class="line">	ep-&gt;ovflist = <span class="literal">NULL</span>;</span><br><span class="line">	spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Now call the callback function.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//***********************************************************************</span></span><br><span class="line">	<span class="comment">//执行函数ep_send_events_proc</span></span><br><span class="line">	error = (*sproc)(ep, &amp;txlist, priv);</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * During the time we spent inside the &quot;sproc&quot; callback, some</span></span><br><span class="line"><span class="comment">	 * other events might have been queued by the poll callback.</span></span><br><span class="line"><span class="comment">	 * We re-insert them inside the main ready-list here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (nepi = ep-&gt;ovflist; (epi = nepi) != <span class="literal">NULL</span>;</span><br><span class="line">	     nepi = epi-&gt;next, epi-&gt;next = EP_UNACTIVE_PTR) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We need to check if the item is already in the list.</span></span><br><span class="line"><span class="comment">		 * During the &quot;sproc&quot; callback execution time, items are</span></span><br><span class="line"><span class="comment">		 * queued into -&gt;ovflist but the &quot;txlist&quot; might already</span></span><br><span class="line"><span class="comment">		 * contain them, and the list_splice() below takes care of them.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!ep_is_linked(&amp;epi-&gt;rdllink)) &#123;</span><br><span class="line">			list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">			ep_pm_stay_awake(epi);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We need to set back ep-&gt;ovflist to EP_UNACTIVE_PTR, so that after</span></span><br><span class="line"><span class="comment">	 * releasing the lock, events will be queued in the normal way inside</span></span><br><span class="line"><span class="comment">	 * ep-&gt;rdllist.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ep-&gt;ovflist = EP_UNACTIVE_PTR;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Quickly re-inject items left on &quot;txlist&quot;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	list_splice(&amp;txlist, &amp;ep-&gt;rdllist);</span><br><span class="line">	__pm_relax(ep-&gt;ws);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!list_empty(&amp;ep-&gt;rdllist)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Wake up (if active) both the eventpoll wait list and</span></span><br><span class="line"><span class="comment">		 * the -&gt;poll() wait list (delayed after we release the lock).</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">			wake_up_locked(&amp;ep-&gt;wq);</span><br><span class="line">		<span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">			pwake++;</span><br><span class="line">	&#125;</span><br><span class="line">	spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;ep-&gt;mtx);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We have to call this outside the lock */</span></span><br><span class="line">	<span class="keyword">if</span> (pwake)</span><br><span class="line">		ep_poll_safewake(&amp;ep-&gt;poll_wait);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p><code>init_poll_funcptr</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init_poll_funcptr</span><span class="params">(poll_table *pt, poll_queue_proc qproc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pt-&gt;_qproc = qproc;</span><br><span class="line">	pt-&gt;_key   = ~(<span class="keyword">__poll_t</span>)<span class="number">0</span>; <span class="comment">/* all events enabled */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>list_for_each_entry_safe</code></p>
<pre><code>/**
 * list_for_each_entry_safe - iterate over list of given type safe against removal of list entry
 * @pos:    the type * to use as a loop cursor.
 * @n:        another type * to use as temporary storage
 * @head:    the head for your list.
 * @member:    the name of the list_head within the struct.
 */
#define list_for_each_entry_safe(pos, n, head, member)            \
    for (pos = list_first_entry(head, typeof(*pos), member),    \
        n = list_next_entry(pos, member);            \
         &amp;pos-&gt;member != (head);                     \
         pos = n, n = list_next_entry(n, member))</code></pre>
<hr>
<p><code>ep_send_events_proc</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">__poll_t</span> <span class="title">ep_send_events_proc</span><span class="params">(struct eventpoll *ep, struct list_head *head,</span></span></span><br><span class="line"><span class="function"><span class="params">			       <span class="keyword">void</span> *priv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ep_send_events_data</span> *<span class="title">esed</span> =</span> priv;</span><br><span class="line">	<span class="keyword">__poll_t</span> revents;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>, *<span class="title">tmp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> __<span class="title">user</span> *<span class="title">uevent</span> =</span> esed-&gt;events;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wakeup_source</span> *<span class="title">ws</span>;</span></span><br><span class="line">	poll_table pt;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//pt-&gt;_qproc = NULL </span></span><br><span class="line">	<span class="comment">//pt-&gt;_key = ~(__poll_t)0	/* all events enabled */</span></span><br><span class="line">	init_poll_funcptr(&amp;pt, <span class="literal">NULL</span>);</span><br><span class="line">	esed-&gt;res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We can loop without lock because we are passed a task private list.</span></span><br><span class="line"><span class="comment">	 * Items cannot vanish during the loop because ep_scan_ready_list() is</span></span><br><span class="line"><span class="comment">	 * holding &quot;mtx&quot; during this call.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	lockdep_assert_held(&amp;ep-&gt;mtx);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//head=ep-&gt;rdllist</span></span><br><span class="line">	<span class="comment">//遍历rdllink链表，直到其中某个节点的member成员=ep-&gt;rdllist的</span></span><br><span class="line">	<span class="comment">//我理解是找到ep-&gt;rdllist就绪链表在内存某个数据结构中的地址</span></span><br><span class="line">	<span class="comment">//这个地址用epi指针保存</span></span><br><span class="line">	<span class="comment">//*******************************************************************</span></span><br><span class="line">	list_for_each_entry_safe(epi, tmp, head, rdllink) &#123;</span><br><span class="line">		<span class="keyword">if</span> (esed-&gt;res &gt;= esed-&gt;maxevents)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Activate ep-&gt;ws before deactivating epi-&gt;ws to prevent</span></span><br><span class="line"><span class="comment">		 * triggering auto-suspend here (in case we reactive epi-&gt;ws</span></span><br><span class="line"><span class="comment">		 * below).</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * This could be rearranged to delay the deactivation of epi-&gt;ws</span></span><br><span class="line"><span class="comment">		 * instead, but then epi-&gt;ws would temporarily be out of sync</span></span><br><span class="line"><span class="comment">		 * with ep_is_linked().</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		ws = ep_wakeup_source(epi);</span><br><span class="line">		<span class="keyword">if</span> (ws) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ws-&gt;active)</span><br><span class="line">				__pm_stay_awake(ep-&gt;ws);</span><br><span class="line">			__pm_relax(ws);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		list_del_init(&amp;epi-&gt;rdllink);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If the event mask intersect the caller-requested one,</span></span><br><span class="line"><span class="comment">		 * deliver the event to userspace. Again, ep_scan_ready_list()</span></span><br><span class="line"><span class="comment">		 * is holding ep-&gt;mtx, so no operations coming from userspace</span></span><br><span class="line"><span class="comment">		 * can change the item.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//如果事件掩码与调用方请求的掩码相交，则将事件传递到用户空间</span></span><br><span class="line">		<span class="comment">//ep_scan_ready_list重新获得锁</span></span><br><span class="line">		<span class="comment">//所以来自用户空间的操作不会改变这个epitem</span></span><br><span class="line">		<span class="comment">//readylist只是表明当前epi有事件，具体的事件信息还是得调用对应file的poll</span></span><br><span class="line">		<span class="comment">//执行tcp_poll,确认是否是感兴趣的事件</span></span><br><span class="line">		<span class="comment">//*********************************************************************</span></span><br><span class="line">		revents = ep_item_poll(epi, &amp;pt, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (!revents)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将event放入到用户空间 </span></span><br><span class="line">		<span class="keyword">if</span> (__put_user(revents, &amp;uevent-&gt;events) ||</span><br><span class="line">		    __put_user(epi-&gt;event.data, &amp;uevent-&gt;data)) &#123;</span><br><span class="line">			list_add(&amp;epi-&gt;rdllink, head);</span><br><span class="line">			ep_pm_stay_awake(epi);</span><br><span class="line">			<span class="keyword">if</span> (!esed-&gt;res)</span><br><span class="line">				esed-&gt;res = -EFAULT;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		esed-&gt;res++;</span><br><span class="line">		uevent++;</span><br><span class="line">		<span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLONESHOT)</span><br><span class="line">			epi-&gt;event.events &amp;= EP_PRIVATE_BITS;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!(epi-&gt;event.events &amp; EPOLLET)) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * If this file has been added with Level</span></span><br><span class="line"><span class="comment">			 * Trigger mode, we need to insert back inside</span></span><br><span class="line"><span class="comment">			 * the ready list, so that the next call to</span></span><br><span class="line"><span class="comment">			 * epoll_wait() will check again the events</span></span><br><span class="line"><span class="comment">			 * availability. At this point, no one can insert</span></span><br><span class="line"><span class="comment">			 * into ep-&gt;rdllist besides us. The epoll_ctl()</span></span><br><span class="line"><span class="comment">			 * callers are locked out by</span></span><br><span class="line"><span class="comment">			 * ep_scan_ready_list() holding &quot;mtx&quot; and the</span></span><br><span class="line"><span class="comment">			 * poll callback will queue them in ep-&gt;ovflist.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="comment">//如果是水平触发，则将当前的epi重新加回到可用列表中，这样就可以下一次继续触发poll,</span></span><br><span class="line">			<span class="comment">//如果下一次poll的revents不为0，那么用户空间依旧能感知 </span></span><br><span class="line">			list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">			ep_pm_stay_awake(epi);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果是边缘触发，那么就不加回可用列表，因此只能等到下一个可用事件触发的时候才会将对应的epi放到可用列表里面</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p><code>struct poll_wqueues</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Structures and helpers for select/poll syscall</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> &#123;</span></span><br><span class="line">	poll_table pt;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">poll_table_page</span> *<span class="title">table</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">polling_task</span>;</span></span><br><span class="line">	<span class="keyword">int</span> triggered;</span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line">	<span class="keyword">int</span> inline_index;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">poll_table_entry</span> <span class="title">inline_entries</span>[<span class="title">N_INLINE_POLL_ENTRIES</span>];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p><code>__pollwait(pollwait)</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ok, Peter made a complicated, but straightforward multiple_wait() function.</span></span><br><span class="line"><span class="comment"> * I have rewritten this, taking some shortcuts: This code may not be easy to</span></span><br><span class="line"><span class="comment"> * follow, but it should be free of race-conditions, and it&#x27;s practical. If you</span></span><br><span class="line"><span class="comment"> * understand what I&#x27;m doing here, then you understand how the linux</span></span><br><span class="line"><span class="comment"> * sleep/wakeup mechanism works.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Two very simple procedures, poll_wait() and poll_freewait() make all the</span></span><br><span class="line"><span class="comment"> * work.  poll_wait() is an inline-function defined in &lt;linux/poll.h&gt;,</span></span><br><span class="line"><span class="comment"> * as all select/poll functions have to call it to add an entry to the</span></span><br><span class="line"><span class="comment"> * poll table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __pollwait(struct file *filp, <span class="keyword">wait_queue_head_t</span> *wait_address,</span><br><span class="line">		       poll_table *p);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add a new entry */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __pollwait(struct file *filp, <span class="keyword">wait_queue_head_t</span> *wait_address,</span><br><span class="line">				poll_table *p)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//根据poll_wqueues的成员pt指针p找到所在的poll_wqueues结构指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> *<span class="title">pwq</span> =</span> container_of(p, struct poll_wqueues, pt);</span><br><span class="line">	<span class="comment">//根据pwq找到entry</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">poll_table_entry</span> *<span class="title">entry</span> =</span> poll_get_entry(pwq);</span><br><span class="line">	<span class="keyword">if</span> (!entry)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//entry-&gt;filp = get_file(epi-&gt;ffd.file)</span></span><br><span class="line">	entry-&gt;filp = get_file(filp);</span><br><span class="line">	<span class="comment">//wait_address = &amp;ep-&gt;poll_wait</span></span><br><span class="line">	entry-&gt;wait_address = wait_address;</span><br><span class="line">	<span class="comment">//entry-&gt;key = epi-&gt;event.events</span></span><br><span class="line">	entry-&gt;key = p-&gt;_key;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//(&amp;entry-&gt;wait)-&gt;func = pollwake</span></span><br><span class="line">	init_waitqueue_func_entry(&amp;entry-&gt;wait, pollwake);</span><br><span class="line">	entry-&gt;wait.<span class="keyword">private</span> = pwq;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	add_wait_queue(wait_address, &amp;entry-&gt;wait);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>struct poll_table_entry</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poll_table_entry</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>;</span></span><br><span class="line">	<span class="keyword">__poll_t</span> key;</span><br><span class="line">	<span class="keyword">wait_queue_entry_t</span> wait;</span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> *wait_address;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>init_waitqueue_func_entry</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">init_waitqueue_func_entry(struct wait_queue_entry *wq_entry, <span class="keyword">wait_queue_func_t</span> func)</span><br><span class="line">&#123;</span><br><span class="line">	wq_entry-&gt;flags		= <span class="number">0</span>;</span><br><span class="line">	wq_entry-&gt;<span class="keyword">private</span>	= <span class="literal">NULL</span>;</span><br><span class="line">	wq_entry-&gt;func		= func;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>vfs_poll</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">__poll_t</span> <span class="title">vfs_poll</span><span class="params">(struct file *file, struct poll_table_struct *pt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!file-&gt;f_op-&gt;poll))</span><br><span class="line">		<span class="keyword">return</span> DEFAULT_POLLMASK;</span><br><span class="line">	<span class="comment">// 这边的poll即是tcp_poll,根据tcp本身的信息设置掩码(mask)等信息 &amp; 上兴趣事件掩码，则可以得知当前事件是否是epoll_wait感兴趣的事件</span></span><br><span class="line">	<span class="keyword">return</span> file-&gt;f_op-&gt;poll(file, pt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<pre><code>ep_send_events
    |-&gt;ep_scan_ready_list
        |-&gt;ep_send_events_proc(poll_table pt)
            //pt-&gt;_key = epi-&gt;event.events;
            |-&gt;ep_item_poll(epi, &amp;pt, 1)
                |-&gt;vfs_poll(epi-&gt;ffd.file, pt)
                    |-&gt;file-&gt;f_op-&gt;poll()</code></pre>
<ul>
<li>ep_send_events只是知道epoll_wait被唤醒，还需要获取具体信息</li>
<li>ep_send_events_proc遍历rdllink链表(全局的)，直到其中某个节点的member成员=ep-&gt;rdllist,找到epi节点</li>
<li>ep_item_poll执行epi-&gt;ffd.file-&gt;f_op-&gt;poll() 这边的poll即是file_poll(网络套接字则是tcp_poll)，根据file本身的信息设置掩码(mask)等信息 &amp; 上兴趣事件掩码</li>
<li>ep_send_events_proc根据上一步的结果确认要不要将event放入用户空间</li>
<li>ep_item_poll有2个分支，在两个2同阶段</li>
</ul>
<p><strong>图片来源:</strong> <a href="https://my.oschina.net/alchemystar/blog/3008840">从linux源码看epoll</a></p>
<p><img src="https://i.loli.net/2020/03/08/56NcQU9TDBv7oME.png" alt="epoll_send.jpg"></p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/03/07/1yn3g9mtjPUwiqx.jpg" alt="tumblr_p0koo3JtFk1sfie3io1_1280.jpg"></p>
]]></content>
      <tags>
        <tag>IO复用</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-互斥锁和条件变量</title>
    <url>/2020-04-07-linux-posix%E4%BA%92%E6%96%A5%E9%94%81%E5%92%8C%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%20/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.ibm.com/developerworks/cn/linux/thread/posix_threadapi/part3/">Posix线程编程指南(3)</a></p>
<p><a href="https://blog.csdn.net/a7980718/article/details/88544075">glibc nptl库pthread_mutex_lock和pthread_mutex_unlock浅析</a></p>
<a id="more"></a>

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>互斥锁和条件变量出自posix.1线程标准，它们总是可用来同步一个进程内的各个线程的，如果一个互斥锁或条件变量存放在多个进程间共享的某个内存区内，那么posix还允许它用于这些个进程间的同步。</p>
<p><strong>Posix mutex</strong> <br><br>互斥锁（英语：Mutual exclusion，缩写 Mutex）是一种用于多线程编程中，防止两条线程同时对同一公共资源（比如全局变量）进行读写的机制。该目的通过将代码切片成一个一个的临界区域（critical section）达成。临界区域指的是一块对公共资源进行访问的代码，并非一种机制或是算法。一个程序、进程、线程可以拥有多个临界区域，但是并不一定会应用互斥锁。</p>
<p><strong>Posix Thread中的条件变量</strong> <br><br>pthread中，条件变量实际上是一个阻塞线程处于睡眠状态的线程队列。每个条件变量都必须与一个（且建议只能是一个）互斥锁配套使用。一个线程首先获得互斥锁，然后检查或者修改“条件”；如果条件不成立，则调用pthread_cond_wait()，依次实施3个操作：</p>
<p>1 对当前互斥锁解锁（以便其它线程可以访问或者修改“条件”）<br><br>2 把线程自身阻塞挂起到互斥锁的线程队列中 <br><br>3 被其它线程的信号从互斥锁的线程队列唤醒后，对当前配套的互斥锁申请加锁，如果加锁未能成功，则阻塞挂起到当前互斥锁上。pthread_cond_wait() 函数将不返回直到线程获得配套的互斥锁。 <br></p>
<p>线程离开“条件”的临界区时，必须对当前互斥锁执行解锁。</p>
<h2 id="NPTL"><a href="#NPTL" class="headerlink" title="NPTL"></a>NPTL</h2><p><a href="https://zh.wikipedia.org/wiki/Native_POSIX_Thread_Library">Native POSIX Thread Library</a></p>
<p>Native POSIX Thread Library（NPTL）是Linux内核中实践POSIX Threads标准的库</p>
<p>在Linux内核2.6出现之前进程是(最小)可调度的对象，当时的Linux不真正支持线程。但是Linux内核有一个系统调用指令<code>clone()</code>，这个指令产生一个调用调用的进程的复件，而且这个复件与原进程使用同一地址空间。LinuxThreads计划使用这个系统调用来提供一个内核级的线程支持。但是这个解决方法与真正的POSIX标准有一些不兼容的地方，尤其是在信号处理、进程调度和进程间同步原语方面。</p>
<p>要提高LinuxThreads的效应很明显需要提供内核支持以及必须重写线程函数库。为了解决这个问题出现了两个互相竞争的项目：一个IBM的组的项目叫做NGPT（Next Generation POSIX Threads，下一代POSIX线程），另一个组是由Red Hat程序员组成的。2003年中NGPT被放弃，几乎与此同时NPTL公布了。</p>
<p>NPTL首次是随Red Hat Linux 9发表的。此前老式的Linux POSIX线程偶尔会发生系统无法产生线程的毛病，这个毛病的原因是因为在新线程开始的时候系统没有借机先占。当时的Windows系统对这个问题的解决比较好。Red Hat在关于Red Hat Linux 9上的Java的网页上发表了一篇文章称NPTL解决了这个问题[3]。</p>
<p>从第3版开始NPTL是Red Hat Enterprise Linux的一部分，从Linux内核2.6开始它被纳入内核。当前它完全被结合入<code>GNU C</code> 库。</p>
<p>NPTL的解决方法与LinuxThreads类似，内核看到的首要抽象依然是一个进程，新线程是通过clone()系统调用产生的。但是NPTL需要特殊的内核支持来解决同步的原始类型之间互相竞争的状况。在这种情况下线程必须能够入眠和再复苏。用来完成这个任务的原始类型叫做<code>futex</code>。</p>
<p>NPTL是一个所谓的<code>1×1线程函数库</code>。用户产生的线程与内核能够分配的对象之间的联系是一对一的。这是所有线程程序中最简单的。</p>
<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>GNU C Library (GNU libc) stable release version 2.17, by Roland McGrath et al.</p>
<hr>
<h3 id="pthread-mutex-t"><a href="#pthread-mutex-t" class="headerlink" title="pthread_mutex_t"></a>pthread_mutex_t</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Data structures for mutex handling.  The structure of the attribute</span></span><br><span class="line"><span class="comment">   type is deliberately not exposed.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">pthread_mutex_s</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">int</span> __lock;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> __count;</span><br><span class="line">    <span class="keyword">int</span> __owner;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> __nusers;</span><br><span class="line">    <span class="comment">/* KIND must stay at this position in the structure to maintain</span></span><br><span class="line"><span class="comment">       binary compatibility.  */</span></span><br><span class="line">    <span class="keyword">int</span> __kind;</span><br><span class="line">    <span class="keyword">int</span> __spins;</span><br><span class="line">    <span class="keyword">__pthread_list_t</span> __list;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __PTHREAD_MUTEX_HAVE_PREV	1</span></span><br><span class="line">  &#125; __data;</span><br><span class="line">  <span class="keyword">char</span> __size[__SIZEOF_PTHREAD_MUTEX_T];</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> __align;</span><br><span class="line">&#125; <span class="keyword">pthread_mutex_t</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="PTHREAD-MUTEX-INITIALIZER"><a href="#PTHREAD-MUTEX-INITIALIZER" class="headerlink" title="PTHREAD_MUTEX_INITIALIZER"></a>PTHREAD_MUTEX_INITIALIZER</h3><p>静态初始化的宏</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mutex=PTHREAD_MUTEX_INITIALIZER; </span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex=PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Mutex initializers.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __PTHREAD_MUTEX_HAVE_PREV</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> PTHREAD_MUTEX_INITIALIZER \</span></span><br><span class="line">  &#123; &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, &#123; <span class="number">0</span>, <span class="number">0</span> &#125; &#125; &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="pthread-mutex-init"><a href="#pthread-mutex-init" class="headerlink" title="pthread_mutex_init"></a>pthread_mutex_init</h3><p>动态初始化的函数(malloc或者分配在共享内存区)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__pthread_mutex_init (mutex, mutexattr)</span><br><span class="line">     <span class="keyword">pthread_mutex_t</span> *mutex;</span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *mutexattr;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pthread_mutexattr</span> *<span class="title">imutexattr</span>;</span></span><br><span class="line"></span><br><span class="line">  assert (<span class="keyword">sizeof</span> (<span class="keyword">pthread_mutex_t</span>) &lt;= __SIZEOF_PTHREAD_MUTEX_T);</span><br><span class="line"></span><br><span class="line">  imutexattr = (<span class="keyword">const</span> struct pthread_mutexattr *) mutexattr ?: &amp;default_attr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Sanity checks.  */</span></span><br><span class="line">  <span class="keyword">switch</span> (__builtin_expect (imutexattr-&gt;mutexkind</span><br><span class="line">			    &amp; PTHREAD_MUTEXATTR_PROTOCOL_MASK,</span><br><span class="line">			    PTHREAD_PRIO_NONE</span><br><span class="line">			    &lt;&lt; PTHREAD_MUTEXATTR_PROTOCOL_SHIFT))</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> PTHREAD_PRIO_NONE &lt;&lt; PTHREAD_MUTEXATTR_PROTOCOL_SHIFT:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> PTHREAD_PRIO_INHERIT &lt;&lt; PTHREAD_MUTEXATTR_PROTOCOL_SHIFT:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __ASSUME_FUTEX_LOCK_PI</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (tpi_supported == <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">int</span> lock = <span class="number">0</span>;</span><br><span class="line">	  INTERNAL_SYSCALL_DECL (err);</span><br><span class="line">	  <span class="keyword">int</span> ret = INTERNAL_SYSCALL (futex, err, <span class="number">4</span>, &amp;lock, FUTEX_UNLOCK_PI,</span><br><span class="line">				      <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	  assert (INTERNAL_SYSCALL_ERROR_P (ret, err));</span><br><span class="line">	  tpi_supported = INTERNAL_SYSCALL_ERRNO (ret, err) == ENOSYS ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (tpi_supported &lt; <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">	<span class="keyword">return</span> ENOTSUP;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">/* <span class="doctag">XXX:</span> For now we don&#x27;t support robust priority protected mutexes.  */</span></span><br><span class="line">      <span class="keyword">if</span> (imutexattr-&gt;mutexkind &amp; PTHREAD_MUTEXATTR_FLAG_ROBUST)</span><br><span class="line">	<span class="keyword">return</span> ENOTSUP;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Clear the whole variable.  */</span></span><br><span class="line">  <span class="built_in">memset</span> (mutex, <span class="string">&#x27;\0&#x27;</span>, __SIZEOF_PTHREAD_MUTEX_T);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Copy the values from the attribute.  */</span></span><br><span class="line">  mutex-&gt;__data.__kind = imutexattr-&gt;mutexkind &amp; ~PTHREAD_MUTEXATTR_FLAG_BITS;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((imutexattr-&gt;mutexkind &amp; PTHREAD_MUTEXATTR_FLAG_ROBUST) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __ASSUME_SET_ROBUST_LIST</span></span><br><span class="line">      <span class="keyword">if</span> ((imutexattr-&gt;mutexkind &amp; PTHREAD_MUTEXATTR_FLAG_PSHARED) != <span class="number">0</span></span><br><span class="line">	  &amp;&amp; __set_robust_list_avail &lt; <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> ENOTSUP;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      mutex-&gt;__data.__kind |= PTHREAD_MUTEX_ROBUST_NORMAL_NP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (imutexattr-&gt;mutexkind &amp; PTHREAD_MUTEXATTR_PROTOCOL_MASK)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> PTHREAD_PRIO_INHERIT &lt;&lt; PTHREAD_MUTEXATTR_PROTOCOL_SHIFT:</span><br><span class="line">      mutex-&gt;__data.__kind |= PTHREAD_MUTEX_PRIO_INHERIT_NP;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> PTHREAD_PRIO_PROTECT &lt;&lt; PTHREAD_MUTEXATTR_PROTOCOL_SHIFT:</span><br><span class="line">      mutex-&gt;__data.__kind |= PTHREAD_MUTEX_PRIO_PROTECT_NP;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> ceiling = (imutexattr-&gt;mutexkind</span><br><span class="line">		     &amp; PTHREAD_MUTEXATTR_PRIO_CEILING_MASK)</span><br><span class="line">		    &gt;&gt; PTHREAD_MUTEXATTR_PRIO_CEILING_SHIFT;</span><br><span class="line">      <span class="keyword">if</span> (! ceiling)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">if</span> (__sched_fifo_min_prio == <span class="number">-1</span>)</span><br><span class="line">	    __init_sched_fifo_prio ();</span><br><span class="line">	  <span class="keyword">if</span> (ceiling &lt; __sched_fifo_min_prio)</span><br><span class="line">	    ceiling = __sched_fifo_min_prio;</span><br><span class="line">	&#125;</span><br><span class="line">      mutex-&gt;__data.__lock = ceiling &lt;&lt; PTHREAD_MUTEX_PRIO_CEILING_SHIFT;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The kernel when waking robust mutexes on exit never uses</span></span><br><span class="line"><span class="comment">     FUTEX_PRIVATE_FLAG FUTEX_WAKE.  */</span></span><br><span class="line">  <span class="keyword">if</span> ((imutexattr-&gt;mutexkind &amp; (PTHREAD_MUTEXATTR_FLAG_PSHARED</span><br><span class="line">				| PTHREAD_MUTEXATTR_FLAG_ROBUST)) != <span class="number">0</span>)</span><br><span class="line">    mutex-&gt;__data.__kind |= PTHREAD_MUTEX_PSHARED_BIT;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Default values: mutex not used yet.  */</span></span><br><span class="line">  <span class="comment">// mutex-&gt;__count = 0;	already done by memset</span></span><br><span class="line">  <span class="comment">// mutex-&gt;__owner = 0;	already done by memset</span></span><br><span class="line">  <span class="comment">// mutex-&gt;__nusers = 0;	already done by memset</span></span><br><span class="line">  <span class="comment">// mutex-&gt;__spins = 0;	already done by memset</span></span><br><span class="line">  <span class="comment">// mutex-&gt;__next = NULL;	already done by memset</span></span><br><span class="line"></span><br><span class="line">  LIBC_PROBE (mutex_init, <span class="number">1</span>, mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>比较复杂，不研究了</p>
<p><strong>unp:</strong> <br></p>
<blockquote>
<p>你可能会碰到省略了初始化操作的代码，因为它所在的实现把初始化常量定义为0(而且静态分配的变量被自动得初始化为0)，不过这是不正确的代码</p>
</blockquote>
<hr>
<h3 id="pthread-mutex-lock"><a href="#pthread-mutex-lock" class="headerlink" title="__pthread_mutex_lock"></a>__pthread_mutex_lock</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//pthread_mutex_lock.c</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">__pthread_mutex_lock (mutex)</span><br><span class="line">     <span class="keyword">pthread_mutex_t</span> *mutex;</span><br><span class="line">&#123;</span><br><span class="line">  assert (<span class="keyword">sizeof</span> (mutex-&gt;__size) &gt;= <span class="keyword">sizeof</span> (mutex-&gt;__data));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> type = PTHREAD_MUTEX_TYPE (mutex);</span><br><span class="line"></span><br><span class="line">  LIBC_PROBE (mutex_entry, <span class="number">1</span>, mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (type &amp; ~PTHREAD_MUTEX_KIND_MASK_NP, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> __pthread_mutex_lock_full (mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">pid_t</span> id = THREAD_GETMEM (THREAD_SELF, tid);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (type, PTHREAD_MUTEX_TIMED_NP)</span><br><span class="line">      == PTHREAD_MUTEX_TIMED_NP)</span><br><span class="line">    &#123;</span><br><span class="line">    simple:</span><br><span class="line">      <span class="comment">/* Normal mutex.  */</span></span><br><span class="line">      LLL_MUTEX_LOCK (mutex);</span><br><span class="line">      assert (mutex-&gt;__data.__owner == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (__builtin_expect (type == PTHREAD_MUTEX_RECURSIVE_NP, <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//递归锁</span></span><br><span class="line">      <span class="comment">/* Recursive mutex.  */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Check whether we already hold the mutex.  */</span></span><br><span class="line">      <span class="keyword">if</span> (mutex-&gt;__data.__owner == id)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* Just bump the counter.  */</span></span><br><span class="line">	  <span class="keyword">if</span> (__builtin_expect (mutex-&gt;__data.__count + <span class="number">1</span> == <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">	    <span class="comment">/* Overflow of the counter.  */</span></span><br><span class="line">	    <span class="keyword">return</span> EAGAIN;</span><br><span class="line"></span><br><span class="line">	  ++mutex-&gt;__data.__count;</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We have to get the mutex.  */</span></span><br><span class="line">      LLL_MUTEX_LOCK (mutex);</span><br><span class="line"></span><br><span class="line">      assert (mutex-&gt;__data.__owner == <span class="number">0</span>);</span><br><span class="line">      mutex-&gt;__data.__count = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (__builtin_expect (type == PTHREAD_MUTEX_ADAPTIVE_NP, <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (! __is_smp)</span><br><span class="line">	<span class="keyword">goto</span> simple;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (LLL_MUTEX_TRYLOCK (mutex) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	  <span class="keyword">int</span> max_cnt = MIN (MAX_ADAPTIVE_COUNT,</span><br><span class="line">			     mutex-&gt;__data.__spins * <span class="number">2</span> + <span class="number">10</span>);</span><br><span class="line">	  <span class="keyword">do</span></span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">if</span> (cnt++ &gt;= max_cnt)</span><br><span class="line">		&#123;</span><br><span class="line">		  LLL_MUTEX_LOCK (mutex);</span><br><span class="line">		  <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> BUSY_WAIT_NOP</span></span><br><span class="line">	      BUSY_WAIT_NOP;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	    &#125;</span><br><span class="line">	  <span class="keyword">while</span> (LLL_MUTEX_TRYLOCK (mutex) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	  mutex-&gt;__data.__spins += (cnt - mutex-&gt;__data.__spins) / <span class="number">8</span>;</span><br><span class="line">	&#125;</span><br><span class="line">      assert (mutex-&gt;__data.__owner == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      assert (type == PTHREAD_MUTEX_ERRORCHECK_NP);</span><br><span class="line">      <span class="comment">/* Check whether we already hold the mutex.  */</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (mutex-&gt;__data.__owner == id, <span class="number">0</span>))</span><br><span class="line">	<span class="keyword">return</span> EDEADLK;</span><br><span class="line">      <span class="keyword">goto</span> simple;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Record the ownership.  */</span></span><br><span class="line">  mutex-&gt;__data.__owner = id;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NO_INCR</span></span><br><span class="line">  ++mutex-&gt;__data.__nusers;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  LIBC_PROBE (mutex_acquired, <span class="number">1</span>, mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>如果是普通锁，调用LLL_MUTEX_LOCK，进行CAS(Compare-and-Swap)操作，失败则执行系统调用sys_futex陷入内核态</li>
<li>如果是递归锁，判断是否是当前进程(线程)持有锁。然后将count计数器加一，如果count等于0，则return EAGAIN</li>
<li>如果是自适应锁，通过非阻塞的LLL_MUTEX_TRYLOCK自旋到最大次数后，执行LLL_MUTEX_LOCK</li>
<li>如果是检错锁，判断是否是当前进程(线程)重复加锁，返回EDEADLK</li>
</ul>
<hr>
<h3 id="pthread-mutex-unlock"><a href="#pthread-mutex-unlock" class="headerlink" title="__pthread_mutex_unlock"></a>__pthread_mutex_unlock</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__pthread_mutex_unlock (mutex)</span><br><span class="line">     <span class="keyword">pthread_mutex_t</span> *mutex;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __pthread_mutex_unlock_usercnt (mutex, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">internal_function attribute_hidden</span><br><span class="line">__pthread_mutex_unlock_usercnt (mutex, decr)</span><br><span class="line">     <span class="keyword">pthread_mutex_t</span> *mutex;</span><br><span class="line">     <span class="keyword">int</span> decr;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> type = PTHREAD_MUTEX_TYPE (mutex);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (type &amp; ~PTHREAD_MUTEX_KIND_MASK_NP, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> __pthread_mutex_unlock_full (mutex, decr);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (type, PTHREAD_MUTEX_TIMED_NP)</span><br><span class="line">      == PTHREAD_MUTEX_TIMED_NP)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Always reset the owner field.  */</span></span><br><span class="line">    normal:</span><br><span class="line">      mutex-&gt;__data.__owner = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (decr)</span><br><span class="line">	<span class="comment">/* One less user.  */</span></span><br><span class="line">	--mutex-&gt;__data.__nusers;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Unlock.  */</span></span><br><span class="line">      lll_unlock (mutex-&gt;__data.__lock, PTHREAD_MUTEX_PSHARED (mutex));</span><br><span class="line"></span><br><span class="line">      LIBC_PROBE (mutex_release, <span class="number">1</span>, mutex);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (__builtin_expect (type == PTHREAD_MUTEX_RECURSIVE_NP, <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Recursive mutex.  */</span></span><br><span class="line">      <span class="keyword">if</span> (mutex-&gt;__data.__owner != THREAD_GETMEM (THREAD_SELF, tid))</span><br><span class="line">	<span class="keyword">return</span> EPERM;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (--mutex-&gt;__data.__count != <span class="number">0</span>)</span><br><span class="line">	<span class="comment">/* We still hold the mutex.  */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">goto</span> normal;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (__builtin_expect (type == PTHREAD_MUTEX_ADAPTIVE_NP, <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">goto</span> normal;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Error checking mutex.  */</span></span><br><span class="line">      assert (type == PTHREAD_MUTEX_ERRORCHECK_NP);</span><br><span class="line">      <span class="keyword">if</span> (mutex-&gt;__data.__owner != THREAD_GETMEM (THREAD_SELF, tid)</span><br><span class="line">	  || ! lll_islocked (mutex-&gt;__data.__lock))</span><br><span class="line">	<span class="keyword">return</span> EPERM;</span><br><span class="line">      <span class="keyword">goto</span> normal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果是普通锁，执行lll_unlock</li>
<li>如果是递归锁，判断是否是当前的进程(线程)持有锁，如果是，count计数器减一，count为0的话，返回</li>
<li>如果是自适应锁，执行lll_unlock</li>
<li>如果是检错锁，判断是否是当前的进程(线程)持有锁，如果是，执行lll_unlock。如果不是，返回EPERM</li>
</ul>
<hr>
<h3 id="pthread-mutex-trylock"><a href="#pthread-mutex-trylock" class="headerlink" title="__pthread_mutex_trylock"></a>__pthread_mutex_trylock</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__pthread_mutex_trylock (mutex)</span><br><span class="line">     <span class="keyword">pthread_mutex_t</span> *mutex;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> oldval;</span><br><span class="line">  <span class="keyword">pid_t</span> id = THREAD_GETMEM (THREAD_SELF, tid);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (__builtin_expect (PTHREAD_MUTEX_TYPE (mutex),</span><br><span class="line">			    PTHREAD_MUTEX_TIMED_NP))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Recursive mutex.  */</span></span><br><span class="line">    <span class="keyword">case</span> PTHREAD_MUTEX_RECURSIVE_NP:</span><br><span class="line">      <span class="comment">/* Check whether we already hold the mutex.  */</span></span><br><span class="line">      <span class="keyword">if</span> (mutex-&gt;__data.__owner == id)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* Just bump the counter.  */</span></span><br><span class="line">	  <span class="keyword">if</span> (__builtin_expect (mutex-&gt;__data.__count + <span class="number">1</span> == <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">	    <span class="comment">/* Overflow of the counter.  */</span></span><br><span class="line">	    <span class="keyword">return</span> EAGAIN;</span><br><span class="line"></span><br><span class="line">	  ++mutex-&gt;__data.__count;</span><br><span class="line">	  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (lll_trylock (mutex-&gt;__data.__lock) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* Record the ownership.  */</span></span><br><span class="line">	  mutex-&gt;__data.__owner = id;</span><br><span class="line">	  mutex-&gt;__data.__count = <span class="number">1</span>;</span><br><span class="line">	  ++mutex-&gt;__data.__nusers;</span><br><span class="line">	  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> PTHREAD_MUTEX_ERRORCHECK_NP:</span><br><span class="line">    <span class="keyword">case</span> PTHREAD_MUTEX_TIMED_NP:</span><br><span class="line">    <span class="keyword">case</span> PTHREAD_MUTEX_ADAPTIVE_NP:</span><br><span class="line">      <span class="comment">/* Normal mutex.  */</span></span><br><span class="line">      <span class="keyword">if</span> (lll_trylock (mutex-&gt;__data.__lock) != <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Record the ownership.  */</span></span><br><span class="line">      mutex-&gt;__data.__owner = id;</span><br><span class="line">      ++mutex-&gt;__data.__nusers;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> PTHREAD_MUTEX_ROBUST_RECURSIVE_NP:</span><br><span class="line">    <span class="keyword">case</span> PTHREAD_MUTEX_ROBUST_ERRORCHECK_NP:</span><br><span class="line">    <span class="keyword">case</span> PTHREAD_MUTEX_ROBUST_NORMAL_NP:</span><br><span class="line">    <span class="keyword">case</span> PTHREAD_MUTEX_ROBUST_ADAPTIVE_NP:</span><br><span class="line">      THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending,</span><br><span class="line">		     &amp;mutex-&gt;__data.__list.__next);</span><br><span class="line"></span><br><span class="line">      oldval = mutex-&gt;__data.__lock;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">	again:</span><br><span class="line">	  <span class="keyword">if</span> ((oldval &amp; FUTEX_OWNER_DIED) != <span class="number">0</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="comment">/* The previous owner died.  Try locking the mutex.  */</span></span><br><span class="line">	      <span class="keyword">int</span> newval = id | (oldval &amp; FUTEX_WAITERS);</span><br><span class="line"></span><br><span class="line">	      newval</span><br><span class="line">		= atomic_compare_and_exchange_val_acq (&amp;mutex-&gt;__data.__lock,</span><br><span class="line">						       newval, oldval);</span><br><span class="line"></span><br><span class="line">	      <span class="keyword">if</span> (newval != oldval)</span><br><span class="line">		&#123;</span><br><span class="line">		  oldval = newval;</span><br><span class="line">		  <span class="keyword">goto</span> again;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	      <span class="comment">/* We got the mutex.  */</span></span><br><span class="line">	      mutex-&gt;__data.__count = <span class="number">1</span>;</span><br><span class="line">	      <span class="comment">/* But it is inconsistent unless marked otherwise.  */</span></span><br><span class="line">	      mutex-&gt;__data.__owner = PTHREAD_MUTEX_INCONSISTENT;</span><br><span class="line"></span><br><span class="line">	      ENQUEUE_MUTEX (mutex);</span><br><span class="line">	      THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	      <span class="comment">/* Note that we deliberately exist here.  If we fall</span></span><br><span class="line"><span class="comment">		 through to the end of the function __nusers would be</span></span><br><span class="line"><span class="comment">		 incremented which is not correct because the old</span></span><br><span class="line"><span class="comment">		 owner has to be discounted.  */</span></span><br><span class="line">	      <span class="keyword">return</span> EOWNERDEAD;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Check whether we already hold the mutex.  */</span></span><br><span class="line">	  <span class="keyword">if</span> (__builtin_expect ((oldval &amp; FUTEX_TID_MASK) == id, <span class="number">0</span>))</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">int</span> kind = PTHREAD_MUTEX_TYPE (mutex);</span><br><span class="line">	      <span class="keyword">if</span> (kind == PTHREAD_MUTEX_ROBUST_ERRORCHECK_NP)</span><br><span class="line">		&#123;</span><br><span class="line">		  THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending,</span><br><span class="line">				 <span class="literal">NULL</span>);</span><br><span class="line">		  <span class="keyword">return</span> EDEADLK;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	      <span class="keyword">if</span> (kind == PTHREAD_MUTEX_ROBUST_RECURSIVE_NP)</span><br><span class="line">		&#123;</span><br><span class="line">		  THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending,</span><br><span class="line">				 <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		  <span class="comment">/* Just bump the counter.  */</span></span><br><span class="line">		  <span class="keyword">if</span> (__builtin_expect (mutex-&gt;__data.__count + <span class="number">1</span> == <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">		    <span class="comment">/* Overflow of the counter.  */</span></span><br><span class="line">		    <span class="keyword">return</span> EAGAIN;</span><br><span class="line"></span><br><span class="line">		  ++mutex-&gt;__data.__count;</span><br><span class="line"></span><br><span class="line">		  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  oldval = lll_robust_trylock (mutex-&gt;__data.__lock, id);</span><br><span class="line">	  <span class="keyword">if</span> (oldval != <span class="number">0</span> &amp;&amp; (oldval &amp; FUTEX_OWNER_DIED) == <span class="number">0</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	      <span class="keyword">return</span> EBUSY;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (__builtin_expect (mutex-&gt;__data.__owner</span><br><span class="line">				== PTHREAD_MUTEX_NOTRECOVERABLE, <span class="number">0</span>))</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="comment">/* This mutex is now not recoverable.  */</span></span><br><span class="line">	      mutex-&gt;__data.__count = <span class="number">0</span>;</span><br><span class="line">	      <span class="keyword">if</span> (oldval == id)</span><br><span class="line">		lll_unlock (mutex-&gt;__data.__lock,</span><br><span class="line">			    PTHREAD_ROBUST_MUTEX_PSHARED (mutex));</span><br><span class="line">	      THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending, <span class="literal">NULL</span>);</span><br><span class="line">	      <span class="keyword">return</span> ENOTRECOVERABLE;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">while</span> ((oldval &amp; FUTEX_OWNER_DIED) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      ENQUEUE_MUTEX (mutex);</span><br><span class="line">      THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">      mutex-&gt;__data.__owner = id;</span><br><span class="line">      ++mutex-&gt;__data.__nusers;</span><br><span class="line">      mutex-&gt;__data.__count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> PTHREAD_MUTEX_PI_RECURSIVE_NP:</span><br><span class="line">    <span class="keyword">case</span> PTHREAD_MUTEX_PI_ERRORCHECK_NP:</span><br><span class="line">    <span class="keyword">case</span> PTHREAD_MUTEX_PI_NORMAL_NP:</span><br><span class="line">    <span class="keyword">case</span> PTHREAD_MUTEX_PI_ADAPTIVE_NP:</span><br><span class="line">    <span class="keyword">case</span> PTHREAD_MUTEX_PI_ROBUST_RECURSIVE_NP:</span><br><span class="line">    <span class="keyword">case</span> PTHREAD_MUTEX_PI_ROBUST_ERRORCHECK_NP:</span><br><span class="line">    <span class="keyword">case</span> PTHREAD_MUTEX_PI_ROBUST_NORMAL_NP:</span><br><span class="line">    <span class="keyword">case</span> PTHREAD_MUTEX_PI_ROBUST_ADAPTIVE_NP:</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="keyword">int</span> kind = mutex-&gt;__data.__kind &amp; PTHREAD_MUTEX_KIND_MASK_NP;</span><br><span class="line">	<span class="keyword">int</span> robust = mutex-&gt;__data.__kind &amp; PTHREAD_MUTEX_ROBUST_NORMAL_NP;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (robust)</span><br><span class="line">	  <span class="comment">/* Note: robust PI futexes are signaled by setting bit 0.  */</span></span><br><span class="line">	  THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending,</span><br><span class="line">			 (<span class="keyword">void</span> *) (((<span class="keyword">uintptr_t</span>) &amp;mutex-&gt;__data.__list.__next)</span><br><span class="line">				   | <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">	oldval = mutex-&gt;__data.__lock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check whether we already hold the mutex.  */</span></span><br><span class="line">	<span class="keyword">if</span> (__builtin_expect ((oldval &amp; FUTEX_TID_MASK) == id, <span class="number">0</span>))</span><br><span class="line">	  &#123;</span><br><span class="line">	    <span class="keyword">if</span> (kind == PTHREAD_MUTEX_ERRORCHECK_NP)</span><br><span class="line">	      &#123;</span><br><span class="line">		THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">return</span> EDEADLK;</span><br><span class="line">	      &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> (kind == PTHREAD_MUTEX_RECURSIVE_NP)</span><br><span class="line">	      &#123;</span><br><span class="line">		THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Just bump the counter.  */</span></span><br><span class="line">		<span class="keyword">if</span> (__builtin_expect (mutex-&gt;__data.__count + <span class="number">1</span> == <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">		  <span class="comment">/* Overflow of the counter.  */</span></span><br><span class="line">		  <span class="keyword">return</span> EAGAIN;</span><br><span class="line"></span><br><span class="line">		++mutex-&gt;__data.__count;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	      &#125;</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	oldval</span><br><span class="line">	  = atomic_compare_and_exchange_val_acq (&amp;mutex-&gt;__data.__lock,</span><br><span class="line">						 id, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (oldval != <span class="number">0</span>)</span><br><span class="line">	  &#123;</span><br><span class="line">	    <span class="keyword">if</span> ((oldval &amp; FUTEX_OWNER_DIED) == <span class="number">0</span>)</span><br><span class="line">	      &#123;</span><br><span class="line">		THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> EBUSY;</span><br><span class="line">	      &#125;</span><br><span class="line"></span><br><span class="line">	    assert (robust);</span><br><span class="line"></span><br><span class="line">	    <span class="comment">/* The mutex owner died.  The kernel will now take care of</span></span><br><span class="line"><span class="comment">	       everything.  */</span></span><br><span class="line">	    <span class="keyword">int</span> <span class="keyword">private</span> = (robust</span><br><span class="line">			   ? PTHREAD_ROBUST_MUTEX_PSHARED (mutex)</span><br><span class="line">			   : PTHREAD_MUTEX_PSHARED (mutex));</span><br><span class="line">	    INTERNAL_SYSCALL_DECL (__err);</span><br><span class="line">	    <span class="keyword">int</span> e = INTERNAL_SYSCALL (futex, __err, <span class="number">4</span>, &amp;mutex-&gt;__data.__lock,</span><br><span class="line">				      __lll_private_flag (FUTEX_TRYLOCK_PI,</span><br><span class="line">							  <span class="keyword">private</span>), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> (INTERNAL_SYSCALL_ERROR_P (e, __err)</span><br><span class="line">		&amp;&amp; INTERNAL_SYSCALL_ERRNO (e, __err) == EWOULDBLOCK)</span><br><span class="line">	      &#123;</span><br><span class="line">		THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> EBUSY;</span><br><span class="line">	      &#125;</span><br><span class="line"></span><br><span class="line">	    oldval = mutex-&gt;__data.__lock;</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (__builtin_expect (oldval &amp; FUTEX_OWNER_DIED, <span class="number">0</span>))</span><br><span class="line">	  &#123;</span><br><span class="line">	    atomic_and (&amp;mutex-&gt;__data.__lock, ~FUTEX_OWNER_DIED);</span><br><span class="line"></span><br><span class="line">	    <span class="comment">/* We got the mutex.  */</span></span><br><span class="line">	    mutex-&gt;__data.__count = <span class="number">1</span>;</span><br><span class="line">	    <span class="comment">/* But it is inconsistent unless marked otherwise.  */</span></span><br><span class="line">	    mutex-&gt;__data.__owner = PTHREAD_MUTEX_INCONSISTENT;</span><br><span class="line"></span><br><span class="line">	    ENQUEUE_MUTEX (mutex);</span><br><span class="line">	    THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	    <span class="comment">/* Note that we deliberately exit here.  If we fall</span></span><br><span class="line"><span class="comment">	       through to the end of the function __nusers would be</span></span><br><span class="line"><span class="comment">	       incremented which is not correct because the old owner</span></span><br><span class="line"><span class="comment">	       has to be discounted.  */</span></span><br><span class="line">	    <span class="keyword">return</span> EOWNERDEAD;</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (robust</span><br><span class="line">	    &amp;&amp; __builtin_expect (mutex-&gt;__data.__owner</span><br><span class="line">				 == PTHREAD_MUTEX_NOTRECOVERABLE, <span class="number">0</span>))</span><br><span class="line">	  &#123;</span><br><span class="line">	    <span class="comment">/* This mutex is now not recoverable.  */</span></span><br><span class="line">	    mutex-&gt;__data.__count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	    INTERNAL_SYSCALL_DECL (__err);</span><br><span class="line">	    INTERNAL_SYSCALL (futex, __err, <span class="number">4</span>, &amp;mutex-&gt;__data.__lock,</span><br><span class="line">			      __lll_private_flag (FUTEX_UNLOCK_PI,</span><br><span class="line">						  PTHREAD_ROBUST_MUTEX_PSHARED (mutex)),</span><br><span class="line">			      <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	    THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending, <span class="literal">NULL</span>);</span><br><span class="line">	    <span class="keyword">return</span> ENOTRECOVERABLE;</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (robust)</span><br><span class="line">	  &#123;</span><br><span class="line">	    ENQUEUE_MUTEX_PI (mutex);</span><br><span class="line">	    THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending, <span class="literal">NULL</span>);</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	mutex-&gt;__data.__owner = id;</span><br><span class="line">	++mutex-&gt;__data.__nusers;</span><br><span class="line">	mutex-&gt;__data.__count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> PTHREAD_MUTEX_PP_RECURSIVE_NP:</span><br><span class="line">    <span class="keyword">case</span> PTHREAD_MUTEX_PP_ERRORCHECK_NP:</span><br><span class="line">    <span class="keyword">case</span> PTHREAD_MUTEX_PP_NORMAL_NP:</span><br><span class="line">    <span class="keyword">case</span> PTHREAD_MUTEX_PP_ADAPTIVE_NP:</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="keyword">int</span> kind = mutex-&gt;__data.__kind &amp; PTHREAD_MUTEX_KIND_MASK_NP;</span><br><span class="line"></span><br><span class="line">	oldval = mutex-&gt;__data.__lock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check whether we already hold the mutex.  */</span></span><br><span class="line">	<span class="keyword">if</span> (mutex-&gt;__data.__owner == id)</span><br><span class="line">	  &#123;</span><br><span class="line">	    <span class="keyword">if</span> (kind == PTHREAD_MUTEX_ERRORCHECK_NP)</span><br><span class="line">	      <span class="keyword">return</span> EDEADLK;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> (kind == PTHREAD_MUTEX_RECURSIVE_NP)</span><br><span class="line">	      &#123;</span><br><span class="line">		<span class="comment">/* Just bump the counter.  */</span></span><br><span class="line">		<span class="keyword">if</span> (__builtin_expect (mutex-&gt;__data.__count + <span class="number">1</span> == <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">		  <span class="comment">/* Overflow of the counter.  */</span></span><br><span class="line">		  <span class="keyword">return</span> EAGAIN;</span><br><span class="line"></span><br><span class="line">		++mutex-&gt;__data.__count;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	      &#125;</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> oldprio = <span class="number">-1</span>, ceilval;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	  &#123;</span><br><span class="line">	    <span class="keyword">int</span> ceiling = (oldval &amp; PTHREAD_MUTEX_PRIO_CEILING_MASK)</span><br><span class="line">			  &gt;&gt; PTHREAD_MUTEX_PRIO_CEILING_SHIFT;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> (__pthread_current_priority () &gt; ceiling)</span><br><span class="line">	      &#123;</span><br><span class="line">		<span class="keyword">if</span> (oldprio != <span class="number">-1</span>)</span><br><span class="line">		  __pthread_tpp_change_priority (oldprio, <span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">return</span> EINVAL;</span><br><span class="line">	      &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">int</span> retval = __pthread_tpp_change_priority (oldprio, ceiling);</span><br><span class="line">	    <span class="keyword">if</span> (retval)</span><br><span class="line">	      <span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">	    ceilval = ceiling &lt;&lt; PTHREAD_MUTEX_PRIO_CEILING_SHIFT;</span><br><span class="line">	    oldprio = ceiling;</span><br><span class="line"></span><br><span class="line">	    oldval</span><br><span class="line">	      = atomic_compare_and_exchange_val_acq (&amp;mutex-&gt;__data.__lock,</span><br><span class="line">						     ceilval | <span class="number">1</span>, ceilval);</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> (oldval == ceilval)</span><br><span class="line">	      <span class="keyword">break</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">	<span class="keyword">while</span> ((oldval &amp; PTHREAD_MUTEX_PRIO_CEILING_MASK) != ceilval);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (oldval != ceilval)</span><br><span class="line">	  &#123;</span><br><span class="line">	    __pthread_tpp_change_priority (oldprio, <span class="number">-1</span>);</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	assert (mutex-&gt;__data.__owner == <span class="number">0</span>);</span><br><span class="line">	<span class="comment">/* Record the ownership.  */</span></span><br><span class="line">	mutex-&gt;__data.__owner = id;</span><br><span class="line">	++mutex-&gt;__data.__nusers;</span><br><span class="line">	mutex-&gt;__data.__count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">/* Correct code cannot set any other type.  */</span></span><br><span class="line">      <span class="keyword">return</span> EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> EBUSY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>非阻塞获取锁，具体不分析了</p>
<hr>
<h3 id="pthread-mutex-destroy"><a href="#pthread-mutex-destroy" class="headerlink" title="__pthread_mutex_destroy"></a>__pthread_mutex_destroy</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__pthread_mutex_destroy (mutex)</span><br><span class="line">     <span class="keyword">pthread_mutex_t</span> *mutex;</span><br><span class="line">&#123;</span><br><span class="line">  LIBC_PROBE (mutex_destroy, <span class="number">1</span>, mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((mutex-&gt;__data.__kind &amp; PTHREAD_MUTEX_ROBUST_NORMAL_NP) == <span class="number">0</span></span><br><span class="line">      &amp;&amp; mutex-&gt;__data.__nusers != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> EBUSY;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set to an invalid value.  */</span></span><br><span class="line">  mutex-&gt;__data.__kind = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>摧毁互斥锁</p>
<hr>
<h3 id="四种锁的属性"><a href="#四种锁的属性" class="headerlink" title="四种锁的属性"></a>四种锁的属性</h3><p><a href="https://www.ibm.com/developerworks/cn/linux/thread/posix_threadapi/part3/">Posix线程编程指南(3)</a></p>
<p>互斥锁的属性在创建锁的时候指定，在LinuxThreads实现中仅有一个锁类型属性，不同的锁类型在试图对一个已经被锁定的互斥锁加锁时表现不同。当前（glibc2.2.3,linuxthreads0.9）有四个值可供选择：</p>
<ul>
<li><p>PTHREAD_MUTEX_TIMED_NP，这是缺省值，也就是普通锁。当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后按优先级获得锁。这种锁策略保证了资源分配的公平性</p>
</li>
<li><p>PTHREAD_MUTEX_RECURSIVE_NP,嵌套锁，允许同一个线程对同一个锁成功获得多次，并通过多次unlock解锁。如果是不同线程请求，则在加锁线程解锁时重新竞争。</p>
</li>
<li><p>PTHREAD_MUTEX_ADAPTIVE_NP 适应锁，动作最简单的锁类型，仅等待解锁后重新竞争。线程旋转直到达到最大旋转计数或获得锁定为止<a href="https://stackoverflow.com/questions/19863734/what-is-pthread-mutex-adaptive-np">https://stackoverflow.com/questions/19863734/what-is-pthread-mutex-adaptive-np</a></p>
</li>
<li><p>PTHREAD_MUTEX_ERRORCHECK_NP 检错锁，如果同一个线程请求同一个锁，则返回EDEADLK，否则与PTHREAD_MUTEX_TIMED_NP类型动作相同。这样就保证当不允许多次加锁时不会出现最简单情况下的死锁。</p>
</li>
</ul>
<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><h3 id="pthread-cond-t"><a href="#pthread-cond-t" class="headerlink" title="pthread_cond_t"></a>pthread_cond_t</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Data structure for conditional variable handling.  The structure of</span></span><br><span class="line"><span class="comment">   the attribute type is deliberately not exposed.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">int</span> __lock;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> __futex;</span><br><span class="line">    __extension__ <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> __total_seq;</span><br><span class="line">    __extension__ <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> __wakeup_seq;</span><br><span class="line">    __extension__ <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> __woken_seq;</span><br><span class="line">    <span class="keyword">void</span> *__mutex;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> __nwaiters;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> __broadcast_seq;</span><br><span class="line">  &#125; __data;</span><br><span class="line">  <span class="keyword">char</span> __size[__SIZEOF_PTHREAD_COND_T];</span><br><span class="line">  __extension__ <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> __align;</span><br><span class="line">&#125; <span class="keyword">pthread_cond_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="PTHREAD-COND-INITIALIZER"><a href="#PTHREAD-COND-INITIALIZER" class="headerlink" title="PTHREAD_COND_INITIALIZER"></a>PTHREAD_COND_INITIALIZER</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Conditional variable handling.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTHREAD_COND_INITIALIZER &#123; &#123; 0, 0, 0, 0, 0, (void *) 0, 0, 0 &#125; &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>静态初始化</p>
<hr>
<h3 id="pthread-cond-init"><a href="#pthread-cond-init" class="headerlink" title="__pthread_cond_init"></a>__pthread_cond_init</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__pthread_cond_init (cond, cond_attr)</span><br><span class="line">     <span class="keyword">pthread_cond_t</span> *cond;</span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *cond_attr;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pthread_condattr</span> *<span class="title">icond_attr</span> =</span> (struct pthread_condattr *) cond_attr;</span><br><span class="line"></span><br><span class="line">  cond-&gt;__data.__lock = LLL_LOCK_INITIALIZER;</span><br><span class="line">  cond-&gt;__data.__futex = <span class="number">0</span>;</span><br><span class="line">  cond-&gt;__data.__nwaiters = (icond_attr != <span class="literal">NULL</span></span><br><span class="line">			     ? ((icond_attr-&gt;value &gt;&gt; <span class="number">1</span>)</span><br><span class="line">				&amp; ((<span class="number">1</span> &lt;&lt; COND_NWAITERS_SHIFT) - <span class="number">1</span>))</span><br><span class="line">			     : CLOCK_REALTIME);</span><br><span class="line">  cond-&gt;__data.__total_seq = <span class="number">0</span>;</span><br><span class="line">  cond-&gt;__data.__wakeup_seq = <span class="number">0</span>;</span><br><span class="line">  cond-&gt;__data.__woken_seq = <span class="number">0</span>;</span><br><span class="line">  cond-&gt;__data.__mutex = (icond_attr == <span class="literal">NULL</span> || (icond_attr-&gt;value &amp; <span class="number">1</span>) == <span class="number">0</span></span><br><span class="line">			  ? <span class="literal">NULL</span> : (<span class="keyword">void</span> *) ~<span class="number">0l</span>);</span><br><span class="line">  cond-&gt;__data.__broadcast_seq = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  LIBC_PROBE (cond_init, <span class="number">2</span>, cond, cond_attr);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态初始化</p>
<hr>
<h3 id="pthread-cond-wait"><a href="#pthread-cond-wait" class="headerlink" title="__pthread_cond_wait"></a>__pthread_cond_wait</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__pthread_cond_wait (cond, mutex)</span><br><span class="line">     <span class="keyword">pthread_cond_t</span> *cond;</span><br><span class="line">     <span class="keyword">pthread_mutex_t</span> *mutex;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">pthread_cleanup_buffer</span> <span class="title">buffer</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">condvar_cleanup_buffer</span> <span class="title">cbuffer</span>;</span></span><br><span class="line">  <span class="keyword">int</span> err;</span><br><span class="line">  <span class="keyword">int</span> pshared = (cond-&gt;__data.__mutex == (<span class="keyword">void</span> *) ~<span class="number">0l</span>)</span><br><span class="line">		? LLL_SHARED : LLL_PRIVATE;</span><br><span class="line"></span><br><span class="line">  LIBC_PROBE (cond_wait, <span class="number">2</span>, cond, mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make sure we are alone.  */</span></span><br><span class="line">  lll_lock (cond-&gt;__data.__lock, pshared);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Now we can release the mutex.  */</span></span><br><span class="line">  err = __pthread_mutex_unlock_usercnt (mutex, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (err, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      lll_unlock (cond-&gt;__data.__lock, pshared);</span><br><span class="line">      <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We have one new user of the condvar.  */</span></span><br><span class="line">  ++cond-&gt;__data.__total_seq;</span><br><span class="line">  ++cond-&gt;__data.__futex;</span><br><span class="line">  cond-&gt;__data.__nwaiters += <span class="number">1</span> &lt;&lt; COND_NWAITERS_SHIFT;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Remember the mutex we are using here.  If there is already a</span></span><br><span class="line"><span class="comment">     different address store this is a bad user bug.  Do not store</span></span><br><span class="line"><span class="comment">     anything for pshared condvars.  */</span></span><br><span class="line">  <span class="keyword">if</span> (cond-&gt;__data.__mutex != (<span class="keyword">void</span> *) ~<span class="number">0l</span>)</span><br><span class="line">    cond-&gt;__data.__mutex = mutex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Prepare structure passed to cancellation handler.  */</span></span><br><span class="line">  cbuffer.cond = cond;</span><br><span class="line">  cbuffer.mutex = mutex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Before we block we enable cancellation.  Therefore we have to</span></span><br><span class="line"><span class="comment">     install a cancellation handler.  */</span></span><br><span class="line">  __pthread_cleanup_push (&amp;buffer, __condvar_cleanup, &amp;cbuffer);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The current values of the wakeup counter.  The &quot;woken&quot; counter</span></span><br><span class="line"><span class="comment">     must exceed this value.  */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> val;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> seq;</span><br><span class="line">  val = seq = cond-&gt;__data.__wakeup_seq;</span><br><span class="line">  <span class="comment">/* Remember the broadcast counter.  */</span></span><br><span class="line">  cbuffer.bc_seq = cond-&gt;__data.__broadcast_seq;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span> futex_val = cond-&gt;__data.__futex;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Prepare to wait.  Release the condvar futex.  */</span></span><br><span class="line">      lll_unlock (cond-&gt;__data.__lock, pshared);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Enable asynchronous cancellation.  Required by the standard.  */</span></span><br><span class="line">      cbuffer.oldtype = __pthread_enable_asynccancel ();</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Wait until woken by signal or broadcast.  */</span></span><br><span class="line">      lll_futex_wait (&amp;cond-&gt;__data.__futex, futex_val, pshared);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Disable asynchronous cancellation.  */</span></span><br><span class="line">      __pthread_disable_asynccancel (cbuffer.oldtype);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We are going to look at shared data again, so get the lock.  */</span></span><br><span class="line">      lll_lock (cond-&gt;__data.__lock, pshared);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* If a broadcast happened, we are done.  */</span></span><br><span class="line">      <span class="keyword">if</span> (cbuffer.bc_seq != cond-&gt;__data.__broadcast_seq)</span><br><span class="line">	<span class="keyword">goto</span> bc_out;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Check whether we are eligible for wakeup.  */</span></span><br><span class="line">      val = cond-&gt;__data.__wakeup_seq;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">while</span> (val == seq || cond-&gt;__data.__woken_seq == val);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Another thread woken up.  */</span></span><br><span class="line">  ++cond-&gt;__data.__woken_seq;</span><br><span class="line"></span><br><span class="line"> bc_out:</span><br><span class="line"></span><br><span class="line">  cond-&gt;__data.__nwaiters -= <span class="number">1</span> &lt;&lt; COND_NWAITERS_SHIFT;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If pthread_cond_destroy was called on this varaible already,</span></span><br><span class="line"><span class="comment">     notify the pthread_cond_destroy caller all waiters have left</span></span><br><span class="line"><span class="comment">     and it can be successfully destroyed.  */</span></span><br><span class="line">  <span class="keyword">if</span> (cond-&gt;__data.__total_seq == <span class="number">-1ULL</span></span><br><span class="line">      &amp;&amp; cond-&gt;__data.__nwaiters &lt; (<span class="number">1</span> &lt;&lt; COND_NWAITERS_SHIFT))</span><br><span class="line">    lll_futex_wake (&amp;cond-&gt;__data.__nwaiters, <span class="number">1</span>, pshared);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We are done with the condvar.  */</span></span><br><span class="line">  lll_unlock (cond-&gt;__data.__lock, pshared);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The cancellation handling is back to normal, remove the handler.  */</span></span><br><span class="line">  __pthread_cleanup_pop (&amp;buffer, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get the mutex before returning.  */</span></span><br><span class="line">  <span class="keyword">return</span> __pthread_mutex_cond_lock (mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>无条件等待pthread_cond_wait()，必须和一个互斥锁配合，以防止多个线程同时请求pthread_cond_wait()（或pthread_cond_timedwait()，下同）的竞争条件（Race Condition）。mutex互斥锁必须是普通锁（PTHREAD_MUTEX_TIMED_NP）或者适应锁（PTHREAD_MUTEX_ADAPTIVE_NP），且在调用pthread_cond_wait()前必须由本线程加锁（pthread_mutex_lock()），而在更新条件等待队列以前，mutex保持锁定状态，并在线程挂起进入等待前解锁。在条件满足从而离开pthread_cond_wait()之前，mutex将被重新加锁，以与进入pthread_cond_wait()前的加锁动作对应。</p>
<p>激发条件有两种形式，pthread_cond_signal()激活一个等待该条件的线程，存在多个等待线程时按入队顺序激活其中一个；而pthread_cond_broadcast()则激活所有等待线程。</p>
<hr>
<h3 id="pthread-cond-timedwait"><a href="#pthread-cond-timedwait" class="headerlink" title="__pthread_cond_timedwait"></a>__pthread_cond_timedwait</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__pthread_cond_timedwait (cond, mutex, abstime)</span><br><span class="line">     <span class="keyword">pthread_cond_t</span> *cond;</span><br><span class="line">     <span class="keyword">pthread_mutex_t</span> *mutex;</span><br><span class="line">     <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> *<span class="title">abstime</span>;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">pthread_cleanup_buffer</span> <span class="title">buffer</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">condvar_cleanup_buffer</span> <span class="title">cbuffer</span>;</span></span><br><span class="line">  <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Catch invalid parameters.  */</span></span><br><span class="line">  <span class="keyword">if</span> (abstime-&gt;tv_nsec &lt; <span class="number">0</span> || abstime-&gt;tv_nsec &gt;= <span class="number">1000000000</span>)</span><br><span class="line">    <span class="keyword">return</span> EINVAL;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> pshared = (cond-&gt;__data.__mutex == (<span class="keyword">void</span> *) ~<span class="number">0l</span>)</span><br><span class="line">		? LLL_SHARED : LLL_PRIVATE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make sure we are alone.  */</span></span><br><span class="line">  lll_lock (cond-&gt;__data.__lock, pshared);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Now we can release the mutex.  */</span></span><br><span class="line">  <span class="keyword">int</span> err = __pthread_mutex_unlock_usercnt (mutex, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    &#123;</span><br><span class="line">      lll_unlock (cond-&gt;__data.__lock, pshared);</span><br><span class="line">      <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We have one new user of the condvar.  */</span></span><br><span class="line">  ++cond-&gt;__data.__total_seq;</span><br><span class="line">  ++cond-&gt;__data.__futex;</span><br><span class="line">  cond-&gt;__data.__nwaiters += <span class="number">1</span> &lt;&lt; COND_NWAITERS_SHIFT;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Work around the fact that the kernel rejects negative timeout values</span></span><br><span class="line"><span class="comment">     despite them being valid.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (abstime-&gt;tv_sec &lt; <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">goto</span> timeout;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Remember the mutex we are using here.  If there is already a</span></span><br><span class="line"><span class="comment">     different address store this is a bad user bug.  Do not store</span></span><br><span class="line"><span class="comment">     anything for pshared condvars.  */</span></span><br><span class="line">  <span class="keyword">if</span> (cond-&gt;__data.__mutex != (<span class="keyword">void</span> *) ~<span class="number">0l</span>)</span><br><span class="line">    cond-&gt;__data.__mutex = mutex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Prepare structure passed to cancellation handler.  */</span></span><br><span class="line">  cbuffer.cond = cond;</span><br><span class="line">  cbuffer.mutex = mutex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Before we block we enable cancellation.  Therefore we have to</span></span><br><span class="line"><span class="comment">     install a cancellation handler.  */</span></span><br><span class="line">  __pthread_cleanup_push (&amp;buffer, __condvar_cleanup, &amp;cbuffer);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The current values of the wakeup counter.  The &quot;woken&quot; counter</span></span><br><span class="line"><span class="comment">     must exceed this value.  */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> val;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> seq;</span><br><span class="line">  val = seq = cond-&gt;__data.__wakeup_seq;</span><br><span class="line">  <span class="comment">/* Remember the broadcast counter.  */</span></span><br><span class="line">  cbuffer.bc_seq = cond-&gt;__data.__broadcast_seq;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (!defined __ASSUME_FUTEX_CLOCK_REALTIME \</span></span><br><span class="line">     || !defined lll_futex_timed_wait_bitset)</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">rt</span>;</span></span><br><span class="line">      &#123;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __NR_clock_gettime</span></span><br><span class="line">	INTERNAL_SYSCALL_DECL (err);</span><br><span class="line">	(<span class="keyword">void</span>) INTERNAL_VSYSCALL (clock_gettime, err, <span class="number">2</span>,</span><br><span class="line">				  (cond-&gt;__data.__nwaiters</span><br><span class="line">				   &amp; ((<span class="number">1</span> &lt;&lt; COND_NWAITERS_SHIFT) - <span class="number">1</span>)),</span><br><span class="line">				  &amp;rt);</span><br><span class="line">	<span class="comment">/* Convert the absolute timeout value to a relative timeout.  */</span></span><br><span class="line">	rt.tv_sec = abstime-&gt;tv_sec - rt.tv_sec;</span><br><span class="line">	rt.tv_nsec = abstime-&gt;tv_nsec - rt.tv_nsec;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="comment">/* Get the current time.  So far we support only one clock.  */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">	(<span class="keyword">void</span>) gettimeofday (&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Convert the absolute timeout value to a relative timeout.  */</span></span><br><span class="line">	rt.tv_sec = abstime-&gt;tv_sec - tv.tv_sec;</span><br><span class="line">	rt.tv_nsec = abstime-&gt;tv_nsec - tv.tv_usec * <span class="number">1000</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (rt.tv_nsec &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  rt.tv_nsec += <span class="number">1000000000</span>;</span><br><span class="line">	  --rt.tv_sec;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="comment">/* Did we already time out?  */</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (rt.tv_sec &lt; <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">if</span> (cbuffer.bc_seq != cond-&gt;__data.__broadcast_seq)</span><br><span class="line">	    <span class="keyword">goto</span> bc_out;</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">goto</span> timeout;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span> futex_val = cond-&gt;__data.__futex;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Prepare to wait.  Release the condvar futex.  */</span></span><br><span class="line">      lll_unlock (cond-&gt;__data.__lock, pshared);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Enable asynchronous cancellation.  Required by the standard.  */</span></span><br><span class="line">      cbuffer.oldtype = __pthread_enable_asynccancel ();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (!defined __ASSUME_FUTEX_CLOCK_REALTIME \</span></span><br><span class="line">     || !defined lll_futex_timed_wait_bitset)</span><br><span class="line">      <span class="comment">/* Wait until woken by signal or broadcast.  */</span></span><br><span class="line">      err = lll_futex_timed_wait (&amp;cond-&gt;__data.__futex,</span><br><span class="line">				  futex_val, &amp;rt, pshared);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span> clockbit = (cond-&gt;__data.__nwaiters &amp; <span class="number">1</span></span><br><span class="line">			       ? <span class="number">0</span> : FUTEX_CLOCK_REALTIME);</span><br><span class="line">      err = lll_futex_timed_wait_bitset (&amp;cond-&gt;__data.__futex, futex_val,</span><br><span class="line">					 abstime, clockbit, pshared);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Disable asynchronous cancellation.  */</span></span><br><span class="line">      __pthread_disable_asynccancel (cbuffer.oldtype);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We are going to look at shared data again, so get the lock.  */</span></span><br><span class="line">      lll_lock (cond-&gt;__data.__lock, pshared);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* If a broadcast happened, we are done.  */</span></span><br><span class="line">      <span class="keyword">if</span> (cbuffer.bc_seq != cond-&gt;__data.__broadcast_seq)</span><br><span class="line">	<span class="keyword">goto</span> bc_out;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Check whether we are eligible for wakeup.  */</span></span><br><span class="line">      val = cond-&gt;__data.__wakeup_seq;</span><br><span class="line">      <span class="keyword">if</span> (val != seq &amp;&amp; cond-&gt;__data.__woken_seq != val)</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Not woken yet.  Maybe the time expired?  */</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (err == -ETIMEDOUT, <span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line">	timeout:</span><br><span class="line">	  <span class="comment">/* Yep.  Adjust the counters.  */</span></span><br><span class="line">	  ++cond-&gt;__data.__wakeup_seq;</span><br><span class="line">	  ++cond-&gt;__data.__futex;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* The error value.  */</span></span><br><span class="line">	  result = ETIMEDOUT;</span><br><span class="line">	  <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Another thread woken up.  */</span></span><br><span class="line">  ++cond-&gt;__data.__woken_seq;</span><br><span class="line"></span><br><span class="line"> bc_out:</span><br><span class="line"></span><br><span class="line">  cond-&gt;__data.__nwaiters -= <span class="number">1</span> &lt;&lt; COND_NWAITERS_SHIFT;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If pthread_cond_destroy was called on this variable already,</span></span><br><span class="line"><span class="comment">     notify the pthread_cond_destroy caller all waiters have left</span></span><br><span class="line"><span class="comment">     and it can be successfully destroyed.  */</span></span><br><span class="line">  <span class="keyword">if</span> (cond-&gt;__data.__total_seq == <span class="number">-1ULL</span></span><br><span class="line">      &amp;&amp; cond-&gt;__data.__nwaiters &lt; (<span class="number">1</span> &lt;&lt; COND_NWAITERS_SHIFT))</span><br><span class="line">    lll_futex_wake (&amp;cond-&gt;__data.__nwaiters, <span class="number">1</span>, pshared);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We are done with the condvar.  */</span></span><br><span class="line">  lll_unlock (cond-&gt;__data.__lock, pshared);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The cancellation handling is back to normal, remove the handler.  */</span></span><br><span class="line">  __pthread_cleanup_pop (&amp;buffer, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get the mutex before returning.  */</span></span><br><span class="line">  err = __pthread_mutex_cond_lock (mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> err ?: result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>超时等待__pthread_cond_timedwait()，必须和一个互斥锁配合，以防止多个线程同时请求pthread_cond_wait()（或pthread_cond_timedwait()，下同）的竞争条件（Race Condition）。mutex互斥锁必须是普通锁（PTHREAD_MUTEX_TIMED_NP）或者适应锁（PTHREAD_MUTEX_ADAPTIVE_NP），且在调用pthread_cond_wait()前必须由本线程加锁（pthread_mutex_lock()），而在更新条件等待队列以前，mutex保持锁定状态，并在线程挂起进入等待前解锁。在条件满足从而离开pthread_cond_wait()之前，mutex将被重新加锁，以与进入pthread_cond_wait()前的加锁动作对应。</p>
<p>激发条件有两种形式，pthread_cond_signal()激活一个等待该条件的线程，存在多个等待线程时按入队顺序激活其中一个；而pthread_cond_broadcast()则激活所有等待线程。</p>
<hr>
<h3 id="pthread-cond-signal"><a href="#pthread-cond-signal" class="headerlink" title="__pthread_cond_signal"></a>__pthread_cond_signal</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__pthread_cond_signal (cond)</span><br><span class="line">     <span class="keyword">pthread_cond_t</span> *cond;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> pshared = (cond-&gt;__data.__mutex == (<span class="keyword">void</span> *) ~<span class="number">0l</span>)</span><br><span class="line">		? LLL_SHARED : LLL_PRIVATE;</span><br><span class="line"></span><br><span class="line">  LIBC_PROBE (cond_signal, <span class="number">1</span>, cond);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make sure we are alone.  */</span></span><br><span class="line">  lll_lock (cond-&gt;__data.__lock, pshared);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Are there any waiters to be woken?  */</span></span><br><span class="line">  <span class="keyword">if</span> (cond-&gt;__data.__total_seq &gt; cond-&gt;__data.__wakeup_seq)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Yes.  Mark one of them as woken.  */</span></span><br><span class="line">      ++cond-&gt;__data.__wakeup_seq;</span><br><span class="line">      ++cond-&gt;__data.__futex;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Wake one.  */</span></span><br><span class="line">      <span class="keyword">if</span> (! __builtin_expect (lll_futex_wake_unlock (&amp;cond-&gt;__data.__futex, <span class="number">1</span>,</span><br><span class="line">						     <span class="number">1</span>, &amp;cond-&gt;__data.__lock,</span><br><span class="line">						     pshared), <span class="number">0</span>))</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      lll_futex_wake (&amp;cond-&gt;__data.__futex, <span class="number">1</span>, pshared);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We are done.  */</span></span><br><span class="line">  lll_unlock (cond-&gt;__data.__lock, pshared);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>唤醒单个线程lll_futex_wake (&amp;cond-&gt;__data.__futex, 1, pshared);</p>
<hr>
<h3 id="pthread-cond-broadcast"><a href="#pthread-cond-broadcast" class="headerlink" title="__pthread_cond_broadcast"></a>__pthread_cond_broadcast</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__pthread_cond_broadcast (cond)</span><br><span class="line">     <span class="keyword">pthread_cond_t</span> *cond;</span><br><span class="line">&#123;</span><br><span class="line">  LIBC_PROBE (cond_broadcast, <span class="number">1</span>, cond);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> pshared = (cond-&gt;__data.__mutex == (<span class="keyword">void</span> *) ~<span class="number">0l</span>)</span><br><span class="line">		? LLL_SHARED : LLL_PRIVATE;</span><br><span class="line">  <span class="comment">/* Make sure we are alone.  */</span></span><br><span class="line">  lll_lock (cond-&gt;__data.__lock, pshared);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Are there any waiters to be woken?  */</span></span><br><span class="line">  <span class="keyword">if</span> (cond-&gt;__data.__total_seq &gt; cond-&gt;__data.__wakeup_seq)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Yes.  Mark them all as woken.  */</span></span><br><span class="line">      cond-&gt;__data.__wakeup_seq = cond-&gt;__data.__total_seq;</span><br><span class="line">      cond-&gt;__data.__woken_seq = cond-&gt;__data.__total_seq;</span><br><span class="line">      cond-&gt;__data.__futex = (<span class="keyword">unsigned</span> <span class="keyword">int</span>) cond-&gt;__data.__total_seq * <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">int</span> futex_val = cond-&gt;__data.__futex;</span><br><span class="line">      <span class="comment">/* Signal that a broadcast happened.  */</span></span><br><span class="line">      ++cond-&gt;__data.__broadcast_seq;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We are done.  */</span></span><br><span class="line">      lll_unlock (cond-&gt;__data.__lock, pshared);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Do not use requeue for pshared condvars.  */</span></span><br><span class="line">      <span class="keyword">if</span> (cond-&gt;__data.__mutex == (<span class="keyword">void</span> *) ~<span class="number">0l</span>)</span><br><span class="line">	<span class="keyword">goto</span> wake_all;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Wake everybody.  */</span></span><br><span class="line">      <span class="keyword">pthread_mutex_t</span> *mut = (<span class="keyword">pthread_mutex_t</span> *) cond-&gt;__data.__mutex;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* <span class="doctag">XXX:</span> Kernel so far doesn&#x27;t support requeue to PI futex.  */</span></span><br><span class="line">      <span class="comment">/* <span class="doctag">XXX:</span> Kernel so far can only requeue to the same type of futex,</span></span><br><span class="line"><span class="comment">	 in this case private (we don&#x27;t requeue for pshared condvars).  */</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (mut-&gt;__data.__kind</span><br><span class="line">			    &amp; (PTHREAD_MUTEX_PRIO_INHERIT_NP</span><br><span class="line">			       | PTHREAD_MUTEX_PSHARED_BIT), <span class="number">0</span>))</span><br><span class="line">	<span class="keyword">goto</span> wake_all;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* lll_futex_requeue returns 0 for success and non-zero</span></span><br><span class="line"><span class="comment">	 for errors.  */</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (lll_futex_requeue (&amp;cond-&gt;__data.__futex, <span class="number">1</span>,</span><br><span class="line">					       INT_MAX, &amp;mut-&gt;__data.__lock,</span><br><span class="line">					       futex_val, LLL_PRIVATE), <span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* The requeue functionality is not available.  */</span></span><br><span class="line">	wake_all:</span><br><span class="line">	<span class="comment">//INT_MAX 唤醒所有等待的线程</span></span><br><span class="line">	  lll_futex_wake (&amp;cond-&gt;__data.__futex, INT_MAX, pshared);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* That&#x27;s all.  */</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We are done.  */</span></span><br><span class="line">  lll_unlock (cond-&gt;__data.__lock, pshared);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>唤醒所有等待的线程lll_futex_wake (&amp;cond-&gt;__data.__futex, INT_MAX, pshared);</p>
<hr>
<h3 id="pthread-cond-destroy"><a href="#pthread-cond-destroy" class="headerlink" title="pthread_cond_destroy"></a>pthread_cond_destroy</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__pthread_cond_destroy (cond)</span><br><span class="line">     <span class="keyword">pthread_cond_t</span> *cond;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> pshared = (cond-&gt;__data.__mutex == (<span class="keyword">void</span> *) ~<span class="number">0l</span>)</span><br><span class="line">		? LLL_SHARED : LLL_PRIVATE;</span><br><span class="line"></span><br><span class="line">  LIBC_PROBE (cond_destroy, <span class="number">1</span>, cond);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make sure we are alone.  */</span></span><br><span class="line">  lll_lock (cond-&gt;__data.__lock, pshared);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cond-&gt;__data.__total_seq &gt; cond-&gt;__data.__wakeup_seq)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* If there are still some waiters which have not been</span></span><br><span class="line"><span class="comment">	 woken up, this is an application bug.  */</span></span><br><span class="line">      lll_unlock (cond-&gt;__data.__lock, pshared);</span><br><span class="line">      <span class="keyword">return</span> EBUSY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Tell pthread_cond_*wait that this condvar is being destroyed.  */</span></span><br><span class="line">  cond-&gt;__data.__total_seq = <span class="number">-1ULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If there are waiters which have been already signalled or</span></span><br><span class="line"><span class="comment">     broadcasted, but still are using the pthread_cond_t structure,</span></span><br><span class="line"><span class="comment">     pthread_cond_destroy needs to wait for them.  */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> nwaiters = cond-&gt;__data.__nwaiters;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nwaiters &gt;= (<span class="number">1</span> &lt;&lt; COND_NWAITERS_SHIFT))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Wake everybody on the associated mutex in case there are</span></span><br><span class="line"><span class="comment">	 threads that have been requeued to it.</span></span><br><span class="line"><span class="comment">	 Without this, pthread_cond_destroy could block potentially</span></span><br><span class="line"><span class="comment">	 for a long time or forever, as it would depend on other</span></span><br><span class="line"><span class="comment">	 thread&#x27;s using the mutex.</span></span><br><span class="line"><span class="comment">	 When all threads waiting on the mutex are woken up, pthread_cond_wait</span></span><br><span class="line"><span class="comment">	 only waits for threads to acquire and release the internal</span></span><br><span class="line"><span class="comment">	 condvar lock.  */</span></span><br><span class="line">      <span class="keyword">if</span> (cond-&gt;__data.__mutex != <span class="literal">NULL</span></span><br><span class="line">	  &amp;&amp; cond-&gt;__data.__mutex != (<span class="keyword">void</span> *) ~<span class="number">0l</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">pthread_mutex_t</span> *mut = (<span class="keyword">pthread_mutex_t</span> *) cond-&gt;__data.__mutex;</span><br><span class="line">	  lll_futex_wake (&amp;mut-&gt;__data.__lock, INT_MAX,</span><br><span class="line">			  PTHREAD_MUTEX_PSHARED (mut));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">	  lll_unlock (cond-&gt;__data.__lock, pshared);</span><br><span class="line"></span><br><span class="line">	  lll_futex_wait (&amp;cond-&gt;__data.__nwaiters, nwaiters, pshared);</span><br><span class="line"></span><br><span class="line">	  lll_lock (cond-&gt;__data.__lock, pshared);</span><br><span class="line"></span><br><span class="line">	  nwaiters = cond-&gt;__data.__nwaiters;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">while</span> (nwaiters &gt;= (<span class="number">1</span> &lt;&lt; COND_NWAITERS_SHIFT));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在释放或废弃条件变量之前，需要毁坏它</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>pthread_cleanup_push和pthread_cleanup_pop作为线程取消的回调函数，在wait函数中执行，防止线程退出导致的锁未释放，进而出现死锁的情况</li>
<li>条件变量机制不是异步信号安全的，也就是说，在信号处理函数中调用pthread_cond_signal()或者pthread_cond_broadcast()很可能引起死锁。</li>
<li>wait函数先解锁，然后加入睡眠列表，没有忙轮询的消耗，被其他线程”唤醒”后重新加锁</li>
<li>wait函数执行前当前线程必须已经对mutex加锁，并且锁的类型是普通锁或者适应锁</li>
</ul>
<hr>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/04/05/L9yTWmxYrC3JgiN.jpg" alt="80413347_p0_master1200.jpg"></p>
]]></content>
      <tags>
        <tag>ipc</tag>
      </tags>
  </entry>
  <entry>
    <title>c++内存模型</title>
    <url>/2020-07-27-c++%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://baiy.cn/doc/cpp/inside_rtti.htm">http://baiy.cn/doc/cpp/inside_rtti.htm</a></p>
<p><a href="https://stackoverflow.com/questions/6258559/what-is-the-vtt-for-a-class">https://stackoverflow.com/questions/6258559/what-is-the-vtt-for-a-class</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/41309205">https://zhuanlan.zhihu.com/p/41309205</a></p>
<p><a href="%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B">深度探索C++对象模型</a></p>
<p><a href="https://stackoverflow.com/questions/6613870/gnu-gcc-g-why-does-it-generate-multiple-dtors">https://stackoverflow.com/questions/6613870/gnu-gcc-g-why-does-it-generate-multiple-dtors</a></p>
<a id="more"></a>

<h2 id="虚函数和虚基类"><a href="#虚函数和虚基类" class="headerlink" title="虚函数和虚基类"></a>虚函数和虚基类</h2><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>():<span class="built_in">a</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;cout &lt;&lt; <span class="string">&quot;A&quot;</span> &lt;&lt; endl;&#125;;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">v</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>():<span class="built_in">b</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;cout &lt;&lt; <span class="string">&quot;B&quot;</span> &lt;&lt; endl;&#125;;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">w</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>():<span class="built_in">c</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;cout &lt;&lt; <span class="string">&quot;C&quot;</span> &lt;&lt; endl;&#125;;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">x</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">D</span>():<span class="built_in">d</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;cout &lt;&lt; <span class="string">&quot;D&quot;</span> &lt;&lt; endl;&#125;;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">y</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    D dd;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h3><p>虚基类：单独sizeof</p>
<pre><code>A   16  //vptr_a inta 8+8=16
B   32  //vptr_b intb vptr_a inta 8*4=32
C   32  //vptr_c intc vptr_a inta 8*4=32
D   48  //vptr_b intb vptr_c (intc intd) vptr_a inta 8*6=48

  |  vtable  |
  +----------+
  |     b    |
  +----------+
  |  vtable  |
  +----------+
  |     c    |
  +----------+
  |     d    |
  +----------+
  |  vtable  |
  +----------+
  |     a    |
  +----------+</code></pre>
<p>非虚基类： 单独sizeof</p>
<pre><code>A   16  //vptr_a inta 8+8=16
B   16  //vptr_a (inta intb)    8*2=16
A   
C   16  //vptr_a (inta intc)    8*2=16
D   40  //vptr_a (inta inb) vptr_a (inta intc) intd 8*5=40

  |  vtable  |
  +----------+
  |     a    |
  +----------+
  |     b    |
  +----------+
  |  vtable  |
  +----------+
  |     a    |
  +----------+
  |     c    |
  +----------+
  |     d    |
  +----------+</code></pre>
<h3 id="fdump-class-hierarchy"><a href="#fdump-class-hierarchy" class="headerlink" title="-fdump-class-hierarchy"></a>-fdump-class-hierarchy</h3><pre><code>Vtable for A
A::_ZTV1A: 3u entries
0     (int (*)(...))0
8     (int (*)(...))(&amp; _ZTI1A)
16    (int (*)(...))A::v

Class A
size=16 align=8
base size=12 base align=8
A (0x0x7f0f37c70b40) 0
    vptr=((&amp; A::_ZTV1A) + 16u)

Vtable for B
B::_ZTV1B: 8u entries
0     16u
8     (int (*)(...))0
16    (int (*)(...))(&amp; _ZTI1B)
24    (int (*)(...))B::w
32    0u
40    (int (*)(...))-16
48    (int (*)(...))(&amp; _ZTI1B)
56    (int (*)(...))A::v

VTT for B
B::_ZTT1B: 2u entries
0     ((&amp; B::_ZTV1B) + 24u)
8     ((&amp; B::_ZTV1B) + 56u)

Class B
size=32 align=8
base size=12 base align=8
B (0x0x7f0f37cab5b0) 0
    vptridx=0u vptr=((&amp; B::_ZTV1B) + 24u)
A (0x0x7f0f37c70ba0) 16 virtual
    vptridx=8u vbaseoffset=-24 vptr=((&amp; B::_ZTV1B) + 56u)

Vtable for C
C::_ZTV1C: 8u entries
0     16u
8     (int (*)(...))0
16    (int (*)(...))(&amp; _ZTI1C)
24    (int (*)(...))C::x
32    0u
40    (int (*)(...))-16
48    (int (*)(...))(&amp; _ZTI1C)
56    (int (*)(...))A::v

VTT for C
C::_ZTT1C: 2u entries
0     ((&amp; C::_ZTV1C) + 24u)
8     ((&amp; C::_ZTV1C) + 56u)

Class C
size=32 align=8
base size=12 base align=8
C (0x0x7f0f37cab9c0) 0
    vptridx=0u vptr=((&amp; C::_ZTV1C) + 24u)
A (0x0x7f0f37c70c00) 16 virtual
    vptridx=8u vbaseoffset=-24 vptr=((&amp; C::_ZTV1C) + 56u)

Vtable for D
D::_ZTV1D: 13u entries
0     32u
8     (int (*)(...))0
16    (int (*)(...))(&amp; _ZTI1D)
24    (int (*)(...))B::w
32    (int (*)(...))D::y
40    16u
48    (int (*)(...))-16
56    (int (*)(...))(&amp; _ZTI1D)
64    (int (*)(...))C::x
72    0u
80    (int (*)(...))-32
88    (int (*)(...))(&amp; _ZTI1D)
96    (int (*)(...))A::v

Construction vtable for B (0x0x7f0f37cabdd0 instance) in D
D::_ZTC1D0_1B: 8u entries
0     32u
8     (int (*)(...))0
16    (int (*)(...))(&amp; _ZTI1B)
24    (int (*)(...))B::w
32    0u
40    (int (*)(...))-32
48    (int (*)(...))(&amp; _ZTI1B)
56    (int (*)(...))A::v

Construction vtable for C (0x0x7f0f37cabe38 instance) in D
D::_ZTC1D16_1C: 8u entries
0     16u
8     (int (*)(...))0
16    (int (*)(...))(&amp; _ZTI1C)
24    (int (*)(...))C::x
32    0u
40    (int (*)(...))-16
48    (int (*)(...))(&amp; _ZTI1C)
56    (int (*)(...))A::v

VTT for D
D::_ZTT1D: 7u entries
0     ((&amp; D::_ZTV1D) + 24u)
8     ((&amp; D::_ZTC1D0_1B) + 24u)
16    ((&amp; D::_ZTC1D0_1B) + 56u)
24    ((&amp; D::_ZTC1D16_1C) + 24u)
32    ((&amp; D::_ZTC1D16_1C) + 56u)
40    ((&amp; D::_ZTV1D) + 96u)
48    ((&amp; D::_ZTV1D) + 64u)

Class D
size=48 align=8
base size=32 base align=8
D (0x0x7f0f37a82a80) 0
    vptridx=0u vptr=((&amp; D::_ZTV1D) + 24u)
B (0x0x7f0f37cabdd0) 0
    primary-for D (0x0x7f0f37a82a80)
    subvttidx=8u
    A (0x0x7f0f37c70c60) 32 virtual
        vptridx=40u vbaseoffset=-24 vptr=((&amp; D::_ZTV1D) + 96u)
C (0x0x7f0f37cabe38) 16
    subvttidx=24u vptridx=48u vptr=((&amp; D::_ZTV1D) + 64u)
    A (0x0x7f0f37c70c60) alternative-path</code></pre>
<p>这个结果挺乱的，不好分析，命令记住就行</p>
<h3 id="子类对象完整性"><a href="#子类对象完整性" class="headerlink" title="子类对象完整性"></a>子类对象完整性</h3><p>子类对象data member并没有和派生类对象data member放在一起，中间有对其的字节填充。这样是为了保持派生类中子类对象的完整性</p>
<p><img src="https://i.loli.net/2020/07/28/z7WxYZkwNJALKEl.jpg" alt="2020072701.jpg"></p>
<p>如果不填充的话，BB拷贝给CC,会把CC的data member(c)给覆盖掉。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BB</span> :</span> AA&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CC</span> :</span> BB&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(CC) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">        <span class="number">8</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然而我的测试结果是填充在一起了，具体原因未知。</p>
<h3 id="指向数据成员的指针"><a href="#指向数据成员的指针" class="headerlink" title="指向数据成员的指针"></a>指向数据成员的指针</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> a2;</span><br><span class="line">    <span class="keyword">int</span> a3;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//D dd;</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(A) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(B) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> AA::*p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> AA::*a = &amp;AA::a;</span><br><span class="line">    <span class="keyword">int</span> AA::*b = &amp;AA::a2;</span><br><span class="line">    <span class="keyword">int</span> AA::*c = &amp;AA::a3;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;AA::a);     <span class="comment">//(nil)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;AA::a2);    <span class="comment">//0x4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;AA::a3);    <span class="comment">//0x8</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, p);     <span class="comment">//0xffffffffffffffff</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, a);    <span class="comment">//(nil)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, b);    <span class="comment">//0x4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, c);    <span class="comment">//0x8</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; (p == a) &lt;&lt; endl;   <span class="comment">//0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有的编译期给&amp;AA::a这样的成员变量偏移值结果+1,用于区分AA::*p.即区别：</p>
<ul>
<li>没有指向任何成员变量的指针</li>
<li>指向第一个成员变量的指针</li>
</ul>
<p>但是显然gcc没有这样做。但也可以区分。</p>
<h3 id="成员函数指针"><a href="#成员函数指针" class="headerlink" title="成员函数指针"></a>成员函数指针</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;yes\n&quot;</span>; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//def member function pointer</span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (AA::*pmf)();</span><br><span class="line">    pmf = &amp;AA::func;</span><br><span class="line"></span><br><span class="line">    AA a;</span><br><span class="line">    AA *pa;</span><br><span class="line"></span><br><span class="line">    (a.*pmf)();</span><br><span class="line">    (pa-&gt;*pmf)();</span><br><span class="line"></span><br><span class="line">    (*pmf)();   <span class="comment">//error: invalid use of unary ‘*’ on pointer to member (*pmf)();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="this指针的作用："><a href="#this指针的作用：" class="headerlink" title="this指针的作用："></a>this指针的作用：</h2><p>主要是找派生类对象的地址。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">base2 * pb = <span class="keyword">new</span> derived;</span><br><span class="line">pb-&gt;<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">类结构：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ~<span class="built_in">base1</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">vfunc</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base2</span>;</span></span><br><span class="line">&#123;</span><br><span class="line">    ~<span class="built_in">base2</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">vfunc2</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span>:</span> <span class="keyword">public</span> base, <span class="keyword">public</span> base2</span><br><span class="line">&#123;</span><br><span class="line">    ~<span class="built_in">derived</span>();</span><br><span class="line">    <span class="built_in">vfunc</span>()&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>new之后，pb = &amp;derived + sizeof(base1); //编译期由编译器决定<br>pb-&gt;func()在这里是调用的derived的func函数，但也可能调用base2的func函数。想想random的情况。所以这是运行期才能决定的。编译器在编译期并不能算出固定结果，所以编译器让他指向一个可变的地址,假如是： (*pb-&gt;vptr[4])(this + pb-&gt;vptr[2].offset)</p>
<pre><code>//derived--&gt;table
vptr_base1
0   rtti
1   base_offset 
2   top_offset      //0
3   ~derived()
4   func

vptr_base2
0   rtti
1   base_offset
2   top_offset      //-20 假定是-20
3   ~derived()
4   func

//base2--&gt;table
vptr
0   rtti
1   base_offset
2   top_offset      //0
3   ~base2()
4   func</code></pre>
<ul>
<li>如果pb = new base2,则top_offset=0，this指针就是base2的地址,detele &amp;base2</li>
<li>如果pb = new derived,则pb(this) = &amp;derived + sizeof(base1)(编译器计算)，(this + pb-&gt;vptr[2].offset)，指向的具体值运行期判断，这里就是offset = -20,得到derived的地址，delete &amp;derived</li>
</ul>
<p>总结：</p>
<p>派生类可以赋值给基类(upcast),是因为有一系列机制来保证，比如this指针偏移，base指针偏移，rtti,即整个vtable.</p>
<p>正是因为有这么多机制保证upcast转换可行，才导致base指针可能指向base对象也可能指向derived对象的不确定性，从而导致downcast的不可行，只能在运行期判断了。编译器在对象构造的时候已经确定了vptr和vtable,同样的this+offset指向的内存确实根据base指针指向的空间即vtable的不同来变化的。</p>
<p>下面的代码对于downcast也印证了this指针偏移在类型转换的时候，也是找对象首地址的:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;yes\n&quot;</span>; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BB</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CC</span>:</span> <span class="keyword">public</span> AA, <span class="keyword">public</span> BB&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;yes\n&quot;</span>; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//dynamic_cast只能用于指针和引用</span></span><br><span class="line">    AA *a = <span class="keyword">new</span> AA;</span><br><span class="line">    CC *c = <span class="keyword">dynamic_cast</span>&lt;CC*&gt;(a);</span><br><span class="line">    <span class="keyword">if</span> (c)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;true 1&quot;</span> &lt;&lt; endl;   <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    AA *b = <span class="keyword">new</span> CC;</span><br><span class="line">    CC *d = <span class="keyword">dynamic_cast</span>&lt;CC*&gt;(b);</span><br><span class="line">    <span class="keyword">if</span> (d)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;true 2&quot;</span> &lt;&lt; endl;   <span class="comment">//true</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>upcast是在编译期执行的，对象内存布局是确定的，只有在指针，引用的时候由于<code>不明确</code>导致的含义模糊才需要this指针。</p>
<h2 id="base指针的作用"><a href="#base指针的作用" class="headerlink" title="base指针的作用"></a>base指针的作用</h2><p>就是因为有虚基类才有了base指针：</p>
<p><img src="https://i.loli.net/2020/07/28/Z9U5qWNwRP8ucKx.jpg" alt="2020072702.jpg"></p>
<p>虚基类的地址在类的最下边，属于可变区域，编译器不能直接sizeof计算偏移值，所以引入了base指针偏移值来计算。不同于this指针是找对象的首地址，base指针是找对象的末尾子类地址的。仅此而已了。</p>
<h2 id="thrunk"><a href="#thrunk" class="headerlink" title="thrunk"></a>thrunk</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">  int a;</span><br><span class="line">  virtual void v();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">public:</span><br><span class="line">  int b;</span><br><span class="line">  virtual void w();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class C : public A, public B &#123;</span><br><span class="line">public:</span><br><span class="line">  int c;</span><br><span class="line">  void w();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">                           +-----------------------+</span><br><span class="line">                           |     0 (top_offset)    |</span><br><span class="line">                           +-----------------------+</span><br><span class="line">c --&gt; +----------+         | ptr to typeinfo for C |</span><br><span class="line">      |  vtable  |-------&gt; +-----------------------+</span><br><span class="line">      +----------+         |         A::v()        |</span><br><span class="line">      |     a    |         +-----------------------+</span><br><span class="line">      +----------+         |         C::w()        |</span><br><span class="line">      |  vtable  |---+     +-----------------------+</span><br><span class="line">      +----------+   |     |    -8 (top_offset)    |</span><br><span class="line">      |     b    |   |     +-----------------------+</span><br><span class="line">      +----------+   |     | ptr to typeinfo for C |</span><br><span class="line">      |     c    |   +---&gt; +-----------------------+</span><br><span class="line">      +----------+         |    thunk to C::w()    |</span><br><span class="line">                           +-----------------------+</span><br></pre></td></tr></table></figure>

<p>C重写了B的w函数，vptr_b和vptr_a都指向了一个w().thrunk的作用就是用trunk函数做一个转换，先偏移this指针，然后调用上面的C::w().</p>
<h2 id="VTT-virtual-table-tbale"><a href="#VTT-virtual-table-tbale" class="headerlink" title="VTT(virtual table tbale)"></a>VTT(virtual table tbale)</h2><p>避免二次消化，把原文贴上来，即使是英文，啃下来确实收益很大的：</p>
<p><a href="https://stackoverflow.com/questions/6258559/what-is-the-vtt-for-a-class">https://stackoverflow.com/questions/6258559/what-is-the-vtt-for-a-class</a></p>
<p>PART2:</p>
<p>Construction/Destruction in the Presence of Multiple Inheritance</p>
<p>How is the above object constructed in memory when the object itself is constructed? And how do we ensure that a partially-constructed object (and its vtable) are safe for constructors to operate on?</p>
<p>Fortunately, it’s all handled very carefully for us. Say we’re constructing a new object of type D (through, for example, new D). First, the memory for the object is allocated in the heap and a pointer returned. D’s constructor is invoked, but before doing any D-specific construction it call’s A’s constructor on the object (after adjusting the this pointer, of course!). A’s constructor fills in the A part of the D object as if it were an instance of A.</p>
<pre><code>d --&gt; +----------+
    |          |
    +----------+
    |          |
    +----------+
    |          |
    +----------+
    |          |       +-----------------------+
    +----------+       |     0 (top_offset)    |
    |          |       +-----------------------+
    +----------+       | ptr to typeinfo for A |
    |  vtable  |-----&gt; +-----------------------+
    +----------+       |         A::v()        |
    |    a     |       +-----------------------+
    +----------+</code></pre>
<p>Control is returned to D’s constructor, which invokes B’s constructor. (Pointer adjustment isn’t needed here.) When B’s constructor is done,the object looks like this:</p>
<pre><code>B-in-D
                        +-----------------------+
                        |   20 (vbase_offset)   |
                        +-----------------------+
                        |     0 (top_offset)    |
                        +-----------------------+
d --&gt; +----------+        | ptr to typeinfo for B |
    |  vtable  |------&gt; +-----------------------+
    +----------+        |         B::w()        |
    |    b     |        +-----------------------+
    +----------+        |    0 (vbase_offset)   |
    |          |        +-----------------------+
    +----------+        |   -20 (top_offset)    |
    |          |        +-----------------------+
    +----------+        | ptr to typeinfo for B |
    |          |   +--&gt; +-----------------------+
    +----------+   |    |         A::v()        |
    |  vtable  |---+    +-----------------------+
    +----------+
    |    a     |
    +----------+</code></pre>
<p>But wait… B’s constructor modified the A part of the object by changing it’s vtable pointer! How did it know to distinguish this kind of B-in-D from a B-in-something-else (or a standalone B for that matter)? Simple. The virtual table table told it to do this. This structure, abbreviated VTT, is a table of vtables used in construction. In our case, the VTT for D looks like this:</p>
<pre><code>B-in-D
                                            +-----------------------+
                                            |   20 (vbase_offset)   |
            VTT for D                          +-----------------------+
+-------------------+                          |     0 (top_offset)    |
|    vtable for D   |-------------+            +-----------------------+
+-------------------+             |            | ptr to typeinfo for B |
| vtable for B-in-D |-------------|----------&gt; +-----------------------+
+-------------------+             |            |         B::w()        |
| vtable for B-in-D |-------------|--------+   +-----------------------+
+-------------------+             |        |   |    0 (vbase_offset)   |
| vtable for C-in-D |-------------|-----+  |   +-----------------------+
+-------------------+             |     |  |   |   -20 (top_offset)    |
| vtable for C-in-D |-------------|--+  |  |   +-----------------------+
+-------------------+             |  |  |  |   | ptr to typeinfo for B |
|    vtable for D   |----------+  |  |  |  +-&gt; +-----------------------+
+-------------------+          |  |  |  |      |         A::v()        |
|    vtable for D   |-------+  |  |  |  |      +-----------------------+
+-------------------+       |  |  |  |  |
                            |  |  |  |  |                         C-in-D
                            |  |  |  |  |      +-----------------------+
                            |  |  |  |  |      |   12 (vbase_offset)   |
                            |  |  |  |  |      +-----------------------+
                            |  |  |  |  |      |     0 (top_offset)    |
                            |  |  |  |  |      +-----------------------+
                            |  |  |  |  |      | ptr to typeinfo for C |
                            |  |  |  |  +----&gt; +-----------------------+
                            |  |  |  |         |         C::x()        |
                            |  |  |  |         +-----------------------+
                            |  |  |  |         |    0 (vbase_offset)   |
                            |  |  |  |         +-----------------------+
                            |  |  |  |         |   -12 (top_offset)    |
                            |  |  |  |         +-----------------------+
                            |  |  |  |         | ptr to typeinfo for C |
                            |  |  |  +-------&gt; +-----------------------+
                            |  |  |            |         A::v()        |
                            |  |  |            +-----------------------+
                            |  |  |
                            |  |  |                                    D
                            |  |  |            +-----------------------+
                            |  |  |            |   20 (vbase_offset)   |
                            |  |  |            +-----------------------+
                            |  |  |            |     0 (top_offset)    |
                            |  |  |            +-----------------------+
                            |  |  |            | ptr to typeinfo for D |
                            |  |  +----------&gt; +-----------------------+
                            |  |               |         B::w()        |
                            |  |               +-----------------------+
                            |  |               |         D::y()        |
                            |  |               +-----------------------+
                            |  |               |   12 (vbase_offset)   |
                            |  |               +-----------------------+
                            |  |               |    -8 (top_offset)    |
                            |  |               +-----------------------+
                            |  |               | ptr to typeinfo for D |
                            +----------------&gt; +-----------------------+
                            |               |         C::x()        |
                            |               +-----------------------+
                            |               |    0 (vbase_offset)   |
                            |               +-----------------------+
                            |               |   -20 (top_offset)    |
                            |               +-----------------------+
                            |               | ptr to typeinfo for D |
                            +-------------&gt; +-----------------------+
                                            |         A::v()        |
                                            +-----------------------+</code></pre>
<p>D’s constructor passes a pointer into D’s VTT to B’s constructor (in this case, it passes in the address of the first B-in-D entry). And, indeed,the vtable that was used for the object layout above is a special vtable used just for the construction of B-in-D.</p>
<p>Control is returned to the D constructor, and it calls the C constructor(with a VTT address parameter pointing to the “C-in-D+12” entry). When C’s constructor is done with the object it looks like this:</p>
<pre><code>B-in-D
                                                        +-----------------------+
                                                        |   20 (vbase_offset)   |
                                                        +-----------------------+
                                                        |     0 (top_offset)    |
                                                        +-----------------------+
                                                        | ptr to typeinfo for B |
                    +---------------------------------&gt; +-----------------------+
                    |                                   |         B::w()        |
                    |                                   +-----------------------+
                    |                          C-in-D   |    0 (vbase_offset)   |
                    |       +-----------------------+   +-----------------------+
d --&gt; +----------+  |       |   12 (vbase_offset)   |   |   -20 (top_offset)    |
    |  vtable  |--+       +-----------------------+   +-----------------------+
    +----------+          |     0 (top_offset)    |   | ptr to typeinfo for B |
    |    b     |          +-----------------------+   +-----------------------+
    +----------+          | ptr to typeinfo for C |   |         A::v()        |
    |  vtable  |--------&gt; +-----------------------+   +-----------------------+
    +----------+          |         C::x()        |
    |    c     |          +-----------------------+
    +----------+          |    0 (vbase_offset)   |
    |          |          +-----------------------+
    +----------+          |   -12 (top_offset)    |
    |  vtable  |--+       +-----------------------+
    +----------+  |       | ptr to typeinfo for C |
    |    a     |  +-----&gt; +-----------------------+
    +----------+          |         A::v()        |
                            +-----------------------+</code></pre>
<p>As you see, C’s constructor again modified the embedded A’s vtable pointer.The embedded C and A objects are now using the special construction C-in-D vtable, and the embedded B object is using the special construction B-in-D vtable. Finally, D’s constructor finishes the job and we end up with the same diagram as before:</p>
<pre><code>                                +-----------------------+
                                |   20 (vbase_offset)   |
                                +-----------------------+
                                |     0 (top_offset)    |
                                +-----------------------+
                                | ptr to typeinfo for D |
                    +----------&gt; +-----------------------+
d --&gt; +----------+    |            |         B::w()        |
    |  vtable  |----+            +-----------------------+
    +----------+                 |         D::y()        |
    |     b    |                 +-----------------------+
    +----------+                 |   12 (vbase_offset)   |
    |  vtable  |---------+       +-----------------------+
    +----------+         |       |    -8 (top_offset)    |
    |     c    |         |       +-----------------------+
    +----------+         |       | ptr to typeinfo for D |
    |     d    |         +-----&gt; +-----------------------+
    +----------+                 |         C::x()        |
    |  vtable  |----+            +-----------------------+
    +----------+    |            |    0 (vbase_offset)   |
    |     a    |    |            +-----------------------+
    +----------+    |            |   -20 (top_offset)    |
                    |            +-----------------------+
                    |            | ptr to typeinfo for D |
                    +----------&gt; +-----------------------+
                                |         A::v()        |
                                +-----------------------+</code></pre>
<p>Destruction occurs in the same fashion but in reverse. D’s destructor is invoked. After the user’s destruction code runs, the destructor calls C’s destructor and directs it to use the relevant portion of D’s VTT. C’s destructor manipulates the vtable pointers in the same way it did during construction; that is, the relevant vtable pointers now point into the C-in-D construction vtable. Then it runs the user’s destruction code for C and returns control to D’s destructor, which next invokes B’s destructor with a reference into D’s VTT. B’s destructor sets up the relevant portions of the object to refer into the B-in-D construction vtable. It runs the user’s destruction code for B and returns control to D’s destructor, which finally invokes A’s destructor. A’s destructor changes the vtable for the A portion of the object to refer into the vtable for A. Finally, control returns to D’s destructor and destruction of the object is complete. The memory once used by the object is returned to the system.</p>
<p>简单总结：</p>
<p>普通的一个派生类，赋值给一个基类对象，直接偏移就行了，派生类中基类的部分可以直接给独立的基类来用。但是对于含有虚基类的派生类来说，由于虚基类的内存分布在最底下，和中间类(B,C)独立时的布局是不一样的。对于对象赋值的偏移可以根据base指针，但是构造函数构造vtable的时候应该构造哪种vtable?当构造函数构造B,C的时候应该使用B,C独立状态下的vtable还是B-in-D,C-in-D时候的vtable,就需要VTT来保存多个虚指针和虚表随机应变了。(普通情况下派生类一张表就够了，现在得3张表了，7个虚指针：2+2+3)</p>
<h2 id="in-charge-not-in-charge-in-charge-delete"><a href="#in-charge-not-in-charge-in-charge-delete" class="headerlink" title="in-charge not-in-charge in-charge-delete"></a>in-charge not-in-charge in-charge-delete</h2><p>续上面的文章：</p>
<p>Now, in fact, the story is somewhat more complicated. Have you ever seen those “in-charge” and “not-in-charge” constructor and destructor specifications in GCC-produced warning and error messages or in GCC-produced binaries? Well, the fact is that there can be two constructor implementations and up to three destructor implementations.</p>
<p>An “in-charge” (or complete object) constructor is one that constructs virtual bases, and a “not-in-charge” (or base object) constructor is one that does not. Consider our above example. If a B is constructed, its constructor needs to call A’s constructor to construct it. Similarly, C’s constructor needs to construct A. However, if B and C are constructed as part of a construction of a D, their constructors should not construct A, because A is a virtual base and D’s constructor will take care of constructing it exactly once for the instance of D. Consider the cases:</p>
<p>If you do a new A, A’s “in-charge” constructor is invoked to construct A. When you do a new B, B’s “in-charge” constructor is invoked. It will call the “not-in-charge” constructor for A.</p>
<p>new C is similar to new B.</p>
<p>A new D invokes D’s “in-charge” constructor. Wewalked through this example. D’s “in-charge” constructor calls the”not-in-charge” versions of A’s, B’s, and C’s constructors (in thatorder).</p>
<p>An “in-charge” destructor is the analogue of an “in-charge”constructor—it takes charge of destructing virtual bases. Similarly,a “not-in-charge” destructor is generated. But there’s a third one as well. An “in-charge deleting” destructor is one that deallocates the storage as well as destructing the object. So when is one called in preference to the other?</p>
<p>Well, there are two kinds of objects that can be destructed—those allocated on the stack, and those allocated in the heap. Consider this code (given our diamond hierarchy with virtual-inheritance from before):</p>
<p>D d;            // allocates a D on the stack and constructs it<br>D <em>pd = new D;  // allocates a D in the heap and constructs it<br>/</em> … */<br>delete pd;      // calls “in-charge deleting” destructor for D<br>return;         // calls “in-charge” destructor for stack-allocated D<br>We see that the actual delete operator isn’t invoked by the code doing the delete, but rather by the in-charge deleting destructor for the object being deleted. Why do it this way? Why not have the caller call the in-charge destructor, then delete the object? Then you’d have only two copies of destructor implementations instead of three…</p>
<p>Well, the compiler could do such a thing, but it would be morecomplicated for other reasons. Consider this code (assuming a virtual destructor,which you always use, right?…right?!?):</p>
<p>D *pd = new D;  // allocates a D in the heap and constructs it<br>    C <em>pc = d;      // we have a pointer-to-C that points to our heap-allocated D<br>    /</em> … */<br>    delete pc;      // call destructor thunk through vtable, but what about delete?<br>If you didn’t have an “in-charge deleting” variety of D’s destructor, then the delete operation would need to adjust the pointer just like the destructor thunk does. Remember, the C object is embedded in a D, and so our pointer-to-C above is adjusted to point into the middle of our D object.We can’t just delete this pointer, since it isn’t the pointer that was returned by malloc() when we constructed it.</p>
<p>So, if we didn’t have an in-charge deleting destructor, we’d have to have thunks to the delete operator (and represent them in our vtables), or something else similar.</p>
<p>Thunks, Virtual and Non-Virtual</p>
<p>This section not written yet.</p>
<p>Multiple Inheritance with Virtual Methods on One Side</p>
<p>Okay. One last exercise. What if we have a diamond inheritance hierarchy with virtual inheritance, as before, but only have virtual methods along one side of it? So:</p>
<p>class A {<br>public:<br>  int a;<br>};</p>
<p>class B : public virtual A {<br>public:<br>  int b;<br>  virtual void w();<br>};</p>
<p>class C : public virtual A {<br>public:<br>  int c;<br>};</p>
<p>class D : public B, public C {<br>public:<br>  int d;<br>  virtual void y();<br>};<br>In this case the object layout is the following:</p>
<pre><code>                                +-----------------------+
                                |   20 (vbase_offset)   |
                                +-----------------------+
                                |     0 (top_offset)    |
                                +-----------------------+
                                | ptr to typeinfo for D |
                    +----------&gt; +-----------------------+
d --&gt; +----------+    |            |         B::w()        |
    |  vtable  |----+            +-----------------------+
    +----------+                 |         D::y()        |
    |     b    |                 +-----------------------+
    +----------+                 |   12 (vbase_offset)   |
    |  vtable  |---------+       +-----------------------+
    +----------+         |       |    -8 (top_offset)    |
    |     c    |         |       +-----------------------+
    +----------+         |       | ptr to typeinfo for D |
    |     d    |         +-----&gt; +-----------------------+
    +----------+
    |     a    |
    +----------+</code></pre>
<p>So you can see the C subobject, which has no virtual methods, still has a vtable (albeit empty). Indeed, all instances of C have an empty vtable.</p>
<p>Thanks, Morgan Deters!!</p>
<p>再加上这个：</p>
<p><a href="https://stackoverflow.com/questions/6613870/gnu-gcc-g-why-does-it-generate-multiple-dtors">https://stackoverflow.com/questions/6613870/gnu-gcc-g-why-does-it-generate-multiple-dtors</a></p>
<p>First, the purposes of these functions are described in the Itanium C++ ABI; see definitions under “base object destructor”, “complete object destructor”, and “deleting destructor”. The mapping to mangled names is given in 5.1.4.</p>
<p>Basically:</p>
<ul>
<li>D2 is the “base object destructor”. It destroys the object itself, as well as data members and non-virtual base classes.</li>
<li>D1 is the “complete object destructor”. It additionally destroys virtual base classes.</li>
<li>D0 is the “deleting object destructor”. It does everything the complete object destructor does, plus it calls operator delete to actually free the memory.</li>
</ul>
<p>If you have no virtual base classes, D2 and D1 are identical; GCC will, on sufficient optimization levels, actually alias the symbols to the same code for both.</p>
<pre><code>in-charge == complete object dtor
not-in-charge == base object dtor
in-charge-delete == deleting object dtor</code></pre>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//-C或--demangle：将低级符号名解码(demangle)成用户级名字。</span></span><br><span class="line"><span class="comment">//这样可以使得C++函数名具有可读性。</span></span><br><span class="line">nm --demangle a.out</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000400b</span>7c T DerivedClass::~<span class="built_in">DerivedClass</span>()</span><br><span class="line"><span class="number">0000000000400b</span>04 T DerivedClass::~<span class="built_in">DerivedClass</span>()</span><br><span class="line"><span class="number">0000000000400b</span>04 T DerivedClass::~<span class="built_in">DerivedClass</span>()</span><br><span class="line"><span class="number">0000000000400</span><span class="function">ada T <span class="title">BaseClass::someMethod</span><span class="params">()</span></span></span><br><span class="line"><span class="function">0000000000400c72 W <span class="title">BaseClass::BaseClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function">0000000000400c72 W <span class="title">BaseClass::BaseClass</span><span class="params">()</span></span></span><br><span class="line">0000000000400ab0 T BaseClass::~BaseClass()</span><br><span class="line"><span class="number">0000000000400</span>ab0 T BaseClass::~<span class="built_in">BaseClass</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2>]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>stl-vector源码剖析</title>
    <url>/2020-03-09-stl-vector%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://read.pudn.com/downloads496/ebook/2065703/%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B.pdf">STL源码剖析.pdf</a></p>
<p><a href="https://github.com/tolerious/Programming_learning_resource/blob/master/C%2B%2B/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%88%E6%89%B9%E6%B3%A8%E7%89%88%EF%BC%89.pdf">STL源码剖析（批注版）.pdf</a></p>
<p><a href="http://www.cplusplus.com/reference/vector/vector/">cplusplus-vector</a></p>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><img src="https://i.loli.net/2020/03/09/ztCGkFS56hoeOLg.png" alt="vector.png"></p>
<h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3><pre><code>TODO</code></pre>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p><code>gcc-9.2.0 stl_vector.h</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">  <span class="comment">// .......................................................</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc = std::allocator&lt;_Tp&gt; &gt;</span><br><span class="line">    class vector : <span class="keyword">protected</span> _Vector_base&lt;_Tp, _Alloc&gt;</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">// .......................................................</span></span><br><span class="line">      <span class="keyword">typedef</span> _Vector_base&lt;_Tp, _Alloc&gt;			_Base;</span><br><span class="line">      <span class="keyword">typedef</span> <span class="keyword">typename</span> _Base::_Tp_alloc_type		_Tp_alloc_type;</span><br><span class="line">      <span class="keyword">typedef</span> __gnu_cxx::__alloc_traits&lt;_Tp_alloc_type&gt;	_Alloc_traits;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">typedef</span> _Tp					value_type;</span><br><span class="line">      <span class="keyword">typedef</span> <span class="keyword">typename</span> _Base::pointer			pointer;</span><br><span class="line">      <span class="keyword">typedef</span> <span class="keyword">typename</span> _Alloc_traits::const_pointer	const_pointer;</span><br><span class="line">      <span class="keyword">typedef</span> <span class="keyword">typename</span> _Alloc_traits::reference		reference;</span><br><span class="line">      <span class="keyword">typedef</span> <span class="keyword">typename</span> _Alloc_traits::const_reference	const_reference;</span><br><span class="line">      <span class="keyword">typedef</span> __gnu_cxx::__normal_iterator&lt;pointer, vector&gt; iterator;</span><br><span class="line">      <span class="keyword">typedef</span> __gnu_cxx::__normal_iterator&lt;const_pointer, vector&gt;</span><br><span class="line">      const_iterator;</span><br><span class="line">      <span class="keyword">typedef</span> std::reverse_iterator&lt;const_iterator&gt;	const_reverse_iterator;</span><br><span class="line">      <span class="keyword">typedef</span> std::reverse_iterator&lt;iterator&gt;		reverse_iterator;</span><br><span class="line">      <span class="keyword">typedef</span> <span class="keyword">size_t</span>					size_type;</span><br><span class="line">      <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>					difference_type;</span><br><span class="line">      <span class="keyword">typedef</span> _Alloc					allocator_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// C++11</span></span><br><span class="line">	<span class="comment">// .......................................................</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">using</span> _Base::_M_allocate;</span><br><span class="line">      <span class="keyword">using</span> _Base::_M_deallocate;</span><br><span class="line">      <span class="keyword">using</span> _Base::_M_impl;</span><br><span class="line">      <span class="keyword">using</span> _Base::_M_get_Tp_allocator;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="comment">// [23.2.4.1] construct/copy/destroy</span></span><br><span class="line">      <span class="comment">// (assign() and get_allocator() are also listed in this section)</span></span><br><span class="line">	  <span class="comment">//无参构造</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">      <span class="built_in">vector</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      <span class="built_in">vector</span>() &#123; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  @brief  Creates a %vector with no elements.</span></span><br><span class="line"><span class="comment">       *  @param  __a  An allocator object.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">explicit</span></span><br><span class="line">      <span class="built_in">vector</span>(<span class="keyword">const</span> allocator_type&amp; __a) _GLIBCXX_NOEXCEPT</span><br><span class="line">      : _Base(__a) &#123; &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">//有参构造，vector(n, m) n个元素，每个元素的值是m</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line"> 	  <span class="comment">// C++11</span></span><br><span class="line">	  <span class="comment">// .......................................................</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  @brief  Creates a %vector with copies of an exemplar element.</span></span><br><span class="line"><span class="comment">       *  @param  __n  The number of elements to initially create.</span></span><br><span class="line"><span class="comment">       *  @param  __value  An element to copy.</span></span><br><span class="line"><span class="comment">       *  @param  __a  An allocator.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">explicit</span></span><br><span class="line">      <span class="built_in">vector</span>(size_type __n, <span class="keyword">const</span> value_type&amp; __value = <span class="built_in">value_type</span>(),</span><br><span class="line">	     <span class="keyword">const</span> allocator_type&amp; __a = <span class="built_in">allocator_type</span>())</span><br><span class="line">      : _Base(_S_check_init_len(__n, __a), __a)</span><br><span class="line">      &#123; _M_fill_initialize(__n, __value); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	  <span class="comment">//拷贝构造</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  @brief  %Vector copy constructor.</span></span><br><span class="line"><span class="comment">       *  @param  __x  A %vector of identical element and allocator types.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       *  All the elements of @a __x are copied, but any unused capacity in</span></span><br><span class="line"><span class="comment">       *  @a __x  will not be copied</span></span><br><span class="line"><span class="comment">       *  (i.e. capacity() == size() in the new %vector).</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       *  The newly-created %vector uses a copy of the allocator object used</span></span><br><span class="line"><span class="comment">       *  by @a __x (unless the allocator traits dictate a different object).</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="built_in">vector</span>(<span class="keyword">const</span> vector&amp; __x)</span><br><span class="line">      : _Base(__x.<span class="built_in">size</span>(),</span><br><span class="line">	_Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;_M_impl._M_finish =</span><br><span class="line">	  std::__uninitialized_copy_a(__x.<span class="built_in">begin</span>(), __x.<span class="built_in">end</span>(),</span><br><span class="line">				      <span class="keyword">this</span>-&gt;_M_impl._M_start,</span><br><span class="line">				      _M_get_Tp_allocator());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">      <span class="comment">// C++11</span></span><br><span class="line">	  <span class="comment">// .......................................................</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	  <span class="comment">//接收范围参数的构造函数</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  @brief  Builds a %vector from a range.</span></span><br><span class="line"><span class="comment">       *  @param  __first  An input iterator.</span></span><br><span class="line"><span class="comment">       *  @param  __last  An input iterator.</span></span><br><span class="line"><span class="comment">       *  @param  __a  An allocator.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       *  Create a %vector consisting of copies of the elements from</span></span><br><span class="line"><span class="comment">       *  [first,last).</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       *  If the iterators are forward, bidirectional, or</span></span><br><span class="line"><span class="comment">       *  random-access, then this will call the elements&#x27; copy</span></span><br><span class="line"><span class="comment">       *  constructor N times (where N is distance(first,last)) and do</span></span><br><span class="line"><span class="comment">       *  no memory reallocation.  But if only input iterators are</span></span><br><span class="line"><span class="comment">       *  used, then this will do at most 2N calls to the copy</span></span><br><span class="line"><span class="comment">       *  constructor, and logN memory reallocations.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">     <span class="comment">// C++11</span></span><br><span class="line">	 <span class="comment">// .......................................................</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _InputIterator&gt;</span><br><span class="line">	<span class="built_in">vector</span>(_InputIterator __first, _InputIterator __last,</span><br><span class="line">	       <span class="keyword">const</span> allocator_type&amp; __a = <span class="built_in">allocator_type</span>())</span><br><span class="line">	: _Base(__a)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">// Check whether it&#x27;s an integral type.  If so, it&#x27;s not an iterator.</span></span><br><span class="line">	  <span class="keyword">typedef</span> <span class="keyword">typename</span> std::__is_integer&lt;_InputIterator&gt;::__type _Integral;</span><br><span class="line">	  _M_initialize_dispatch(__first, __last, _Integral());</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  The dtor only erases the elements, and note that if the</span></span><br><span class="line"><span class="comment">       *  elements themselves are pointers, the pointed-to memory is</span></span><br><span class="line"><span class="comment">       *  not touched in any way.  Managing the pointer is the user&#x27;s</span></span><br><span class="line"><span class="comment">       *  responsibility.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">	  <span class="comment">//_Destroy仅擦除元素，并请注意，如果元素本身是指针，则不会以任何方式访问指向的内存</span></span><br><span class="line">	  <span class="comment">//管理指针是用户的责任</span></span><br><span class="line">      ~<span class="built_in">vector</span>() _GLIBCXX_NOEXCEPT</span><br><span class="line">      &#123;</span><br><span class="line">	std::_Destroy(<span class="keyword">this</span>-&gt;_M_impl._M_start, <span class="keyword">this</span>-&gt;_M_impl._M_finish,</span><br><span class="line">		      _M_get_Tp_allocator());</span><br><span class="line">	_GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">//运算符重载，=</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  @brief  %Vector assignment operator.</span></span><br><span class="line"><span class="comment">       *  @param  __x  A %vector of identical element and allocator types.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       *  All the elements of @a __x are copied, but any unused capacity in</span></span><br><span class="line"><span class="comment">       *  @a __x will not be copied.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       *  Whether the allocator is copied depends on the allocator traits.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      vector&amp;</span><br><span class="line">      <span class="keyword">operator</span>=(<span class="keyword">const</span> vector&amp; __x);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">      <span class="comment">// C++11</span></span><br><span class="line">	  <span class="comment">// .......................................................</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	  <span class="comment">//assign函数，具体见下文</span></span><br><span class="line">	  <span class="comment">//给vector分配__n个元素，每个元素的值为__val</span></span><br><span class="line">      <span class="keyword">void</span></span><br><span class="line">      <span class="built_in">assign</span>(size_type __n, <span class="keyword">const</span> value_type&amp; __val)</span><br><span class="line">      &#123; _M_fill_assign(__n, __val); &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">//把模板类型的__first到__last范围的值复制给vector</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">      <span class="comment">// C++11</span></span><br><span class="line">	  <span class="comment">// .......................................................</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _InputIterator&gt;</span><br><span class="line">	<span class="keyword">void</span></span><br><span class="line">	<span class="built_in">assign</span>(_InputIterator __first, _InputIterator __last)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">// Check whether it&#x27;s an integral type.  If so, it&#x27;s not an iterator.</span></span><br><span class="line">	  <span class="keyword">typedef</span> <span class="keyword">typename</span> std::__is_integer&lt;_InputIterator&gt;::__type _Integral;</span><br><span class="line">	  _M_assign_dispatch(__first, __last, _Integral());</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">      <span class="comment">// C++11</span></span><br><span class="line">	  <span class="comment">// .......................................................</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/// Get a copy of the memory allocation object.</span></span><br><span class="line">      <span class="keyword">using</span> _Base::get_allocator;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// iterators</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  Returns a read/write iterator that points to the first</span></span><br><span class="line"><span class="comment">       *  element in the %vector.  Iteration is done in ordinary</span></span><br><span class="line"><span class="comment">       *  element order.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      iterator</span><br><span class="line">      <span class="built_in">begin</span>() _GLIBCXX_NOEXCEPT</span><br><span class="line">      &#123; <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>-&gt;_M_impl._M_start); &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  Returns a read-only (constant) iterator that points to the</span></span><br><span class="line"><span class="comment">       *  first element in the %vector.  Iteration is done in ordinary</span></span><br><span class="line"><span class="comment">       *  element order.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      const_iterator</span><br><span class="line">      <span class="built_in">begin</span>() <span class="keyword">const</span> _GLIBCXX_NOEXCEPT</span><br><span class="line">      &#123; <span class="keyword">return</span> <span class="built_in">const_iterator</span>(<span class="keyword">this</span>-&gt;_M_impl._M_start); &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  Returns a read/write iterator that points one past the last</span></span><br><span class="line"><span class="comment">       *  element in the %vector.  Iteration is done in ordinary</span></span><br><span class="line"><span class="comment">       *  element order.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      iterator</span><br><span class="line">      <span class="built_in">end</span>() _GLIBCXX_NOEXCEPT</span><br><span class="line">      &#123; <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>-&gt;_M_impl._M_finish); &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  Returns a read-only (constant) iterator that points one past</span></span><br><span class="line"><span class="comment">       *  the last element in the %vector.  Iteration is done in</span></span><br><span class="line"><span class="comment">       *  ordinary element order.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      const_iterator</span><br><span class="line">      <span class="built_in">end</span>() <span class="keyword">const</span> _GLIBCXX_NOEXCEPT</span><br><span class="line">      &#123; <span class="keyword">return</span> <span class="built_in">const_iterator</span>(<span class="keyword">this</span>-&gt;_M_impl._M_finish); &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  Returns a read/write reverse iterator that points to the</span></span><br><span class="line"><span class="comment">       *  last element in the %vector.  Iteration is done in reverse</span></span><br><span class="line"><span class="comment">       *  element order.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      reverse_iterator</span><br><span class="line">      <span class="built_in">rbegin</span>() _GLIBCXX_NOEXCEPT</span><br><span class="line">      &#123; <span class="keyword">return</span> <span class="built_in">reverse_iterator</span>(<span class="built_in">end</span>()); &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  Returns a read-only (constant) reverse iterator that points</span></span><br><span class="line"><span class="comment">       *  to the last element in the %vector.  Iteration is done in</span></span><br><span class="line"><span class="comment">       *  reverse element order.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      const_reverse_iterator</span><br><span class="line">      <span class="built_in">rbegin</span>() <span class="keyword">const</span> _GLIBCXX_NOEXCEPT</span><br><span class="line">      &#123; <span class="keyword">return</span> <span class="built_in">const_reverse_iterator</span>(<span class="built_in">end</span>()); &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  Returns a read/write reverse iterator that points to one</span></span><br><span class="line"><span class="comment">       *  before the first element in the %vector.  Iteration is done</span></span><br><span class="line"><span class="comment">       *  in reverse element order.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      reverse_iterator</span><br><span class="line">      <span class="built_in">rend</span>() _GLIBCXX_NOEXCEPT</span><br><span class="line">      &#123; <span class="keyword">return</span> <span class="built_in">reverse_iterator</span>(<span class="built_in">begin</span>()); &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  Returns a read-only (constant) reverse iterator that points</span></span><br><span class="line"><span class="comment">       *  to one before the first element in the %vector.  Iteration</span></span><br><span class="line"><span class="comment">       *  is done in reverse element order.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      const_reverse_iterator</span><br><span class="line">      <span class="built_in">rend</span>() <span class="keyword">const</span> _GLIBCXX_NOEXCEPT</span><br><span class="line">      &#123; <span class="keyword">return</span> <span class="built_in">const_reverse_iterator</span>(<span class="built_in">begin</span>()); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  Returns a read-only (constant) iterator that points to the</span></span><br><span class="line"><span class="comment">       *  first element in the %vector.  Iteration is done in ordinary</span></span><br><span class="line"><span class="comment">       *  element order.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      const_iterator</span><br><span class="line">      <span class="built_in">cbegin</span>() <span class="keyword">const</span> <span class="keyword">noexcept</span></span><br><span class="line">      &#123; <span class="keyword">return</span> <span class="built_in">const_iterator</span>(<span class="keyword">this</span>-&gt;_M_impl._M_start); &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  Returns a read-only (constant) iterator that points one past</span></span><br><span class="line"><span class="comment">       *  the last element in the %vector.  Iteration is done in</span></span><br><span class="line"><span class="comment">       *  ordinary element order.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      const_iterator</span><br><span class="line">      <span class="built_in">cend</span>() <span class="keyword">const</span> <span class="keyword">noexcept</span></span><br><span class="line">      &#123; <span class="keyword">return</span> <span class="built_in">const_iterator</span>(<span class="keyword">this</span>-&gt;_M_impl._M_finish); &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  Returns a read-only (constant) reverse iterator that points</span></span><br><span class="line"><span class="comment">       *  to the last element in the %vector.  Iteration is done in</span></span><br><span class="line"><span class="comment">       *  reverse element order.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      const_reverse_iterator</span><br><span class="line">      <span class="built_in">crbegin</span>() <span class="keyword">const</span> <span class="keyword">noexcept</span></span><br><span class="line">      &#123; <span class="keyword">return</span> <span class="built_in">const_reverse_iterator</span>(<span class="built_in">end</span>()); &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  Returns a read-only (constant) reverse iterator that points</span></span><br><span class="line"><span class="comment">       *  to one before the first element in the %vector.  Iteration</span></span><br><span class="line"><span class="comment">       *  is done in reverse element order.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      const_reverse_iterator</span><br><span class="line">      <span class="built_in">crend</span>() <span class="keyword">const</span> <span class="keyword">noexcept</span></span><br><span class="line">      &#123; <span class="keyword">return</span> <span class="built_in">const_reverse_iterator</span>(<span class="built_in">begin</span>()); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// [23.2.4.2] capacity</span></span><br><span class="line">      <span class="comment">/**  Returns the number of elements in the %vector.  */</span></span><br><span class="line">      size_type</span><br><span class="line">      <span class="built_in">size</span>() <span class="keyword">const</span> _GLIBCXX_NOEXCEPT</span><br><span class="line">      &#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="keyword">this</span>-&gt;_M_impl._M_finish - <span class="keyword">this</span>-&gt;_M_impl._M_start); &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**  Returns the size() of the largest possible %vector.  */</span></span><br><span class="line">      size_type</span><br><span class="line">      <span class="built_in">max_size</span>() <span class="keyword">const</span> _GLIBCXX_NOEXCEPT</span><br><span class="line">      &#123; <span class="keyword">return</span> _S_max_size(_M_get_Tp_allocator()); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  @brief  Resizes the %vector to the specified number of elements.</span></span><br><span class="line"><span class="comment">       *  @param  __new_size  Number of elements the %vector should contain.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       *  This function will %resize the %vector to the specified</span></span><br><span class="line"><span class="comment">       *  number of elements.  If the number is smaller than the</span></span><br><span class="line"><span class="comment">       *  %vector&#x27;s current size the %vector is truncated, otherwise</span></span><br><span class="line"><span class="comment">       *  default constructed elements are appended.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">void</span></span><br><span class="line">      <span class="built_in">resize</span>(size_type __new_size)</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="keyword">if</span> (__new_size &gt; <span class="built_in">size</span>())</span><br><span class="line">	  _M_default_append(__new_size - <span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (__new_size &lt; <span class="built_in">size</span>())</span><br><span class="line">	  _M_erase_at_end(<span class="keyword">this</span>-&gt;_M_impl._M_start + __new_size);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  @brief  Resizes the %vector to the specified number of elements.</span></span><br><span class="line"><span class="comment">       *  @param  __new_size  Number of elements the %vector should contain.</span></span><br><span class="line"><span class="comment">       *  @param  __x  Data with which new elements should be populated.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       *  This function will %resize the %vector to the specified</span></span><br><span class="line"><span class="comment">       *  number of elements.  If the number is smaller than the</span></span><br><span class="line"><span class="comment">       *  %vector&#x27;s current size the %vector is truncated, otherwise</span></span><br><span class="line"><span class="comment">       *  the %vector is extended and new elements are populated with</span></span><br><span class="line"><span class="comment">       *  given data.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">void</span></span><br><span class="line">      <span class="built_in">resize</span>(size_type __new_size, <span class="keyword">const</span> value_type&amp; __x)</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="keyword">if</span> (__new_size &gt; <span class="built_in">size</span>())</span><br><span class="line">	  _M_fill_insert(<span class="built_in">end</span>(), __new_size - <span class="built_in">size</span>(), __x);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (__new_size &lt; <span class="built_in">size</span>())</span><br><span class="line">	  _M_erase_at_end(<span class="keyword">this</span>-&gt;_M_impl._M_start + __new_size);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  @brief  Resizes the %vector to the specified number of elements.</span></span><br><span class="line"><span class="comment">       *  @param  __new_size  Number of elements the %vector should contain.</span></span><br><span class="line"><span class="comment">       *  @param  __x  Data with which new elements should be populated.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       *  This function will %resize the %vector to the specified</span></span><br><span class="line"><span class="comment">       *  number of elements.  If the number is smaller than the</span></span><br><span class="line"><span class="comment">       *  %vector&#x27;s current size the %vector is truncated, otherwise</span></span><br><span class="line"><span class="comment">       *  the %vector is extended and new elements are populated with</span></span><br><span class="line"><span class="comment">       *  given data.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">void</span></span><br><span class="line">      <span class="built_in">resize</span>(size_type __new_size, value_type __x = <span class="built_in">value_type</span>())</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="keyword">if</span> (__new_size &gt; <span class="built_in">size</span>())</span><br><span class="line">	  _M_fill_insert(<span class="built_in">end</span>(), __new_size - <span class="built_in">size</span>(), __x);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (__new_size &lt; <span class="built_in">size</span>())</span><br><span class="line">	  _M_erase_at_end(<span class="keyword">this</span>-&gt;_M_impl._M_start + __new_size);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">      <span class="comment">/**  A non-binding request to reduce capacity() to size().  */</span></span><br><span class="line">      <span class="keyword">void</span></span><br><span class="line">      <span class="built_in">shrink_to_fit</span>()</span><br><span class="line">      &#123; _M_shrink_to_fit(); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  Returns the total number of elements that the %vector can</span></span><br><span class="line"><span class="comment">       *  hold before needing to allocate more memory.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      size_type</span><br><span class="line">      <span class="built_in">capacity</span>() <span class="keyword">const</span> _GLIBCXX_NOEXCEPT</span><br><span class="line">      &#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="keyword">this</span>-&gt;_M_impl._M_end_of_storage</span><br><span class="line">			 - <span class="keyword">this</span>-&gt;_M_impl._M_start); &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  Returns true if the %vector is empty.  (Thus begin() would</span></span><br><span class="line"><span class="comment">       *  equal end().)</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      _GLIBCXX_NODISCARD <span class="keyword">bool</span></span><br><span class="line">      <span class="built_in">empty</span>() <span class="keyword">const</span> _GLIBCXX_NOEXCEPT</span><br><span class="line">      &#123; <span class="keyword">return</span> <span class="built_in">begin</span>() == <span class="built_in">end</span>(); &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  @brief  Attempt to preallocate enough memory for specified number of</span></span><br><span class="line"><span class="comment">       *          elements.</span></span><br><span class="line"><span class="comment">       *  @param  __n  Number of elements required.</span></span><br><span class="line"><span class="comment">       *  @throw  std::length_error  If @a n exceeds @c max_size().</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       *  This function attempts to reserve enough memory for the</span></span><br><span class="line"><span class="comment">       *  %vector to hold the specified number of elements.  If the</span></span><br><span class="line"><span class="comment">       *  number requested is more than max_size(), length_error is</span></span><br><span class="line"><span class="comment">       *  thrown.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       *  The advantage of this function is that if optimal code is a</span></span><br><span class="line"><span class="comment">       *  necessity and the user can determine the number of elements</span></span><br><span class="line"><span class="comment">       *  that will be required, the user can reserve the memory in</span></span><br><span class="line"><span class="comment">       *  %advance, and thus prevent a possible reallocation of memory</span></span><br><span class="line"><span class="comment">       *  and copying of %vector data.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">void</span></span><br><span class="line">      <span class="built_in">reserve</span>(size_type __n);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// element access</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  @brief  Subscript access to the data contained in the %vector.</span></span><br><span class="line"><span class="comment">       *  @param __n The index of the element for which data should be</span></span><br><span class="line"><span class="comment">       *  accessed.</span></span><br><span class="line"><span class="comment">       *  @return  Read/write reference to data.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       *  This operator allows for easy, array-style, data access.</span></span><br><span class="line"><span class="comment">       *  Note that data access with this operator is unchecked and</span></span><br><span class="line"><span class="comment">       *  out_of_range lookups are not defined. (For checked lookups</span></span><br><span class="line"><span class="comment">       *  see at().)</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      reference</span><br><span class="line">      <span class="keyword">operator</span>[](size_type __n) _GLIBCXX_NOEXCEPT</span><br><span class="line">      &#123;</span><br><span class="line">	__glibcxx_requires_subscript(__n);</span><br><span class="line">	<span class="keyword">return</span> *(<span class="keyword">this</span>-&gt;_M_impl._M_start + __n);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  @brief  Subscript access to the data contained in the %vector.</span></span><br><span class="line"><span class="comment">       *  @param __n The index of the element for which data should be</span></span><br><span class="line"><span class="comment">       *  accessed.</span></span><br><span class="line"><span class="comment">       *  @return  Read-only (constant) reference to data.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       *  This operator allows for easy, array-style, data access.</span></span><br><span class="line"><span class="comment">       *  Note that data access with this operator is unchecked and</span></span><br><span class="line"><span class="comment">       *  out_of_range lookups are not defined. (For checked lookups</span></span><br><span class="line"><span class="comment">       *  see at().)</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      const_reference</span><br><span class="line">      <span class="keyword">operator</span>[](size_type __n) <span class="keyword">const</span> _GLIBCXX_NOEXCEPT</span><br><span class="line">      &#123;</span><br><span class="line">	__glibcxx_requires_subscript(__n);</span><br><span class="line">	<span class="keyword">return</span> *(<span class="keyword">this</span>-&gt;_M_impl._M_start + __n);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">      <span class="comment">/// Safety check used only from at().</span></span><br><span class="line">      <span class="keyword">void</span></span><br><span class="line">      _M_range_check(size_type __n) <span class="keyword">const</span></span><br><span class="line">      &#123;</span><br><span class="line">	<span class="keyword">if</span> (__n &gt;= <span class="keyword">this</span>-&gt;<span class="built_in">size</span>())</span><br><span class="line">	  __throw_out_of_range_fmt(__N(<span class="string">&quot;vector::_M_range_check: __n &quot;</span></span><br><span class="line">				       <span class="string">&quot;(which is %zu) &gt;= this-&gt;size() &quot;</span></span><br><span class="line">				       <span class="string">&quot;(which is %zu)&quot;</span>),</span><br><span class="line">				   __n, <span class="keyword">this</span>-&gt;<span class="built_in">size</span>());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  @brief  Provides access to the data contained in the %vector.</span></span><br><span class="line"><span class="comment">       *  @param __n The index of the element for which data should be</span></span><br><span class="line"><span class="comment">       *  accessed.</span></span><br><span class="line"><span class="comment">       *  @return  Read/write reference to data.</span></span><br><span class="line"><span class="comment">       *  @throw  std::out_of_range  If @a __n is an invalid index.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       *  This function provides for safer data access.  The parameter</span></span><br><span class="line"><span class="comment">       *  is first checked that it is in the range of the vector.  The</span></span><br><span class="line"><span class="comment">       *  function throws out_of_range if the check fails.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      reference</span><br><span class="line">      <span class="built_in">at</span>(size_type __n)</span><br><span class="line">      &#123;</span><br><span class="line">	_M_range_check(__n);</span><br><span class="line">	<span class="keyword">return</span> (*<span class="keyword">this</span>)[__n];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  @brief  Provides access to the data contained in the %vector.</span></span><br><span class="line"><span class="comment">       *  @param __n The index of the element for which data should be</span></span><br><span class="line"><span class="comment">       *  accessed.</span></span><br><span class="line"><span class="comment">       *  @return  Read-only (constant) reference to data.</span></span><br><span class="line"><span class="comment">       *  @throw  std::out_of_range  If @a __n is an invalid index.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       *  This function provides for safer data access.  The parameter</span></span><br><span class="line"><span class="comment">       *  is first checked that it is in the range of the vector.  The</span></span><br><span class="line"><span class="comment">       *  function throws out_of_range if the check fails.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      const_reference</span><br><span class="line">      <span class="built_in">at</span>(size_type __n) <span class="keyword">const</span></span><br><span class="line">      &#123;</span><br><span class="line">	_M_range_check(__n);</span><br><span class="line">	<span class="keyword">return</span> (*<span class="keyword">this</span>)[__n];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  Returns a read/write reference to the data at the first</span></span><br><span class="line"><span class="comment">       *  element of the %vector.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      reference</span><br><span class="line">      <span class="built_in">front</span>() _GLIBCXX_NOEXCEPT</span><br><span class="line">      &#123;</span><br><span class="line">	__glibcxx_requires_nonempty();</span><br><span class="line">	<span class="keyword">return</span> *<span class="built_in">begin</span>();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  Returns a read-only (constant) reference to the data at the first</span></span><br><span class="line"><span class="comment">       *  element of the %vector.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      const_reference</span><br><span class="line">      <span class="built_in">front</span>() <span class="keyword">const</span> _GLIBCXX_NOEXCEPT</span><br><span class="line">      &#123;</span><br><span class="line">	__glibcxx_requires_nonempty();</span><br><span class="line">	<span class="keyword">return</span> *<span class="built_in">begin</span>();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  Returns a read/write reference to the data at the last</span></span><br><span class="line"><span class="comment">       *  element of the %vector.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      reference</span><br><span class="line">      <span class="built_in">back</span>() _GLIBCXX_NOEXCEPT</span><br><span class="line">      &#123;</span><br><span class="line">	__glibcxx_requires_nonempty();</span><br><span class="line">	<span class="keyword">return</span> *(<span class="built_in">end</span>() - <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  Returns a read-only (constant) reference to the data at the</span></span><br><span class="line"><span class="comment">       *  last element of the %vector.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      const_reference</span><br><span class="line">      <span class="built_in">back</span>() <span class="keyword">const</span> _GLIBCXX_NOEXCEPT</span><br><span class="line">      &#123;</span><br><span class="line">	__glibcxx_requires_nonempty();</span><br><span class="line">	<span class="keyword">return</span> *(<span class="built_in">end</span>() - <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// _GLIBCXX_RESOLVE_LIB_DEFECTS</span></span><br><span class="line">      <span class="comment">// DR 464. Suggestion for new member functions in standard containers.</span></span><br><span class="line">      <span class="comment">// data access</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *   Returns a pointer such that [data(), data() + size()) is a valid</span></span><br><span class="line"><span class="comment">       *   range.  For a non-empty %vector, data() == &amp;front().</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      _Tp*</span><br><span class="line">      <span class="built_in">data</span>() _GLIBCXX_NOEXCEPT</span><br><span class="line">      &#123; <span class="keyword">return</span> _M_data_ptr(<span class="keyword">this</span>-&gt;_M_impl._M_start); &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> _Tp*</span><br><span class="line">      <span class="built_in">data</span>() <span class="keyword">const</span> _GLIBCXX_NOEXCEPT</span><br><span class="line">      &#123; <span class="keyword">return</span> _M_data_ptr(<span class="keyword">this</span>-&gt;_M_impl._M_start); &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// [23.2.4.3] modifiers</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  @brief  Add data to the end of the %vector.</span></span><br><span class="line"><span class="comment">       *  @param  __x  Data to be added.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       *  This is a typical stack operation.  The function creates an</span></span><br><span class="line"><span class="comment">       *  element at the end of the %vector and assigns the given data</span></span><br><span class="line"><span class="comment">       *  to it.  Due to the nature of a %vector this operation can be</span></span><br><span class="line"><span class="comment">       *  done in constant time if the %vector has preallocated space</span></span><br><span class="line"><span class="comment">       *  available.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">void</span></span><br><span class="line">      <span class="built_in">push_back</span>(<span class="keyword">const</span> value_type&amp; __x)</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_M_impl._M_finish != <span class="keyword">this</span>-&gt;_M_impl._M_end_of_storage)</span><br><span class="line">	  &#123;</span><br><span class="line">	    _GLIBCXX_ASAN_ANNOTATE_GROW(<span class="number">1</span>);</span><br><span class="line">	    _Alloc_traits::<span class="built_in">construct</span>(<span class="keyword">this</span>-&gt;_M_impl, <span class="keyword">this</span>-&gt;_M_impl._M_finish,</span><br><span class="line">				     __x);</span><br><span class="line">	    ++<span class="keyword">this</span>-&gt;_M_impl._M_finish;</span><br><span class="line">	    _GLIBCXX_ASAN_ANNOTATE_GREW(<span class="number">1</span>);</span><br><span class="line">	  &#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	  _M_realloc_insert(<span class="built_in">end</span>(), __x);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">      <span class="keyword">void</span></span><br><span class="line">      <span class="built_in">push_back</span>(value_type&amp;&amp; __x)</span><br><span class="line">      &#123; <span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(__x)); &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... _Args&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt; 201402L</span></span><br><span class="line">	reference</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="keyword">void</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="built_in">emplace_back</span>(_Args&amp;&amp;... __args);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  @brief  Removes last element.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       *  This is a typical stack operation. It shrinks the %vector by one.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       *  Note that no data is returned, and if the last element&#x27;s</span></span><br><span class="line"><span class="comment">       *  data is needed, it should be retrieved before pop_back() is</span></span><br><span class="line"><span class="comment">       *  called.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">void</span></span><br><span class="line">      <span class="built_in">pop_back</span>() _GLIBCXX_NOEXCEPT</span><br><span class="line">      &#123;</span><br><span class="line">	__glibcxx_requires_nonempty();</span><br><span class="line">	--<span class="keyword">this</span>-&gt;_M_impl._M_finish;</span><br><span class="line">	_Alloc_traits::<span class="built_in">destroy</span>(<span class="keyword">this</span>-&gt;_M_impl, <span class="keyword">this</span>-&gt;_M_impl._M_finish);</span><br><span class="line">	_GLIBCXX_ASAN_ANNOTATE_SHRINK(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  @brief  Inserts an object in %vector before specified iterator.</span></span><br><span class="line"><span class="comment">       *  @param  __position  A const_iterator into the %vector.</span></span><br><span class="line"><span class="comment">       *  @param  __args  Arguments.</span></span><br><span class="line"><span class="comment">       *  @return  An iterator that points to the inserted data.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       *  This function will insert an object of type T constructed</span></span><br><span class="line"><span class="comment">       *  with T(std::forward&lt;Args&gt;(args)...) before the specified location.</span></span><br><span class="line"><span class="comment">       *  Note that this kind of operation could be expensive for a %vector</span></span><br><span class="line"><span class="comment">       *  and if it is frequently used the user should consider using</span></span><br><span class="line"><span class="comment">       *  std::list.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... _Args&gt;</span><br><span class="line">	iterator</span><br><span class="line">	<span class="built_in">emplace</span>(const_iterator __position, _Args&amp;&amp;... __args)</span><br><span class="line">	&#123; <span class="keyword">return</span> _M_emplace_aux(__position, std::forward&lt;_Args&gt;(__args)...); &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  @brief  Inserts given value into %vector before specified iterator.</span></span><br><span class="line"><span class="comment">       *  @param  __position  A const_iterator into the %vector.</span></span><br><span class="line"><span class="comment">       *  @param  __x  Data to be inserted.</span></span><br><span class="line"><span class="comment">       *  @return  An iterator that points to the inserted data.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       *  This function will insert a copy of the given value before</span></span><br><span class="line"><span class="comment">       *  the specified location.  Note that this kind of operation</span></span><br><span class="line"><span class="comment">       *  could be expensive for a %vector and if it is frequently</span></span><br><span class="line"><span class="comment">       *  used the user should consider using std::list.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      iterator</span><br><span class="line">      <span class="built_in">insert</span>(const_iterator __position, <span class="keyword">const</span> value_type&amp; __x);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  @brief  Inserts given value into %vector before specified iterator.</span></span><br><span class="line"><span class="comment">       *  @param  __position  An iterator into the %vector.</span></span><br><span class="line"><span class="comment">       *  @param  __x  Data to be inserted.</span></span><br><span class="line"><span class="comment">       *  @return  An iterator that points to the inserted data.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       *  This function will insert a copy of the given value before</span></span><br><span class="line"><span class="comment">       *  the specified location.  Note that this kind of operation</span></span><br><span class="line"><span class="comment">       *  could be expensive for a %vector and if it is frequently</span></span><br><span class="line"><span class="comment">       *  used the user should consider using std::list.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      iterator</span><br><span class="line">      <span class="built_in">insert</span>(iterator __position, <span class="keyword">const</span> value_type&amp; __x);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  @brief  Inserts given rvalue into %vector before specified iterator.</span></span><br><span class="line"><span class="comment">       *  @param  __position  A const_iterator into the %vector.</span></span><br><span class="line"><span class="comment">       *  @param  __x  Data to be inserted.</span></span><br><span class="line"><span class="comment">       *  @return  An iterator that points to the inserted data.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       *  This function will insert a copy of the given rvalue before</span></span><br><span class="line"><span class="comment">       *  the specified location.  Note that this kind of operation</span></span><br><span class="line"><span class="comment">       *  could be expensive for a %vector and if it is frequently</span></span><br><span class="line"><span class="comment">       *  used the user should consider using std::list.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      iterator</span><br><span class="line">      <span class="built_in">insert</span>(const_iterator __position, value_type&amp;&amp; __x)</span><br><span class="line">      &#123; <span class="keyword">return</span> _M_insert_rval(__position, std::<span class="built_in">move</span>(__x)); &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  @brief  Inserts an initializer_list into the %vector.</span></span><br><span class="line"><span class="comment">       *  @param  __position  An iterator into the %vector.</span></span><br><span class="line"><span class="comment">       *  @param  __l  An initializer_list.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       *  This function will insert copies of the data in the</span></span><br><span class="line"><span class="comment">       *  initializer_list @a l into the %vector before the location</span></span><br><span class="line"><span class="comment">       *  specified by @a position.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       *  Note that this kind of operation could be expensive for a</span></span><br><span class="line"><span class="comment">       *  %vector and if it is frequently used the user should</span></span><br><span class="line"><span class="comment">       *  consider using std::list.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      iterator</span><br><span class="line">      <span class="built_in">insert</span>(const_iterator __position, initializer_list&lt;value_type&gt; __l)</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="keyword">auto</span> __offset = __position - <span class="built_in">cbegin</span>();</span><br><span class="line">	_M_range_insert(<span class="built_in">begin</span>() + __offset, __l.<span class="built_in">begin</span>(), __l.<span class="built_in">end</span>(),</span><br><span class="line">			std::<span class="built_in">random_access_iterator_tag</span>());</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">begin</span>() + __offset;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  @brief  Inserts a number of copies of given data into the %vector.</span></span><br><span class="line"><span class="comment">       *  @param  __position  A const_iterator into the %vector.</span></span><br><span class="line"><span class="comment">       *  @param  __n  Number of elements to be inserted.</span></span><br><span class="line"><span class="comment">       *  @param  __x  Data to be inserted.</span></span><br><span class="line"><span class="comment">       *  @return  An iterator that points to the inserted data.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       *  This function will insert a specified number of copies of</span></span><br><span class="line"><span class="comment">       *  the given data before the location specified by @a position.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       *  Note that this kind of operation could be expensive for a</span></span><br><span class="line"><span class="comment">       *  %vector and if it is frequently used the user should</span></span><br><span class="line"><span class="comment">       *  consider using std::list.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      iterator</span><br><span class="line">      <span class="built_in">insert</span>(const_iterator __position, size_type __n, <span class="keyword">const</span> value_type&amp; __x)</span><br><span class="line">      &#123;</span><br><span class="line">	difference_type __offset = __position - <span class="built_in">cbegin</span>();</span><br><span class="line">	_M_fill_insert(<span class="built_in">begin</span>() + __offset, __n, __x);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">begin</span>() + __offset;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  @brief  Inserts a number of copies of given data into the %vector.</span></span><br><span class="line"><span class="comment">       *  @param  __position  An iterator into the %vector.</span></span><br><span class="line"><span class="comment">       *  @param  __n  Number of elements to be inserted.</span></span><br><span class="line"><span class="comment">       *  @param  __x  Data to be inserted.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       *  This function will insert a specified number of copies of</span></span><br><span class="line"><span class="comment">       *  the given data before the location specified by @a position.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       *  Note that this kind of operation could be expensive for a</span></span><br><span class="line"><span class="comment">       *  %vector and if it is frequently used the user should</span></span><br><span class="line"><span class="comment">       *  consider using std::list.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">void</span></span><br><span class="line">      <span class="built_in">insert</span>(iterator __position, size_type __n, <span class="keyword">const</span> value_type&amp; __x)</span><br><span class="line">      &#123; _M_fill_insert(__position, __n, __x); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  @brief  Inserts a range into the %vector.</span></span><br><span class="line"><span class="comment">       *  @param  __position  A const_iterator into the %vector.</span></span><br><span class="line"><span class="comment">       *  @param  __first  An input iterator.</span></span><br><span class="line"><span class="comment">       *  @param  __last   An input iterator.</span></span><br><span class="line"><span class="comment">       *  @return  An iterator that points to the inserted data.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       *  This function will insert copies of the data in the range</span></span><br><span class="line"><span class="comment">       *  [__first,__last) into the %vector before the location specified</span></span><br><span class="line"><span class="comment">       *  by @a pos.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       *  Note that this kind of operation could be expensive for a</span></span><br><span class="line"><span class="comment">       *  %vector and if it is frequently used the user should</span></span><br><span class="line"><span class="comment">       *  consider using std::list.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _InputIterator,</span><br><span class="line">	       <span class="keyword">typename</span> = std::_RequireInputIter&lt;_InputIterator&gt;&gt;</span><br><span class="line">	iterator</span><br><span class="line">	<span class="built_in">insert</span>(const_iterator __position, _InputIterator __first,</span><br><span class="line">	       _InputIterator __last)</span><br><span class="line">	&#123;</span><br><span class="line">	  difference_type __offset = __position - <span class="built_in">cbegin</span>();</span><br><span class="line">	  _M_insert_dispatch(<span class="built_in">begin</span>() + __offset,</span><br><span class="line">			     __first, __last, __false_type());</span><br><span class="line">	  <span class="keyword">return</span> <span class="built_in">begin</span>() + __offset;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  @brief  Inserts a range into the %vector.</span></span><br><span class="line"><span class="comment">       *  @param  __position  An iterator into the %vector.</span></span><br><span class="line"><span class="comment">       *  @param  __first  An input iterator.</span></span><br><span class="line"><span class="comment">       *  @param  __last   An input iterator.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       *  This function will insert copies of the data in the range</span></span><br><span class="line"><span class="comment">       *  [__first,__last) into the %vector before the location specified</span></span><br><span class="line"><span class="comment">       *  by @a pos.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       *  Note that this kind of operation could be expensive for a</span></span><br><span class="line"><span class="comment">       *  %vector and if it is frequently used the user should</span></span><br><span class="line"><span class="comment">       *  consider using std::list.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _InputIterator&gt;</span><br><span class="line">	<span class="keyword">void</span></span><br><span class="line">	<span class="built_in">insert</span>(iterator __position, _InputIterator __first,</span><br><span class="line">	       _InputIterator __last)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">// Check whether it&#x27;s an integral type.  If so, it&#x27;s not an iterator.</span></span><br><span class="line">	  <span class="keyword">typedef</span> <span class="keyword">typename</span> std::__is_integer&lt;_InputIterator&gt;::__type _Integral;</span><br><span class="line">	  _M_insert_dispatch(__position, __first, __last, _Integral());</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  @brief  Remove element at given position.</span></span><br><span class="line"><span class="comment">       *  @param  __position  Iterator pointing to element to be erased.</span></span><br><span class="line"><span class="comment">       *  @return  An iterator pointing to the next element (or end()).</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       *  This function will erase the element at the given position and thus</span></span><br><span class="line"><span class="comment">       *  shorten the %vector by one.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       *  Note This operation could be expensive and if it is</span></span><br><span class="line"><span class="comment">       *  frequently used the user should consider using std::list.</span></span><br><span class="line"><span class="comment">       *  The user is also cautioned that this function only erases</span></span><br><span class="line"><span class="comment">       *  the element, and that if the element is itself a pointer,</span></span><br><span class="line"><span class="comment">       *  the pointed-to memory is not touched in any way.  Managing</span></span><br><span class="line"><span class="comment">       *  the pointer is the user&#x27;s responsibility.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      iterator</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">      <span class="built_in">erase</span>(const_iterator __position)</span><br><span class="line">      &#123; <span class="keyword">return</span> _M_erase(<span class="built_in">begin</span>() + (__position - <span class="built_in">cbegin</span>())); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      <span class="built_in">erase</span>(iterator __position)</span><br><span class="line">      &#123; <span class="keyword">return</span> _M_erase(__position); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  @brief  Remove a range of elements.</span></span><br><span class="line"><span class="comment">       *  @param  __first  Iterator pointing to the first element to be erased.</span></span><br><span class="line"><span class="comment">       *  @param  __last  Iterator pointing to one past the last element to be</span></span><br><span class="line"><span class="comment">       *                  erased.</span></span><br><span class="line"><span class="comment">       *  @return  An iterator pointing to the element pointed to by @a __last</span></span><br><span class="line"><span class="comment">       *           prior to erasing (or end()).</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       *  This function will erase the elements in the range</span></span><br><span class="line"><span class="comment">       *  [__first,__last) and shorten the %vector accordingly.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       *  Note This operation could be expensive and if it is</span></span><br><span class="line"><span class="comment">       *  frequently used the user should consider using std::list.</span></span><br><span class="line"><span class="comment">       *  The user is also cautioned that this function only erases</span></span><br><span class="line"><span class="comment">       *  the elements, and that if the elements themselves are</span></span><br><span class="line"><span class="comment">       *  pointers, the pointed-to memory is not touched in any way.</span></span><br><span class="line"><span class="comment">       *  Managing the pointer is the user&#x27;s responsibility.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      iterator</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">      <span class="built_in">erase</span>(const_iterator __first, const_iterator __last)</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">auto</span> __beg = <span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">auto</span> __cbeg = <span class="built_in">cbegin</span>();</span><br><span class="line">	<span class="keyword">return</span> _M_erase(__beg + (__first - __cbeg), __beg + (__last - __cbeg));</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      <span class="built_in">erase</span>(iterator __first, iterator __last)</span><br><span class="line">      &#123; <span class="keyword">return</span> _M_erase(__first, __last); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  @brief  Swaps data with another %vector.</span></span><br><span class="line"><span class="comment">       *  @param  __x  A %vector of the same element and allocator types.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       *  This exchanges the elements between two vectors in constant time.</span></span><br><span class="line"><span class="comment">       *  (Three pointers, so it should be quite fast.)</span></span><br><span class="line"><span class="comment">       *  Note that the global std::swap() function is specialized such that</span></span><br><span class="line"><span class="comment">       *  std::swap(v1,v2) will feed to this function.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       *  Whether the allocators are swapped depends on the allocator traits.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">void</span></span><br><span class="line">      <span class="built_in">swap</span>(vector&amp; __x) _GLIBCXX_NOEXCEPT</span><br><span class="line">      &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">	__glibcxx_assert(_Alloc_traits::propagate_on_container_swap::value</span><br><span class="line">			 || _M_get_Tp_allocator() == __x._M_get_Tp_allocator());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">this</span>-&gt;_M_impl._M_swap_data(__x._M_impl);</span><br><span class="line">	_Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),</span><br><span class="line">				  __x._M_get_Tp_allocator());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  Erases all the elements.  Note that this function only erases the</span></span><br><span class="line"><span class="comment">       *  elements, and that if the elements themselves are pointers, the</span></span><br><span class="line"><span class="comment">       *  pointed-to memory is not touched in any way.  Managing the pointer is</span></span><br><span class="line"><span class="comment">       *  the user&#x27;s responsibility.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">void</span></span><br><span class="line">      <span class="built_in">clear</span>() _GLIBCXX_NOEXCEPT</span><br><span class="line">      &#123; _M_erase_at_end(<span class="keyword">this</span>-&gt;_M_impl._M_start); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  Memory expansion handler.  Uses the member allocation function to</span></span><br><span class="line"><span class="comment">       *  obtain @a n bytes of memory, and then copies [first,last) into it.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ForwardIterator&gt;</span><br><span class="line">	pointer</span><br><span class="line">	_M_allocate_and_copy(size_type __n,</span><br><span class="line">			     _ForwardIterator __first, _ForwardIterator __last)</span><br><span class="line">	&#123;</span><br><span class="line">	  pointer __result = <span class="keyword">this</span>-&gt;_M_allocate(__n);</span><br><span class="line">	  __try</span><br><span class="line">	    &#123;</span><br><span class="line">	      std::__uninitialized_copy_a(__first, __last, __result,</span><br><span class="line">					  _M_get_Tp_allocator());</span><br><span class="line">	      <span class="keyword">return</span> __result;</span><br><span class="line">	    &#125;</span><br><span class="line">	  __catch(...)</span><br><span class="line">	    &#123;</span><br><span class="line">	      _M_deallocate(__result, __n);</span><br><span class="line">	      __throw_exception_again;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Internal constructor functions follow.</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Called by the range constructor to implement [23.1.1]/9</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &lt; 201103L</span></span><br><span class="line">      <span class="comment">// _GLIBCXX_RESOLVE_LIB_DEFECTS</span></span><br><span class="line">      <span class="comment">// 438. Ambiguity in the &quot;do the right thing&quot; clause</span></span><br><span class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Integer&gt;</span><br><span class="line">	<span class="keyword">void</span></span><br><span class="line">	_M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">this</span>-&gt;_M_impl._M_start = _M_allocate(_S_check_init_len(</span><br><span class="line">		<span class="keyword">static_cast</span>&lt;size_type&gt;(__n), _M_get_Tp_allocator()));</span><br><span class="line">	  <span class="keyword">this</span>-&gt;_M_impl._M_end_of_storage =</span><br><span class="line">	    <span class="keyword">this</span>-&gt;_M_impl._M_start + <span class="keyword">static_cast</span>&lt;size_type&gt;(__n);</span><br><span class="line">	  _M_fill_initialize(<span class="keyword">static_cast</span>&lt;size_type&gt;(__n), __value);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Called by the range constructor to implement [23.1.1]/9</span></span><br><span class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _InputIterator&gt;</span><br><span class="line">	<span class="keyword">void</span></span><br><span class="line">	_M_initialize_dispatch(_InputIterator __first, _InputIterator __last,</span><br><span class="line">			       __false_type)</span><br><span class="line">	&#123;</span><br><span class="line">	  _M_range_initialize(__first, __last,</span><br><span class="line">			      std::__iterator_category(__first));</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Called by the second initialize_dispatch above</span></span><br><span class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _InputIterator&gt;</span><br><span class="line">	<span class="keyword">void</span></span><br><span class="line">	_M_range_initialize(_InputIterator __first, _InputIterator __last,</span><br><span class="line">			    std::input_iterator_tag)</span><br><span class="line">	&#123;</span><br><span class="line">	  __try &#123;</span><br><span class="line">	    <span class="keyword">for</span> (; __first != __last; ++__first)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">	      <span class="built_in">emplace_back</span>(*__first);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	      <span class="built_in">push_back</span>(*__first);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	  &#125; __catch(...) &#123;</span><br><span class="line">	    <span class="built_in">clear</span>();</span><br><span class="line">	    __throw_exception_again;</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Called by the second initialize_dispatch above</span></span><br><span class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ForwardIterator&gt;</span><br><span class="line">	<span class="keyword">void</span></span><br><span class="line">	_M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,</span><br><span class="line">			    std::forward_iterator_tag)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">const</span> size_type __n = std::<span class="built_in">distance</span>(__first, __last);</span><br><span class="line">	  <span class="keyword">this</span>-&gt;_M_impl._M_start</span><br><span class="line">	    = <span class="keyword">this</span>-&gt;_M_allocate(_S_check_init_len(__n, _M_get_Tp_allocator()));</span><br><span class="line">	  <span class="keyword">this</span>-&gt;_M_impl._M_end_of_storage = <span class="keyword">this</span>-&gt;_M_impl._M_start + __n;</span><br><span class="line">	  <span class="keyword">this</span>-&gt;_M_impl._M_finish =</span><br><span class="line">	    std::__uninitialized_copy_a(__first, __last,</span><br><span class="line">					<span class="keyword">this</span>-&gt;_M_impl._M_start,</span><br><span class="line">					_M_get_Tp_allocator());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Called by the first initialize_dispatch above and by the</span></span><br><span class="line">      <span class="comment">// vector(n,value,a) constructor.</span></span><br><span class="line">      <span class="keyword">void</span></span><br><span class="line">      _M_fill_initialize(size_type __n, <span class="keyword">const</span> value_type&amp; __value)</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;_M_impl._M_finish =</span><br><span class="line">	  std::__uninitialized_fill_n_a(<span class="keyword">this</span>-&gt;_M_impl._M_start, __n, __value,</span><br><span class="line">					_M_get_Tp_allocator());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">      <span class="comment">// Called by the vector(n) constructor.</span></span><br><span class="line">      <span class="keyword">void</span></span><br><span class="line">      _M_default_initialize(size_type __n)</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;_M_impl._M_finish =</span><br><span class="line">	  std::__uninitialized_default_n_a(<span class="keyword">this</span>-&gt;_M_impl._M_start, __n,</span><br><span class="line">					   _M_get_Tp_allocator());</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Internal assign functions follow.  The *_aux functions do the actual</span></span><br><span class="line">      <span class="comment">// assignment work for the range versions.</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Called by the range assign to implement [23.1.1]/9</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// _GLIBCXX_RESOLVE_LIB_DEFECTS</span></span><br><span class="line">      <span class="comment">// 438. Ambiguity in the &quot;do the right thing&quot; clause</span></span><br><span class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Integer&gt;</span><br><span class="line">	<span class="keyword">void</span></span><br><span class="line">	_M_assign_dispatch(_Integer __n, _Integer __val, __true_type)</span><br><span class="line">	&#123; _M_fill_assign(__n, __val); &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Called by the range assign to implement [23.1.1]/9</span></span><br><span class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _InputIterator&gt;</span><br><span class="line">	<span class="keyword">void</span></span><br><span class="line">	_M_assign_dispatch(_InputIterator __first, _InputIterator __last,</span><br><span class="line">			   __false_type)</span><br><span class="line">	&#123; _M_assign_aux(__first, __last, std::__iterator_category(__first)); &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Called by the second assign_dispatch above</span></span><br><span class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _InputIterator&gt;</span><br><span class="line">	<span class="keyword">void</span></span><br><span class="line">	_M_assign_aux(_InputIterator __first, _InputIterator __last,</span><br><span class="line">		      std::input_iterator_tag);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Called by the second assign_dispatch above</span></span><br><span class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ForwardIterator&gt;</span><br><span class="line">	<span class="keyword">void</span></span><br><span class="line">	_M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,</span><br><span class="line">		      std::forward_iterator_tag);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Called by assign(n,t), and the range assign when it turns out</span></span><br><span class="line">      <span class="comment">// to be the same thing.</span></span><br><span class="line">      <span class="keyword">void</span></span><br><span class="line">      _M_fill_assign(size_type __n, <span class="keyword">const</span> value_type&amp; __val);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Internal insert functions follow.</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Called by the range insert to implement [23.1.1]/9</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// _GLIBCXX_RESOLVE_LIB_DEFECTS</span></span><br><span class="line">      <span class="comment">// 438. Ambiguity in the &quot;do the right thing&quot; clause</span></span><br><span class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Integer&gt;</span><br><span class="line">	<span class="keyword">void</span></span><br><span class="line">	_M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,</span><br><span class="line">			   __true_type)</span><br><span class="line">	&#123; _M_fill_insert(__pos, __n, __val); &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Called by the range insert to implement [23.1.1]/9</span></span><br><span class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _InputIterator&gt;</span><br><span class="line">	<span class="keyword">void</span></span><br><span class="line">	_M_insert_dispatch(iterator __pos, _InputIterator __first,</span><br><span class="line">			   _InputIterator __last, __false_type)</span><br><span class="line">	&#123;</span><br><span class="line">	  _M_range_insert(__pos, __first, __last,</span><br><span class="line">			  std::__iterator_category(__first));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Called by the second insert_dispatch above</span></span><br><span class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _InputIterator&gt;</span><br><span class="line">	<span class="keyword">void</span></span><br><span class="line">	_M_range_insert(iterator __pos, _InputIterator __first,</span><br><span class="line">			_InputIterator __last, std::input_iterator_tag);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Called by the second insert_dispatch above</span></span><br><span class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ForwardIterator&gt;</span><br><span class="line">	<span class="keyword">void</span></span><br><span class="line">	_M_range_insert(iterator __pos, _ForwardIterator __first,</span><br><span class="line">			_ForwardIterator __last, std::forward_iterator_tag);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Called by insert(p,n,x), and the range insert when it turns out to be</span></span><br><span class="line">      <span class="comment">// the same thing.</span></span><br><span class="line">      <span class="keyword">void</span></span><br><span class="line">      _M_fill_insert(iterator __pos, size_type __n, <span class="keyword">const</span> value_type&amp; __x);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">      <span class="comment">// Called by resize(n).</span></span><br><span class="line">      <span class="keyword">void</span></span><br><span class="line">      _M_default_append(size_type __n);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">bool</span></span><br><span class="line">      _M_shrink_to_fit();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &lt; 201103L</span></span><br><span class="line">      <span class="comment">// Called by insert(p,x)</span></span><br><span class="line">      <span class="keyword">void</span></span><br><span class="line">      _M_insert_aux(iterator __position, <span class="keyword">const</span> value_type&amp; __x);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">void</span></span><br><span class="line">      _M_realloc_insert(iterator __position, <span class="keyword">const</span> value_type&amp; __x);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      <span class="comment">// A value_type object constructed with _Alloc_traits::construct()</span></span><br><span class="line">      <span class="comment">// and destroyed with _Alloc_traits::destroy().</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> _<span class="title">Temporary_value</span></span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span>... _Args&gt;</span><br><span class="line">	  <span class="keyword">explicit</span></span><br><span class="line">	  _Temporary_value(vector* __vec, _Args&amp;&amp;... __args) : _M_this(__vec)</span><br><span class="line">	  &#123;</span><br><span class="line">	    _Alloc_traits::<span class="built_in">construct</span>(_M_this-&gt;_M_impl, _M_ptr(),</span><br><span class="line">				     std::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	~_Temporary_value()</span><br><span class="line">	&#123; _Alloc_traits::<span class="built_in">destroy</span>(_M_this-&gt;_M_impl, _M_ptr()); &#125;</span><br><span class="line"></span><br><span class="line">	value_type&amp;</span><br><span class="line">	_M_val() &#123; <span class="keyword">return</span> *_M_ptr(); &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span>:</span><br><span class="line">	_Tp*</span><br><span class="line">	_M_ptr() &#123; <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;_Tp*&gt;(&amp;__buf); &#125;</span><br><span class="line"></span><br><span class="line">	vector* _M_this;</span><br><span class="line">	<span class="keyword">typename</span> aligned_storage&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(_Tp), <span class="built_in"><span class="keyword">alignof</span></span>(_Tp)&gt;::type __buf;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Called by insert(p,x) and other functions when insertion needs to</span></span><br><span class="line">      <span class="comment">// reallocate or move existing elements. _Arg is either _Tp&amp; or _Tp.</span></span><br><span class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Arg&gt;</span><br><span class="line">	<span class="keyword">void</span></span><br><span class="line">	_M_insert_aux(iterator __position, _Arg&amp;&amp; __arg);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... _Args&gt;</span><br><span class="line">	<span class="keyword">void</span></span><br><span class="line">	_M_realloc_insert(iterator __position, _Args&amp;&amp;... __args);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Either move-construct at the end, or forward to _M_insert_aux.</span></span><br><span class="line">      iterator</span><br><span class="line">      _M_insert_rval(const_iterator __position, value_type&amp;&amp; __v);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Try to emplace at the end, otherwise forward to _M_insert_aux.</span></span><br><span class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... _Args&gt;</span><br><span class="line">	iterator</span><br><span class="line">	_M_emplace_aux(const_iterator __position, _Args&amp;&amp;... __args);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Emplacing an rvalue of the correct type can use _M_insert_rval.</span></span><br><span class="line">      iterator</span><br><span class="line">      _M_emplace_aux(const_iterator __position, value_type&amp;&amp; __v)</span><br><span class="line">      &#123; <span class="keyword">return</span> _M_insert_rval(__position, std::<span class="built_in">move</span>(__v)); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Called by _M_fill_insert, _M_insert_aux etc.</span></span><br><span class="line">      size_type</span><br><span class="line">      _M_check_len(size_type __n, <span class="keyword">const</span> <span class="keyword">char</span>* __s) <span class="keyword">const</span></span><br><span class="line">      &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">max_size</span>() - <span class="built_in">size</span>() &lt; __n)</span><br><span class="line">	  __throw_length_error(__N(__s));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> size_type __len = <span class="built_in">size</span>() + (std::max)(<span class="built_in">size</span>(), __n);</span><br><span class="line">	<span class="keyword">return</span> (__len &lt; <span class="built_in">size</span>() || __len &gt; <span class="built_in">max_size</span>()) ? <span class="built_in">max_size</span>() : __len;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Called by constructors to check initial size.</span></span><br><span class="line">      <span class="keyword">static</span> size_type</span><br><span class="line">      _S_check_init_len(size_type __n, <span class="keyword">const</span> allocator_type&amp; __a)</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="keyword">if</span> (__n &gt; _S_max_size(_Tp_alloc_type(__a)))</span><br><span class="line">	  __throw_length_error(</span><br><span class="line">	      __N(<span class="string">&quot;cannot create std::vector larger than max_size()&quot;</span>));</span><br><span class="line">	<span class="keyword">return</span> __n;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">static</span> size_type</span><br><span class="line">      _S_max_size(<span class="keyword">const</span> _Tp_alloc_type&amp; __a) _GLIBCXX_NOEXCEPT</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="comment">// std::distance(begin(), end()) cannot be greater than PTRDIFF_MAX,</span></span><br><span class="line">	<span class="comment">// and realistically we can&#x27;t store more than PTRDIFF_MAX/sizeof(T)</span></span><br><span class="line">	<span class="comment">// (even if std::allocator_traits::max_size says we can).</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">size_t</span> __diffmax</span><br><span class="line">	  = __gnu_cxx::__numeric_traits&lt;<span class="keyword">ptrdiff_t</span>&gt;::__max / <span class="built_in"><span class="keyword">sizeof</span></span>(_Tp);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">size_t</span> __allocmax = _Alloc_traits::<span class="built_in">max_size</span>(__a);</span><br><span class="line">	<span class="keyword">return</span> (std::min)(__diffmax, __allocmax);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Internal erase functions follow.</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Called by erase(q1,q2), clear(), resize(), _M_fill_assign,</span></span><br><span class="line">      <span class="comment">// _M_assign_aux.</span></span><br><span class="line">      <span class="keyword">void</span></span><br><span class="line">      _M_erase_at_end(pointer __pos) _GLIBCXX_NOEXCEPT</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="keyword">if</span> (size_type __n = <span class="keyword">this</span>-&gt;_M_impl._M_finish - __pos)</span><br><span class="line">	  &#123;</span><br><span class="line">	    std::_Destroy(__pos, <span class="keyword">this</span>-&gt;_M_impl._M_finish,</span><br><span class="line">			  _M_get_Tp_allocator());</span><br><span class="line">	    <span class="keyword">this</span>-&gt;_M_impl._M_finish = __pos;</span><br><span class="line">	    _GLIBCXX_ASAN_ANNOTATE_SHRINK(__n);</span><br><span class="line">	  &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      iterator</span><br><span class="line">      _M_erase(iterator __position);</span><br><span class="line"></span><br><span class="line">      iterator</span><br><span class="line">      _M_erase(iterator __first, iterator __last);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      <span class="comment">// Constant-time move assignment when source object&#x27;s memory can be</span></span><br><span class="line">      <span class="comment">// moved, either because the source&#x27;s allocator will move too</span></span><br><span class="line">      <span class="comment">// or because the allocators are equal.</span></span><br><span class="line">      <span class="keyword">void</span></span><br><span class="line">      _M_move_assign(vector&amp;&amp; __x, true_type) <span class="keyword">noexcept</span></span><br><span class="line">      &#123;</span><br><span class="line">	vector __tmp(<span class="built_in">get_allocator</span>());</span><br><span class="line">	<span class="keyword">this</span>-&gt;_M_impl._M_swap_data(__x._M_impl);</span><br><span class="line">	__tmp._M_impl._M_swap_data(__x._M_impl);</span><br><span class="line">	std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Do move assignment when it might not be possible to move source</span></span><br><span class="line">      <span class="comment">// object&#x27;s memory, resulting in a linear-time operation.</span></span><br><span class="line">      <span class="keyword">void</span></span><br><span class="line">      _M_move_assign(vector&amp;&amp; __x, false_type)</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="keyword">if</span> (__x._M_get_Tp_allocator() == <span class="keyword">this</span>-&gt;_M_get_Tp_allocator())</span><br><span class="line">	  _M_move_assign(std::<span class="built_in">move</span>(__x), <span class="built_in">true_type</span>());</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	  &#123;</span><br><span class="line">	    <span class="comment">// The rvalue&#x27;s allocator cannot be moved and is not equal,</span></span><br><span class="line">	    <span class="comment">// so we need to individually move each element.</span></span><br><span class="line">	    <span class="keyword">this</span>-&gt;<span class="built_in">assign</span>(std::__make_move_if_noexcept_iterator(__x.<span class="built_in">begin</span>()),</span><br><span class="line">			 std::__make_move_if_noexcept_iterator(__x.<span class="built_in">end</span>()));</span><br><span class="line">	    __x.<span class="built_in">clear</span>();</span><br><span class="line">	  &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Up&gt;</span><br><span class="line">	_Up*</span><br><span class="line">	_M_data_ptr(_Up* __ptr) <span class="keyword">const</span> _GLIBCXX_NOEXCEPT</span><br><span class="line">	&#123; <span class="keyword">return</span> __ptr; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Ptr&gt;</span><br><span class="line">	<span class="keyword">typename</span> std::pointer_traits&lt;_Ptr&gt;::element_type*</span><br><span class="line">	_M_data_ptr(_Ptr __ptr) <span class="keyword">const</span></span><br><span class="line">	&#123; <span class="keyword">return</span> <span class="built_in">empty</span>() ? <span class="literal">nullptr</span> : std::__to_address(__ptr); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Up&gt;</span><br><span class="line">	_Up*</span><br><span class="line">	_M_data_ptr(_Up* __ptr) _GLIBCXX_NOEXCEPT</span><br><span class="line">	&#123; <span class="keyword">return</span> __ptr; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Ptr&gt;</span><br><span class="line">	value_type*</span><br><span class="line">	_M_data_ptr(_Ptr __ptr)</span><br><span class="line">	&#123; <span class="keyword">return</span> <span class="built_in">empty</span>() ? (value_type*)<span class="number">0</span> : __ptr.<span class="keyword">operator</span>-&gt;(); &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Ptr&gt;</span><br><span class="line">	<span class="keyword">const</span> value_type*</span><br><span class="line">	_M_data_ptr(_Ptr __ptr) <span class="keyword">const</span></span><br><span class="line">	&#123; <span class="keyword">return</span> <span class="built_in">empty</span>() ? (<span class="keyword">const</span> value_type*)<span class="number">0</span> : __ptr.<span class="keyword">operator</span>-&gt;(); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h4><p><strong>input:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_print</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ovec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = ovec.begin();</span><br><span class="line">    <span class="keyword">for</span>(it; it != ovec.end(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; *it ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; first;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; second;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; third;</span><br><span class="line"></span><br><span class="line">  first.assign (<span class="number">7</span>,<span class="number">100</span>);             <span class="comment">// 7 ints with a value of 100</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">  it=first.begin()+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  second.assign (it,first.end()<span class="number">-1</span>); <span class="comment">// the 5 central values of first</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> myints[] = &#123;<span class="number">1776</span>,<span class="number">7</span>,<span class="number">4</span>&#125;;</span><br><span class="line">  third.assign (myints,myints+<span class="number">3</span>);   <span class="comment">// assigning from array.</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size of first: &quot;</span> &lt;&lt; <span class="keyword">int</span> (first.size()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  func_print(first);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size of second: &quot;</span> &lt;&lt; <span class="keyword">int</span> (second.size()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  func_print(second);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Size of third: &quot;</span> &lt;&lt; <span class="keyword">int</span> (third.size()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  func_print(third);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>output:</strong></p>
<pre><code>Size of first: 7
 100 100 100 100 100 100 100
Size of second: 5
 100 100 100 100 100
Size of third: 3
 1776 7 4

Process returned 0 (0x0)   execution time : 0.015 s
Press any key to continue.</code></pre>
<p><strong>总结</strong></p>
<p>assgin有2个实现：</p>
<blockquote>
<p>void assign (InputIterator first, InputIterator last);</p>
</blockquote>
<blockquote>
<p>void assign (size_type n, const value_type&amp; val);</p>
</blockquote>
<p>带范围的assign的最后一个参数是不会被复制的，<br><br>如first = it, last = it + 5, 则一共复制5个值 <br></p>
<pre><code>it, it+1, it+2, it+3, it+4</code></pre>
<p>end()函数是vector最后一个元素的后一个元素，一般值为0</p>
<p>cout打印iterator的地址： &amp;*it</p>
<hr>
<h4 id="push-bask"><a href="#push-bask" class="headerlink" title="push_bask()"></a>push_bask()</h4><p><code> void push_back (const value_type&amp; val);</code></p>
<blockquote>
<p>Adds a new element at the end of the vector, after its current last element. The content of val is copied (or moved) to the new element.</p>
</blockquote>
<blockquote>
<p>This effectively increases the container size by one, which causes an automatic reallocation of the allocated storage space if -and only if- the new vector size surpasses the current vector capacity.</p>
</blockquote>
<pre><code>void
  push_back(const value_type&amp; __x)
  &#123;
if (this-&gt;_M_impl._M_finish != this-&gt;_M_impl._M_end_of_storage)
  &#123;
    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
    _Alloc_traits::construct(this-&gt;_M_impl, this-&gt;_M_impl._M_finish,
                 __x);
    ++this-&gt;_M_impl._M_finish;
    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
  &#125;
else
  _M_realloc_insert(end(), __x);
  &#125;</code></pre>
<p>扩容实现见下文空间配置实现</p>
<h4 id="pop-back"><a href="#pop-back" class="headerlink" title="pop_back()"></a>pop_back()</h4><p><code>void pop_back（）;</code></p>
<blockquote>
<p>Removes the last element in the vector, effectively reducing the container size by one.</p>
</blockquote>
<blockquote>
<p>This destroys the removed element.</p>
</blockquote>
<pre><code>void
  pop_back() _GLIBCXX_NOEXCEPT
  &#123;
__glibcxx_requires_nonempty();
--this-&gt;_M_impl._M_finish;
_Alloc_traits::destroy(this-&gt;_M_impl, this-&gt;_M_impl._M_finish);
_GLIBCXX_ASAN_ANNOTATE_SHRINK(1);
  &#125;</code></pre>
<p>从最后删除一个元素，这并不会导致vector的总容量变化</p>
<h4 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h4><p><code>size_type size() const;</code></p>
<blockquote>
<p>Returns the number of elements in the vector.</p>
</blockquote>
<blockquote>
<p>This is the number of actual objects held in the vector, which is not necessarily equal to its storage capacity.</p>
</blockquote>
<pre><code>size_type
  size() const _GLIBCXX_NOEXCEPT
  &#123; return size_type(this-&gt;_M_impl._M_finish - this-&gt;_M_impl._M_start); &#125;</code></pre>
<h4 id="begin"><a href="#begin" class="headerlink" title="begin()"></a>begin()</h4><p><code>iterator begin();     const_iterator begin() const;</code></p>
<blockquote>
<p>Returns an iterator pointing to the first element in the vector.</p>
</blockquote>
<blockquote>
<p>Notice that, unlike member vector::front, which returns a reference to the first element, this function returns a random access iterator pointing to it.</p>
</blockquote>
<blockquote>
<p>If the container is empty, the returned iterator value shall not be dereferenced.</p>
</blockquote>
<pre><code>iterator
  begin() _GLIBCXX_NOEXCEPT
  &#123; return iterator(this-&gt;_M_impl._M_start); &#125;


const_iterator
  begin() const _GLIBCXX_NOEXCEPT
  &#123; return const_iterator(this-&gt;_M_impl._M_start); &#125;</code></pre>
<h4 id="front"><a href="#front" class="headerlink" title="front()"></a>front()</h4><p><code>reference front(); const_reference front() const;</code></p>
<blockquote>
<p>Access first element<br>Returns a reference to the first element in the vector.</p>
</blockquote>
<blockquote>
<p>Unlike member vector::begin, which returns an iterator to this same element, this function returns a direct reference.</p>
</blockquote>
<blockquote>
<p>Calling this function on an empty container causes undefined behavior.</p>
</blockquote>
<pre><code>reference
  front() _GLIBCXX_NOEXCEPT
  &#123;
__glibcxx_requires_nonempty();
return *begin();
  &#125;

const_reference
  front() const _GLIBCXX_NOEXCEPT
  &#123;
__glibcxx_requires_nonempty();
return *begin();
  &#125;</code></pre>
<p>front返回的是*begin(),是引用</p>
<h4 id="back"><a href="#back" class="headerlink" title="back()"></a>back()</h4><p><code>reference back(); const_reference back() const;</code></p>
<blockquote>
<p>Returns a reference to the last element in the vector.</p>
</blockquote>
<pre><code>reference
  back() _GLIBCXX_NOEXCEPT
  &#123;
__glibcxx_requires_nonempty();
return *(end() - 1);
  &#125;

 const_reference
  back() const _GLIBCXX_NOEXCEPT
  &#123;
__glibcxx_requires_nonempty();
return *(end() - 1);</code></pre>
<p>back返回最后一个值，返回值是reference <br><br>end返回最后一个元素的下一个元素，是iterator</p>
<h4 id="end"><a href="#end" class="headerlink" title="end()"></a>end()</h4><p><code>iterator end(); const_iterator end() const;</code></p>
<blockquote>
<p>Returns an iterator referring to the past-the-end element in the vector container.</p>
</blockquote>
<pre><code>iterator
  end() _GLIBCXX_NOEXCEPT
  &#123; return iterator(this-&gt;_M_impl._M_finish); &#125;

const_iterator
  end() const _GLIBCXX_NOEXCEPT
  &#123; return const_iterator(this-&gt;_M_impl._M_finish); &#125;</code></pre>
<h4 id="rbegin"><a href="#rbegin" class="headerlink" title="rbegin()"></a>rbegin()</h4><p><code>const_iterator cbegin() const noexcept;</code></p>
<blockquote>
<p>Return const_iterator to beginning</p>
</blockquote>
<pre><code>reverse_iterator
  rbegin() _GLIBCXX_NOEXCEPT
  &#123; return reverse_iterator(end()); &#125;

const_reverse_iterator
  rbegin() const _GLIBCXX_NOEXCEPT
  &#123; return const_reverse_iterator(end()); &#125;</code></pre>
<h4 id="rend"><a href="#rend" class="headerlink" title="rend()"></a>rend()</h4><h4 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h4><hr>
<h3 id="空间配置原则"><a href="#空间配置原则" class="headerlink" title="空间配置原则"></a>空间配置原则</h3><p><img src="https://i.loli.net/2020/03/10/cn9BTedJwO1yH3X.png" alt="vector内存布局.png"></p>
<pre><code>template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt; &gt;
class vector : protected _Vector_base&lt;_Tp, _Alloc&gt;
&#123;
    ...
&#125;

template&lt;typename _Tp, typename _Alloc&gt;
struct _Vector_base
&#123;

    struct _Vector_impl_data
      &#123;
        pointer _M_start;                //表示目前使用空间的头
        pointer _M_finish;                //表示目前使用空间的尾
        pointer _M_end_of_storage;        //表示目前可用空间的尾
        ...
      &#125;

&#125;</code></pre>
<p><strong>input</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::vector&lt;<span class="keyword">int</span>&gt; vec ;</span><br><span class="line">	vec.<span class="built_in">push_back</span>(<span class="number">8</span>);</span><br><span class="line">	vec.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line">	vec.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">	vec.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* stl_vector.h  gcc 4.8.5 c++ 98</span></span><br><span class="line"><span class="comment">900	  void</span></span><br><span class="line"><span class="comment">901		   push_back(const value_type&amp; __x)</span></span><br><span class="line"><span class="comment">902		   &#123;</span></span><br><span class="line"><span class="comment">903		 if (this-&gt;_M_impl._M_finish != this-&gt;_M_impl._M_end_of_storage)</span></span><br><span class="line"><span class="comment">904		   &#123;</span></span><br><span class="line"><span class="comment">905		 	 _Alloc_traits::construct(this-&gt;_M_impl, this-&gt;_M_impl._M_finish,</span></span><br><span class="line"><span class="comment">906									  __x);</span></span><br><span class="line"><span class="comment">907			 ++this-&gt;_M_impl._M_finish;</span></span><br><span class="line"><span class="comment">908		   &#125;</span></span><br><span class="line"><span class="comment">909		 else</span></span><br><span class="line"><span class="comment">910	 #if __cplusplus &gt;= 201103L</span></span><br><span class="line"><span class="comment">911		   _M_emplace_back_aux(__x);</span></span><br><span class="line"><span class="comment">912	 #else</span></span><br><span class="line"><span class="comment">913		   _M_insert_aux(end(), __x);</span></span><br><span class="line"><span class="comment">914	 #endif</span></span><br><span class="line"><span class="comment">915		   &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>output</strong></p>
<pre><code>Breakpoint 5, std::vector&lt;int, std::allocator&lt;int&gt; &gt;::push_back (this=0x7fffffffe220, __x=@0x7fffffffe244: 8) at /usr/include/c++/4.8.2/bits/stl_vector.h:915
915          &#125;
(gdb) p (this-&gt;_M_impl._M_start)
$17 = (std::_Vector_base&lt;int, std::allocator&lt;int&gt; &gt;::pointer) 0x604010
(gdb) p (this-&gt;_M_impl._M_finish)
$18 = (std::_Vector_base&lt;int, std::allocator&lt;int&gt; &gt;::pointer) 0x604014
(gdb) p (this-&gt;_M_impl._M_end_of_storage)
$19 = (std::_Vector_base&lt;int, std::allocator&lt;int&gt; &gt;::pointer) 0x604014
(gdb) p (this-&gt;_M_impl._M_end_of_storage-this-&gt;_M_impl._M_start)
$20 = 1
(gdb) p *(this-&gt;_M_impl._M_start)
$21 = 8
(gdb) c
Continuing.

Breakpoint 4, std::vector&lt;int, std::allocator&lt;int&gt; &gt;::push_back (this=0x7fffffffe220, __x=@0x7fffffffe248: 6) at /usr/include/c++/4.8.2/bits/stl_vector.h:903
903        if (this-&gt;_M_impl._M_finish != this-&gt;_M_impl._M_end_of_storage)
(gdb) c
Continuing.

Breakpoint 5, std::vector&lt;int, std::allocator&lt;int&gt; &gt;::push_back (this=0x7fffffffe220, __x=@0x7fffffffe248: 6) at /usr/include/c++/4.8.2/bits/stl_vector.h:915
915          &#125;
(gdb) p (this-&gt;_M_impl._M_start)
$22 = (std::_Vector_base&lt;int, std::allocator&lt;int&gt; &gt;::pointer) 0x604030
(gdb) p (this-&gt;_M_impl._M_finish)
$23 = (std::_Vector_base&lt;int, std::allocator&lt;int&gt; &gt;::pointer) 0x604038
(gdb) p (this-&gt;_M_impl._M_end_of_storage)
$24 = (std::_Vector_base&lt;int, std::allocator&lt;int&gt; &gt;::pointer) 0x604038
(gdb) p (this-&gt;_M_impl._M_end_of_storage-this-&gt;_M_impl._M_start)
$25 = 2
(gdb) p *(this-&gt;_M_impl._M_start)
$26 = 8
(gdb) p *(this-&gt;_M_impl._M_start+1)
$27 = 6
(gdb) p (this-&gt;_M_impl._M_start+1)
$28 = (int *) 0x604034
(gdb) c
Continuing.

Breakpoint 4, std::vector&lt;int, std::allocator&lt;int&gt; &gt;::push_back (this=0x7fffffffe220, __x=@0x7fffffffe24c: 7) at /usr/include/c++/4.8.2/bits/stl_vector.h:903
903        if (this-&gt;_M_impl._M_finish != this-&gt;_M_impl._M_end_of_storage)
(gdb) c
Continuing.

Breakpoint 5, std::vector&lt;int, std::allocator&lt;int&gt; &gt;::push_back (this=0x7fffffffe220, __x=@0x7fffffffe24c: 7) at /usr/include/c++/4.8.2/bits/stl_vector.h:915
915          &#125;
(gdb) p (this-&gt;_M_impl._M_start)
$29 = (std::_Vector_base&lt;int, std::allocator&lt;int&gt; &gt;::pointer) 0x604010
(gdb) p (this-&gt;_M_impl._M_finish)
$30 = (std::_Vector_base&lt;int, std::allocator&lt;int&gt; &gt;::pointer) 0x60401c
(gdb) p (this-&gt;_M_impl._M_end_of_storage-this-&gt;_M_impl._M_start)
$31 = 4
(gdb) p (this-&gt;_M_impl._M_end_of_storage)
$32 = (std::_Vector_base&lt;int, std::allocator&lt;int&gt; &gt;::pointer) 0x604020
(gdb) p *(this-&gt;_M_impl._M_start+2)
$33 = 7
(gdb) p (this-&gt;_M_impl._M_start+2)
$34 = (int *) 0x604018
(gdb) q</code></pre>
<h3 id="空间配置实现"><a href="#空间配置实现" class="headerlink" title="空间配置实现"></a>空间配置实现</h3><pre><code>//*******************vector constructor
explicit
  vector(size_type __n, const value_type&amp; __value = value_type(),
     const allocator_type&amp; __a = allocator_type())
  : _Base(_S_check_init_len(__n, __a), __a)
  &#123; _M_fill_initialize(__n, __value); &#125;


  //*******************_M_fill_initialize
  // Called by the first initialize_dispatch above and by the
  // vector(n,value,a) constructor.
  void
  _M_fill_initialize(size_type __n, const value_type&amp; __value)
  &#123;
this-&gt;_M_impl._M_finish =
  std::__uninitialized_fill_n_a(this-&gt;_M_impl._M_start, __n, __value,
                _M_get_Tp_allocator());
  &#125;

//*******************__uninitialized_fill_n_a
//__uninitialized_fill_n_a会根据第一参数的型别特性（type traits），
//决定使用算法 fill_n()或反复呼叫 construct() 来完成任务
template&lt;typename _ForwardIterator, typename _Size, typename _Tp,
   typename _Allocator&gt;
_ForwardIterator
__uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, 
             const _Tp&amp; __x, _Allocator&amp; __alloc)
&#123;
  _ForwardIterator __cur = __first;
  __try
&#123;
  typedef __gnu_cxx::__alloc_traits&lt;_Allocator&gt; __traits;
  for (; __n &gt; 0; --__n, (void) ++__cur)
    __traits::construct(__alloc, std::__addressof(*__cur), __x);
  return __cur;
&#125;
  __catch(...)
&#123;
  std::_Destroy(__first, __cur, __alloc);
  __throw_exception_again;
&#125;
&#125;

//__uninitialized_fill_n_a使用uninitialized_fill_n
template&lt;typename _ForwardIterator, typename _Size, typename _Tp,
   typename _Tp2&gt;
inline _ForwardIterator
__uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, 
             const _Tp&amp; __x, allocator&lt;_Tp2&gt;&amp;)
&#123; return std::uninitialized_fill_n(__first, __n, __x); &#125;</code></pre>
<h3 id="constructor-与-–"><a href="#constructor-与-–" class="headerlink" title="constructor 与 ++ –"></a>constructor 与 ++ –</h3><h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/03/09/b7jev9FIWwMGXsN.jpg" alt="tumblr_pd1i8dNW3U1sfie3io1_1280.jpg"></p>
]]></content>
      <tags>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title>c++基础知识点</title>
    <url>/2020-03-29-c++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>以前面试准备的，比较凌乱，先放这里</p>
<a id="more"></a>


<h2 id="001-说一下static关键字的作用"><a href="#001-说一下static关键字的作用" class="headerlink" title="001 说一下static关键字的作用"></a>001 说一下static关键字的作用</h2><p><strong>1. 全局静态变量</strong></p>
<p>在全局变量前加上关键字static，全局变量就定义成一个全局静态变量.</p>
<p>静态存储区，在整个程序运行期间一直存在。</p>
<p>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；</p>
<p>作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。</p>
<p><strong>2.  局部静态变量</strong></p>
<p>在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。</p>
<p>内存中的位置：静态存储区</p>
<p>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；</p>
<p>作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；</p>
<p><strong>3. 静态函数</strong></p>
<p>在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。</p>
<p>函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；</p>
<p>warning：不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；</p>
<p><strong>4. 类的静态成员</strong></p>
<p>在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用</p>
<p><strong>5. 类的静态函数</strong></p>
<p>静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。</p>
<p>在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;);</p>
<h2 id="002-extern关键字"><a href="#002-extern关键字" class="headerlink" title="002 extern关键字"></a>002 extern关键字</h2><p>我们知道，程序的编译单位是源程序文件，一个源文件可以包含一个或若干个函数。在函数内定义的变量是局部变量，而在函数之外定义的变量则称为外部变量，外部变量也就是我们所讲的全局变量。它的存储方式为静态存储，其生存周期为整个程序的生存周期。全局变量可以为本文件中的其他函数所共用，它的有效范围为从定义变量的位置开始到本源文件结束。</p>
<p>然而，如果全局变量不在文件的开头定义，有效的作用范围将只限于其定义处到文件结束。如果在定义点之前的函数想引用该全局变量，则应该在引用之前用关键字 extern 对该变量作“外部变量声明”，表示该变量是一个已经定义的外部变量。有了此声明，就可以从“声明”处起，合法地使用该外部变量。</p>
<h2 id="003-C-和C的区别"><a href="#003-C-和C的区别" class="headerlink" title="003 C++和C的区别"></a>003 C++和C的区别</h2><p><strong>设计思想上：</strong></p>
<p>C++是面向对象的语言，而C是面向过程的结构化编程语言</p>
<p><strong>语法上：</strong></p>
<p>C++具有封装、继承和多态三种特性</p>
<p>C++相比C，增加多许多类型安全的功能，比如强制类型转换、</p>
<p>C++支持范式编程，比如模板类、函数模板等</p>
<h2 id="004-说一说c-中四种cast转换"><a href="#004-说一说c-中四种cast转换" class="headerlink" title="004 说一说c++中四种cast转换"></a>004 说一说c++中四种cast转换</h2><p>C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast</p>
<p><strong>1、const_cast</strong></p>
<p>用于将const变量转为非const</p>
<p><strong>2、static_cast</strong></p>
<p>用于各种隐式转换，比如非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知；</p>
<p><strong>3、dynamic_cast</strong></p>
<p>用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。</p>
<p>向上转换：指的是子类向基类的转换</p>
<p>向下转换：指的是基类向子类的转换</p>
<p>它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。</p>
<p><strong>4、reinterpret_cast</strong></p>
<p>几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；</p>
<p><strong>5、为什么不使用C的强制转换？</strong></p>
<p>C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。</p>
<h2 id="005-请说一下C-C-中指针和引用的区别？"><a href="#005-请说一下C-C-中指针和引用的区别？" class="headerlink" title="005 请说一下C/C++ 中指针和引用的区别？"></a>005 请说一下C/C++ 中指针和引用的区别？</h2><p>1.指针有自己的一块空间，而引用只是一个别名；<br><br>2.使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；<br><br>3.指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；<br><br>4.作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；<br><br>5.可以有const指针，但是没有const引用；<br><br>6.指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；<br><br>7.指针可以有多级指针（**p），而引用至于一级；<br><br>8.指针和引用使用++运算符的意义不一样；<br><br>9.如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。<br></p>
<h2 id="006-智能指针"><a href="#006-智能指针" class="headerlink" title="006 智能指针"></a>006 智能指针</h2><h2 id="007-指针和数组的主要区别如下"><a href="#007-指针和数组的主要区别如下" class="headerlink" title="007 指针和数组的主要区别如下"></a>007 指针和数组的主要区别如下</h2><p><a href="https://blog.csdn.net/Dawn_sf/article/details/54588128">数组和指针的比较和关系以及区别</a></p>
<h2 id="008-请你回答一下野指针是什么？"><a href="#008-请你回答一下野指针是什么？" class="headerlink" title="008 请你回答一下野指针是什么？"></a>008 请你回答一下野指针是什么？</h2><p>野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针</p>
<h2 id="009-为什么析构函数必须是虚函数？为什么C-默认的析构函数不是虚函数-考点-虚函数-析构函数"><a href="#009-为什么析构函数必须是虚函数？为什么C-默认的析构函数不是虚函数-考点-虚函数-析构函数" class="headerlink" title="009 为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数 考点:虚函数 析构函数"></a>009 为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数 考点:虚函数 析构函数</h2><p>将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。</p>
<p>C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</p>
<h2 id="010-请你来说一下函数指针"><a href="#010-请你来说一下函数指针" class="headerlink" title="010 请你来说一下函数指针"></a>010 请你来说一下函数指针</h2><p><strong>1、定义</strong><br>函数指针是指向函数的指针变量。</p>
<p>函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。</p>
<p>C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。</p>
<p><strong>2、用途：</strong></p>
<p>调用函数和做函数的参数，比如回调函数。</p>
<p><strong>3、示例：</strong></p>
<p>char * fun(char * p)  {…}       // 函数fun</p>
<p>char * (*pf)(char * p);             // 函数指针pf</p>
<p>pf = fun;                        // 函数指针pf指向函数fun</p>
<p>pf(p);                        // 通过函数指针pf调用函数fun</p>
<h2 id="011-请你来说一下fork函数"><a href="#011-请你来说一下fork函数" class="headerlink" title="011 请你来说一下fork函数"></a>011 请你来说一下fork函数</h2><p>Fork：创建一个和当前进程映像一样的进程可以通过fork( )系统调用：<br>#include &lt;sys/types.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>pid_t fork(void);</p>
<p>成功调用fork( )会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错误，fork( )返回一个负值。</p>
<p>最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。</p>
<p>在早期的Unix系统中，创建进程比较原始。当调用fork时，内核会把所有的内部数据结构复制一份，复制进程的页表项，然后把父进程的地址空间中的内容逐页的复制到子进程的地址空间中。但从内核角度来说，逐页的复制方式是十分耗时的。现代的Unix系统采取了更多的优化，例如Linux，采用了写时复制的方法，而不是对父进程空间进程整体复制。</p>
<h2 id="012-请你来说一下C-中析构函数的作用"><a href="#012-请你来说一下C-中析构函数的作用" class="headerlink" title="012 请你来说一下C++中析构函数的作用"></a>012 请你来说一下C++中析构函数的作用</h2><p>析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。<br>析构函数名也应与类名相同，只是在函数名前面加一个位取反符<del>，例如</del>stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。</p>
<p>如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。</p>
<p>如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。</p>
<p>类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。</p>
<h2 id="013-请你来说一下静态函数和虚函数的区别"><a href="#013-请你来说一下静态函数和虚函数的区别" class="headerlink" title="013 请你来说一下静态函数和虚函数的区别"></a>013 请你来说一下静态函数和虚函数的区别</h2><p>静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销</p>
<h2 id="014-请你来说一说重载和覆盖"><a href="#014-请你来说一说重载和覆盖" class="headerlink" title="014 请你来说一说重载和覆盖"></a>014 请你来说一说重载和覆盖</h2><p>重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中<br>重写：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写</p>
<p><a href="https://www.cnblogs.com/skynet/archive/2010/09/05/1818636.html">C++的函数重载</a></p>
<h2 id="015-请你说一说strcpy和strlen"><a href="#015-请你说一说strcpy和strlen" class="headerlink" title="015 请你说一说strcpy和strlen"></a>015 请你说一说strcpy和strlen</h2><p>strcpy是字符串拷贝函数，原型：<br>char <em>strcpy(char</em> dest, const char *src);</p>
<p>从src逐字节拷贝到dest，直到遇到’\0’结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,安全版本是strncpy函数。<br>strlen函数是计算字符串长度的函数，返回从开始到’\0’之间的字符个数。</p>
<h2 id="016-请你说一说你理解的虚函数和多态"><a href="#016-请你说一说你理解的虚函数和多态" class="headerlink" title="016 请你说一说你理解的虚函数和多态"></a>016 请你说一说你理解的虚函数和多态</h2><p>多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。<br>虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。</p>
<h2 id="017-请你来回答一下-i和i-的区别"><a href="#017-请你来回答一下-i和i-的区别" class="headerlink" title="017 请你来回答一下++i和i++的区别"></a>017 请你来回答一下++i和i++的区别</h2><p>++i先自增1，再返回，i++先返回i,再自增1</p>
<h2 id="018-请你来写个函数在main函数执行前先运行"><a href="#018-请你来写个函数在main函数执行前先运行" class="headerlink" title="018 请你来写个函数在main函数执行前先运行"></a>018 请你来写个函数在main函数执行前先运行</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__attribute((constructor))<span class="function"><span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;before main\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="019-以下四行代码的区别是什么？"><a href="#019-以下四行代码的区别是什么？" class="headerlink" title="019 以下四行代码的区别是什么？"></a>019 以下四行代码的区别是什么？</h2><p>const char * arr = “123”; char * brr = “123”; const char crr[] = “123”; char drr[] = “123”;</p>
<p>const char * arr = “123”;<br>//字符串123保存在常量区，const本来是修饰arr指向的值不能通过arr去修改，但是字符串“123”在常量区，本来就不能改变，所以加不加const效果都一样</p>
<p>char * brr = “123”;</p>
<p>//字符串123保存在常量区，这个arr指针指向的是同一个位置，同样不能通过brr去修改”123”的值</p>
<p>const char crr[] = “123”;</p>
<p>//这里123本来是在栈上的，但是编译器可能会做某些优化，将其放到常量区</p>
<p>char drr[] = “123”;</p>
<p>//字符串123保存在栈区，可以通过drr去修改</p>
<h2 id="020-请你来说一下C-里是怎么定义常量的？常量存放在内存的哪个位置？"><a href="#020-请你来说一下C-里是怎么定义常量的？常量存放在内存的哪个位置？" class="headerlink" title="020 请你来说一下C++里是怎么定义常量的？常量存放在内存的哪个位置？"></a>020 请你来说一下C++里是怎么定义常量的？常量存放在内存的哪个位置？</h2><p>常量在C++里的定义就是一个top-level const加上对象类型，常量定义必须初始化。对于局部对象，常量存放在栈区，对于全局对象，常量存放在全局/静态存储区。对于字面值常量，常量存放在常量存储区。</p>
<h2 id="021-请你来回答一下const修饰成员函数的目的是什么？"><a href="#021-请你来回答一下const修饰成员函数的目的是什么？" class="headerlink" title="021 请你来回答一下const修饰成员函数的目的是什么？"></a>021 请你来回答一下const修饰成员函数的目的是什么？</h2><p>const修饰的成员函数表明函数调用不会对对象做出任何更改，事实上，如果确认不会对对象做更改，就应该为函数加上const限定，这样无论const对象还是普通对象都可以调用该函数。</p>
<h2 id="022-如果同时定义了两个函数，一个带const，一个不带，会有问题吗？"><a href="#022-如果同时定义了两个函数，一个带const，一个不带，会有问题吗？" class="headerlink" title="022 如果同时定义了两个函数，一个带const，一个不带，会有问题吗？"></a>022 如果同时定义了两个函数，一个带const，一个不带，会有问题吗？</h2><p>不会，这相当于函数的重载。</p>
<p>搜了下，这是一个牛客用户面经里的内容，小编直接复制粘贴过来了其中的一个片段。结合原文语境，这里的两个函数指的是一个类中两个成员函数，带const，const是放在函数后面的，也就是对this指针做const限定。所以说是重载</p>
<h2 id="023-请你来说一说隐式类型转换"><a href="#023-请你来说一说隐式类型转换" class="headerlink" title="023 请你来说一说隐式类型转换"></a>023 请你来说一说隐式类型转换</h2><h2 id="024-请你来说一说C-函数栈空间的最大值"><a href="#024-请你来说一说C-函数栈空间的最大值" class="headerlink" title="024 请你来说一说C++函数栈空间的最大值"></a>024 请你来说一说C++函数栈空间的最大值</h2><p>默认是1M，不过可以调整</p>
<h2 id="025-请你来说一说extern“C”"><a href="#025-请你来说一说extern“C”" class="headerlink" title="025 请你来说一说extern“C”"></a>025 请你来说一说extern“C”</h2><p>C++调用C函数需要extern C，因为C语言没有函数重载。</p>
<h2 id="026-请你回答一下new-delete与malloc-free的区别是什么"><a href="#026-请你回答一下new-delete与malloc-free的区别是什么" class="headerlink" title="026 请你回答一下new/delete与malloc/free的区别是什么"></a>026 请你回答一下new/delete与malloc/free的区别是什么</h2><p>首先，new/delete是C++的关键字，而malloc/free是C语言的库函数，后者使用必须指明申请内存空间的大小，对于类类型的对象，后者不会调用构造函数和析构函数</p>
<h2 id="027-请你说说虚函数表具体是怎样实现运行时多态的"><a href="#027-请你说说虚函数表具体是怎样实现运行时多态的" class="headerlink" title="027 请你说说虚函数表具体是怎样实现运行时多态的?"></a>027 请你说说虚函数表具体是怎样实现运行时多态的?</h2><p>子类若重写父类虚函数，虚函数表中，该函数的地址会被替换，对于存在虚函数的类的对象，在VS中，对象的对象模型的头部存放指向虚函数表的指针，通过该机制实现多态。</p>
<h2 id="028-请你说说C语言是怎么进行函数调用的？"><a href="#028-请你说说C语言是怎么进行函数调用的？" class="headerlink" title="028 请你说说C语言是怎么进行函数调用的？"></a>028 请你说说C语言是怎么进行函数调用的？</h2><p>每一个函数调用都会分配函数栈，在栈内进行函数执行过程。调用前，先把返回地址压栈，然后把当前函数的esp指针压栈。</p>
<h2 id="029-请你说说C语言参数压栈顺序？"><a href="#029-请你说说C语言参数压栈顺序？" class="headerlink" title="029 请你说说C语言参数压栈顺序？"></a>029 请你说说C语言参数压栈顺序？</h2><p>从右到左</p>
<h2 id="030-请你说说C-如何处理返回值？"><a href="#030-请你说说C-如何处理返回值？" class="headerlink" title="030 请你说说C++如何处理返回值？"></a>030 请你说说C++如何处理返回值？</h2><p>生成一个临时变量，把它的引用作为函数参数传入函数内。</p>
<h2 id="031-请你回答一下C-中拷贝赋值函数的形参能否进行值传递？"><a href="#031-请你回答一下C-中拷贝赋值函数的形参能否进行值传递？" class="headerlink" title="031 请你回答一下C++中拷贝赋值函数的形参能否进行值传递？"></a>031 请你回答一下C++中拷贝赋值函数的形参能否进行值传递？</h2><p>不能。如果是这种情况下，调用拷贝构造函数的时候，首先要将实参传递给形参，这个传递的时候又要调用拷贝构造函数。。如此循环，无法完成拷贝，栈也会满。</p>
<h2 id="032-请你回答一下malloc与new区别"><a href="#032-请你回答一下malloc与new区别" class="headerlink" title="032  请你回答一下malloc与new区别"></a>032  请你回答一下malloc与new区别</h2><p>malloc需要给定申请内存的大小，返回的指针需要强转。<br>new会调用构造函数，返回的指针不用强转。</p>
<p>区别是 new 失败了会掉一个 handler 做补救, 该 handler 默认是 nullptr.再一个是 new 失败了会丢 bad_alloc(如果没指定 nothrow 的话)再一个是 C++ 不许有 size 为 0 的对象, 所以这样的 new 会被强制转为 1</p>
<p>作者：a owensss<br>链接：<a href="https://www.zhihu.com/question/30115922/answer/46819323">https://www.zhihu.com/question/30115922/answer/46819323</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="033-请你说一说select"><a href="#033-请你说一说select" class="headerlink" title="033 请你说一说select"></a>033 请你说一说select</h2><p>select在使用前，先将需要监控的描述符对应的bit位置1，然后将其传给select,当有任何一个事件发生时，select将会返回所有的描述符，需要在应用程序自己遍历去检查哪个描述符上有事件发生，效率很低，并且其不断在内核态和用户态进行描述符的拷贝，开销很大</p>
<h2 id="034-请你说说fork-wait-exec函数"><a href="#034-请你说说fork-wait-exec函数" class="headerlink" title="034  请你说说fork,wait,exec函数"></a>034  请你说说fork,wait,exec函数</h2><p>父进程产生子进程使用fork拷贝出来一个父进程的副本，此时只拷贝了父进程的页表，两个进程都读同一块内存，当有进程写的时候使用写实拷贝机制分配内存，exec函数可以加载一个elf文件去替换父进程，从此父进程和子进程就可以运行不同的程序了。fork从父进程返回子进程的pid，从子进程返回0.调用了wait的父进程将会发生阻塞，直到有子进程状态改变,执行成功返回0，错误返回-1。exec执行成功则子进程从新的程序开始运行，无返回值，执行失败返回-1</p>
<h2 id="035-请你来说一下map和set有什么区别，分别又是怎么实现的？"><a href="#035-请你来说一下map和set有什么区别，分别又是怎么实现的？" class="headerlink" title="035 请你来说一下map和set有什么区别，分别又是怎么实现的？"></a>035 请你来说一下map和set有什么区别，分别又是怎么实现的？</h2><p>map和set都是C++的关联容器，其底层实现都是红黑树（RB-Tree）。由于 map 和set所开放的各种操作接口，RB-tree 也都提供了，所以几乎所有的 map 和set的操作行为，都只是转调 RB-tree 的操作行为。<br>map和set区别在于：</p>
<p>（1）map中的元素是key-value（关键字—值）对：关键字起到索引的作用，值则表示与索引相关联的数据；Set与之相对就是关键字的简单集合，set中每个元素只包含一个关键字。</p>
<p>（2）set的迭代器是const的，不允许修改元素的值；map允许修改value，但不允许修改key。其原因是因为map和set是根据关键字排序来保证其有序性的，如果允许修改key的话，那么首先需要删除该键，然后调节平衡，再插入修改后的键值，调节平衡，如此一来，严重破坏了map和set的结构，导致iterator失效，不知道应该指向改变前的位置，还是指向改变后的位置。所以STL中将set的迭代器设置成const，不允许修改迭代器的值；而map的迭代器则不允许修改key值，允许修改value值。</p>
<p>（3）map支持下标操作，set不支持下标操作。map可以用key做下标，map的下标运算符[ ]将关键码作为下标去执行查找，如果关键码不存在，则插入一个具有该关键码和mapped_type类型默认值的元素至map中，因此下标运算符[ ]在map应用中需要慎用，const_map不能用，只希望确定某一个关键值是否存在而不希望插入元素时也不应该使用，mapped_type类型没有默认值也不应该使用。如果find能解决需要，尽可能用find。</p>
<h2 id="036-请你来介绍一下STL的allocaotr"><a href="#036-请你来介绍一下STL的allocaotr" class="headerlink" title="036 请你来介绍一下STL的allocaotr"></a>036 请你来介绍一下STL的allocaotr</h2><p>STL的分配器用于封装STL容器在内存管理上的底层细节。在C++中，其内存配置和释放如下：<br>new运算分两个阶段：(1)调用::operator new配置内存;(2)调用对象构造函数构造对象内容</p>
<p>delete运算分两个阶段：(1)调用对象希构函数；(2)掉员工::operator delete释放内存</p>
<p>为了精密分工，STL allocator将两个阶段操作区分开来：内存配置有alloc::allocate()负责，内存释放由alloc::deallocate()负责；对象构造由::construct()负责，对象析构由::destroy()负责。</p>
<p>同时为了提升内存管理的效率，减少申请小内存造成的内存碎片问题，SGI STL采用了两级配置器，当分配的空间大小超过128B时，会使用第一级空间配置器；当分配的空间大小小于128B时，将使用第二级空间配置器。第一级空间配置器直接使用malloc()、realloc()、free()函数进行内存空间的分配和释放，而第二级空间配置器采用了内存池技术，通过空闲链表来管理内存。</p>
<h2 id="037-请你说一说STL中MAP数据存放形式"><a href="#037-请你说一说STL中MAP数据存放形式" class="headerlink" title="037 请你说一说STL中MAP数据存放形式"></a>037 请你说一说STL中MAP数据存放形式</h2><p>红黑树。unordered map底层结构是哈希表</p>
<h2 id="038-请你来说一说STL迭代器删除元素"><a href="#038-请你来说一说STL迭代器删除元素" class="headerlink" title="038 请你来说一说STL迭代器删除元素"></a>038 请你来说一说STL迭代器删除元素</h2><p><a href="https://github.com/selfboot/CS_Offer/blob/master/C%2B%2B/STL_Iterator.md">https://github.com/selfboot/CS_Offer/blob/master/C%2B%2B/STL_Iterator.md</a></p>
<h2 id="039-请你讲讲STL有什么基本组成"><a href="#039-请你讲讲STL有什么基本组成" class="headerlink" title="039 请你讲讲STL有什么基本组成"></a>039 请你讲讲STL有什么基本组成</h2><p>STL主要由：以下几部分组成：<br>容器迭代器仿函数算法分配器配接器<br>他们之间的关系：分配器给容器分配存储空间，算法通过迭代器获取容器中的内容，仿函数可以协助算法完成各种操作，配接器用来套接适配仿函数</p>
<h2 id="040-请你说说STL中map与unordered-map和Multimap"><a href="#040-请你说说STL中map与unordered-map和Multimap" class="headerlink" title="040 请你说说STL中map与unordered_map和Multimap"></a>040 请你说说STL中map与unordered_map和Multimap</h2><p>Multimap允许重复元素，map不允许重复。</p>
<p>map： map内部实现了一个红黑树，该结构具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素，因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行这样的操作，故红黑树的效率决定了map的效率。<br>unordered_map: unordered_map内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的</p>
<h2 id="041-请你说一说vector和list的区别，应用，越详细越好"><a href="#041-请你说一说vector和list的区别，应用，越详细越好" class="headerlink" title="041 请你说一说vector和list的区别，应用，越详细越好"></a>041 请你说一说vector和list的区别，应用，越详细越好</h2><p>1、概念：<br>1）Vector</p>
<p>连续存储的容器，动态数组，在堆上分配空间</p>
<p>底层实现：数组</p>
<p>两倍容量增长：</p>
<p>vector 增加（插入）新元素时，如果未超过当时的容量，则还有剩余空间，那么直接添加到最后（插入指定位置），然后调整迭代器。</p>
<p>如果没有剩余空间了，则会重新配置原有元素个数的两倍空间，然后将原空间元素通过复制的方式初始化新空间，再向新空间增加元素，最后析构并释放原空间，之前的迭代器会失效。</p>
<p>性能：</p>
<p>访问：O(1)</p>
<p>插入：在最后插入（空间够）：很快</p>
<p>在最后插入（空间不够）：需要内存申请和释放，以及对之前数据进行拷贝。</p>
<p>在中间插入（空间够）：内存拷贝</p>
<p>在中间插入（空间不够）：需要内存申请和释放，以及对之前数据进行拷贝。</p>
<p>删除：在最后删除：很快</p>
<p>在中间删除：内存拷贝</p>
<p>适用场景：经常随机访问，且不经常对非尾节点进行插入删除。</p>
<p>2、List</p>
<p>动态链表，在堆上分配空间，每插入一个元数都会分配空间，每删除一个元素都会释放空间。</p>
<p>底层：双向链表</p>
<p>性能：</p>
<p>访问：随机访问性能很差，只能快速访问头尾节点。</p>
<p>插入：很快，一般是常数开销</p>
<p>删除：很快，一般是常数开销</p>
<p>适用场景：经常插入删除大量数据</p>
<p>2、区别：</p>
<p>1）vector底层实现是数组；list是双向 链表。</p>
<p>2）vector支持随机访问，list不支持。</p>
<p>3）vector是顺序内存，list不是。</p>
<p>4）vector在中间节点进行插入删除会导致内存拷贝，list不会。</p>
<p>5）vector一次性分配好内存，不够时才进行2倍扩容；list每次插入新节点都会进行内存申请。</p>
<p>6）vector随机访问性能好，插入删除性能差；list随机访问性能差，插入删除性能好。</p>
<p>3、应用</p>
<p>vector拥有一段连续的内存空间，因此支持随机访问，如果需要高效的随即访问，而不在乎插入和删除的效率，使用vector。</p>
<p>list拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应使用list。</p>
<h2 id="042-请你来说一下STL中迭代器的作用，有指针为何还要迭代器"><a href="#042-请你来说一下STL中迭代器的作用，有指针为何还要迭代器" class="headerlink" title="042 请你来说一下STL中迭代器的作用，有指针为何还要迭代器"></a>042 请你来说一下STL中迭代器的作用，有指针为何还要迭代器</h2><p>1、迭代器<br>Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。</p>
<p>由于Iterator模式的以上特性：与聚合对象耦合，在一定程度上限制了它的广泛运用，一般仅用于底层聚合支持类，如STL的list、vector、stack等容器类及ostream_iterator等扩展iterator。</p>
<p>2、迭代器和指针的区别</p>
<p>迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，-&gt;、*、++、–等。迭代器封装了指针，是一个“可遍历STL（ Standard Template Library）容器内全部或部分元素”的对象， 本质是封装了原生指针，是指针概念的一种提升（lift），提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，–等操作。</p>
<p>迭代器返回的是对象引用而不是对象的值，所以cout只能输出迭代器使用*取值后的值而不能直接输出其自身。</p>
<p>3、迭代器产生原因</p>
<p>Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。</p>
<h2 id="043-请你回答一下STL里resize和reserve的区别"><a href="#043-请你回答一下STL里resize和reserve的区别" class="headerlink" title="043 请你回答一下STL里resize和reserve的区别"></a>043 请你回答一下STL里resize和reserve的区别</h2><p>resize()：改变当前容器内含有元素的数量(size())，eg: vector<int>v; v.resize(len);v的size变为len,如果原来v的size小于len，那么容器新增（len-size）个元素，元素的值为默认为0.当v.push_back(3);之后，则是3是放在了v的末尾，即下标为len，此时容器是size为len+1；<br>reserve()：改变当前容器的最大容量（capacity）,它不会生成元素，只是确定这个容器允许放入多少对象，如果reserve(len)的值大于当前的capacity()，那么会重新分配一块能存len个对象的空间，然后把之前v.size()个对象通过copy construtor复制过来，销毁之前的内存；</p>
<h2 id="044-请你来说一下C-中类成员的访问权限"><a href="#044-请你来说一下C-中类成员的访问权限" class="headerlink" title="044 请你来说一下C++中类成员的访问权限"></a>044 请你来说一下C++中类成员的访问权限</h2><p>参考回答：C++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员</p>
<h2 id="045-请你来说一下C-中struct和class的区别"><a href="#045-请你来说一下C-中struct和class的区别" class="headerlink" title="045 请你来说一下C++中struct和class的区别"></a>045 请你来说一下C++中struct和class的区别</h2><p>1.默认的继承访问权。class默认的是private,strcut默认的是public。<br>2.默认访问权限：struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。<br>3.“class”这个关键字还用于定义模板参数，就像“typename”。但关建字“struct”不用于定义模板参数</p>
<p>4.class和struct在使用大括号{ }上的区别<br>关于使用大括号初始化<br>1.）class和struct如果定义了构造函数的话，都不能用大括号进行初始化<br>　　2.）如果没有定义构造函数，struct可以用大括号初始化。<br>　　3.）如果没有定义构造函数，且所有成员变量全是public的话，class可以用大括号初始化</p>
<p><a href="https://zhuanlan.zhihu.com/p/47808468">https://zhuanlan.zhihu.com/p/47808468</a></p>
<h2 id="046-请你回答一下C-类内可以定义引用数据成员吗？"><a href="#046-请你回答一下C-类内可以定义引用数据成员吗？" class="headerlink" title="046 请你回答一下C++类内可以定义引用数据成员吗？"></a>046 请你回答一下C++类内可以定义引用数据成员吗？</h2><p>可以，必须通过成员函数初始化列表初始化。</p>
<h2 id="047-请你回答一下什么是右值引用，跟左值又有什么区别？"><a href="#047-请你回答一下什么是右值引用，跟左值又有什么区别？" class="headerlink" title="047 请你回答一下什么是右值引用，跟左值又有什么区别？"></a>047 请你回答一下什么是右值引用，跟左值又有什么区别？</h2><p>右值引用是C++11中引入的新特性 , 它实现了转移语义和精确传递。它的主要目的有两个方面：</p>
<ol>
<li><p>消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。</p>
</li>
<li><p>能够更简洁明确地定义泛型函数。</p>
</li>
</ol>
<p>左值和右值的概念：</p>
<p>左值：能对表达式取地址、或具名对象/变量。一般指表达式结束后依然存在的持久对象。</p>
<p>右值：不能对表达式取地址，或匿名对象。一般指表达式结束就不再存在的临时对象。</p>
<p>右值引用和左值引用的区别：</p>
<ol>
<li><p>左值可以寻址，而右值不可以。</p>
</li>
<li><p>左值可以被赋值，右值不可以被赋值，可以用来给左值赋值。</p>
</li>
<li><p>左值可变,右值不可变（仅对基础类型适用，用户自定义类型右值引用可以通过成员函数改变）。</p>
</li>
</ol>
<h2 id="048-请你来说一下一个C-源文件从文本到可执行文件经历的过程？"><a href="#048-请你来说一下一个C-源文件从文本到可执行文件经历的过程？" class="headerlink" title="048 请你来说一下一个C++源文件从文本到可执行文件经历的过程？"></a>048 请你来说一下一个C++源文件从文本到可执行文件经历的过程？</h2><p>对于C++源文件，从文本到可执行文件一般需要四个过程：<br>预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。</p>
<p>编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件</p>
<p>汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件</p>
<p>链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件</p>
<h2 id="049-请你来回答一下include头文件的顺序以及双引号””和尖括号-lt-gt-的区别？"><a href="#049-请你来回答一下include头文件的顺序以及双引号””和尖括号-lt-gt-的区别？" class="headerlink" title="049 请你来回答一下include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别？"></a>049 请你来回答一下include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别？</h2><p>Include头文件的顺序：对于include的头文件来说，如果在文件a.h中声明一个在文件b.h中定义的变量，而不引用b.h。那么要在a.c文件中引用b.h文件，并且要先引用b.h，后引用a.h,否则汇报变量类型未声明错误。<br>双引号和尖括号的区别：编译器预处理阶段查找头文件的路径不一样。</p>
<p>对于使用双引号包含的头文件，查找头文件路径的顺序为：</p>
<p>当前头文件目录</p>
<p>编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）</p>
<p>系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径</p>
<p>对于使用尖括号包含的头文件，查找头文件的路径顺序为：</p>
<p>编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）</p>
<p>系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径</p>
<h2 id="050-请你回答一下malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？"><a href="#050-请你回答一下malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？" class="headerlink" title="050 请你回答一下malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？"></a>050 请你回答一下malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？</h2><p>Malloc函数用于动态分配内存。为了减少内存碎片和系统调用的开销，malloc其采用内存池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位。当用户申请内存时，直接从堆区分配一块合适的空闲块。Malloc采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块；同时malloc采用显示链表结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。<br>当进行内存分配时，Malloc会通过隐式链表遍历所有的空闲块，选择满足要求的块进行分配；当进行内存合并时，malloc采用边界标记法，根据每个块的前后块是否已经分配来决定是否进行块合并。</p>
<p>Malloc在申请内存时，一般会通过brk或者mmap系统调用进行申请。其中当申请内存小于128K时，会使用系统函数brk在堆区中分配；而当申请内存大于128K时，会使用系统函数mmap在映射区分配。</p>
<h2 id="051-请你说一说C-的内存管理是怎样的？"><a href="#051-请你说一说C-的内存管理是怎样的？" class="headerlink" title="051 请你说一说C++的内存管理是怎样的？"></a>051 请你说一说C++的内存管理是怎样的？</h2><p>在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。<br>代码段:包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。</p>
<p>数据段：存储程序中已初始化的全局变量和静态变量</p>
<p>bss 段：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。</p>
<p>堆区：调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存。</p>
<p>映射区:存储动态链接库以及调用mmap函数进行的文件映射</p>
<p>栈：使用栈空间存储函数的返回地址、参数、局部变量、返回值</p>
<h2 id="052-请你回答一下如何判断内存泄漏？"><a href="#052-请你回答一下如何判断内存泄漏？" class="headerlink" title="052 请你回答一下如何判断内存泄漏？"></a>052 请你回答一下如何判断内存泄漏？</h2><p>内存泄漏通常是由于调用了malloc/new等内存申请的操作，但是缺少了对应的free/delete。为了判断内存是否泄露，我们一方面可以使用linux环境下的内存泄漏检查工具Valgrind,另一方面我们在写代码时可以添加内存申请和释放的统计功能，统计当前申请和释放的内存是否一致，以此来判断内存是否泄露。</p>
<h2 id="053-请你来说一下什么时候会发生段错误"><a href="#053-请你来说一下什么时候会发生段错误" class="headerlink" title="053 请你来说一下什么时候会发生段错误"></a>053 请你来说一下什么时候会发生段错误</h2><p>段错误通常发生在访问非法内存地址的时候，具体来说分为以下几种情况：<br>使用野指针</p>
<p>试图修改字符串常量的内容</p>
<h2 id="054-请你来回答一下什么是memory-leak，也就是内存泄漏"><a href="#054-请你来回答一下什么是memory-leak，也就是内存泄漏" class="headerlink" title="054 请你来回答一下什么是memory leak，也就是内存泄漏"></a>054 请你来回答一下什么是memory leak，也就是内存泄漏</h2><p>内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。<br>内存泄漏的分类：</p>
<ol>
<li><p>堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak.</p>
</li>
<li><p>系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。</p>
</li>
<li><p>没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。</p>
</li>
</ol>
<h2 id="055-请你来回答一下new和malloc的区别"><a href="#055-请你来回答一下new和malloc的区别" class="headerlink" title="055 请你来回答一下new和malloc的区别"></a>055 请你来回答一下new和malloc的区别</h2><p>1、new分配内存按照数据类型进行分配，malloc分配内存按照指定的大小分配；<br>2、new返回的是指定对象的指针，而malloc返回的是void*，因此malloc的返回值一般都需要进行类型转化。</p>
<p>3、new不仅分配一段内存，而且会调用构造函数，malloc不会。</p>
<p>4、new分配的内存要用delete销毁，malloc要用free来销毁；delete销毁的时候会调用对象的析构函数，而free则不会。</p>
<p>5、new是一个操作符可以重载，malloc是一个库函数。</p>
<p>6、malloc分配的内存不够的时候，可以用realloc扩容。扩容的原理？new没用这样操作。</p>
<p>7、new如果分配失败了会抛出bad_malloc的异常，而malloc失败了会返回NULL。</p>
<p>8、申请数组时： new[]一次分配所有内存，多次调用构造函数，搭配使用delete[]，delete[]多次调用析构函数，销毁数组中的每个对象。而malloc则只能sizeof(int) * n。</p>
<h2 id="056-请你来说一下共享内存相关api"><a href="#056-请你来说一下共享内存相关api" class="headerlink" title="056 请你来说一下共享内存相关api"></a>056 请你来说一下共享内存相关api</h2><p>Linux允许不同进程访问同一个逻辑内存，提供了一组API，头文件在sys/shm.h中。<br>1）新建共享内存shmget</p>
<p>int shmget(key_t key,size_t size,int shmflg);</p>
<p>key：共享内存键值，可以理解为共享内存的唯一性标记。</p>
<p>size：共享内存大小</p>
<p>shmflag：创建进程和其他进程的读写权限标识。</p>
<p>返回值：相应的共享内存标识符，失败返回-1</p>
<p>2）连接共享内存到当前进程的地址空间shmat</p>
<p>void *shmat(int shm_id,const void *shm_addr,int shmflg);</p>
<p>shm_id：共享内存标识符</p>
<p>shm_addr：指定共享内存连接到当前进程的地址，通常为0，表示由系统来选择。</p>
<p>shmflg：标志位</p>
<p>返回值：指向共享内存第一个字节的指针，失败返回-1</p>
<p>3）当前进程分离共享内存shmdt</p>
<p>int shmdt(const void *shmaddr);</p>
<p>4）控制共享内存shmctl</p>
<p>和信号量的semctl函数类似，控制共享内存</p>
<p>int shmctl(int shm_id,int command,struct shmid_ds *buf);</p>
<p>shm_id：共享内存标识符</p>
<p>command: 有三个值</p>
<p>IPC_STAT:获取共享内存的状态，把共享内存的shmid_ds结构复制到buf中。</p>
<p>IPC_SET:设置共享内存的状态，把buf复制到共享内存的shmid_ds结构。</p>
<p>IPC_RMID:删除共享内存</p>
<p>buf：共享内存管理结构体。</p>
<h2 id="057-请你来说一下reactor模型组成"><a href="#057-请你来说一下reactor模型组成" class="headerlink" title="057 请你来说一下reactor模型组成"></a>057 请你来说一下reactor模型组成</h2><p>reactor模型要求主线程只负责监听文件描述上是否有事件发生，有的话就立即将该事件通知工作线程，除此之外，主线程不做任何其他实质性的工作，读写数据、接受新的连接以及处理客户请求均在工作线程中完成。其模型组成如下：</p>
<p>1）Handle：即操作系统中的句柄，是对资源在操作系统层面上的一种抽象，它可以是打开的文件、一个连接(Socket)、Timer等。由于Reactor模式一般使用在网络编程中，因而这里一般指Socket Handle，即一个网络连接。</p>
<p>2）Synchronous Event Demultiplexer（同步事件复用器）：阻塞等待一系列的Handle中的事件到来，如果阻塞等待返回，即表示在返回的Handle中可以不阻塞的执行返回的事件类型。这个模块一般使用操作系统的select来实现。</p>
<p>3）Initiation Dispatcher：用于管理Event Handler，即EventHandler的容器，用以注册、移除EventHandler等；另外，它还作为Reactor模式的入口调用Synchronous Event Demultiplexer的select方法以阻塞等待事件返回，当阻塞等待返回时，根据事件发生的Handle将其分发给对应的Event Handler处理，即回调EventHandler中的handle_event()方法。</p>
<p>4）Event Handler：定义事件处理方法：handle_event()，以供InitiationDispatcher回调使用。</p>
<p>5）Concrete Event Handler：事件EventHandler接口，实现特定事件处理逻辑。</p>
<h2 id="058-请自己设计一下如何采用单线程的方式处理高并发"><a href="#058-请自己设计一下如何采用单线程的方式处理高并发" class="headerlink" title="058 请自己设计一下如何采用单线程的方式处理高并发"></a>058 请自己设计一下如何采用单线程的方式处理高并发</h2><p>在单线程模型中，可以采用I/O复用来提高单线程处理多个请求的能力，然后再采用事件驱动模型，基于异步回调来处理事件来</p>
<h2 id="059-请你说说select，epoll的区别，原理，性能，限制都说一说"><a href="#059-请你说说select，epoll的区别，原理，性能，限制都说一说" class="headerlink" title="059 请你说说select，epoll的区别，原理，性能，限制都说一说"></a>059 请你说说select，epoll的区别，原理，性能，限制都说一说</h2><p>1）IO多路复用<br>IO复用模型在阻塞IO模型上多了一个select函数，select函数有一个参数是文件描述符集合，意思就是对这些的文件描述符进行循环监听，当某个文件描述符就绪的时候，就对这个文件描述符进行处理。</p>
<p>这种IO模型是属于阻塞的IO。但是由于它可以对多个文件描述符进行阻塞监听，所以它的效率比阻塞IO模型高效。</p>
<p>IO多路复用就是我们说的select，poll，epoll。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</p>
<p>当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p>
<p>所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。</p>
<p>I/O多路复用和阻塞I/O其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。</p>
<p>所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）</p>
<p>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p>
<p>2、select</p>
<p>select：是最初解决IO阻塞问题的方法。用结构体fd_set来告诉内核监听多个文件描述符，该结构体被称为描述符集。由数组来维持哪些描述符被置位了。对结构体的操作封装在三个宏定义中。通过轮寻来查找是否有描述符要被处理。</p>
<p>存在的问题：</p>
<ol>
<li><p>内置数组的形式使得select的最大文件数受限与FD_SIZE；</p>
</li>
<li><p>每次调用select前都要重新初始化描述符集，将fd从用户态拷贝到内核态，每次调用select后，都需要将fd从内核态拷贝到用户态；</p>
</li>
<li><p>轮寻排查当文件描述符个数很多时，效率很低；</p>
</li>
</ol>
<p>3、poll</p>
<p>poll：通过一个可变长度的数组解决了select文件描述符受限的问题。数组中元素是结构体，该结构体保存描述符的信息，每增加一个文件描述符就向数组中加入一个结构体，结构体只需要拷贝一次到内核态。poll解决了select重复初始化的问题。轮寻排查的问题未解决。</p>
<p>4、epoll</p>
<p>epoll：轮寻排查所有文件描述符的效率不高，使服务器并发能力受限。因此，epoll采用只返回状态发生变化的文件描述符，便解决了轮寻的瓶颈。</p>
<p>epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式</p>
<ol>
<li>LT模式</li>
</ol>
<p>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。</p>
<ol start="2">
<li>ET模式</li>
</ol>
<p>ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)</p>
<p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
<p>3、LT模式与ET模式的区别如下：<br>LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。<br>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p>
<h2 id="060-请你说一说C-STL-的内存优化"><a href="#060-请你说一说C-STL-的内存优化" class="headerlink" title="060  请你说一说C++ STL 的内存优化"></a>060  请你说一说C++ STL 的内存优化</h2><p>1）二级配置器结构<br>STL内存管理使用二级内存配置器。<br>1、第一级配置器<br>第一级配置器以malloc()，free()，realloc()等C函数执行实际的内存配置、释放、重新配置等操作，并且能在内存需求不被满足的时候，调用一个指定的函数。<br>一级空间配置器分配的是大于128字节的空间<br>如果分配不成功，调用句柄释放一部分内存<br>如果还不能分配成功，抛出异常<br>2、第二级配置器<br>在STL的第二级配置器中多了一些机制，避免太多小区块造成的内存碎片，小额区块带来的不仅是内存碎片，配置时还有额外的负担。区块越小，额外负担所占比例就越大。<br>3、分配原则<br>如果要分配的区块大于128bytes，则移交给第一级配置器处理。<br>如果要分配的区块小于128bytes，则以内存池管理（memory pool），又称之次层配置（sub-allocation）：每次配置一大块内存，并维护对应的16个空闲链表（free-list）。下次若有相同大小的内存需求，则直接从free-list中取。如果有小额区块被释放，则由配置器回收到free-list中。<br>当用户申请的空间小于128字节时，将字节数扩展到8的倍数，然后在自由链表中查找对应大小的子链表<br>如果在自由链表查找不到或者块数不够，则向内存池进行申请，一般一次申请20块<br>如果内存池空间足够，则取出内存<br>如果不够分配20块，则分配最多的块数给自由链表，并且更新每次申请的块数<br>如果一块都无法提供，则把剩余的内存挂到自由链表，然后向系统heap申请空间，如果申请失败，则看看自由链表还有没有可用的块，如果也没有，则最后调用一级空间配置器<br>2）二级内存池<br>二级内存池采用了16个空闲链表，这里的16个空闲链表分别管理大小为8、16、24……120、128的数据块。这里空闲链表节点的设计十分巧妙，这里用了一个联合体既可以表示下一个空闲数据块（存在于空闲链表中）的地址，也可以表示已经被用户使用的数据块（不存在空闲链表中）的地址。</p>
<p>1、空间配置函数allocate<br>首先先要检查申请空间的大小，如果大于128字节就调用第一级配置器，小于128字节就检查对应的空闲链表，如果该空闲链表中有可用数据块，则直接拿来用（拿取空闲链表中的第一个可用数据块，然后把该空闲链表的地址设置为该数据块指向的下一个地址），如果没有可用数据块，则调用refill重新填充空间。<br>2、空间释放函数deallocate<br>首先先要检查释放数据块的大小，如果大于128字节就调用第一级配置器，小于128字节则根据数据块的大小来判断回收后的空间会被插入到哪个空闲链表。<br>3、重新填充空闲链表refill<br>在用allocate配置空间时，如果空闲链表中没有可用数据块，就会调用refill来重新填充空间，新的空间取自内存池。缺省取20个数据块，如果内存池空间不足，那么能取多少个节点就取多少个。<br>从内存池取空间给空闲链表用是chunk_alloc的工作，首先根据end_free-start_free来判断内存池中的剩余空间是否足以调出nobjs个大小为size的数据块出去，如果内存连一个数据块的空间都无法供应，需要用malloc取堆中申请内存。<br>假如山穷水尽，整个系统的堆空间都不够用了，malloc失败，那么chunk_alloc会从空闲链表中找是否有大的数据块，然后将该数据块的空间分给内存池（这个数据块会从链表中去除）。<br>3、总结：</p>
<ol>
<li>使用allocate向内存池请求size大小的内存空间，如果需要请求的内存大小大于128bytes，直接使用malloc。</li>
<li>如果需要的内存大小小于128bytes，allocate根据size找到最适合的自由链表。<br>a. 如果链表不为空，返回第一个node，链表头改为第二个node。<br>b. 如果链表为空，使用blockAlloc请求分配node。<br>x. 如果内存池中有大于一个node的空间，分配竟可能多的node(但是最多20个)，将一个node返回，其他的node添加到链表中。<br>y. 如果内存池只有一个node的空间，直接返回给用户。<br>z. 若果如果连一个node都没有，再次向操作系统请求分配内存。<br>①分配成功，再次进行b过程。<br>②分配失败，循环各个自由链表，寻找空间。<br>I. 找到空间，再次进行过程b。<br>II. 找不到空间，抛出异常。</li>
<li>用户调用deallocate释放内存空间，如果要求释放的内存空间大于128bytes，直接调用free。</li>
<li>否则按照其大小找到合适的自由链表，并将其插入。</li>
</ol>
<h2 id="61-拷贝构造"><a href="#61-拷贝构造" class="headerlink" title="61 拷贝构造"></a>61 拷贝构造</h2><p>上面的定义的类Person显式的删除了拷贝构造函数和赋值运算符，在需要调用拷贝构造函数或者赋值运算符的地方，会提示_无法调用该函数，它是已删除的函数_。<br>还有一点需要注意的是，拷贝构造函数必须以引用的方式传递参数。这是因为，在值传递的方式传递给一个函数的时候，会调用拷贝构造函数生成函数的实参。如果拷贝构造函数的参数仍然是以值的方式，就会无限循环的调用下去，直到函数的栈溢出。</p>
<p>何时调用<br>拷贝构造函数和赋值运算符的行为比较相似，都是将一个对象的值复制给另一个对象；但是其结果却有些不同，拷贝构造函数使用传入对象的值生成一个新的对象的实例，而赋值运算符是将对象的值复制给一个已经存在的实例。这种区别从两者的名字也可以很轻易的分辨出来，拷贝构造函数也是一种构造函数，那么它的功能就是创建一个新的对象实例；赋值运算符是执行某种运算，将一个对象的值复制给另一个对象（已经存在的）。调用的是拷贝构造函数还是赋值运算符，主要是看是否有新的对象实例产生。如果产生了新的对象实例，那调用的就是拷贝构造函数；如果没有，那就是对已有的对象赋值，调用的是赋值运算符。</p>
<h2 id="062-深拷贝、浅拷贝"><a href="#062-深拷贝、浅拷贝" class="headerlink" title="062 深拷贝、浅拷贝"></a>062 深拷贝、浅拷贝</h2><p>说到拷贝构造函数，就不得不提深拷贝和浅拷贝。通常，默认生成的拷贝构造函数和赋值运算符，只是简单的进行值的复制。例如：上面的Person类，字段只有int和string两种类型，这在拷贝或者赋值时进行值复制创建的出来的对象和源对象也是没有任何关联，对源对象的任何操作都不会影响到拷贝出来的对象。反之，假如Person有一个对象为int *，这时在拷贝时还只是进行值复制，那么创建出来的Person对象的int *的值就和源对象的int *指向的是同一个位置。任何一个对象对该值的修改都会影响到另一个对象，这种情况就是浅拷贝。</p>
<p>深拷贝和浅拷贝主要是针对类中的指针和动态分配的空间来说的，因为对于指针只是简单的值复制并不能分割开两个对象的关联，任何一个对象对该指针的操作都会影响到另一个对象。这时候就需要提供自定义的深拷贝的拷贝构造函数，消除这种影响。通常的原则是：</p>
<p>含有指针类型的成员或者有动态分配内存的成员都应该提供自定义的拷贝构造函数<br>在提供拷贝构造函数的同时，还应该考虑实现自定义的赋值运算符<br>对于拷贝构造函数的实现要确保以下几点：</p>
<p>对于值类型的成员进行值复制<br>对于指针和动态分配的空间，在拷贝中应重新分配分配空间<br>对于基类，要调用基类合适的拷贝方法，完成基类的拷贝</p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2>]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>[译文]MapReduce: Simplified Data Processing on Large Clusters</title>
    <url>/2021-01-21-MapReduce-Simplified-Data-Processing-on-Large-Clusters/</url>
    <content><![CDATA[<p>尝试翻译一下，会大量参考翻译软件和其他翻译文章，纯自学，无其他用途。参考文章在文末，原文在此: <a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf">MapReduce: Simplified Data Processing on Large Clusters</a></p>
<p>翻译的工作量超出了预期，让我产生了投入回报比的疑惑，这种积累需要很长时期的沉淀，而目前我的重点应该是内容而不是语言的形式。所以后面应该会依赖于对翻译文章的搜索以及各种翻译软件的使用。英文水平提高待日后再提上日程吧。</p>
<a id="more"></a>

<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>MapReduce is a programming model and an associated implementation for processing and generating large data sets. Users specify a map function that processes a key/value pair to generate a set of intermediate key/value pairs, and a reduce function that merges all intermediate values associated with the same intermediate key. Many real world tasks are expressible in this model, as shown in the paper.</p>
<div class="note info">
            <p>MapReduce一种编程模型，和处理，生成大数据库集的相关实现。用户指定一个map函数，处理k/v pair并生成中间的k/v pair,以及一个reduce函数来合并所有相同的中间key对应的中间value.很多真实世界的任务都可以通过这个模型表示，如本文描述的那样。</p>
          </div>

<p>Programs written in this functional style are automatically <code>parallelized</code> and executed on a large cluster of <code>commodity</code> machines. The run-time system takes care of the details of partitioning the input data, scheduling the program’s execution across a set of machines, handling machine failures, and managing the required inter-machine communication. This allows programmers without any experience with parallel and <code>distributed</code> systems to easily <code>utilize</code> the resources of a large distributed system.</p>
<div class="note info">
            <p>用MapReduce这种函数风格实现的程序能够自动实现并行化，可以运行在大的商用集群中。运行时系统负责一些细节：划分输入数据，调度程序在一组机器上执行，处理机器故障，管理内部机器间的交流请求。这使毫无并行以及分布式经验的程序员能够很容易的利用一个大的分布式系统的资源。</p>
          </div>

<p>Our implementation of MapReduce runs on a large cluster of <code>commodity</code> machines and is highly <code>scalable</code>: a typical MapReduce <code>computation</code> processes many <code>terabytes</code> of data on thousands of machines. Programmers find the system easy to use: hundreds of MapReduce programs have been implemented and <code>upwards</code> of one thousand MapReduce jobs are executed on Google’s clusters every day.</p>
<div class="note info">
            <p>我们对MapReduce的实现可在大的商业集群上运行并有很好的扩展性：一个典型的在数千台机器上处理TB级数据的MapReduce计算。谷歌程序员觉得这种系统很容易使用：已经有数百个MapReduce被实现，谷歌的集群上每天运行一千个mapReduce作业</p>
          </div>

<hr>
<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><p>Over the past five years, the authors and many others at Google have implemented hundreds of special-purpose computations that process large <code>amounts</code> of <code>raw data</code>, such as <code>crawled</code> documents, web request logs, etc., to compute <code>various kinds of</code> derived data, such as <code>inverted indices</code>, various <code>representations</code> of the <code>graph</code> structure of web documents, <code>summaries</code> of the number of pages crawled per host, the set of most frequent queries in a given day, etc. Most such computations are <code>conceptually straightforward</code>. However, the input data is usually large and the computations have to be distributed across hundreds or thousands of machines in order to finish in a reasonable amount of time. The issues of how to parallelize the computation, distribute the data, and handle failures <code>conspire</code> to <code>obscure </code>the original simple computation with large amounts of complex code to deal with these issues.</p>
<div class="note info">
            <p>过去5年，笔者和许多谷歌人员已经实现了数百个用于特定用途的计算过程，包括处理大量的原始数据(比如抓取的文档，web请求日志等)，处理各种衍生数据(如反向索引，各种网页文档中图结构的表示,单台主机抓取网页数量概要，指定日期top频次查询的集合等)。大多数这类计算在概念上是直截了当的。然而输入数据通常很大，需要成百上千台机器通过分布式计算以在合理时间内完成。解决并行计算，分布式数据，错误处理这些问题引入了大量复杂的代码将原本简单的计算变得晦涩难懂。</p>
          </div>

<p>As a reaction to this complexity, we designed a new abstraction that allows us to express the simple computations we were trying to perform but hides the messy details of parallelization, fault-tolerance, data distribution and load balancing in a library. Our abstraction is <code>inspired</code> by the map and reduce <code>primitives</code> present in Lisp and many other functional languages. We realized that<br>most of our computations <code>involved</code> applying a map operation to each logical “record” in our input in order to compute a set of intermediate key/value pairs, and then applying a reduce operation to all the values that shared the same key, in order to <code>combine</code> the derived data appropriately. Our use of a functional model with userspecified map and reduce operations allows us to parallelize large computations easily and to use re-execution as the primary <code>mechanism</code> for fault tolerance.</p>
<div class="note info">
            <p>作为对这种复杂性的回应，我们设计了一个新的抽象，允许我们将计算进行简单的表达，而隐藏对于并行，容错，分布式计算，负载均衡这些复杂的细节。我们实现的抽象，受到了当下Lisp等函数式语言的启发。我们意识到大多数的计算都涉及到对于每一个输入的逻辑数据的map操作从而计算出一个中间的k/v pair的集合，然后对于所有相同key的value,进行reduce操作,从而适当的合并这些衍生的数据。使用这种通过用户指定map reduce操作的函数模型让我们可以很容易的将大型计算并行化，并且以恢复执行作为容错的机制。</p>
          </div>

<p>The major <code>contributions</code> of this work are a simple and powerful interface that enables automatic parallelization and distribution of <code>large-scale</code> computations, combined with an implementation of this interface that <code>achieve</code>s high performance on large clusters of <code>commodity</code> PCs.</p>
<div class="note info">
            <p>这份工作主要的贡献是提供一个简单而强大的接口，能够自动实现并行化和大规模分布式计算。结合这些接口的实现能够在大的商用pc集群中有很好的表现。</p>
          </div>

<p>Section 2 describes the basic programming model and gives several examples. Section 3 describes an implementation of the MapReduce interface tailored towards our cluster-based computing environment. Section 4 describes several <code>refinements</code> of the programming model that we have found useful. Section 5 has performance <code>measurements</code> of our implementation for a <code>variety</code> of tasks. Section 6 explores the use of MapReduce within Google including our experiences in using it as the basis for a rewrite of our production indexing system. Section 7 discusses related and future work.</p>
<div class="note info">
            <p>第二部分描述了简单的程序模型并提供了几个例子。第三部分描述了对于我们基础计算集群环境上量身定制的MapReduce接口的实现。第四部分描述了几种我们已经发现的有用的程序模型的细化。第五部分展示了我们的实现对于各种各样任务的数据表现。第六部分探索了谷歌内部基于MapReduce改写我们的索引系统中的经验。第七部分讨论了相关的和未来的工作。</p>
          </div>

<hr>
<h2 id="2-Programming-Model"><a href="#2-Programming-Model" class="headerlink" title="2 Programming Model"></a>2 Programming Model</h2><p>The computation takes a set of input key/value pairs, and produces a set of output key/value pairs. The user of the MapReduce library expresses the computation as two functions: Map and Reduce.</p>
<div class="note info">
            <p>计算过程使用一个输入的k/v pair集合，产出一个输出的k/v pair集合。MapReduce库的用户通过map和reduce函数来使用。</p>
          </div>

<p>Map, written by the user, takes an input pair and produces a set of intermediate key/value pairs. The MapReduce library groups together all intermediate values associated with the same intermediate key I and passes them to the Reduce function.</p>
<div class="note info">
            <p>map函数由用户实现，使用一个输入的pair然后产出一个中间的kv pair.MapReduce库对所有有相同key的中间值进行组合然后传递给reduce函数。</p>
          </div>

<p>The Reduce function, also written by the user, accepts an intermediate key I and a set of values for that key. It merges together these values to form a possibly smaller set of values. Typically just zero or one output value is produced per Reduce invocation. The intermediate values are supplied to the user’s reduce function via an iterator. This allows us to handle lists of values that are too large to fit in memory.</p>
<div class="note info">
            <p>reduce函数也由用户实现，接受一个中间的key和该key对应的value的集合，合并这些值并构造出一个更小的值得集合。典型的o或1作为reduce函数每次执行的输出。中间值通过迭代器提供给用户的reduce函数。这允许我们处理哪些太大以至于不能保存在内存中的以链表保存的值。</p>
          </div>

<hr>
<h3 id="2-1-Example"><a href="#2-1-Example" class="headerlink" title="2.1 Example"></a>2.1 Example</h3><p>Consider the problem of counting the number of occurrences of each word in a large collection of documents. The user would write code similar to the following <code>pseudo-code</code>:</p>
<div class="note info">
            <p>思考统计一个大的文档中单词出现次数的问题。用户可以很简单的写出如下的伪代码。</p>
          </div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">map(String key, String value):</span><br><span class="line">    &#x2F;&#x2F; key: document name</span><br><span class="line">    &#x2F;&#x2F; value: document contents</span><br><span class="line">    for each word w in value:</span><br><span class="line">        EmitIntermediate(w, &quot;1&quot;);</span><br><span class="line"></span><br><span class="line">reduce(String key, Iterator values):</span><br><span class="line">    &#x2F;&#x2F; key: a word</span><br><span class="line">    &#x2F;&#x2F; values: a list of counts</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    for each v in values:</span><br><span class="line">        result +&#x3D; ParseInt(v);</span><br><span class="line">    Emit(AsString(result));</span><br></pre></td></tr></table></figure>

<p>The map function emits each word plus an associated count of occurrences (just ‘1’ in this simple example). The reduce function sums together all counts emitted for a <code>particular</code> word.</p>
<div class="note info">
            <p>map函数发射每一个单词加上关联的次数(本例中是1)。reduce函数统计所有发出的特定单词的次数。</p>
          </div>

<p>In addition, the user writes code to fill in a mapreduce specification object with the names of the input and output files, and optional <code>tuning parameters</code>. The user then invokes the MapReduce function, passing it the specification object. The user’s code is linked together with the MapReduce library (implemented in C++). Appendix A contains the full program text for this example.</p>
<div class="note info">
            <p>除此之外，用户实现代码用输入输出文件名和可选的调优参数填充特定的mapreduce函数。然后传递特定的对象并执行MapReduce函数。用户的代码和MapReduce库链接起来(用c++实现)。附录A包含完整的此实例的代码。</p>
          </div>

<hr>
<h3 id="2-2-Types"><a href="#2-2-Types" class="headerlink" title="2.2 Types"></a>2.2 Types</h3><p>Even though the previous pseudo-code is written in terms of string inputs and outputs, <code>conceptually</code> the map and reduce functions supplied by the user have associated types:</p>
<div class="note info">
            <p>即使前面伪代码里面用string作为输入和输出，概念上用户提供的map和reduce函数是和类型关联的：</p>
          </div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">map (k1,v1) → list(k2,v2)</span><br><span class="line">reduce (k2,list(v2)) → list(v2)</span><br></pre></td></tr></table></figure>

<p>I.e., the input keys and values are <code>drawn from</code> a different domain than the output keys and values. Furthermore, the intermediate keys and values are from the same domain as the output keys and values.</p>
<div class="note info">
            <p>输入的k/v和输出的k/v来自不同的域。此外，中间的k/v和输出的k/v来自同一域。</p>
          </div>

<p>Our C++ implementation passes strings to and from the user-defined functions and leaves it to the user code to convert between strings and appropriate types.</p>
<div class="note info">
            <p>我们的c++实现传递string到用户定义的函数，用户代码将string和相应的类型进行转换。</p>
          </div>

<hr>
<h3 id="2-3-More-Examples"><a href="#2-3-More-Examples" class="headerlink" title="2.3 More Examples"></a>2.3 More Examples</h3><p>Here are a few simple examples of interesting programs that can be easily expressed as MapReduce computations.</p>
<div class="note info">
            <p>这里有一些简单有趣的程序可以容易的用于MapRedece计算</p>
          </div>

<p><strong>Distributed Grep</strong>: The map function emits a line if it matches a supplied pattern. The reduce function is an <code>identity function</code> that just copies the supplied intermediate data to the output.</p>
<div class="note info">
            <p>分布式grep: map函数如果匹配到特定模式则发射一行。reduce函数复制中间数据到输出。</p>
          </div>

<p><strong>Count of URL Access Frequency</strong>: The map function processes logs of web page requests and outputs (URL, 1). The reduce function adds together all values for the same URL and emits a (URL, total count) pair.</p>
<div class="note info">
            <p>统计url访问频率：map函数处理网页输入和输出日志(url, 1). reduce函数把所有相同url的值加起来然后发射(url, total count)pair.</p>
          </div>

<p><strong>Reverse Web-Link Graph</strong>: The map function outputs (target, source) pairs for each link to a target URL found in a page named source. The reduce function <code>concatenates</code> the list of all source URLs associated with a given target URL and emits the pair: (target, list(source))</p>
<div class="note info">
            <p>反向web链接图：map函数对于source页中每一个指向target的链接都输出一个(target, source)pair. reduce函数将所有和给定target相关联的source串联成链表然后发送：(target, list(source)) pair.</p>
          </div>

<p><strong>Term-Vector per Host</strong>: A term vector summarizes the most important words that occur in a document or a set of documents as a list of (word, frequency) pairs. The map function emits a (hostname, term vector) pair for each input document (where the hostname is extracted from the URL of the document). The reduce function is passed all per-document term vectors for a given host. It adds these term vectors together, throwing away <code>infrequent</code> terms, and then emits a final (hostname, term vector) pair.</p>
<div class="note info">
            <p>每台主机的关键词向量： 关键词向量概括了一个或一组文档中出现的最重要的单词，形如(word, frequency) pair的链表。map函数对于每一个输入数据(其中hostname是从文档的Url中提取的)发射(hostname, term vector)pair. 给定主机的所有关键词向量都会传递给reduce函数。reduce函数将这些关键词向量相加，去掉频率较低的关键词，然后发射最终的(hostname, term vector) pair.</p>
          </div>

<p><strong>Inverted Index</strong>: The map function parses each document, and emits a sequence of (word, document ID) pairs. The reduce function accepts all pairs for a given word, sorts the <code>corresponding </code>document IDs and emits a (word, list(document ID)) pair. The set of all output pairs forms a simple inverted index. It is easy to <code>augment</code> this computation to keep track of word positions.</p>
<div class="note info">
            <p>反向索引(倒排索引)：map函数解析每一个文件，然后发射一个有序的(word, document id)pair. reduce函数接收所有给定单词的所有pairs,对document ids进行排序然后发射(word, list(document id))pair.所有输出的pairs组成一个简单的反向索引。通过扩展这个计算来跟踪单词位置是很容易的。</p>
          </div>

<p><strong>Distributed Sort</strong>: The map function <code>extracts</code> the key from each record, and emits a (key, record) pair. The reduce function emits all pairs unchanged. This computation depends on the partitioning <code>facilities</code> described in Section 4.1 and the <code>ordering properties</code> described in Section 4.2.</p>
<div class="note info">
            <p>分布式排序：map函数从每一个记录中提取key,然后发射(key, record) pair. reduce函数发射所有未改变的pairs.这个计算依赖于4.1节描述的划分机制以及4.2节描述的排序性质。</p>
          </div>

<hr>
<h2 id="3-Implementation"><a href="#3-Implementation" class="headerlink" title="3 Implementation"></a>3 Implementation</h2><p>Many different implementations of the MapReduce interface are possible. The right choice depends on the environment. For example, one implementation may be suitable for a small shared-memory machine, another for a large NUMA multi-processor, and yet another for an even larger collection of networked machines.</p>
<div class="note info">
            <p>许多不同MapReduce接口的实现都是可能的。正确的选择依赖于环境。例如，有的实现可能适合一个小的共享内存机器，有的适合大的NUMA多处理器，也有的适合大的网络机器集合</p>
          </div>

<p>This section describes an implementation targeted to the computing environment in wide use at Google:</p>
<div class="note info">
            <p>这个部分描述的实现主要针对谷歌使用的计算环境：</p>
          </div>

<p>large clusters of commodity PCs connected together with switched Ethernet [4]. In our environment:</p>
<div class="note info">
            <p>大集群的商用pc机通过以太网连接在一起，在我们的环境中：</p>
          </div>


<p>(1) Machines are typically dual-processor x86 processors running Linux, with 2-4 GB of memory per machine.</p>
<div class="note info">
            <p>(1) 每台机器都是典型的基于x86架构的运行在linux下的2-4g内存的配置</p>
          </div>

<p>(2) Commodity networking hardware is used – typically either 100 megabits/second or 1 gigabit/second at the machine level, but averaging considerably less in <code>overall</code> <code>bisection bandwidth</code>.</p>
<div class="note info">
            <p>(2) 使用商用的网络硬件-在机器层面上通常是100mb/s或者1g/s，但平均下来少于整体带宽一般的速度。</p>
          </div>

<p>(3) A cluster consists of hundreds or thousands of machines, and therefore machine failures are common.</p>
<div class="note info">
            <p>(3) 成百上千机器组成的集群，所以机器故障会很常见</p>
          </div>

<p>(4) Storage is provided by inexpensive IDE disks attached directly to <code>individual</code> machines. A distributed file system [8] developed <code>in-house</code> is used to manage the data stored on these disks. The file system uses replication to provide availability and reliability on top of unreliable hardware.</p>
<div class="note info">
            <p>(4) 廉价IDE磁盘嵌入到个人机作为存储。内部开发的文件系统用来管理这些存储在磁盘的数据。文件系统使用复制来保证在不可靠的硬件上提供可用性，可靠性</p>
          </div>

<p>(5) Users submit jobs to a scheduling system. Each job consists of a set of tasks, and is mapped by the scheduler to a set of available machines within a cluster.</p>
<div class="note info">
            <p>(5) 用户提交作业到调度系统。每个作业由一组任务组成，通过调度器映射到集群中一组可用的机器。</p>
          </div>

<hr>
<h3 id="3-1-Execution-Overview"><a href="#3-1-Execution-Overview" class="headerlink" title="3.1 Execution Overview"></a>3.1 Execution Overview</h3><p>The Map invocations are distributed across multiple machines by automatically partitioning the input data into a set of M splits. The input splits can be processed in parallel by different machines. Reduce invocations are distributed by partitioning the intermediate key space into R pieces using a partitioning function (e.g., hash(key) mod R). The number of partitions (R) and the partitioning function are specified by the user.</p>
<div class="note info">
            <p>通过自动化的将输入数据分割成M块的集合，map调用可以在多台机器上分布式执行。输入数据可以通过不同的机器并行处理。reduce通过分割函数(eg., hash(key) mod R)分割中间数据成R块来分布式调用。R的数量和分割函数由用户指定</p>
          </div>

<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/Snipaste_2021-01-21_14-27-03.jpg"></p>
<p>Figure 1 shows the <code>overall flow</code> of a MapReduce operation in our implementation. When the user program calls the MapReduce function, the following sequence of actions occurs (the numbered labels in Figure 1 <code>correspond</code> to the numbers in the list below):</p>
<div class="note info">
            <p>图一展示了实现的MapReduce操作的总体流程。用户调用MapReduce函数的时候，会发生下面的行为(图一的标号和下面列表的数字对应)</p>
          </div>

<ol>
<li>The MapReduce library in the user program first splits the input files into M pieces of typically 16 megabytes to 64 megabytes (MB) per piece (controllable by the user via an optional parameter). It then starts up many copies of the program on a cluster of machines.</li>
</ol>
<div class="note info">
            <ol><li>MapReduce库在用户程序中首先分割输入数据成典型的16m-64m(用户通过可选参数指定)大小的M片，然后在集群中启动多个程序的副本</li></ol>
          </div>

<ol start="2">
<li>One of the copies of the program is special – the master. The rest are workers that are assigned work by the master. There are M map tasks and R reduce tasks to assign. The master picks idle workers and assigns each one a map task or a reduce task.</li>
</ol>
<div class="note info">
            <ol start="2"><li>其中一个副本程序时特殊的-主节点。其余的工作节点通过主节点分配工作。一共有m个map任务和r个reduce任务需要分配。主节点选择一个idle的工作节点执行map或者reduce任务</li></ol>
          </div>

<ol start="3">
<li>A worker who is assigned a map task reads the contents of the corresponding input split. It parses key/value pairs out of the input data and passes each pair to the user-defined Map function. The intermediate key/value pairs produced by the Map function are buffered in memory.</li>
</ol>
<div class="note info">
            <ol><li>被分配map任务的worker(工作节点)读取相应输入块的内容。worker解析输入文件成k/v pair然后发给用户定义的map函数。map函数生成中间的k/v pair并缓存在内存中</li></ol>
          </div>

<ol start="4">
<li><code>Periodically</code>, the buffered pairs are written to local disk, partitioned into <code>R regions</code> by the partitioning function. The locations of these buffered pairs on the local disk are passed back to the master, who is <code>responsible</code> for forwarding these locations to the reduce workers.</li>
</ol>
<div class="note info">
            <ol start="4"><li>缓存的pair会定期的写入本地磁盘，通过分割函数分割到R个块。存在本地磁盘的缓存pairs将被传递给master,由master负责传递给reduce workers</li></ol>
          </div>

<ol start="5">
<li>When a reduce worker is notified by the master about these locations, it uses remote procedure calls to read the buffered data from the local disks of the map workers. When a reduce worker has read all intermediate data, it sorts it by the intermediate keys so that all occurrences of the same key are grouped together. The sorting is needed because typically many different keys map to the same reduce task. If the amount of intermediate data is too large to fit in memory, an external sort is used.</li>
</ol>
<div class="note info">
            <ol start="5"><li>当reduce work收到master发来的位置通知信息，会通过rpc从map workers读取缓存的pairs. reduce读取完所有的中间数据后，将对所有的中间keys进行排序分组。之所以排序是因为通常多个不同的keys会映射到同一个reduce task. 如果中间数据太大以至于内存放不下，则会使用外部排序</li></ol>
          </div>

<ol start="6">
<li>The reduce worker iterates over the sorted intermediate data and for each unique intermediate key encountered, it passes the key and the corresponding set of intermediate values to the user’s Reduce function. The output of the Reduce function is appended to a final output file for this reduce partition.</li>
</ol>
<div class="note info">
            <ol start="6"><li>reduce worker迭代的对唯一的中间keys进行排序统计， 传递key和相应的value到用户的Reduce函数。 Reduce函数输出会追加到该reduce work的最终输出文件。</li></ol>
          </div>

<ol start="7">
<li>When all map tasks and reduce tasks have been completed, the master wakes up the user program. At this point, the MapReduce call in the user program returns back to the user code.</li>
</ol>
<div class="note info">
            <ol start="7"><li>当所有的map和reduce task处理完成， master会唤醒用户程序。 然后MapReduce调用结束返回到用户代码</li></ol>
          </div>

<p>After successful completion, the output of the mapreduce execution is available in the R output files (one per reduce task, with file names as specified by the user). Typically, users do not need to combine these R output files into one file – they often pass these files as input to another MapReduce call, or use them from another distributed application that is able to deal with input that is partitioned into multiple files.</p>
<div class="note info">
            <p>成功执行后，MapReduce将输出写入到R个输出文件(每一个reduce任务都有一个由用户指定的文件名)。 通常用户不需要合并这R个文件到一个文件中-一般会将这些文件作为输入传递给其他的MapReduce调用， 或者使用那些能够处理以多个文件作为输入的分布式程序</p>
          </div>

<hr>
<h3 id="3-2-Master-Data-Structures"><a href="#3-2-Master-Data-Structures" class="headerlink" title="3.2 Master Data Structures"></a>3.2 Master Data Structures</h3><p>The master keeps several data structures. For each map task and reduce task, it stores the state (idle, in-progress, or completed), and the identity of the worker machine (for non-idle tasks).</p>
<div class="note info">
            <p>master有几种数据结构。对于每一个map任务和reduce任务，master会保存状态(idle, in-progress, or completed)，对于非空闲的任务还会保存任务的ID</p>
          </div>

<p>The master is the <code>conduit</code> through which the location of intermediate file <code>regions</code> is <code>propagated</code> from map tasks to reduce tasks. Therefore, for each completed map task, the master stores the locations and sizes of the R intermediate file regions produced by the map task. Updates to this location and size information are received as map tasks are completed. The information is pushed <code>incrementally</code> to workers that have in-progress reduce tasks.</p>
<div class="note info">
            <p>主节点是map任务将中间文件的位置信息传递给reduce任务的渠道。因此，对于每一个完成的map任务，master保存其R个中间文件(map task生成的)的位置和大小。map任务完成的时候会受到更新位置和大小的通知。这些信息会逐步推送给处于in-progress状态的reduce worker.</p>
          </div>

<hr>
<h3 id="3-3-Fault-Tolerance"><a href="#3-3-Fault-Tolerance" class="headerlink" title="3.3 Fault Tolerance"></a>3.3 Fault Tolerance</h3><p>Since the MapReduce library is designed to help process very large amounts of data using hundreds or thousands of machines, the library must tolerate machine failures <code>gracefully</code>.</p>
<div class="note info">
            <p>因为MapReduce库是设计用来通过数千台机器处理非常大的数据，所以该库必须能够优雅的处理机器故障。</p>
          </div>

<hr>
<h3 id="Worker-Failure"><a href="#Worker-Failure" class="headerlink" title="Worker Failure"></a>Worker Failure</h3><p>The master pings every worker <code>periodically</code>. If no response is received from a worker in a <code>certain</code> amount of time, the master marks the worker as failed. Any map tasks completed by the worker are reset back to their <code>initial</code> idle state, and therefore become <code>eligible</code> for scheduling on other workers. Similarly, any map task or reduce task in progress on a failed worker is also reset to idle and becomes eligible for rescheduling.</p>
<div class="note info">
            <p>master定时ping所有的worker(工作节点).如果没有在一定的时间内收到响应，master会标记这些work为failed状态。这个工作节点的所有已完成任务都会被重置为初始的idle状态，其他工作节点就可以处理这些任务了。类似的，任何一个故障的worker中未完成的map或reduce任务，也会被置为idle状态，等待重新调度</p>
          </div>

<p>Completed map tasks are re-executed on a failure because their output is stored on the local disk(s) of the failed machine and is therefore inaccessible. Completed reduce tasks do not need to be re-executed since their output is stored in a global file system.</p>
<div class="note info">
            <p>已完成的map任务遇到错误会重新执行，因为输出保存在故障机器的本地磁盘中所以是不可访问的。已完成的reduce task不需要从新执行，因为输出存储在公共的文件系统中。</p>
          </div>

<p>When a map task is executed first by worker A and then later executed by worker B (because A failed), all workers executing reduce tasks are notified of the reexecution. Any reduce task that has not already read the data from worker A will read the data from worker B.</p>
<div class="note info">
            <p>当一个map task一开始在worker a执行然后在worker b执行(因为work a)故障了，所有执行reduce task的worker都被收到通知。任何还没有从worker a读取数据的reduce task都会从work b开始读取数据。</p>
          </div>

<p>MapReduce is <code>resilient</code> to large-scale worker failures. For example, during one MapReduce operation, <code>network maintenance</code> on a running cluster was causing groups of 80 machines at a time to become unreachable for several minutes. The MapReduce <code>mastersimply</code> re-executed the work done by the unreachable worker machines, and continued to make forward progress, eventually completing the MapReduce operation.</p>
<div class="note info">
            <p>MapReduce能够弹性处理大规模工作节点故障。比如，网络维护导致80台机器同时持续几分钟不可访问。MapReduce会重新执行网络不可达的worker，然后继续向前执行，最终完成所有的MapReduce操作。</p>
          </div>

<h3 id="Master-Failure"><a href="#Master-Failure" class="headerlink" title="Master Failure"></a>Master Failure</h3><p>It is easy to make the master write <code>periodic</code> checkpoints of the master data structures described above. If the master task dies, a new copy can be started from the last checkpointed state. However, given that there is only a single master, its failure is unlikely; therefore our current implementation aborts the MapReduce computation if the master fails. Clients can check for this condition and retry the MapReduce operation if they <code>desire</code>.</p>
<div class="note info">
            <p>master可以很容易的将前面描述的数据结构写成checkpoint。如果master task失败了，可以从最新的checkpoint开始新的程序副本。然而，给定的只有一台主节点,它也不太可能失败。所以现在的MapReduce没有实现对于master fails的处理。如果客户端需要的话，可以自己检查这种情况然后重新尝试MapReduce操作。</p>
          </div>
<h3 id="Semantics-in-the-Presence-of-Failures"><a href="#Semantics-in-the-Presence-of-Failures" class="headerlink" title="Semantics in the Presence of Failures"></a>Semantics in the Presence of Failures</h3><p>When the user-supplied map and reduce operators are <code>deterministic</code> functions of their input values, our distributed implementation produces the same output as would have been produced by a non-faulting sequential execution of the <code>entire</code> program.</p>
<div class="note info">
            <p>当用户提供的map和reduce函数对于输入值是确定的，我们的分布式实现和非故障顺序执行的结果是一样的。</p>
          </div>

<p>We <code>rely</code> on atomic commits of map and reduce task outputs to achieve this <code>property</code>. Each in-progress task writes its output to private temporary files. A reduce task produces one such file, and a map task produces R such files (one per reduce task). When a map task completes, the worker sends a message to the master and includes the names of the R temporary files in the message. If the master receives a completion message for an already completed map task, it ignores the message. Otherwise, it records the names of R files in a master data structure.</p>
<div class="note info">
            <p>我们依靠原子提交map/reduce任务的输出来实现这个性质。所有in-grogress task将输出写入到自己私有的临时文件中。每个reduce task只生成一个这种文件，每个map task生成r个这种文件(每个reduce一个)。当一个map task完成的时候，会发送包含R个文件名称的消息给master。如果master从一个已经完成了的map task收到一个完成消息，会忽视掉。否则，会记录R个文件的文件名在master的数据结构中。</p>
          </div>

<p>When a reduce task completes, the reduce worker atomically renames its temporary output file to the final output file. If the same reduce task is executed on multiple machines, multiple rename calls will be executed for the same final output file. We rely on the atomic rename operation provided by the underlying file system to guarantee that the final file system state contains just the data produced by one execution of the reduce task.</p>
<div class="note info">
            <p>当reduce任务完成的时候，reduce工作节点会原子的将临时输出文件重命名为最终的输出文件。当相同的reduce任务在多台机器上执行，多个相同的对于最终输出文件的重命名调用会被执行。我们依赖底层文件系统提供的原子重命名操作来保证最终的文件系统仅包含一个reduce任务执行产生的数据。</p>
          </div>

<p><code>The vast majority</code> of our map and reduce operators are deterministic, and the fact that our semantics are equivalent to a sequential execution in this case makes it very easy for programmers to reason about their program’s behavior. When the map and/or reduce operators are nondeterministic, we provide weaker but still reasonable semantics. In the presence of non-deterministic operators, the output of a particular reduce task R1 is equivalent to the output for R1 produced by a sequential execution of the non-deterministic program. However, the output for a different reduce task R2 may correspond to the output for R2 produced by a different sequential execution of the non-deterministic program.</p>
<div class="note info">
            <p>绝大多数map和reduce操作都是确定性的，这在语义上和顺序执行是相等的，都很容易去解释程序的行为。当map或者reduce操作是不确定的时候我们提供较弱但仍旧合理的语义。对于不确定性操作，一个reduce任务R1的输出等价于一个不确定性的顺序执行的R1的输出。然而一个不同的reduce任务R2的输出可能和另外的不确定程序顺序执行下的输出R2相符。</p>
          </div>

<p>Consider map task M and reduce tasks R1 and R2. Let e(Ri) be the execution of Ri that committed (there is exactly one such execution). The weaker semantics <code>arise</code> because e(R1) may have read the output produced by one execution of M and e(R2) may have read the output produced by a different execution of M.</p>
<div class="note info">
            <p>考虑map任务M和reduce任务R1,R2. 让e(Ri)表示Ri的已提交的执行(只执行一次)。此时弱语义生效，因为e(R1)可能读取了M的输出，而e(R2)可能读取了M的另一个输出。</p>
          </div>

<hr>
<h3 id="3-4-Locality"><a href="#3-4-Locality" class="headerlink" title="3.4 Locality"></a>3.4 Locality</h3><p>Network <code>bandwidth</code> is a relatively <code>scarce</code> resource in our computing environment. We <code>conserve</code> network bandwidth by <code>taking advantage</code> of the fact that the input data (managed by GFS [8]) is stored on the local disks of the machines that make up our cluster. GFS divides each file into 64 MB blocks, and stores several copies of each block (typically 3 copies) on different machines. The MapReduce master takes the location information of the input files into account and attempts to schedule a map task on a machine that contains a <code>replica</code> of the corresponding input data. Failing that, it attempts to schedule a map task near a replica of that task’s input data (e.g., on a worker machine that is on the same network switch as the machine containing the data). When running large MapReduce operations on a <code>significant fraction</code> of the workers in a cluster, most input data is read locally and consumes no network bandwidth.</p>
<div class="note info">
            <p>局部性<br>网络带宽在我们的计算环境中是相对稀缺的资源。事实上我们利用将输入数据(通过GFS管理)存储在组成集群的机器的本地磁盘中从而节省了带宽。GFS将每个文件切割成64M大小的块，每块复制几份(通常是3份)存储到不同的机器。考虑到MapReduce master中保存了输入文件的位置信息，可以调用存储了输入数据的机器来执行map task.如果失败了，会接着尝试调度靠近存储输入数据备份的机器(比如和存储数据的机器在同一网关的其他机器)。当一个集群中大部分worker在运行一个大的MapReduce操作的时候，大多数输入数据都是本都读取的，而不消耗带宽。</p>
          </div>

<hr>
<h3 id="3-5-Task-Granularity"><a href="#3-5-Task-Granularity" class="headerlink" title="3.5 Task Granularity"></a>3.5 Task Granularity</h3><p>We <code>subdivide</code> the map phase into M pieces and the reduce phase into R pieces, as described above. <code>Ideally</code>, M and R should be much larger than the number of worker machines. Having each worker perform many different tasks <code>improves</code> dynamic load balancing, and also speeds up recovery when a worker fails: the many map tasks it has completed can be <code>spread out</code> across all the other worker machines.</p>
<div class="note info">
            <p>任务粒度<br>将map细分为M个阶段，reudce细分为R个阶段。理想情况下，M和R的总数远大于机器的worker数。每个worker都运行许多不同的任务从而提供了动态负载均衡，并且加速了worker故障的恢复：失败节点已经完成的map tasks可以扩散到到所有其他的worker中 </p>
          </div>

<p>There are <code>practical bounds</code> on how large M and R can be in our implementation, since the master must make O(M + R) scheduling decisions and keeps O(M<em>R) state in memory as described above. (The constant factors for memory usage are small however: the O(M</em>R) piece of the state consists of <code>approximately</code> one byte of data per map task/reduce task pair.)</p>
<div class="note info">
            <p>在我们的实现中,M和R有实际的上限，因为如前面所讲那样，master必须对O(M+R)做出调度决策，并存储O(M x R)的状态在内存中。(然后内存使用的常数项很小：O(M x R)个状态中每个map/reduce任务对只需要一个字节的数据)</p>
          </div>

<p>Furthermore, R is often <code>constrained</code> by users because the output of each reduce task ends up in a <code>separate</code> output file. In practice, we <code>tend to</code> choose M so that each <code>individual</code> task is <code>roughly</code> 16 MB to 64 MB of input data (so that the locality optimization described above is most effective), and we make R a small multiple of the number of worker machines we expect to use. We often perform MapReduce computations with M = 200000 and R = 5000, using 2000 worker machines.</p>
<div class="note info">
            <p>此外，R通常由用户指定，因为每一个reduce task的输出最终都保存在一个单独的输出文件中。在实践中，我们倾向于这样选择M，即将每个单独的任务都是16-64m大小的输入数据(这样前面说的局部性优化是最有效的)  因为每一个单独的任务的输入文件大小是16到64M(因为地区优化是最有效的)，并且我们选择R为我们希望使用的工作节点机器的小数倍。我们通常使用M=200000,R=5000,使用2000个worker机器来进行MapReduce计算。</p>
          </div>

<hr>
<h3 id="3-6-Backup-Tasks"><a href="#3-6-Backup-Tasks" class="headerlink" title="3.6 Backup Tasks"></a>3.6 Backup Tasks</h3><p>One of the common causes that <code>lengthens</code> the total time taken for a MapReduce operation is a “straggler”: a machine that takes an unusually long time to complete one of the last few map or reduce tasks in the computation. Stragglers can arise for a whole <code>host of reasons</code>. For example, a machine with a bad disk may experience frequent correctable errors that slow its read performance from 30 MB/s to 1 MB/s. The cluster scheduling system may have scheduled other tasks on the machine, causing it to execute the MapReduce code more slowly due to <code>competition</code> for CPU, memory, local disk, or network bandwidth. A recent problem we experienced was a bug in machine initialization code that caused processor caches to be disabled: computations on affected machines slowed down by over a <code>factor of one hundred</code>.</p>
<div class="note info">
            <p>备份任务<br>延长MapReduce操作总时间的常见原因之一是“落后者”：在计算中一台机器需要不正常的大量时间才能完成最后的几个map或者reduce任务。落后者的出现有很多原因。比如，一台机器磁盘损坏可能造成频繁的校正错误从而导致读取速度从30m/s变慢到1m/s.集群调度系统可能已经调度了其他任务在这台机器，因为需要竞争Cpu,内存，本地磁盘，网络带宽进而使得MapReduce变得更慢。我们最近遇到的一个机器初始化代码的bug造成缓存不可用：受影响的机器的计算速度下降了100倍</p>
          </div>

<p>We have a general <code>mechanism</code> to <code>alleviate</code> the problem of stragglers. When a MapReduce operation is close to completion, the master schedules backup executions of the <code>remaining</code> in-progress tasks. The task is marked as completed whenever either the primary or the backup execution completes. We have <code>tuned</code> this mechanism so that it typically increases the computational resources used by the operation by no more than a few percent. We have found that this significantly reduces the time to complete large MapReduce operations. As an example, the sort program described in Section 5.3 takes 44% longer to complete when the backup task mechanism is disabled.</p>
<div class="note info">
            <p>我们有一个一般的机制来减轻落后者的问题：当一个MapReduce操作接近完成的时候，master调度其他in-progress的tasks备份执行。不管是主要的还是备份的执行完成，task都会被master标记为已完成。我们已经调整了该机制使得其增加的计算资源不超过百分之几。我们发现这样显著的降低了完成大的MapReduce操作的时间。作为例子，5.3部分的排序程序在备份任务机制被禁用的情况下多消耗44%的时间。</p>
          </div>

<hr>
<h2 id="4-Refinements"><a href="#4-Refinements" class="headerlink" title="4 Refinements"></a>4 Refinements</h2><p>Although the basic functionality provided by simply writing Map and Reduce functions is <code>sufficient</code> for most needs, we have found a few extensions useful. These are described in this section.</p>
<div class="note info">
            <p>细化<br>尽管map reduce函数提供的基础功能已经足够使用了，我们还发现了一些有用的扩展，会在这部分描述。</p>
          </div>

<hr>
<h3 id="4-1-Partitioning-Function"><a href="#4-1-Partitioning-Function" class="headerlink" title="4.1 Partitioning Function"></a>4.1 Partitioning Function</h3><p>The users of MapReduce specify the number of reduce tasks/output files that they desire (R). Data gets partitioned across these tasks using a partitioning function on the intermediate key. A default partitioning function is provided that uses hashing (e.g. “hash(key) mod R”). This tends to result in fairly well-balanced partitions. In some cases, however, it is useful to partition data by some other function of the key. For example, sometimes the output keys are URLs, and we want all entries for a single host to end up in the same output file. To support situations like this, the user of the MapReduce library can provide a special partitioning function. For example, using “hash(Hostname(urlkey)) mod R” as the partitioning function causes all URLs from the same host to<br>end up in the same output file.</p>
<div class="note info">
            <p>MapReduce的用户可以指定他们想要的reduce tasks/output文件的数量(R).数据被划分函数通过中间key进行划分。我们提供了一个缺省的划分函数hash.这通常会生成成很好平衡性的划分。然而某些情况，其他的划分函数会更加有效。比如，有些时候输出的keys是URLs,我们希望某个主机的所有项最终都在相同的输出文件中。为了支持这种情况，MapReduce的用户可以指定一个特别的划分函数。比如使用hash(Hostname(urlkey)) mod R作为分区函数，这样所有相同主机的URLs都会在相同的输出文件。</p>
          </div>

<hr>
<h3 id="4-2-Ordering-Guarantees"><a href="#4-2-Ordering-Guarantees" class="headerlink" title="4.2 Ordering Guarantees"></a>4.2 Ordering Guarantees</h3><p>We guarantee that within a given partition, the intermediate key/value pairs are processed in increasing key order. This ordering guarantee makes it easy to generate a sorted output file per partition, which is useful when the output file format needs to support efficient random access lookups by key, or users of the output find it <code>convenient</code> to have the data sorted.</p>
<div class="note info">
            <p>我们保证在一个给定的分区内，中间的k/v pairs按照递增key的顺序处理。这种有序保证了每一个分区生成排序的输出文件变得容易，当输出文件格式需要指出按key随机有效访问，或者需要输出数据有序的时候用户会发现这很方便。</p>
          </div>

<hr>
<h3 id="4-3-Combiner-Function"><a href="#4-3-Combiner-Function" class="headerlink" title="4.3 Combiner Function"></a>4.3 Combiner Function</h3><p>In some cases, there is significant <code>repetition</code> in the intermediate keys produced by each map task, and the userspecified Reduce function is <code>commutative</code> and <code>associative</code>. A good example of this is the word counting example in Section 2.1. Since word frequencies tend to follow a Zipf distribution, each map task will produce hundreds or thousands of records of the form &lt;the, 1&gt;. All of these counts will be sent over the network to a single reduce task and then added together by the Reduce function to produce one number. We allow the user to specify an optional Combiner function that does partial merging of this data before it is sent over the network.</p>
<div class="note info">
            <p>合并函数<br>某些情况下，每一个map task生成的中间key有大量重复，并且用户指定的reduce函数可进行交换组合。一个好的例子是2.1节的单词统计例子，因为单词频率分布倾向于Zipf分布，每一个map task从&lt;the, 1&gt;中都会生成成百上千个记录。所有这些次数会通过网络发送给一个简单的reduce task，通过一个reduce函数加起来生成一个总数。我们允许用户指定一个可选的Combiner函数，在发送之前进行部分合并。</p>
          </div>

<p>The Combiner function is executed on each machine that performs a map task. Typically the same code is used to implement both the combiner and the reduce functions. The only difference between a reduce function and a combiner function is how the MapReduce library handles the output of the function. The output of a reduce function is written to the final output file. The output of a combiner function is written to an intermediate file that will be sent to a reduce task.</p>
<div class="note info">
            <p>Combiner函数在任意机器上作为map task运行。典型的combiner和reduce函数使用相同的代码实现。Combiner和Reduce函数的区别是MapReduce库如何处理输出数据。MapReduce函数的输出数据写在最终的输出文件。Combiner函数的输出数据写在中间文件然后发送给reduce task.</p>
          </div>

<p>Partial combining significantly speeds up certain classes of MapReduce operations. Appendix A contains an example that uses a combiner.</p>
<div class="note info">
            <p>部分合并能够显著加快各种MapReduce操作。附录A有一个使用combiner的例子。</p>
          </div>

<hr>
<h3 id="4-4-Input-and-Output-Types"><a href="#4-4-Input-and-Output-Types" class="headerlink" title="4.4 Input and Output Types"></a>4.4 Input and Output Types</h3><p>The MapReduce library provides support for reading input data in several different formats. For example, “text” mode input treats each line as a key/value pair: the key is the offset in the file and the value is the contents of the line. Another common supported format stores a sequence of key/value pairs sorted by key. Each input type implementation knows how to split itself into <code>meaningful</code> ranges for processing as separate map tasks (e.g. text mode’s range splitting ensures that range splits occur only at line boundaries). Users can add support for a new input type by providing an implementation of a simple reader interface, though most users just use one of a small number of <code>predefined</code> input types.</p>
<div class="note info">
            <p>MapReduce库提供了几种不同的格式来读取输入文件。比如，文本模式的输入文件的每一行作为一个k/v pair:key是在文件中的偏移，value是每一行的内容。另一种支持的格式存储了按照key排序的k/v pairs.每一种输入类型都应该知道如何分割为有意义的范围来让每个单独的map task处理(例如，文本模式下范围分割确保在每一行的行边界进行分割)。用户可以通过提供一个简单的读接口来增加新的输入类型，即使大多数用户只使用少数预定义的输入类型。</p>
          </div>

<p>A reader does not necessarily need to provide data read from a file. For example, it is easy to define a reader that reads records from a database, or from data structures mapped in memory.</p>
<div class="note info">
            <p>一个reader不一定要从文件中读取。比如，一个简单实现的reader可以从数据库，或者映射到内存的数据结构读取。</p>
          </div>

<p><code>In a similar fashion</code>, we support a set of output types for producing data in different formats and it is easy for<br>user code to add support for new output types.</p>
<div class="note info">
            <p>类似的方式，我们支持一组输出类型来生成不同格式的数据，用户编码增加新的输出类型很容易。</p>
          </div>

<hr>
<h3 id="4-5-Side-effects"><a href="#4-5-Side-effects" class="headerlink" title="4.5 Side-effects"></a>4.5 Side-effects</h3><p>In some cases, users of MapReduce have found it convenient to produce <code>auxiliary</code> files as additional outputs from their map and/or reduce operators. We rely on the application writer to make such side-effects atomic and <code>idempotent</code>. Typically the application writes to a temporary file and atomically renames this file once it has been fully generated. We do not provide support for atomic two-phase commits of multiple output files produced by a single task. Therefore, tasks that produce multiple output files with cross-file consistency requirements should be deterministic. This <code>restriction</code> has never been an issue in practice.</p>
<div class="note info">
            <p>边界效应<br>某些情况，MapReduce用户发现从他们的map reduce操作生成一些额外的辅助文件很有用。我们依赖应用编写者确保边界效应是原子的和幂等的。通常应用编写者会写到临时文件然后等完整生成的时候进行重命名。我们不支持一个task生成的多个输出文件的自动两阶段提交。因此，生成的多个输出文件的跨文件一致性要求必须是确定性的。这种限制在实践中还没出过问题。</p>
          </div>

<hr>
<h3 id="4-6-Skipping-Bad-Records"><a href="#4-6-Skipping-Bad-Records" class="headerlink" title="4.6 Skipping Bad Records"></a>4.6 Skipping Bad Records</h3><p>Sometimes there are bugs in user code that cause the Map or Reduce functions to crash deterministically on certain records. Such bugs <code>prevent</code> a MapReduce operation from completing. The usual <code>course of action</code> is to fix the bug, but sometimes this is not <code>feasible</code>; perhaps the bug is in a third-party library for which source code is unavailable. Also, sometimes it is acceptable to ignore a few records, for example when doing <code>statistical</code> <code>analysis</code> on a large data set. We provide an optional mode of execution where the MapReduce library detects which records cause deterministic crashes and skips these records in order to make forward progress.</p>
<div class="note info">
            <p>跳过坏记录<br>某些时候，用户代码的bug会在固定的记录上必然的崩溃。这些bug阻止了MapReduce操作的完成。通常的行动方针是修复bug,但有时是不可行的。或许bug来源于第三方库不可读的代码。或者，有时候忽视少数记录也是可接受的，比如统计分析大数据集合的时候。我们提供了一个可选的执行模式当MapReduce库检测到记录会造成确定性的崩溃则跳过这些记录来让程序继续运行。</p>
          </div>

<p>Each worker process installs a signal handler that catches segmentation <code>violations</code> and bus errors. Before invoking a user Map or Reduce operation, the MapReduce library stores the sequence number of the argument in a global variable. If the user code generates a signal, the signal handler sends a “last gasp” UDP packet that contains the sequence number to the MapReduce master. When the master has seen more than one failure on a particular record, it <code>indicates</code> that the record should be skipped when it issues the next re-execution of the corresponding Map or Reduce task.</p>
<div class="note info">
            <p>每一个worker进程都注册了信号处理函数来捕捉分段错误和bus错误。调用用户map reduce函数之前，MapReduce库在全局变量中存储了参数的顺序。如果用户代码产生了信号，信号处理函数发送包含最终序列号的udp报文给MapReduce主节点。当master发现在特定的记录上出现多次错误，表示当下一次记录重新执行map reduce的时候应该被跳过。</p>
          </div>

<hr>
<h3 id="4-7-Local-Execution"><a href="#4-7-Local-Execution" class="headerlink" title="4.7 Local Execution"></a>4.7 Local Execution</h3><p>Debugging problems in Map or Reduce functions can be <code>tricky</code>, since the actual computation happens in a distributed system, often on several thousand machines, with work assignment decisions made dynamically by the master. To help <code>facilitate</code> debugging, <code>profiling</code>, and small-scale testing, we have developed an <code>alternative</code> implementation of the MapReduce library that sequentially executes all of the work for a MapReduce operation on the local machine. Controls are provided to the user so that the computation can be limited to particular map tasks. Users invoke their program with a special flag and can then easily use any debugging or testing tools they find useful (e.g. gdb).</p>
<div class="note info">
            <p>Map Reduce函数的调试问题是棘手的，因为实际的计算发生在分布式系统，通常包括数千台机器，由master动态决定工作的分配。为了便于调试，分析，和小规模测试，我们开发了MapReduce库的另一实现，可在本地机器上顺序执行所有MapReduce操作。提供给用户的控制权使得计算可以被限制在部分的map tasks.用户可以通过特殊的标记调用程序，然后就可以很容易的使用任何他们觉得有用的调试和测试工具(比如gdb)</p>
          </div>

<hr>
<h3 id="4-8-Status-Information"><a href="#4-8-Status-Information" class="headerlink" title="4.8 Status Information"></a>4.8 Status Information</h3><p>The master runs an internal HTTP server and exports a set of status pages for human consumption. The status pages show the progress of the computation, such as how many tasks have been completed, how many are in progress, bytes of input, bytes of intermediate data, bytes of output, processing rates, etc. The pages also contain links to the standard error and standard output files generated by each task. The user can use this data to <code>predict</code> how long the computation will take, and whether or not more resources should be added to the computation. These pages can also be used to figure out when the computation is much slower than expected.</p>
<div class="note info">
            <p>master运行一个内部的http服务，可以将状态导出为网页供用户使用。状态页展示了计算的进度，比如已完成的任务数，处理中的任务数，输入数据大小，中间数据的大小，输出数据大小，处理速度等。页面还包含了指向每个task任务的标准错误和标椎输出文件的链接。用户可以使用这些数据预测计算需要多久，是否需要增加更多的计算资源。这些页面也可以被用来计算什么时间计算是低于预期的。</p>
          </div>

<p>In addition, the top-level status page shows which workers have failed, and which map and reduce tasks they were processing when they failed. This information is useful when attempting to <code>diagnose</code> bugs in the user code.</p>
<div class="note info">
            <p>另外，最高等级的状态页显示了哪些workers失败了，以及失败的时候有哪些map和reduce task在执行。这些信息在你调试用户代码中的Bug时将会很有用。</p>
          </div>

<hr>
<h3 id="4-9-Counters"><a href="#4-9-Counters" class="headerlink" title="4.9 Counters"></a>4.9 Counters</h3><p>The MapReduce library provides a counter facility to count occurrences of various events. For example, user code may want to count total number of words processed or the number of German documents indexed, etc.</p>
<div class="note info">
            <p>MapReduce库提供了一个计数器机制来统计各种事件的发生。比如，用户代码可能希望统计所有被处理的单词的总数或者德语文档索引的总数等。</p>
          </div>

<p>To use this facility, user code creates a named counter object and then increments the counter <code>appropriately</code> in the Map and/or Reduce function. For example:</p>
<div class="note info">
            <p>要使用这个机制，用户代码需要在Map/Reduce函数创建一个命名的计数器对象然后适当的增加该值。比如：</p>
          </div>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Counter* uppercase;</span><br><span class="line">uppercase &#x3D; GetCounter(&quot;uppercase&quot;);</span><br><span class="line"></span><br><span class="line">map(String name, String contents):</span><br><span class="line">    for each word w in contents:</span><br><span class="line">        if (IsCapitalized(w)):</span><br><span class="line">            uppercase-&gt;Increment();</span><br><span class="line">        EmitIntermediate(w, &quot;1&quot;);</span><br></pre></td></tr></table></figure>

<p>The counter values from individual worker machines are <code>periodically</code> <code>propagated</code> to the master (<code>piggybacked</code> on the ping response). The master <code>aggregates</code> the counter values from successful map and reduce tasks and returns them to the user code when the MapReduce operation is completed. The current counter values are also displayed on the master status page so that a human can watch the progress of the live computation. When aggregating counter values, the master <code>eliminates</code> the effects of duplicate executions of the same map or reduce task to avoid double counting. (Duplicate executions can arise from our use of backup tasks and from re-execution of tasks due to failures.)</p>
<div class="note info">
            <p>每个机器的计数值会定期的传播给master(带在ping响应中)。master会汇总成功的map和reduce的计数值并在MapReduce操作成功完成的时候返回给用户代码。这些信息也可以显示在master的状态页中，让用户能够看到实时的计算进展。在汇总这些值的时候，master会消除相同map/reduce重复执行造成的冲突的影响。(冲突会在用户使用备份任务或者任务失败导致的重新执行这些情况下发生)</p>
          </div>

<p>Some counter values are automatically <code>maintained</code> by the MapReduce library, such as the number of input key/value pairs processed and the number of output key/value pairs produced.</p>
<div class="note info">
            <p>一些计数值会由MapReduce库自动维护，比如输入k/v pairs处理的数量，输出的k/v pairs生成的数量。</p>
          </div>

<p>Users have found the counter facility useful for <code>sanity</code> checking the behavior of MapReduce operations. For example, in some MapReduce operations, the user code may want to ensure that the number of output pairs produced exactly equals the number of input pairs processed, or that the fraction of German documents processed is within some <code>tolerable</code> fraction of the total number of documents processed.</p>
<div class="note info">
            <p>用户发现计数机制对于MapReduce操作的智能检查非常有用。比如，对于一些MapReduce操作，用户代码可能希望生成的输出k/v pairs的数量等于处理的输入的pairs，或者已处理的德语文档的比例在所有已处理文档比例的可接受范围内。</p>
          </div>

<hr>
<h2 id="5-Performance"><a href="#5-Performance" class="headerlink" title="5 Performance"></a>5 Performance</h2><p>In this section we <code>measure</code> the performance of MapReduce on two computations running on a large cluster of machines. One computation searches through <code>approximately</code> one terabyte of data looking for a particular pattern. The other computation sorts approximately one terabyte of data.</p>
<div class="note info">
            <p>这部分我们测试MapReduce运行在大集群中的两种计算能力。一种计算用于查找大约1T大小的数据来寻找特定的模式，另一种计算对大约1T的数据进行排序。</p>
          </div>

<p>These two programs are <code>representative</code> of a large subset of the real programs written by users of MapReduce – one class of programs shuffles data from one representation to another, and another class <code>extracts</code> a small amount of interesting data from a large data set.</p>
<div class="note info">
            <p>这两种程序是用户编写的MapReduce程序的的代表。– 一种程序将数据从一种表示形式转换成另一种形式，另一种从大的数据集中提取一小部分感兴趣的数据。</p>
          </div>

<hr>
<h2 id="5-1-Cluster-Configuration"><a href="#5-1-Cluster-Configuration" class="headerlink" title="5.1 Cluster Configuration"></a>5.1 Cluster Configuration</h2><p>All of the programs were executed on a cluster that consisted of approximately 1800 machines. Each machine had two 2GHz Intel Xeon processors with <code>HyperThreading</code> enabled, 4GB of memory, two 160GB IDE disks, and a <code>gigabit</code> Ethernet link. The machines were <code>arranged</code> in a two-level tree-shaped switched network with approximately 100-200 Gbps of <code>aggregate</code> bandwidth available at the root. All of the machines were in the same <code>hosting facility</code> and therefore the <code>round-trip</code> time between any pair of machines was less than a millisecond.</p>
<div class="note info">
            <p>集群配置<br>所有的程序都在大约1800台机器组成的集群上运行。每台机器都有启用了超线程的2GHz的intel xeon处理器，4G内存，两个160g的IDE磁盘，一个千兆的以太网连接。这些机器排列在两层的树形交换机中，根部拥有100-200G的带宽。所有的机器都在相同的托管设施中，任何两台机器的往返时间都在1ms之内。</p>
          </div>

<p>Out of the 4GB of memory, approximately 1-1.5GB was <code>reserved</code> by other tasks running on the cluster. The programs were executed on a weekend afternoon, when the CPUs, disks, and network were mostly idle.</p>
<div class="note info">
            <p>除了4G内存外，还有1-1.5G的内存保留给了集群上其他的task使用。程序在周末的下午执行，此时cpu,磁盘和网络大多处于闲置状态。</p>
          </div>


<hr>
<h3 id="5-2-Grep"><a href="#5-2-Grep" class="headerlink" title="5.2 Grep"></a>5.2 Grep</h3><p>The grep program scans through 10^10 100-byte records, searching for a relatively <code>rare</code> three-character pattern (the pattern occurs in 92,337 records). The input is split into approximately 64MB pieces (M = 15000), and the entire output is placed in one file (R = 1).</p>
<div class="note info">
            <p>grep程序扫描10^10个100字节的记录，寻找比较罕见的3个字符组成的模式(模式在92337个记录中出现)。输入数据被分为64m左右的块(M=15000), 整个输出都包含在一个文件内(R=1)</p>
          </div>

<p>Figure 2 shows the progress of the computation over time. The Y-axis shows the rate at which the input data is scanned. The rate gradually <code>picks up</code> as more machines are assigned to this MapReduce computation, and peaks at over 30 GB/s when 1764 workers have been assigned. As the map tasks finish, the rate starts dropping and hits zero about 80 seconds into the computation. The entire computation takes approximately 150 seconds from start to finish. This includes about a minute of <code>startup overhead</code>. The overhead is due to the <code>propagation</code> of the program to all worker machines, and delays <code>interacting</code> with GFS to open the set of 1000 input files and to get the information needed for the locality optimization.</p>
<div class="note info">
            <p>图2显示了随着时间推移的计算进度。Y轴是输入数据的扫描速度。随着被分配给MapReduce计算的机器数增多速度开始增高，当被分配1764个workers的时候达到30g/s.等到map tasks完成的时候，速度在80秒内逐渐下降到0.整个计算从开始到结束花费大概150s。这包含了一分钟的启动花销。花销是因为程序在所有机器上的传播，以及和GFS互动而打开的1000个输入文件和为了局部优化获取数据造成的。</p>
          </div>

<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/Snipaste_2021-01-21_14-37-29.jpg"></p>
<hr>
<h3 id="5-3-Sort"><a href="#5-3-Sort" class="headerlink" title="5.3 Sort"></a>5.3 Sort</h3><p>The sort program sorts 10^10 100-byte records (approximately 1 terabyte of data). This program is modeled after the TeraSort benchmark [10].</p>
<div class="note info">
            <p>sort程序对大约1T数据进行排序，该程序模仿了TeraSort benchmark。</p>
          </div>

<p>The sorting program consists of less than 50 lines of user code. A three-line Map function extracts a 10-byte sorting key from a text line and emits the key and the original text line as the intermediate key/value pair. We used a built-in Identity function as the Reduce operator. This functions passes the intermediate key/value pair unchanged as the output key/value pair. The final sorted output is written to a set of 2-way replicated GFS files (i.e., 2 terabytes are written as the output of the program).</p>
<div class="note info">
            <p>排序程序由不到50行用户代码组成。map函数一共3行，它从文本行中提取排序的key然后发送key和原始的文本行到中间的k/v pairs.我们使用内置的函数实现reduce操作。该函数传递未改动的中间k/v pair作为输出的k/v pair.最终的结果写到一组2路复制的GFS文件中</p>
          </div>

<p>As before, the input data is split into 64MB pieces (M = 15000). We partition the sorted output into 4000 files (R = 4000). The partitioning function uses the initial bytes of the key to segregate it into one of R pieces.</p>
<div class="note info">
            <p>和前面一样，输入数据被分为64m大小的块。(M=15000) 我们划分有序的输出到4000个文件中(R=4000)。划分函数根据key的首字节将其划分到一个R文件中。</p>
          </div>

<p>Our partitioning function for this benchmark has builtin knowledge of the distribution of keys. In a general sorting program, we would add a pre-pass MapReduce operation that would collect a sample of the keys and use the distribution of the sampled keys to compute splitpoints for the final sorting pass.</p>
<div class="note info">
            <p>此次测试中我们的划分函数已经内建了key分布的知识。在一般的排序程序中，我们会预先添加MapReduce操作，收集key的样本，并使用key抽样的分布来计算最终输出文件的划分点。</p>
          </div>

<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/Snipaste_2021-01-21_14-39-22.jpg"></p>
<p>Figure 3 (a) shows the progress of a normal execution of the sort program. The top-left graph shows the rate at which input is read. The rate peaks at about 13 GB/s and dies off fairly quickly since all map tasks finish before 200 seconds have <code>elapsed</code>. Note that the input rate is less than for grep. This is because the sort map tasks spend about half their time and I/O bandwidth writing intermediate output to their local disks. The corresponding intermediate output for grep had <code>negligible</code> size.</p>
<div class="note info">
            <p>图3展示了排序程序正常执行的过程。左上角图显示了输入数据读取的速度。速度高峰的时候达到13g/s然后在200秒快速降下去。注意这里的输入速度远小于grep.因为排序的map任务写中间文件到磁盘花费了一半的时间和I/O带宽。而grep的中间输出数据非常小。</p>
          </div>

<p>The middle-left graph shows the rate at which data is sent over the network from the map tasks to the reduce tasks. This shuffling starts as soon as the first map task completes. The first <code>hump</code> in the graph is for the first batch of approximately 1700 reduce tasks (the entire MapReduce was assigned about 1700 machines, and each machine executes <code>at most one</code> reduce task at a time). <code>Roughly</code> 300 seconds into the computation, some of these first batch of reduce tasks finish and we start shuffling data for the <code>remaining</code> reduce tasks. All of the shuffling is done about 600 seconds into the computation.</p>
<div class="note info">
            <p>左边中间的图显示了map任务通过网络给reduce任务发送数据的速度。在第一个map任务完成的时候快速变化。图中第一个驼峰是大约1700个reduce任务批量运行的时候(整个MapReduce被分配了1700台机器，每台机器都同时间运行最多一个reduce任务)。计算大概300秒，一些reduce任务已经完成了并开始向其他的reduce任务传递(改组？)数据。所有的传送在600秒结束。</p>
          </div>

<p>The bottom-left graph shows the rate at which sorted data is written to the final output files by the reduce tasks. There is a delay between the end of the first shuffling <code>period</code> and the start of the writing period because the machines are busy sorting the intermediate data. The writes continue at a rate of about 2-4 GB/s for a while. All of the writes finish about 850 seconds into the computation. Including <code>startup overhead</code>, the entire computation takes 891 seconds. This is similar to the current best reported result of 1057 seconds for the TeraSort benchmark [18].</p>
<div class="note info">
            <p>左边底部的图显示了reduce任务将排序数据写到最终输出文件的速度。在第一次传输数据和开始写入数据之间有一个延迟，因为这会机器正忙于对中间数据进行排序。写数据保持2-4G/s的速度一段时间。850秒的时候所有写操作结束。算上启动开销，整个计算需要891秒。这和TeraSort报告的最新测试数据1057秒很接近。</p>
          </div>

<p>A few things to note: the input rate is higher than the shuffle rate and the output rate because of our locality optimization – most data is read from a local disk and bypasses our relatively bandwidth constrained network. The shuffle rate is higher than the output rate because the output phase writes two copies of the sorted data (we make two replicas of the output for reliability and availability reasons). We write two replicas because that is the <code>mechanism</code> for reliability and availability provided by our underlying file system. Network bandwidth requirements for writing data would be reduced if the underlying file system used <code>erasure</code> coding [14] rather than replication.</p>
<div class="note info">
            <p>一些要注意的事：输入数据的速度是高于传输数据和输出数据的因为局部性优化-绕开了带宽受限的网络。传输速度高于输出数据是因为写输出阶段要对排序数据写两份拷贝(我们通过对输出数据写两份拷贝来实现可靠性和可用性)。写两份拷贝是底层文件系统对可靠性和可用性提供的机制。如果底层文件系统使用删除代码而不是复制，写数据的带宽将会降低。</p>
          </div>

<hr>
<h3 id="5-4-Effect-of-Backup-Tasks"><a href="#5-4-Effect-of-Backup-Tasks" class="headerlink" title="5.4 Effect of Backup Tasks"></a>5.4 Effect of Backup Tasks</h3><p>In Figure 3 (b), we show an execution of the sort program with backup tasks disabled. The execution flow is similar to that shown in Figure 3 (a), except that there is a very long tail where hardly any write activity occurs. After 960 seconds, all except 5 of the reduce tasks are completed. However these last few stragglers don’t finish until 300 seconds later. The entire computation takes 1283 seconds, an increase of 44% in elapsed time.</p>
<div class="note info">
            <p>备份任务的影响</p><p>图3b显示了，禁用备份任务下排序程序的运行。和图3a看起来很相似。除了尾部有非常长的时间几乎没有写操作发生。960秒后，只有5个reduce任务还没有完成。但这几个落后者直到300秒后才全部完成。整个计算花了1283秒，比之前多了44%的时间。</p>
          </div>

<hr>
<h3 id="5-5-Machine-Failures"><a href="#5-5-Machine-Failures" class="headerlink" title="5.5 Machine Failures"></a>5.5 Machine Failures</h3><p>In Figure 3 (c), we show an execution of the sort program where we <code>intentionally</code> killed 200 out of 1746 worker processes several minutes into the computation. The underlying cluster scheduler immediately restarted new worker processes on these machines (since only the processes were killed, the machines were still <code>functioning</code> properly).</p>
<div class="note info">
            <p>机器故障<br>图3c中,显示的是我们故意杀掉1746个工作节点中的200个节点达几分钟时排序程序的执行。底层集群调度器马上在这些机器上重启了新的工作节点。(进程被杀掉了，机器还在正常运行)</p>
          </div>

<p>The worker deaths show up as a <code>negative</code> input rate since some previously completed map work disappears (since the corresponding map workers were killed) and needs to be redone. The re-execution of this map work happens relatively quickly. The entire computation finishes in 933 seconds including startup overhead (just an increase of 5% over the normal execution time).</p>
<div class="note info">
            <p>工作节点挂掉显示为负的输入速度，因为之前已经完成的一些map任务消失了(相应的工作节点被杀掉了)需要重新完成。重新执行这些map任务会很快发生。整个计算过程包含启动开销一共花了933秒(只比正常的执行时间多了5%)</p>
          </div>

<hr>
<h2 id="6-Experience"><a href="#6-Experience" class="headerlink" title="6 Experience"></a>6 Experience</h2><p>We wrote the first version of the MapReduce library in February of 2003, and made significant enhancements to it in August of 2003, including the locality optimization, dynamic load balancing of task execution across worker machines, etc. Since that time, we have been pleasantly surprised at how broadly applicable the MapReduce library has been for the kinds of problems we work on.<br>It has been used across a wide range of domains within Google, including:</p>
<ul>
<li>large-scale machine learning problems,</li>
<li>clustering problems for the Google News and Froogle products,</li>
<li>extraction of data used to produce reports of popular queries (e.g. Google Zeitgeist),</li>
<li>extraction of properties of web pages for new experiments and products (e.g. extraction of geographical locations from a large corpus of web pages for localized search), and</li>
<li>large-scale graph computations.</li>
</ul>
<p><a href="https://blog-1254238374.cos.ap-hongkong.myqcloud.com/blog/Snipaste_2021-01-21_14-42-41.jpg">https://blog-1254238374.cos.ap-hongkong.myqcloud.com/blog/Snipaste_2021-01-21_14-42-41.jpg</a></p>
<p>Figure 4 shows the significant growth in the number of separate MapReduce programs checked into our primary source code management system over time, from 0 in early 2003 to almost 900 separate instances as of late September 2004. MapReduce has been so successful because it makes it possible to write a simple program and run it efficiently on a thousand machines in the course of half an hour, greatly speeding up the development and prototyping cycle. Furthermore, it allows programmers who have no experience with distributed and/or parallel systems to exploit large amounts of resources easily.</p>
<p>At the end of each job, the MapReduce library logs statistics about the computational resources used by the job. In Table 1, we show some statistics for a subset of MapReduce jobs run at Google in August 2004.</p>
<div class="note info">
            <p>经验</p>
          </div>

<hr>
<h3 id="6-1-Large-Scale-Indexing"><a href="#6-1-Large-Scale-Indexing" class="headerlink" title="6.1 Large-Scale Indexing"></a>6.1 Large-Scale Indexing</h3><p>One of our most significant uses of MapReduce to date has been a complete rewrite of the production indexing system that produces the data structures used for the Google web search service. The indexing system takes as input a large set of documents that have been <code>retrieved</code> by our crawling system, stored as a set of GFS files. The raw contents for these documents are more than 20 terabytes of data. The indexing process runs as a sequence of five to ten MapReduce operations. Using MapReduce (instead of the ad-hoc distributed passes in the prior version of the indexing system) has provided several benefits:</p>
<div class="note info">
            <p>大规模索引<br>我们对于MapReduce的最重要的一个使用是完全重写了生产环境索引系统，它用来生成谷歌网络搜索服务需要的数据结构。索引系统以我们爬取系统抓取的很多文档集合作为输入，存储为一组GFS文件。这些文件中的原始内容超过20Tb.索引系统以5-20个MapReduce程序运行。使用MapReduce(而不是老版本索引系统中的ad-hoc)带来了几点好处：</p>
          </div>

<ul>
<li>The indexing code is simpler, smaller, and easier to understand, because the code that deals with fault tolerance, distribution and parallelization is hidden within the MapReduce library. For example, the size of one phase of the computation dropped from approximately 3800 lines of C++ code to approximately 700 lines when expressed using MapReduce.</li>
</ul>
<div class="note info">
            <p>索引代码简单，代码量小，容易理解，因为处理容错，分布式和并行化的代码隐藏在了MapReduce的库里面。比如，其中一个阶段的计算在使用了MapReduce后代码量从3800行C++代码降低到只需要700行。</p>
          </div>

<ul>
<li>The performance of the MapReduce library is good enough that we can keep conceptually unrelated computations separate, instead of mixing them together to avoid extra passes over the data. This makes it easy to change the indexing process. For example, one change that took a few months to make in our old indexing system took only a few days to implement in the new system.</li>
</ul>
<div class="note info">
            <p>MapReduce的性能足够好，我们可以把概念上无关的计算分离，而不需要为了避免额外传输数据将其混杂在一起。这让修改索引进程变得容易，以前修改老的索引系统需要几个月的时间，而在现在新实现的索引系统上只需要几天时间。</p>
          </div>

<ul>
<li>The indexing process has become much easier to operate, because most of the problems caused by machine failures, slow machines, and <code>networking hiccups</code> are dealt with automatically by the MapReduce library without operator <code>intervention</code>. Furthermore, it is easy to improve the performance of the indexing process by adding new machines to the indexing cluster.</li>
</ul>
<div class="note info">
            <p>索引系统更容易去操作，因为大多数机器故障，机器执行缓慢，网络中断问题都可以由MapReduce库自动处理而不需要额外介入。此外，通过增加集群中的机器数可以很容易的提高索引进程的性能。</p>
          </div>

<hr>
<h2 id="7-Related-Work"><a href="#7-Related-Work" class="headerlink" title="7 Related Work"></a>7 Related Work</h2><p>Many systems have provided restricted programming models and used the restrictions to parallelize the computation automatically. For example, an associative function can be computed over all prefixes of an N element array in log N time on N processors using parallel prefix computations [6, 9, 13]. MapReduce can be considered a simplification and distillation of some of these models<br>based on our experience with large real-world computations. More significantly, we provide a fault-tolerant implementation that scales to thousands of processors. In contrast, most of the parallel processing systems have only been implemented on smaller scales and leave the details of handling machine failures to the programmer.</p>
<p>Bulk Synchronous Programming [17] and some MPI primitives [11] provide higher-level abstractions that make it easier for programmers to write parallel programs. A key difference between these systems and MapReduce is that MapReduce exploits a restricted programming model to parallelize the user program automatically and to provide transparent fault-tolerance.</p>
<p>Our locality optimization draws its inspiration from techniques such as active disks [12, 15], where computation is pushed into processing elements that are close to local disks, to reduce the amount of data sent across I/O subsystems or the network. We run on commodity processors to which a small number of disks are directly connected instead of running directly on disk controller<br>processors, but the general approach is similar.</p>
<p>Our backup task mechanism is similar to the eager scheduling mechanism employed in the Charlotte System [3]. One of the shortcomings of simple eager scheduling is that if a given task causes repeated failures, the entire computation fails to complete. We fix some instances of this problem with our mechanism for skipping bad records.</p>
<p>The MapReduce implementation relies on an in-house cluster management system that is responsible for distributing and running user tasks on a large collection of shared machines. Though not the focus of this paper, the cluster management system is similar in spirit to other systems such as Condor [16].</p>
<p>The sorting facility that is a part of the MapReduce library is similar in operation to NOW-Sort [1]. Source machines (map workers) partition the data to be sorted and send it to one of R reduce workers. Each reduce worker sorts its data locally (in memory if possible). Of course NOW-Sort does not have the user-definable Map and Reduce functions that make our library widely applicable.</p>
<p>River [2] provides a programming model where processes communicate with each other by sending data over distributed queues. Like MapReduce, the River system tries to provide good average case performance even in the presence of non-uniformities introduced by<br>heterogeneous hardware or system perturbations. River achieves this by careful scheduling of disk and network<br>transfers to achieve balanced completion times. MapReduce has a different approach. By restricting the programming model, the MapReduce framework is able to partition the problem into a large number of finegrained tasks. These tasks are dynamically scheduled<br>on available workers so that faster workers process more tasks. The restricted programming model also allows us to schedule redundant executions of tasks near the end of the job which greatly reduces completion time in the presence of non-uniformities (such as slow or stuck workers).</p>
<p>BAD-FS [5] has a very different programming model from MapReduce, and unlike MapReduce, is targeted to the execution of jobs across a wide-area network. However, there are two fundamental similarities. (1) Both systems use redundant execution to recover from data loss caused by failures. (2) Both use locality-aware scheduling to reduce the amount of data sent across congested network links.</p>
<p>TACC [7] is a system designed to simplify construction of highly-available networked services. Like MapReduce, it relies on re-execution as a mechanism for implementing fault-tolerance.</p>
<div class="note info">
            <p>相关工作<br>…</p>
          </div>

<hr>
<h2 id="8-Conclusions"><a href="#8-Conclusions" class="headerlink" title="8 Conclusions"></a>8 Conclusions</h2><p>The MapReduce programming model has been successfully used at Google for many different purposes. We <code>attribute</code> this success to several reasons. First, the model is easy to use, even for programmers without experience with parallel and distributed systems, since it hides the details of parallelization, fault-tolerance, locality optimization, and load balancing. Second, a large variety of problems are easily expressible as MapReduce computations. For example, MapReduce is used for the generation of data for Google’s production web search service, for sorting, for <code>data mining</code>, for machine learning, and many other systems. Third, we have developed an implementation of MapReduce that scales to large clusters of machines <code>comprising</code> thousands of machines. The implementation makes efficient use of these machine resources and therefore is suitable for use on many of the large computational problems encountered at Google.</p>
<div class="note info">
            <p>结论<br>MapReduce编程模型在谷歌内部已经成功的用于很多不同的用途。我们将其成功归结于几个方面。首先，该模型易于使用，即使对于没有并行和分布式经验的程序员，因为模型隐藏了并行化，容错，局部优化和负载均衡的细节。其次，很多种类的问题都可以方便的表示为MapReduce模型。比如，MapReduce被用于谷歌网络搜索服务的数据生成，排序，数据挖掘，和用于机器学习以及其他的系统。第三，我们已经开发了MapReduce的实现，可以扩展到数千台机器组成的大规模集群中。该实现可以高效利用机器资源，因此适用于谷歌遇到的的许多大的计算问题。</p>
          </div>

<p>We have learned several things from this work. First, <code>restricting</code> the programming model makes it easy to parallelize and distribute computations and to make such computations fault-tolerant. Second, network bandwidth is a <code>scarce</code> resource. <code>A number of</code> optimizations in our system are therefore targeted at reducing the amount of data sent across the network: the locality optimization allows us to read data from local disks, and writing a single copy of the intermediate data to local disk saves network bandwidth. Third, <code>redundant</code> execution can be used to reduce the <code>impact</code> of slow machines, and to handle machine failures and data loss.</p>
<div class="note info">
            <p>从这项工作中我们学到了一些东西。首先，约束编程模型使得并行以及分布式计算，以及计算容错，变得简单。其次，网络带宽是稀缺资源。我们系统因此针对通过网络传输大量数据做了一些优化：局部性优化允许我们从本地磁盘读取数据，写一份中间数据到本地磁盘也节省了带宽。第三，冗余执行可以降低慢机器造成的影响，以及处理机器故障和数据丢失。</p>
          </div>

<hr>
<h2 id="Acknowledgements"><a href="#Acknowledgements" class="headerlink" title="Acknowledgements"></a>Acknowledgements</h2><p>Josh Levenberg has been instrumental in revising and extending the user-level MapReduce API with a number of new features based on his experience with using MapReduce and other people’s suggestions for enhancements. MapReduce reads its input from and writes its output to the Google File System [8]. We would like to thank Mohit Aron, Howard Gobioff, Markus Gutschke,</p>
<p>David Kramer, Shun-Tak Leung, and Josh Redstone for their work in developing GFS. We would also like to thank Percy Liang and Olcan Sercinoglu for their work in developing the cluster management system used by MapReduce. Mike Burrows, Wilson Hsieh, Josh Levenberg, Sharon Perl, Rob Pike, and Debby Wallach provided helpful comments on earlier drafts of this paper. The anonymous OSDI reviewers, and our shepherd, Eric Brewer, provided many useful suggestions of areas where the paper could be improved. Finally, we thank all the users of MapReduce within Google’s engineering organization for providing helpful feedback, suggestions, and bug reports.</p>
<div class="note info">
            <p>致谢…</p>
          </div>

<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] Andrea C. Arpaci-Dusseau, Remzi H. Arpaci-Dusseau, David E. Culler, Joseph M. Hellerstein, and David A. Patterson. High-performance sorting on networks of workstations. In Proceedings of the 1997 ACM SIGMOD International Conference on Management of Data, Tucson, Arizona, May 1997.</p>
<p>[2] Remzi H. Arpaci-Dusseau, Eric Anderson, Noah Treuhaft, David E. Culler, Joseph M. Hellerstein, David Patterson, and Kathy Yelick. Cluster I/O with River: Making the fast case common. In Proceedings of the Sixth Workshop on Input/Output in Parallel and Distributed<br>Systems (IOPADS ’99), pages 10–22, Atlanta, Georgia, May 1999.</p>
<p>[3] Arash Baratloo, Mehmet Karaul, Zvi Kedem, and Peter Wyckoff. Charlotte: Metacomputing on the web. In Proceedings of the 9th International Conference on Parallel and Distributed Computing Systems, 1996.</p>
<p>[4] Luiz A. Barroso, Jeffrey Dean, and Urs Holzle. ¨ Web search for a planet: The Google cluster architecture. IEEE Micro, 23(2):22–28, April 2003.</p>
<p>[5] John Bent, Douglas Thain, Andrea C.Arpaci-Dusseau, Remzi H. Arpaci-Dusseau, and Miron Livny. Explicit control in a batch-aware distributed file system. In Proceedings of the 1st USENIX Symposium on Networked Systems Design and Implementation NSDI, March 2004.</p>
<p>[6] Guy E. Blelloch. Scans as primitive parallel operations. IEEE Transactions on Computers, C-38(11), November</p>
<p>[7] Armando Fox, Steven D. Gribble, Yatin Chawathe, Eric A. Brewer, and Paul Gauthier. Cluster-based scalable network services. In Proceedings of the 16th ACM Symposium on Operating System Principles, pages 78– 91, Saint-Malo, France, 1997.</p>
<p>[8] Sanjay Ghemawat, Howard Gobioff, and Shun-Tak Leung. The Google file system. In 19th Symposium on Operating Systems Principles, pages 29–43, Lake George, New York, 2003.</p>
<p>[9] S. Gorlatch. Systematic efficient parallelization of scan and other list homomorphisms. In L. Bouge, P. Fraigniaud, A. Mignotte, and Y. Robert, editors, Euro-Par’96. Parallel Processing, Lecture Notes in Computer Science 1124, pages 401–408. Springer-Verlag, 1996.</p>
<p>[10] Jim Gray. Sort benchmark home page. <a href="http://research.microsoft.com/barc/SortBenchmark/">http://research.microsoft.com/barc/SortBenchmark/</a>.</p>
<p>[11] William Gropp, Ewing Lusk, and Anthony Skjellum. Using MPI: Portable Parallel Programming with the Message-Passing Interface. MIT Press, Cambridge, MA,</p>
<p>[12] L. Huston, R. Sukthankar, R. Wickremesinghe, M. Satyanarayanan, G. R. Ganger, E. Riedel, and A. Ailamaki. Diamond: A storage architecture for early discard in interactive search. In Proceedings of the 2004 USENIX File and Storage Technologies FAST Conference, April 2004.</p>
<p>[13] Richard E. Ladner and Michael J. Fischer. Parallel prefix computation. Journal of the ACM, 27(4):831–838, 1980.</p>
<p>[14] Michael O. Rabin. Efficient dispersal of information for security, load balancing and fault tolerance. Journal of<br>the ACM, 36(2):335–348, 1989.</p>
<p>[15] Erik Riedel, Christos Faloutsos, Garth A. Gibson, and David Nagle. Active disks for large-scale data processing. IEEE Computer, pages 68–74, June 2001.</p>
<p>[16] Douglas Thain, Todd Tannenbaum, and Miron Livny. Distributed computing in practice: The Condor experience. Concurrency and Computation: Practice and Experience, 2004.</p>
<p>[17] L. G. Valiant. A bridging model for parallel computation. Communications of the ACM, 33(8):103–111, 1997.</p>
<p>[18] Jim Wyllie. Spsort: How to sort a terabyte quickly. <a href="http://alme1.almaden.ibm.com/cs/spsort.pdf">http://alme1.almaden.ibm.com/cs/spsort.pdf</a>.</p>
<h2 id="A-Word-Frequency"><a href="#A-Word-Frequency" class="headerlink" title="A Word Frequency"></a>A Word Frequency</h2><p>This section contains a program that counts the number of occurrences of each unique word in a set of input files specified on the command line.</p>
<p>这部分是一个统计由命令行指定的输入文件集合中每一个唯一的单词出现次数的统计程序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mapreduce/mapreduce.h&quot;</span></span></span><br><span class="line"><span class="comment">// User’s map function</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordCounter</span> :</span> <span class="keyword">public</span> Mapper &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Map</span><span class="params">(<span class="keyword">const</span> MapInput&amp; input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> string&amp; text = input.<span class="built_in">value</span>();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = text.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ) &#123;</span><br><span class="line">            <span class="comment">// Skip past leading whitespace</span></span><br><span class="line">            <span class="keyword">while</span> ((i &lt; n) &amp;&amp; <span class="built_in">isspace</span>(text[i]))</span><br><span class="line">                i++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Find word end</span></span><br><span class="line">            <span class="keyword">int</span> start = i;</span><br><span class="line">            <span class="keyword">while</span> ((i &lt; n) &amp;&amp; !<span class="built_in">isspace</span>(text[i]))</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">if</span> (start &lt; i)</span><br><span class="line">                <span class="built_in">Emit</span>(text.<span class="built_in">substr</span>(start,i-start),<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">REGISTER_MAPPER</span>(WordCounter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// User’s reduce function</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adder</span> :</span> <span class="keyword">public</span> Reducer &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Reduce</span><span class="params">(ReduceInput* input)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Iterate over all entries with the</span></span><br><span class="line">        <span class="comment">// same key and add the values</span></span><br><span class="line">        int64 value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!input-&gt;<span class="built_in">done</span>()) &#123;</span><br><span class="line">            value += <span class="built_in">StringToInt</span>(input-&gt;<span class="built_in">value</span>());</span><br><span class="line">            input-&gt;<span class="built_in">NextValue</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Emit sum for input-&gt;key()</span></span><br><span class="line">        <span class="built_in">Emit</span>(<span class="built_in">IntToString</span>(value));</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">REGISTER_REDUCER</span>(Adder);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ParseCommandLineFlags</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">    MapReduceSpecification spec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Store list of input files into &quot;spec&quot;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        MapReduceInput* input = spec.<span class="built_in">add_input</span>();</span><br><span class="line">        input-&gt;<span class="built_in">set_format</span>(<span class="string">&quot;text&quot;</span>);</span><br><span class="line">        input-&gt;<span class="built_in">set_filepattern</span>(argv[i]);</span><br><span class="line">        input-&gt;<span class="built_in">set_mapper_class</span>(<span class="string">&quot;WordCounter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Specify the output files:</span></span><br><span class="line">    <span class="comment">// /gfs/test/freq-00000-of-00100</span></span><br><span class="line">    <span class="comment">// /gfs/test/freq-00001-of-00100</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    MapReduceOutput* out = spec.<span class="built_in">output</span>();</span><br><span class="line">    out-&gt;<span class="built_in">set_filebase</span>(<span class="string">&quot;/gfs/test/freq&quot;</span>);</span><br><span class="line">    out-&gt;<span class="built_in">set_num_tasks</span>(<span class="number">100</span>);</span><br><span class="line">    out-&gt;<span class="built_in">set_format</span>(<span class="string">&quot;text&quot;</span>);</span><br><span class="line">    out-&gt;<span class="built_in">set_reducer_class</span>(<span class="string">&quot;Adder&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optional: do partial sums within map</span></span><br><span class="line">    <span class="comment">// tasks to save network bandwidth</span></span><br><span class="line">    out-&gt;<span class="built_in">set_combiner_class</span>(<span class="string">&quot;Adder&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tuning parameters: use at most 2000</span></span><br><span class="line">    <span class="comment">// machines and 100 MB of memory per task</span></span><br><span class="line">    spec.<span class="built_in">set_machines</span>(<span class="number">2000</span>);</span><br><span class="line">    spec.<span class="built_in">set_map_megabytes</span>(<span class="number">100</span>);</span><br><span class="line">    spec.<span class="built_in">set_reduce_megabytes</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now run it</span></span><br><span class="line">    MapReduceResult result;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">MapReduce</span>(spec, &amp;result)) <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Done: ’result’ structure contains info</span></span><br><span class="line">    <span class="comment">// about counters, time taken, number of</span></span><br><span class="line">    <span class="comment">// machines used, etc.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bbsmax.com/A/KE5Q0Nq3JL/">https://www.bbsmax.com/A/KE5Q0Nq3JL/</a></p>
]]></content>
  </entry>
  <entry>
    <title>[译文]The Design of a Practical System for Fault-Tolerant VirtualMachines</title>
    <url>/2021-02-12-The-Design-of-a-Practical-System-for-Fault-Tolerant-Virtual-Machines/</url>
    <content><![CDATA[<div class="note info">
            <p>又挖了个坑，还是个大坑，不知道两天能挖完不。愚公竟是我自己？</p>
          </div>

<a id="more"></a>

<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>We have implemented a <code>commercial</code> <code>enterprise-grade</code> system for providing fault-tolerant virtual machines, based on the approach of replicating the execution of a primary virtual machine (VM) <code>via</code> a backup virtual machine on another server. We have designed a complete system in VMware vSphere 4.0 that is easy to use, runs on commodity servers, and typically reduces performance of real applications by less than 10%. Our method for replicating VM execution is similar to that described in Bressoud [3], but we have made a number of significant design changes that greatly improve performance. In addition, an easy-to-use, commercial system that automatically restores <code>redundancy</code> after failure requires many additional components beyond replicated VM execution. We have designed and implemented these extra components and addressed many practical issues <code>encountered</code> in supporting VMs running enterprise applications. In this paper, we describe our basic design, discuss <code>alternate</code> design choices and a number of the implementation details, and provide an <code>evaluation</code> of our performance for both micro-benchmarks and real applications.</p>
<div class="note info">
            <p>我们已经实现了一个支持容错虚拟机的商用企业级系统，基于通过在另一个服务器上的备份虚拟机复制执行主虚拟机的方法。我们已经在VMware vSphere 4.0上实现了一个易于使用的完整的系统，这个系统运行在商用服务器上，并且通常会降低实际应用的性能少于10%.我们复制VM执行的方法和Bressoud描述的是相似的，但是我们做了很多重要的设计选择来极大的提高了性能。另外，一个在故障后能自动恢复冗余的易于使用的商用系统需要许多在复制的虚拟机上的额外组件。我们已经设计并实现了这些额外的组件，并且也遇到了一些实际的问题在支持虚拟机运行企业应用的时候。在这篇文章，我们会描述我们的基础设计，并讨论替代的选择和许多实现的细节，也提供了在micro-benchmarks和实际应用上的性能评估。</p>
          </div>

<p><strong>Key Words and Phrases:</strong> virtual machines, fault tolerance, deterministic replay</p>
<div class="note info">
            <p>关键词和短语：虚拟机，容错，确定性重放</p>
          </div>

<hr>
<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><p>A common approach to implementing fault-tolerant servers is the primary/backup approach [1], where the execution of a primary server is replicated by a backup server. Given that the primary and backup servers execute <code>identically</code>, the backup server can <code>take over</code> serving client requests without any interruption or loss of state if the primary server fails. One method for replicating servers is sometimes <code>referred to</code> as the state-machine approach [13]. The idea is to <code>model</code> the servers as deterministic state machines that are kept in sync by starting them from the same initial state and ensuring that they receive the same input requests in the same order. Since most servers or services have some operations that are not deterministic, extra <code>coordination</code> must be used to ensure that a primary and backup are kept in sync.</p>
<div class="note info">
            <p>一个常用的实现容错服务的方法是主/备份，即主服务上的运行在备份服务上复制运行。如果主服务故障了，备份服务能够接管客户端的请求，而没有任何中断或状态的丢失。复制服务的方法也称为状态机方法。思想是将服务器建模为确定性状态机，通过按照相同初始化状态启动和以相同的顺序接受相同的输入请求来保持同步。因为大多数的服务器或者服务都有一些不确定性的操作，必须通过额外的协作来保证主备之间的同步。</p>
          </div>

<p>Implementing coordination to ensure deterministic execution of physical servers [14] is difficult, particularly as <code>processor</code> frequencies increase and clock synchronization becomes more difficult. <code>In contrast</code>, a virtual machine (VM) running on top of a hypervisor is an <code>excellent</code> platform for implementing the primary/backup approach. A VM can be considered a well-defined state machine whose operations are the operations of the machine being virtualized (including all its devices). <code>As with</code> physical servers, VMs have some non-deterministic operations (e.g. reading a time-of-day clock or <code>delivery</code> of an interrupt), and so extra information must be sent to the backup to ensure that it is kept in sync. Since the hypervisor has full control over the execution of a VM, including delivery of all inputs, the <code>hypervisor</code> is able to <code>capture</code> all the necessary information about non-deterministic operations on the primary VM and to replay these operations correctly on the backup VM.</p>
<div class="note info">
            <p>实现协作来保证物理服务器的完全确定性执行是困难的，特别是随着处理器频率增加和时钟同步变的困难。作为对比，运行在虚拟机监视器顶层的虚拟机是实现主/备份方法的极好的平台。VM可以被认为是良好定义的状态机，其操作是虚拟化(包括所有设备)的机器的操作。和物理服务器一样，VM也有一些不确定的操作(例如读取一个时钟时间或者中断传递),并且这些额外信息必须发送给备份机来保证主从同步。因为虚拟机监视器对于虚拟机执行有完全的控制权，包括输入数据的传递，所以虚拟机监视器能够捕获所有主虚拟机上涉及的非确定性操作的有效信息，然后在备份虚拟机上正确的重放这些操作。</p>
          </div>

<p>A system of replication based on virtual machines can replicate individual VMs, allowing some VMs to be replicated and fault-tolerant, while other VMs are not replicated. In addition, technology based on VMs does not require hardware modifications, allowing the system to <code>ride</code> the hardware performance improvement <code>curve</code> of newer <code>microprocessors</code>. A system based on replicated execution of physical servers requires hardware modifications and thus often <code>lags behind</code> the performance curve. Yet another advantage of virtual machines for this application is the possibility of physical separation of the primary and the backup:<br>for example, the replicated virtual machines can be run on physical machines distributed across a <code>campus</code>, which provides more reliability than a primary/backup system running in the same building.</p>
<div class="note info">
            <p>基于虚拟机的备份系统可以备份单个VM,这允许在一些Vm不被备份的时候，还有部分Vm会被备份和容错。另外，基于的Vm的即使不需要修改硬件，这让系统能够驾驭新的微处理器来改进硬件性能。运行在物理服务器上的备份系统需要修改硬件，因此经常滞后于性能曲线。虚拟机对于应用的另一个优点是能够物理分离主机和备机：比如，备份的虚拟机可以运行在园区内分离的物理机上，这提供了比运行在同一建筑下的主备机更好的可靠性。</p>
          </div>

<p>We have implemented fault-tolerant VMs using the primary/backup approach on the VMware vSphere 4.0 platform, which runs fully virtualized x86 virtual machines in a highly efficient <code>manner</code>. Since VMware vSphere implements a complete x86 virtual machine that can run all operating systems and applications that run on an x86 platform, we are automatically able to provide fault tolerance for any x86 operating systems and applications. The base technology that allows us to record the execution of a primary and ensure that the backup executes identically <code>is known as</code> deterministic replay [15]. VMware vSphere Fault Tolerance (FT) is based on deterministic replay, but adds in the necessary extra protocols and functionality to build a complete fault-tolerant system. In addition to providing hardware fault tolerance, our system restores redundancy by automatically starting a new backup virtual machine on any available server in the local cluster. At this time, the production versions of both deterministic replay and VMware FT support only <code>uni-processor</code> VMs. Recording and replaying the execution of a multi-processor VM is still <code>work in progress</code>, with significant performance issues because <code>nearly</code> every access to shared memory can be a non-deterministic operation.</p>
<div class="note info">
            <p>我们已经在VMware vSphere4.0平台上使用主/备份的方法实现了容错虚拟机，可以高效运行在完全虚拟化的x86平台的虚拟机上。因为Vmware vSphere实现了可以运行所有基于X86平台的操作系统和应用的x86虚拟机，所以我们能够提供对于所有x86的操作系统，应用的容错能力。基础的技术让我们能够记录主机的执行并确保备机相同的执行，这称之为确定性重放。Vmware vSphere的容错是基于确定性重放的，但是为了建立一个完整的容错系统增加了必要的额外的协议和功能。另外为了提供硬件容错，我们的系统能够通过在本地集群的任何可用服务器上开启一个新的虚拟机来自动的回复冗余。现在，确定性重放和VMware FT的版本仅支持单处理器的虚拟机。记录并重放多处理器的虚拟机的执行仍在开发中，一个很重要的性能问题是几乎每一个对于共享内存的访问都会是一个不确定性的操作。</p>
          </div>

<p>Bressoud [3] describes a <code>prototype</code> implementation of fault-tolerant VMs for the HP PARISC platform. Our approach is similar, but we have made some <code>fundamental</code> changes for performance reasons and <code>investigated</code> a number of design <code>alternatives</code>. In addition, we have had to design and implement many additional components in the system and deal with a number of practical issues to build a complete system that is efficient and <code>usable</code> by <code>customers</code> running enterprise applications. Similar to most other practical systems discussed, we only attempt to deal with fail-stop failures [12], which are server failures that can be detected before the failing server causes an incorrect <code>externally</code> <code>visible</code> action.</p>
<div class="note info">
            <p>Bressoud描述了对于HP PARISC平台的容错虚拟机的原型实现。这和我们的方法是相似的，但出于性能原因我们做出了一些根本改变并调查了一系列的可替代方案。另外，为了建立一个能够由顾客运行在企业应用上的高效可以用的完整系统，我们设计并实现了许多额外的系统组件，并且处理了一系列的实际问题。和讨论的大多数其他的实际系统相似，我们只尝试解决fail-stop故障，fail-stop故障是服务器故障可以在故障的服务器引起不正确的外部不可见行为之前被检测到。</p>
          </div>

<p>The rest of the paper is organized as follows. First, we describe our basic design and detail our fundamental protocols that ensure that no data is lost if a backup VM takes over after a primary VM fails. Then, we describe in detail many of the practical issues that must be addressed to build a correct, <code>robust</code>, fully-functioning, and <code>automated</code> system. We also describe several design choices that <code>arise</code> for implementing fault-tolerant VMs and discuss the <code>tradeoffs</code> in these choices. Next, we give performance results for our implementation for some benchmarks and some real enterprise applications. Finally, we describe related work and conclude.</p>
<div class="note info">
            <p>这篇论文的其余部分安排如下。首先，我们描述了我们的基础设计并详细介绍我们的基础协议，基础协议确保主机故障后由备机接管的时候没有数据丢失。然后，我们详细描述为建立一个正确的，健壮的，完整功能的，自动的系统必然会遇到的问题。我们还会描述一些为实现容错虚拟机会遇到的一些设计选择，讨论对这些选择的权衡。接着，我们提供我们的实现在一些benchmarks和一些实际企业应用上的性能表现。最后，我们会介绍相关的工作和结论。</p>
          </div>

<hr>
<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/Snipaste_2021-02-17_23-19-06_water.jpg"></p>
<h2 id="2-Basic-FT-Design"><a href="#2-Basic-FT-Design" class="headerlink" title="2 Basic FT Design"></a>2 Basic FT Design</h2><p>Figure 1 shows the basic setup of our system for fault-tolerant VMs. For a given VM for which we <code>desire</code> to provide fault tolerance (the primary VM), we run a backup VM on a different physical server that is kept in sync and executes identically to the primary virtual machine, though with a small time lag. We say that the two VMs are in virtual <code>lockstep</code>. The virtual disks for the VMs are on shared storage (such a <code>Fibre</code> Channel or iSCSI <code>disk array</code>), and therefore accessible to the primary and backup VM for input and output. (We will discuss a design in which the primary and backup VM have separate non-shared virtual disks in Section 4.1.) Only the primary VM <code>advertises</code> its <code>presence</code> on the network, so all network inputs come to the primary VM. Similarly, all other inputs (such as keyboard and mouse) go only to the primary VM.</p>
<div class="note info">
            <p>图1展示了我们容错虚拟机系统的基础设置。给定一个我们想要用来提供容错的虚拟机(成为主机)，我们会在不同的物理服务器上运行一个备机，备机通过和主机一样的执行来保持同步，不过会有一点延迟。我们称主机和备机是帧同步的。虚拟机的虚拟磁盘在共享存储上(比如光纤通道或者iSCSI磁盘阵列)，因此主机和备机访问共享存储用于输入和输出。(我们将在4.1节讨论，主机和备机在不同的非共享的虚拟磁盘上的设计)。只有主机参与网络交互，所以所有通过网络的输入都发给了主机。类似的，所有其他的输入(比如键盘或者鼠标)也只发给了主机。</p>
          </div>

<p>All input that the primary VM receives is transmitted to the backup VM via a network connection known as the logging channel. For server workloads, the <code>dominant</code> input traffic is network and disk. Additional information, as discussed <code>below in</code> Section 2.1, is transmitted as necessary to ensure that the backup VM executed non-deterministic operations in the same way as the primary VM. The end result is that the backup VM always executes identically to the primary VM. However, the outputs of the backup VM are always <code>dropped</code> by the hypervisor, so only the primary produces actual outputs that are returned to clients. As described in Section 2.2, the primary and backup VM must follow a specific protocol, including explicit <code>acknowledgments</code> by the backup VM, in order to ensure that no data is lost if the primary fails.</p>
<div class="note info">
            <p>所有主机接收的输入会被传输给备机，通过称为日志通道的网络连接。对于服务器工作负载，主要的输入流量来自网络和磁盘。我们在2.1节的下面部分将要讨论的额外信息必要时也会被传输给备机，来确保备机以和主机相同的方式运行不确定性操作。所以最后备机总是和主机以相同的方式运行。然而，备机的输出总是会被虚拟机管理程序丢弃，所以只有主机会产生实际的返回给客户端的输出。如2.2节描述的，主机和备机必须遵从特定的协议，包括备机的显式确认，为了保证主机故障的时候没有数据丢失。</p>
          </div>

<p>A <code>crucial</code> issue that is not discussed much in previous work is the actual process of <code>determining</code> quickly whether a primary or backup VM has failed. Our system uses a <code>combination</code> of heartbeating between the <code>relevant</code> servers and monitoring of the traffic on the logging channel. In addition, we must ensure that only one of the primary or backup VM takes over execution, even if there is a split-brain situation where the primary and backup servers have lost communication with each other.</p>
<div class="note info">
            <p>一个前面没有过多讨论的关键问题是快速判断哪个主机，备机故障的处理过程。我们的系统使用相关服务器和日志通道上流量监控程序的心跳包的关联。另外，我们必须确保只有一个主机或备机接管执行，即使在主机和备机失联导致脑裂的情况。</p>
          </div>

<p>In the following sections, we provide more details on several important areas. In Section 2.1, we give some details on the deterministic replay technology that ensures that primary and backup VMs are kept in sync via the information sent over the logging channel. In Section 2.2, we describe a fundamental rule of our FT protocol that ensures that no data is lost if the primary fails. In Section 2.3, we describe our methods for detecting and responding to a failure in a correct <code>fashion</code>.</p>
<div class="note info">
            <p>在下面的章节中，我们提供对于几个重要领域更多的细节。在2.1节，我们描述对于确定性重放技术的更多细节，确定性重放即使保证主机和备机通过日志通道发送信息来保持同步。在2.2节，我们描述我们容错协议的基础规则，容错协议保证主机故障的时候没有数据丢失。在2.3节，我们描述我们以正确方式来检测和响应故障的方法。</p>
          </div>

<hr>
<h3 id="2-1-Record-Replay-Implementation"><a href="#2-1-Record-Replay-Implementation" class="headerlink" title="2.1 Record-Replay Implementation"></a>2.1 Record-Replay Implementation</h3><p>As we have mentioned, replicating servers (or VMs) can be modeled as the replication of deterministic state machines. If two deterministic state machines are started in the same initial state and provided the exact same inputs in the same order, then they will go through the same sequences of states and produce the same outputs. In the simplest case, one state machine is the primary, and the other is the backup. If all the inputs go to the primary, then the inputs can be distributed to the backup from the primary via a logging channel. A useful physical computer, when considered as a state machine, has a broad set of inputs<br><code>ranging</code> from a keyboard device to network input received from a client. In addition, nondeterministic events like virtual interrupts, and non-deterministic operations like reading the clock cycle counter from the processor, affect the state machine. This presents three challenges to a practical hypervisor capable of running any operating system that can run on a physical machine: (1) correctly <code>capturing</code> all the input and non-determinism necessary to ensure deterministic execution of a backup virtual machine, (2) correctly applying the inputs and non-determinism to the backup virtual machine, and (3) doing so in a manner that doesn’t <code>degrade</code> performance.</p>
<div class="note info">
            <p>如前所述，备份服务器(或备份虚拟机)可以被建模为确定性状态机的备份。如果两个确定性状态机以相同的初始状态启动并提供相同次序的完全相同的输入，则它们将经过相同的状态顺序并产生相同的输出。在最简单的情况，一个状态机是主，另一个是备。如果所有的输入都到达主，则输出可通过日志通道从主分发给备机。一个有用的物理计算机，作为状态机的时候，有广泛的输入范围，从键盘设备到来自客户端的网络输入。另外，不确定的事件比如虚拟中断，和不确定性操作像是从处理器读取时钟周期计数器，会影响状态机。这给实际的虚拟机管理程序在物理机上运行任何操作系统的能力带来了3个挑战：<br>(1) 正确的捕获所有输入和必要的不确定性来保证备机的确定性执行<br>(2) 正确的应用输入和不确定性给备机<br>(3) 以不降低性能的方式进行</p>
          </div>

<p>VMware deterministic replay [15] provides exactly this functionality for x86 virtual machines on the VMware vSphere platform. Deterministic replay allows the inputs of a VM and all possible non-determinism <code>associated</code> with the VM execution to be recorded via a stream of log entries written to a log file. The VM execution may be replayed later exactly by reading the log entries from the file. Non-deterministic state <code>transitions</code> can either result from explicit operations executed by the VM that have non-deterministic results (such as reading the time-of-day clock), or <code>asynchronous</code> events (such as interrupts) which create non-determinism because the point at which they interrupt the <code>dynamic</code> instruction stream affects the virtual machine execution.</p>
<div class="note info">
            <p>Vmware确定性重放正是为VMware vSphere平台上的x86虚拟机提供了此功能。确定性重放允许虚拟的输入和所有与虚拟机执行相关联的可能的不确定性能够通过写到日志文件的日志项的流记录下来。通过读取日志文件的日志项，可以在稍后准确的回访虚拟机的执行。不确定性状态转换可能是由有不确定性结果(比如读取time-of-day的时钟)的虚拟机的显式操作导致，也可能由异步的事件(比如中断)导致。这两种会导致不确定状态是因为它们打断动态指令流的时候会影响虚拟机的执行。</p>
          </div>

<p>For non-deterministic operations, <code>sufficient</code> information must be logged to allow the operation to be <code>reproduced</code> with the same state change and output when replaying. For nondeterministic events such as timer interrupts or IO completion interrupts, the exact instruction at which the event occurred must also be recorded. During replay, the event must be delivered at the exact same point in the instruction stream. VMware deterministic replay implements an efficient event recording and event delivery mechanism that employs various <code>techniques</code>, including the use of hardware performance counters developed in <code>conjunction</code><br>with AMD [2] and Intel [8].</p>
<div class="note info">
            <p>对于不确定性操作，充足的信息必须被日记记录下来，来让重放的时候操作可以按照相同的状态改变和输出被重置。对于不确定性的事件比如时钟中断或者IO完成中断，还必须记录事件发生的确切指令。在重放期间，必须在指令流的同一时间点传递事件。VMware确定性重放实现了一个有效的事件记录和事件传递机制，该机制使用了多种技术，包括由amd和intel联合开发的硬件性能计数器。</p>
          </div>

<p>Bressoud [3] mentions dividing the execution of VM into <code>epochs</code>, where non-deterministic events such as interrupts are only delivered at the end of an epoch. The <code>notion</code> of epoch seems to be used as a batching mechanism because it is too expensive to deliver each interrupt separately at the exact instruction where it occurred. However, our event delivery mechanism is efficient enough that VMware deterministic replay has no need to use epochs. The occurrence of each interrupt is recorded and logged as it occurs and efficiently delivered at the <code>appropriate</code> instruction while being replayed.</p>
<div class="note info">
            <p>Bressoud提到了将虚拟机的执行分为epochs(阶段？时期？)，不确定性事件比如中断只在最后的epoch传递。epoch被用于批处理机制，因为在中断发生的时候分别传递每一个中断在对应的指令是代价很高的。然而，我们的事件传递机制是足够有效的，所以VMware确定性重放不需要使用epochs.每一个中断的发生都可以被记录并写到日志，并有效的传递给适当的指令，在重放的时候。</p>
          </div>

<hr>
<h3 id="2-2-FT-Protocol"><a href="#2-2-FT-Protocol" class="headerlink" title="2.2 FT Protocol"></a>2.2 FT Protocol</h3><p>For VMware FT, we use deterministic replay to produce the necessary log entries to record the execution of the primary VM, but instead of writing the log entries to disk, we send them to the backup VM via the logging channel. The backup VM replays the entries in real time, and hence executes identically to the primary VM. However, we must <code>augment</code> the logging entries with a <code>strict</code> FT protocol on the logging channel in order to ensure that we achieve fault tolerance. Our fundamental requirement is the following:</p>
<div class="note info">
            <p>对于VMware容错，我们使用确定性重放来产生必要的日志项纪录主机的执行，但是不是将日志项写入磁盘，而是通过日志通道将日志项发送给备机。备机实时回放日志项，因此备机可以和主机有相同的执行。但是，为了容错，我们必须通过在日志通道上的严格的容错协议。基础协议有下面这些要求：</p>
          </div>

<blockquote>
<p>Output Requirement: if the backup VM ever takes over after a failure of the primary, the backup VM will continue executing in a way that is entirely consistent with all outputs that the primary VM has sent to the external world.</p>
</blockquote>
<div class="note info">
            <p>输出要求： 如果备机在主机故障后接管，备机将以和主机已经发送发送给外部世界输出完全一致性的继续运行。</p>
          </div>

<p>Note that after a <code>failover</code> occurs (i.e. the backup VM takes over after the failure of the primary VM), the backup VM will likely start executing quite differently from the way the primary VM would have continued executing, because of the many non-deterministic events happening during execution. However, as long as the backup VM <code>satisfies</code> the Output Requirement, no state or data is lost during a failover to the backup VM, and the clients will notice no interruption or inconsistency in their service.</p>
<div class="note info">
            <p>注意，在故障转移发生(备机在主机故障后接管)之后，备机可能以和主机继续执行的方式完全不同的方式启动执行，因为许多不确定性事件在执行期间发生。然而，只要备机满足输出要求，就不会有任何状态和数据在故障转移给备机的时候丢失，并且客户端不会看到服务端有中断和不一致性的现象。</p>
          </div>

<p>The Output Requirement can be ensured by delaying any external output (typically a network packet) until the backup VM has received all information that will allow it to replay execution at least to the point of that output operation. One necessary condition is that the backup VM must have received all log entries generated <code>prior</code> to the output operation. These log entries will allow it to execute up to the point of the last log entry. However, suppose a failure were to happen immediately after the primary executed the output operation. The backup VM must know that it must keep replaying up to the point of the output operation and only “go live” (stop replaying and take over as the primary VM, as described in Section 2.3) at that point. If the backup were to go live at the point of the last log entry before the output operation, some non-deterministic event (e.g. timer interrupt delivered to the VM) might change its execution path before it executed the output operation.</p>
<div class="note info">
            <p>输出要求可以通过延迟所有外部输出(通常是网络包)直到备机已经接受了所有信息(允许备机重放到至少输出操作的时刻)的时候。一个必要的条件是备机必须已经接收了所有的输出操作事先生成的日志项。这些日志项能够让备机执行到最后的日志项的时刻。然而，如果一个故障在主机执行输出操作的时候立刻发生。备机必须知道它必须一直重放到输出操作的时刻然后在那个时刻仅仅上线(停止重放并接管主机，像2.3节描述的那样)。如果备机在输出操作之前的最后的日志项的时刻上线，一些不确定性事件(比如传递给虚拟机的时钟中断)可能改变执行路径，在执行输出操作之前。</p>
          </div>

<p>Given the above <code>constraints</code>, the easiest way to <code>enforce</code> the Output Requirement is to create a special log entry at each output operation. Then, the Output Requirement may be enforced by this specific rule:</p>
<div class="note info">
            <p>鉴于上面的约束，执行输出要求的最简单方式是对每一个输出操作创建一个特殊的日志项。然后，输出要求可以通过这些特殊的规则被执行：</p>
          </div>

<blockquote>
<p>Output Rule: the primary VM may not send an output to the external world, until the backup VM has received and acknowledged the log entry associated with the operation producing the output.</p>
</blockquote>
<div class="note info">
            <p>输出规则：主机直到备机接收被确认了和产生输出相关联的日志项的时候，才发送输出给外部世界。</p>
          </div>

<p>If the backup VM has received all the log entries, including the log entry for the outputproducing operation, then the backup VM will be able to exactly reproduce the state of the primary VM at that output point, and so if the primary dies, the backup will correctly reach a state that is consistent with that output. <code>Conversely</code>, if the backup VM takes over without receiving all necessary log entries, then its state may quickly <code>diverge</code> such that it is inconsistent with the primary’s output. The Output Rule is in some ways <code>analogous</code> to the approach described in [11], where an “externally synchronous” IO can actually be buffered, as long as it is actually written to disk before the next external communication.</p>
<div class="note info">
            <p>如果备机已经接收了所有的日志项，包括输出产生操作的日志项，那么备机将能够准确的重现在该输出点上的主机的状态，即使主机宕了，备机仍能够正确的达到和该输出一致的状态。相反，如果备机在没有接收到所有必要的日志项的时候就接管了主机，则备机的状态可能很快偏离到和主机输出不一致的状态。输出规则在某些方面和[11]提到的方法是类似的，其中外部同步IO可以被缓冲，只要在下一次外部通信前写入磁盘。</p>
          </div>

<p>Note that the Output Rule does not say anything about stopping the execution of the primary VM. We need only delay the sending of the output, but the VM itself can continue execution. Since operating systems do non-blocking network and disk outputs with asynchronous interrupts to <code>indicate</code> completion, the VM can easily continue execution and will not necessarily be immediately affected by the delay in the output. In contrast, previous work [3, 9] has typically indicated that the primary VM must be completely stopped <code>prior to</code> doing an output until the backup VM has acknowledged all necessary information from the primary VM.</p>
<div class="note info">
            <p>注意输出规则没有说任何要通知主机执行的事情。我们只需要延迟发送输出，但是虚拟机可以继续执行。因为操作系统通过异步中断来非阻塞的表示网络和磁盘输出的完成，所以虚拟机只需要继续执行，并且不一定会立即受到输出延迟的影响。相反，先前的工作[3,9]通常表明在完成输出之前主机必须完全停止，直到备机已经确认了所有来自主机的必要信息。</p>
          </div>

<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/Snipaste_2021-02-17_23-19-23_water.jpg"></p>
<p>As an example, we show a <code>chart</code> <code>illustrating</code> the requirements of the FT protocol in Figure 2. This figure shows a timeline of events on the primary and backup VMs. The <code>arrows</code> going from the primary line to the backup line represent the transfer of log entries, and the arrows going from the backup line to the primary line represent acknowledgments. Information on asynchronous events, inputs, and output operations must be sent to the backup as log entries and acknowledged. As illustrated in the figure, an output to the external world is delayed until the primary VM has received an acknowledgment from the backup VM that it has received the log entry associated with an output operation. Given that the Output Rule is followed, the backup VM will be able to take over in a state consistent with the primary’s last output. There will be no loss of state even if the primary has had a non-deterministic event since its last output.</p>
<div class="note info">
            <p>作为例子，我们在图2中展示了一个图表说明容错协议的要求。该图展示了主机和备机上事件的时间线。主机线到备机线的箭头表示日志项的传输，备机线到主机线的箭头表示确认。异步事件的信息，输入，和输出操作都必须被发送给备机，以日志项的方式，然后由备机确认。如图中说明的那样，对于外部世界的输出会被延迟到主机已经接收到来自备机的确认信息，在备机收到和输出操作相关联的日志项的时候会进行确认。如果输出规则得以遵守，备机将能够以和主机最后输出一致性的状态进行接管。</p>
          </div>

<p>As <code>indicated</code> in [3, 9], we can not guarantee that all outputs are produced exactly once in a failover situation. Without the use of transactions with two-phase commit when the primary intends to send an output, there is no way that the backup can <code>determine</code> if a primary crashed immediately before or after sending its last output. Fortunately, the network <code>infrastructure</code> (including the common use of TCP) is designed to deal with lost packets and identical (duplicate) packets.</p>
<div class="note info">
            <p>如[3,9]所表示的，我们不能保证所有的输出都只被生成一次在故障转移的情况下。在主机尝试发送输出的时候不适用两阶段提交事务的话，就没有办法让备机判断主机是在崩溃之前还是之后发送了最后的输出。幸运的是，网络基础设施(包括常用的tcp)被设计为能够处理丢包和重包。</p>
          </div>

<p>Note that incoming packets to the primary may also be lost during a failure of the primary and therefore won’t be delivered to the backup. However, incoming packets may be dropped for any number of reasons unrelated to server failure, so the network infrastructure, operating systems, and applications are all written to ensure that they can <code>compensate</code> for lost packets.</p>
<div class="note info">
            <p>注意，传给主机的数据包在主机故障的时候也可能丢失因而不能被传递给备机。然而，传入的数据包可能出于一系列和服务器故障不相关的原因被丢弃，所以网络基础设施，操作系统和应用都被写入(意思应该是都要适配这个情况？ )来确保可以对丢失的包进行补偿</p>
          </div>

<hr>
<h3 id="2-3-Detecting-and-Responding-to-Failure"><a href="#2-3-Detecting-and-Responding-to-Failure" class="headerlink" title="2.3 Detecting and Responding to Failure"></a>2.3 Detecting and Responding to Failure</h3><p>As mentioned above, the primary and backup VMs must respond quickly if the other VM appears to have failed. If the backup VM fails, the primary VM will go live – that is, leave recording mode (and hence stop sending entries on the logging channel) and start executing normally. If the primary VM fails, the backup VM should similarly go live, but the process is a bit more complex. Because of its lag in execution, the backup VM will likely have a number of log entries that it has received and acknowledged, but have not yet been <code>consumed</code> because the backup VM hasn’t reached the appropriate point in its execution yet. The backup VM must continue replaying its execution from the log entries until it has consumed the last log entry. At that point, the backup VM will stop replaying mode and start executing as a normal VM. <code>In essence</code>, the backup VM has been <code>promoted</code> to the primary VM (and is now missing a backup VM). Since it is no longer a backup VM, the new primary VM will now produce output to the external world when the guest OS does output operations. During the <code>transition</code> to normal mode, there may be some device-specific operations needed to allow this output to occur <code>properly</code>. In particular, for the purposes of networking, VMware FT automatically advertises the MAC address of the new primary VM on the network, so that physical network switches will know on what server the new primary VM is located. In addition, the newly promoted primary VM may need to <code>reissue</code> some disk IOs (as described in Section 3.4).</p>
<div class="note info">
            <p>如前面提到的那样，主机和备机必须在另一方故障的时候快速响应。如果备机故障，主机将会上线-指的是离开记录模式(因此停止在日志通道上发送日志项)并开始正常运行。如果主机故障，备机也会上线，但是处理会更加复杂一点。因为备机是延迟执行的，备机可能有一系列它已经接受和确认的的日志项，但是还没被消费完因为备机还没达到运行的合适时间点。备机必须继续重放来自日志项的运行知道消费完最后的日志项。然后备机将会停止重放模式然后开始正常运行，像普通虚拟机那样。本质上，备机已经被晋升为了主机(现在没有备机了)。因为已经不是备机了，新的主机将在guest os(运行在虚拟机上的操作系统)有输出操作的时候产生输出给外部世界。在过渡为正常模式的期间，可能会需要一些特定设备的操作来让输出正确发生。特别的，出于联网的目的，VMware容错会自动将新的主机的mac地址在网络进行通告，所以物理网络交换机将能够得知新的主机服务器的位置。另外，新的晋升的主机可能需要重发一些磁盘IO(像3.4节描述的那样)</p>
          </div>

<p>There are many possible ways to attempt to detect failure of the primary and backup VMs. VMware FT uses UDP heartbeating between servers that are running fault-tolerant VMs to detect when a server may have crashed. In addition, VMware FT monitors the logging traffic that is sent from the primary to the backup VM and the acknowledgments sent from the backup VM to the primary VM. Because of regular timer interrupts, the logging traffic should be regular and never stop for a functioning guest OS. Therefore, a <code>halt</code> in the flow of log entries or acknowledgments could indicate the failure of a VM or a networking problem. A failure is declared if heartbeating or traffic on the logging channel has stopped for longer than a specific timeout (<code>on the order of</code> a few seconds).</p>
<div class="note info">
            <p>对于尝试检测主机和备机故障有许多可能的方式。VMware容错使用运行在容错虚拟机上的服务器间的udp心跳包来检测哪台服务器已经宕掉了。另外，VMware容错监控从主机发给备机的日志和从备机发送给主机的确认信息的流量。因为经常的时钟中断，日志流量应该是规律的并且永远不会在guest os上停止。因此，日志项和确认信息流的暂停可能表明虚拟机或者网络问题引起的故障。如果心跳包或者日志通道流量停止了超过指定的超时时间(大约几秒钟)则表明这是故障</p>
          </div>

<p>However, any such failure detection method is <code>susceptible</code> to a split-brain problem. If the backup server stops receiving heartbeats from the primary server, that may indicate that the primary server has failed, or it may just mean that all network connectivity has been lost between still <code>functioning</code> servers. If the backup VM then goes live while the primary VM is actually still running, there will likely be data <code>corruption</code> and problems for the clients communicating with the VM. Hence, we must ensure that only one of the primary or backup VM goes live when a failure is detected. To avoid split-brain problems, we make use of the shared storage that is used to store the virtual disks of the VM. At the point where either a primary or backup VM wants to go live, it executes an atomic test-and-set operation on the shared storage. If the operation succeeds, the VM is allowed to go live. If the operation fails, then the other VM must have already gone live, so the current VM actually <code>halts</code> itself (“commits <code>suicide”</code>). If the VM cannot access the shared storage when trying to do the atomic operation, then it just waits until it can. Note that if shared storage is not accessible because of some failure in the storage network, then the VM would likely not be able to do useful work anyway because the virtual disks <code>reside</code> on the same shared storage. Thus, using shared storage to <code>resolve</code> split-brain situations does not <code>introduce</code> any extra unavailability.</p>
<div class="note info">
            <p>然而，任何这类故障检测方法都容易收到脑裂问题的影响。如果备机停止从主机接收心跳包，可能意味着主机故障了，也可能只是因为仍在运行的服务器间的所有网络连接都丢失了。如果备机接着在主机仍旧运行的情况下上线，这可能引起数据损坏或者客户端与虚拟机通信的问题。因此，我们必须确保只有一台主机或备机上线，在故障被检测到的时候。为了避免脑裂的问题，我们使用用来存储虚拟机虚拟磁盘的共享存储。在主机或备机想上线的时候，在共享存储上执行一个原子的test-and-set锁指令。如果操作指令成功，则虚拟机可以上线。如果指令失败，则另外的虚拟机肯定仍在运行，所以当前的虚拟机实际上会结束运行(提交suicide).如果虚拟机无法访问共享存储，在尝试做原子操作指令的时候，只需要一直等到可以访问的时候。记住如果共享存储因为一些存储网络故障导致不能访问，那么虚拟机可能无论如何都不能正常工作，因为虚拟机磁盘也在共享存储上面。因此，使用共享存储来解决脑裂问题不会带来任何额外的不可用</p>
          </div>

<p>One final <code>aspect</code> of the design is that once a failure has occurred and one of the VMs has gone live, VMware FT automatically restores <code>redundancy</code> by starting a new backup VM on another host. Though this process is not covered in most previous work, it is <code>fundamental</code> to making fault-tolerant VMs useful and requires careful design. More details are given in Section 3.1.</p>
<div class="note info">
            <p>该设计的最后一个方面是一旦故障已经发生了并且其中一个虚拟机已经上线了，VMware容错会自动通过在另外主机上启动新的备机来恢复冗余。即使前面大部分没有提及这个过程，但是这一点对于实现有用的容错系统是基础的，并且需要仔细设计。更多的细节见3.1节。</p>
          </div>

<hr>
<h3 id="2-4-Go-live-Points"><a href="#2-4-Go-live-Points" class="headerlink" title="2.4 Go-live Points"></a>2.4 Go-live Points</h3><p>The use of deterministic replay for fault tolerance purposes has driven us to add an interesting mechanism to our replay implementation. Because of network issues or the failure of the primary at any point, the stream of log entries being read and replayed by the backup can be terminated at any point. The possibility of termination at any point in the log can <code>permeate</code> the deterministic replay implementation, since each <code>potential</code> consumer of a log entry (such as a virtual device implementation) would need to check for and deal with the fact that an expected log entry is not available. <code>For instance</code>, given previous log entries and its current state, a virtual device implementation may expect a number of additional log entries about IO completions. The code that is replaying the device will have to be written to check for the end of the log stream, exit some possibly complex replaying code, and restore the device to a reasonable state so that the VM can go live.</p>
<div class="note info">
            <p>为了容错使用的确定性重放驱使我们在我们的重放实现中增加了一种有趣的机制。因为会有网络问题以及主机故障可能发生在任何时刻，由备机正在读取或者重放的日志项流也可能在任何时刻终止。日志项在任何时刻终止的可能性会扩散到确定性重放的实现，因为每一个日志项(比如一个虚拟的设备实现)的潜在消费者都需要检查和处理所需日志不可用的问题。比如，给定一个之前的日志项和它现在的状态，虚拟设备实现可能需要一系列有关IO实现的额外的日志项。需要编写重放部分的代码来检查日志流的结束，退出一些可能复杂的重放代码，回复设备到合理的状态，使之可以在虚拟机上go live.</p>
          </div>

<p>To <code>alleviate</code> this <code>burden</code> on many components of the system, we have implemented go-live points. Any individual log entry can be marked as a go-live point. The idea is that a log entry that is marked as a go-live point represents the last log entry in <code>a series of</code> log entries necessary for replaying an instruction or a particular device operation. If a particular operation or instruction requires several log entries to be recorded, then only the last log entry would be marked as a go-live point. In practice, the hypervisor automatically marks the last new log entry as a go-live point when it has completed all event and device processing for a given instruction.</p>
<div class="note info">
            <p>为了减轻系统上多数组件的负担，我们已经实现了go-live points.任何单个日志项都可以被标记为go-live points.思想是一个被标记为go-live point的日志项可以用来表示对于重放一个指令或者特别的设备操作必要的一系列日志项中的最后一个日志项。如果一个特别的操作或者指令需要一部分被记录的日志项，那么仅最后的日志项会被标记为go-live point.实际上，虚拟机管理程序会自动标记最后的一个新的日志项为go-live point,在它完成给定指令的所有事件和设备处理的时候。</p>
          </div>

<p>Go-live points are used during replaying as follows. While all log entries read from the logging channel are buffered by the hypervisor on the virtual machine that is replaying, only the log entries up to the last go-live point are allowed to be consumed by the replaying (backup) VM. That is, the replaying VM will <code>stall</code> after consuming the last log entry <code>tagged</code> as a go-live point until another series of log entries containing a log entry with a go-live point has been fetched by the hypervisor. The result is that if there is a series of log entries associated with a device operation, the virtual device implementation can <code>assume</code> that all the needed log entries will be available if the first log entry is encountered. Thus, the virtual device implementation does not have to do all the extra checking and recovery code needed if the log entries could be terminated at any point. Similarly, whenever a single instruction executed <code>on behalf of</code> the virtual machine generates multiple log entries, the hypervisor of the replaying virtual machine begins the <code>emulation</code> of that instruction only if all the log entries necessary for completing the emulation of that instruction are available. The <code>tagging scheme</code> doesn’t introduce any significant delay of the replaying VM, since the hypervisor of the recording (primary) VM guarantees that last log entry of each single instruction emulation or a device operation is marked as a go-live point. Since the backup VM cannot be <code>significantly</code> delayed, the primary VM is also not affected by the use of go-live points.</p>
<div class="note info">
            <p>go-live points在重放期间的使用如下。当所有从日志通道读取的日志项都被虚拟机管理程序缓存在正在重放的虚拟机上。只有最后的go-live point之前的日志项可以被重放的备机消费。也就是说，正在重放的虚拟机在消费最后一个被标记为go-live point的日志项之后会停止运行直到一系列包含go-live point的日志项已经被虚拟机管理程序拉取。结果是如果有一系列和设备操作关联的日志项，如果虚拟设备实现遇到了第一个日志项，就可以假定所有需要的日志项都是可用的。因此，虚拟设备实现不需要做所有额外的检查和恢复代码，如果日志项可以在任何时刻终止。类似的，任何代表虚拟机执行的单个指令生成多个日志项的时候，重放虚拟机的虚拟机管理程序仅在所有的对于完成指令仿真有必要的日志项都是可用的时候，才开始指令的模拟。标记方案不会对正在重放的虚拟机带来任何明显的延迟，因此记录(primary)虚拟机的虚拟机管理程序保证每一个模拟指令或者设备操作的最后的日志项被标记为go-live point.因此备机不会有明显的延迟，主机也不会受到go-live point的影响。</p>
          </div>

<hr>
<h2 id="3-Practical-Implementation-of-FT"><a href="#3-Practical-Implementation-of-FT" class="headerlink" title="3 Practical Implementation of FT"></a>3 Practical Implementation of FT</h2><p>Section 2 described our fundamental design and protocols for FT. However, to create a usable, <code>robust</code>, and automatic system, there are a great many other components that must be designed and implemented.</p>
<div class="note info">
            <p>第2节描述了容错的基础设计和协议。但是为了创建一个可用的，健壮的自动化系统，还需要设计实现许多其他组件。</p>
          </div>

<hr>
<h3 id="3-1-Starting-and-Restarting-FT-VMs"><a href="#3-1-Starting-and-Restarting-FT-VMs" class="headerlink" title="3.1 Starting and Restarting FT VMs"></a>3.1 Starting and Restarting FT VMs</h3><p>One of the biggest additional components that must be designed is the mechanism for starting a backup VM in the same state as a primary VM. This mechanism will also be used when restarting a backup VM after a failure has occurred. Hence, this mechanism must be usable for a running primary VM that is in an <code>arbitrary</code> state (i.e. not just starting up). In addition, we would prefer that the mechanism does not significantly <code>disrupt</code> the execution of the primary VM, since that will directly affect any current clients of the VM.</p>
<div class="note info">
            <p>必须设计的最大的额外组件之一是以和主机相同的状态启动备机的机制。这个机制在故障发生重启备机的时候也会用到。因此，该机制对于运行任意状态(不仅仅是启动)的主机必须是可用的。另外，我们更希望该机制不会明显的打断主机的运行，因此这会影响到所有连接虚拟机的客户端。</p>
          </div>

<p>For VMware FT, we adapted the existing VMotion functionality of VMware vSphere. VMware VMotion [10] allows the <code>migration</code> of a running VM from one server to another server with minimal disruption – VM pause times are typically less than a second. We created a modified form of VMotion that creates an exact running copy of a VM on a remote server, but without destroying the VM on the local server. That is, our modified FT VMotion clones a VM to a remote host rather than migrating it. The FT VMotion also sets up a logging channel, causes the source VM to enter logging mode as the primary, and the destination VM to enter replay mode as the new backup. Like normal VMotion, FT VMotion typically <code>interrupts</code> the execution of the primary VM by less than a second. Hence, enabling FT on a running VM is an easy, non-<code>disruptive</code> operation.</p>
<div class="note info">
            <p>对于VMware容错系统，我们适配了VMware vSphere的现有Vmotion功能。VMware VMotion可以在最小化中断的代价下将运行的虚拟机从一台服务器迁移到另一台服务器-虚拟机的暂停时间通常小于1秒。我们创建了一个修改版的Vmotion，通过在远端服务器上创建一个精确的虚拟机的运行拷贝，而不需要摧毁本地服务器上的虚拟机。也就是说，修改版的容错Vmotion克隆一个虚拟机到远端服务器而不是迁移虚拟机。容错Vmotion也会建立一个日志通道，源虚拟机会作为主机进入日志模式，目的虚拟机作为新的备机进入重放模式。和普通版本的Vmotion一样，容错Vmotion通常打断主机的时间少于1秒。因此，在运行中虚拟机启用容错是简单，无中断的操作</p>
          </div>

<p>Another aspect of starting a backup VM is choosing a server on which to run it. Faulttolerant VMs run in a cluster of servers that have access to shared storage, and so all VMs can typically run on any servers in the cluster. This <code>flexibility</code> allows VMware vSphere to restore FT redundancy even when one or more servers have failed. VMware vSphere implements a <code>clustering</code> service that maintains <code>management</code> and resource information. When a failure happens and a primary VM now needs a new backup VM to <code>re-establish</code> redundancy, the primary VM <code>informs</code> the clustering service that it needs a new backup. The clustering service determines the best server on which to run the backup VM based on resource allocations, usage, and other <code>constraints</code>. Then the clustering service automatically invokes an FT VMotion to create the new backup VM. Of course, there are many additional <code>complexities</code>, such as retrying if a first attempt to create a backup fails and automatically detecting when a server in the cluster becomes newly available. The end result is that VMware FT typically can re-establish VM redundancy within minutes of a server failure, all without any <code>noticeable</code> interruption in the execution of a fault-tolerant VM.</p>
<div class="note info">
            <p>启动备机的另一个方面是选择哪台服务器来运行。容错虚拟机运行在访问共享存储的服务器集群上，因而所有的虚拟机是运行在集群中任意的服务器的。这种灵活性让VMware vSphere能够恢复容错冗余在一台或者多台服务器故障的时候。VMware vSphere实现了一个集聚服务来维护管理和资源信息。当故障发生而主机需要一个新的备机重建冗余的时候，主机会通知集聚服务它需要一个新的备机。集聚服务基于资源申请，使用和其他约束来选择运行备机的最佳服务器。然后集聚服务自动调用容错Vmotion来创建新的备机。当然，也有许多额外的复杂性，比如在第一次创建备机失败后的重试，和自动检测集群中服务器什么时候变为新的可用状态。最后的结果是VMware容错可以重建虚拟机冗余在服务器故障后几分钟，而不会对容错虚拟机执行有明显的打断。</p>
          </div>

<hr>
<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/Snipaste_2021-02-17_23-19-37_water.jpg"></p>
<h3 id="3-2-Managing-the-Logging-Channel"><a href="#3-2-Managing-the-Logging-Channel" class="headerlink" title="3.2 Managing the Logging Channel"></a>3.2 Managing the Logging Channel</h3><p>There are a number of interesting implementation details in managing the traffic on the logging channel. In our implementation, the hypervisors maintain a large buffer for logging entries for the primary and backup VMs. As the primary VM executes, it produces log entries into the log buffer, and similarly, the backup VM consumes log entries from its log buffer. The contents of the primary’s log buffer are flushed out to the logging channel as soon as possible, and log entries are read into the backup’s log buffer from the logging channel as soon as they arrive. The backup sends acknowledgments back to the primary each time that it reads some log entries from the network into its log buffer. These acknowledgments allow VMware FT to determine when an output that is delayed by the Output Rule can be sent. Figure 3 illustrates this process.</p>
<div class="note info">
            <p>管理日志通道的流量有一系列有趣的实现细节。在我们实现中，虚拟机管理程序维护了一个大的缓冲，保存了主机和备机的日志项。当主机运行的时候，会产生日志项到日志缓冲，类似的，备机从日志缓冲消费日志项。主机日志缓冲的内容会尽快刷到日志通道中，日志项写到日志缓冲后也会尽快读取到备机的日志缓冲中。备机发送确认信息给主机，在每一次通过网络读取一些日志项到日志缓冲的时候。这些确认信息让VMvare容错能够决定什么时候被输出规则延迟的输出可以被发送。图3说明了这个过程。</p>
          </div>

<p>If the backup VM <code>encounters</code> an empty log buffer when it needs to read the next log entry, it will stop execution until a new log entry is available. Since the backup VM is not communicating <code>externally</code>, this pause will not affect any clients of the VM. Similarly, if the primary VM encounters a full log buffer when it needs to write a log entry, it must stop execution until log entries can be <code>flushed out</code>. This stop in execution is a natural flowcontrol mechanism that <code>slows down</code> the primary VM when it is producing log entries at too fast a rate. However, this pause can affect clients of the VM, since the primary VM will be completely stopped and unresponsive until it can log its entry and continue execution. Therefore, our implementation must be designed to minimize the possibility that the primary log buffer fills up.</p>
<div class="note info">
            <p>如果备机在读取新的日志项的时候遇到了空的日志缓冲，则会停止运行知道日志项变为可用。因为备机不是在外部通信，这种暂停不会虚拟机的客户端有影响。相似的，如果主机在需要写入日志项的时候发现复制缓冲满了，也会停止运行知道日志项被清除了。主机的停止是自然的流控机制，可以在生成的日志项速率过快的时候降低速度。然而，这种暂停会影响虚拟机的客户端，因为主机会完全停止变为不响应知道可以写入日志继续运行的时候。因此，我们的实现必须设计为最小化主机日志缓冲满的可能性</p>
          </div>

<p>One reason that the primary log buffer may fill up is because the bandwidth of the logging channel is too low to <code>carry</code> the <code>volume</code> of log entries being produced. While the bandwidth on the logging channel is typically not high (as seen in Section 5), we strongly <code>recommend</code> the use of a 1 Gbit/s network for the logging channel to avoid any possibility of a bottleneck.</p>
<div class="note info">
            <p>主机日志缓冲满的一个原因是日志通道的带宽太小以至于无法承载正在生成的日志项的容量。因为日志通道的带宽通常不太高(见第5节)，我们强烈建议对于日志通道使用1Gbit/s的网络来避免网络瓶颈。</p>
          </div>

<p>Another reason that the primary log buffer may fill up is because the backup VM is executing too slowly and therefore consuming log entries too slowly. In general, the backup VM must be able to replay an execution at <code>roughly</code> the same speed as the primary VM is recording the execution. Fortunately, the overhead of recording and replaying in VMware <code>deterministic</code> replay is roughly the same. However, if the server hosting the backup VM is heavily loaded with other VMs (and hence <code>overcommitted</code> on resources), the backup VM may not be able to get enough CPU and memory resources to execute as fast as the primary VM, <code>despite</code> the best efforts of the backup hypervisor’s VM scheduler.</p>
<div class="note info">
            <p>主机缓冲满的另一个可能原因是备机执行过慢以至于消费日志项太慢。通常，备机必须能以和主机记录执行大致相同的速度重放执行。幸运的是，VMware确定性重放中记录和重放的负载是大致相同的。然而，如果承载备机的服务器也加载了其他的虚拟机(因此使用资源过渡)，备机可能无法获得足够的cpu和内存资源以和主机相同的速度执行，即使备机虚拟机管理程序的虚拟机调度器尽最大的努力</p>
          </div>

<p><code>Beyond</code> avoiding unexpected pauses if the log buffers fill up, there is another reason why we don’t wish the execution <code>lag</code> to become too large. If the primary VM fails, the backup VM must <code>“catch up”</code> by replaying all the log entries that it has already acknowledged before it goes live and starts communicating with the external world. The time to finish replaying is <code>basically</code> the execution lag time at the point of the failure. Hence, the time for the backup to go live is roughly equal to the failure detection time plus the current execution lag time. So, we don’t wish the execution lag time to be large (more than a second), since that will add significant time to the failover time (the time for the backup to go live).</p>
<div class="note info">
            <p>除了避免在日志缓冲满时不希望的暂停，还有另外原因是我们不希望执行的滞后变得太大。如果主机故障了，备机必须通过重放所有的在上线并开始和外部世界通信前已经确认了的日志项来赶上主机。结束重放的时间基本上是故障点的执行滞后时间。因此，备机上线的时间大致等于故障检测时间加上当前执行滞后时间。所以，我们不希望执行滞后时间太大(超过1秒)，因为这将明显的增加故障转移的时间(备机上线的时间)</p>
          </div>

<p>Therefore, we have an additional mechanism to slow down the primary VM to <code>prevent</code> the backup VM from getting too far behind. In our protocol for sending and acknowledging log entries, we send additional information to determine the real-time execution lag between the primary and backup VMs. Typically the execution lag is less than 100 milliseconds. If the backup VM starts having a significant execution lag (say, more than 1 second), VMware FT starts slowing down the primary VM by informing the scheduler to give it a <code>slightly smaller share</code> of the CPU (initially by just a few percent). We use a slow <code>feedback</code> loop,<br>which will try to <code>gradually</code> <code>pinpoint</code> the appropriate CPU share for the primary VM that will allow the backup VM to match its execution. If the backup VM continues to lag behind, we continue to gradually reduce the primary VM’s CPU share. <code>Conversely</code>, if the backup VM catches up, we gradually increase the primary VM’s CPU share until the backup VM returns to having a slight lag.</p>
<div class="note info">
            <p>因此，我们有一个额外的机制来减慢主机的速度，避免备机落后太多。在发送和确认日志项的协议中，会发送额外的信息来决定实时的运行延迟，在主机和备机之间。通常执行延迟少于100毫秒。如果备机开始有了明显的执行延迟(比如超过1秒)，VMware容错会开始减慢主机的速度，通过通知调度器给主机更少的cpu份额(初始时只有百分之几)。我们使用一个慢反馈环，会逐渐的精确话对于主机的cpu份额来让备机匹配上主机的运行。如果备机仍旧落后，我们会继续降低主机的cpu份额。相反了，如果备机追上了主机，我们会逐渐的增加主机的cpu份额知道备机返回微小的延迟</p>
          </div>

<p>Note that such <code>slowdowns</code> of the primary VM are very <code>rare</code>, and typically happen only when the system is under <code>extreme</code> <code>stress</code>. All the performance numbers of Section 5 include the cost of any such slowdowns.</p>
<div class="note info">
            <p>注意对于主机的减速是很罕见的，通常只在系统处于极端压力的情况下发生。第5节的所有性能数字包含了这些减速的成本。</p>
          </div>

<hr>
<h3 id="3-3-Operation-on-FT-VMs"><a href="#3-3-Operation-on-FT-VMs" class="headerlink" title="3.3 Operation on FT VMs"></a>3.3 Operation on FT VMs</h3><p>Another practical <code>matter</code> is dealing with the various control operations that may be applied to the primary VM. For example, if the primary VM is explicitly <code>powered off</code>, the backup VM should be stopped as well, and not attempt to go live. As another example, any resource management change on the primary (such as increased CPU share) should also be applied to the backup. For these kind of operations, special control entries are sent on the logging channel from the primary to the backup, in order to effect the appropriate operation on the backup.</p>
<div class="note info">
            <p>另一个实际的问题是处理多种可能被应用于主机的控制操作。比如，当主机显式关机的时候，备机也应该关机，而不是尝试上线。另一个例子，主机上任何的资源管理改变(比如增加了cpu份额)也应该应用到备机。对于这些操作，特殊的控制项会通过日志通道从主机发送给备机，为了在备机上也应用适当的操作</p>
          </div>

<p>In general, most operations on the VM should be initiated only on the primary VM. VMware FT then sends any necessary control entry to cause the appropriate change on the backup VM. The only operation that can be done independently on the primary and backup VM is VMotion. That is, the primary and backup VM can each be VMotioned independently to other hosts. Note that VMware FT ensures that neither VM is VMotioned to the server where the other VM is, since that situation would no longer provide fault tolerance.</p>
<div class="note info">
            <p>通常，虚拟机的多数操作仅在主机上初始化。VMware容错会发送所有必要的控制项在备机上应用适当的变更。唯一可以在主机和备机上独立执行的操作是VMotion.也就是说，主机和备机可以分别独立的Vmotiond到其他主机。注意，VMware容错确保主机和备机都不会被VMotioned到对方所在的服务器上，因为这种情况下不再提供容错</p>
          </div>

<p>VMotion of a primary VM adds some complexity over a normal VMotion, since the backup VM must disconnect from the source primary and re-connect to the destination primary VM at the appropriate time. VMotion of a backup VM has a similar issue, but adds an additional complexity. For a normal VMotion, we require that all <code>outstanding</code> disk IOs be <code>quiesced</code> (i.e. completed) just as the final <code>switchover</code> on the VMotion occurs. For a primary VM, this quiescing is easily handled by waiting until the physical IOs complete and delivering these completions to the VM. However, for a backup VM, there is no easy way to cause all IOs to be completed at any required point, since the backup VM must replay the primary VM’s execution and complete IOs at the same execution point. The primary<br>VM may be running a workload in which there are always disk IOs <code>in flight </code>during normal execution. VMware FT has a unique method to solve this problem. When a backup VM is at the final switchover point for a VMotion, it requests via the logging channel that the primary VM temporarily quiesce all of its IOs. The backup VM’s IOs will then naturally be quiesced as well at a single execution point as it replays the primary VM’s execution of the quiescing operation.</p>
<div class="note info">
            <p>主机的Vmotion相对于普通Vmotion增加了一些复杂性，因为备机必须和源主机断开连接然后在合适的时间重新连接到目的主机。备机的VMtion有相同的问题，但是增加了额外的复杂性。对于普通的Vmotion,我们要求所有未完成的磁盘IO都暂停(即完成)就像VMotion上发生的最终切换。对于主机，这种暂停容易处理，可以一直等待直到物理IO完成并发送完成信息给虚拟机。然而，对于备机，没有简单的方法在任何需要的时间点让所有IO完成，因为备机必须重放主机的执行并且在相同的执行点完成IO.主机可以运行在总是有磁盘IO的工作负载上，在正常运行期间。VMware容错有独特的方法解决这个问题。当备机在VMotion的最终切换点的时候，它通过日志通道要求主机临时停止所有的IO.备机的IO也会在单独的执行点上自然的暂停，因为备机会重放主机暂停操作的执行命令</p>
          </div>

<hr>
<h3 id="3-4-Implementation-Issues-for-Disk-IOs"><a href="#3-4-Implementation-Issues-for-Disk-IOs" class="headerlink" title="3.4 Implementation Issues for Disk IOs"></a>3.4 Implementation Issues for Disk IOs</h3><p>There are a number of <code>subtle</code> implementation issues related to disk IO. First, given that disk operations are non-blocking and so can execute in <code>parallel</code>, <code>simultaneous</code> disk operations that access the same disk location can lead to non-determinism. Also, our implementation of disk IO uses DMA directly to/from the memory of the virtual machines, so simultaneous disk operations that access the same memory pages can also lead to non-determinism. Our solution is generally to <code>detect</code> any such IO races (which are rare), and force such racing disk operations to execute sequentially in the same way on the primary and backup. Interestingly, a single disk read operation can cause a race as well, since its <code>scatter-gather</code> array could reference the same block of memory multiple times, hence <code>leaving</code> the final contents of the memory block undetermined. Our solution is to detect this racing IO as well, and in this case ensure that the final contents of memory are sent on the logging channel, so the backup ends up with the same memory contents.</p>
<div class="note info">
            <p>有一些和磁盘IO相关的细微的实现问题。首先，非阻塞的磁盘操作可以并行执行，因此对同一磁盘位置的同时访问可能导致不确定性。我们对磁盘IO的实现使用DMA直接读写虚拟机内存，所有对于相同内存页的同时访问也可能导致不确定性。我们的解决方案通常是检测所有这类IO竞争(是很罕见的)，然后强制这些竞争的磁盘操作以相同的方式在主机和备机上顺序执行。有趣的是，单个磁盘读取操作也可能造成竞争，因为散聚的阵列可能引用相同的内存块多次，而导致内存页的内容变得不确定性。我们的解决方案还是检测这些竞争，保证在这种情况下最后的内存内容会在日志通道上发送，这样备机可以以相同的内存内存结束。</p>
          </div>

<p>Second, a disk operation can also race with a memory access by an application (or OS) in a VM, because the disk operations directly access the memory of a VM via DMA. For example, there could be a non-deterministic result if an application/OS in a VM is reading a memory block at the same time a disk read is occurring to that block. This <code>situation</code> is also unlikely, but we must detect it and deal with it if it happens. One solution is to set up page protection <code>temporarily</code> on pages that are targets of disk operations. The page protections result <code>in a trap</code> if the VM happens to make an access to a page that is also the target of an outstanding disk operation, and the VM can be paused until the disk operation completes. Because changing MMU protections on pages is an expensive operation, we choose instead to use <code>bounce</code> buffers. A bounce buffer is a temporary buffer that has the same size as the memory being accessed by a disk operation. A disk read operation is modified to read the specified data to the bounce buffer, and the data is copied to guest memory only as the IO completion is delivered. Similarly, for a disk write operation, the data to be sent is first copied to the bounce buffer, and the disk write is modified to write data from the bounce buffer. The use of the bounce buffer can slow down disk operations, but we have not seen it cause any noticeable performance differences.</p>
<div class="note info">
            <p>第二，虚拟机上的应用程序(或操作系统)的有关内存访问的磁盘操作也可能产生竞争，因为磁盘操作直接通过DMA访问内存。比如，如果虚拟机中的应用程序/操作系统在同一时间读取一个正在发生磁盘读取的内存块可能会导致不确定性。这种情况也是类似的，但是我们必须检测并解决它在发生的时候。我们的解决方案是设置临时的页保护在由磁盘操作标记的页上。如果虚拟机碰巧对未完成磁盘操作的标记页进行访问则页保护最终会进入陷阱，虚拟机会被暂停直到磁盘操作完成。因为修改页上的MMU保护是昂贵的操作，所以我们使用了bounce buffers. Bounce buffer是和由磁盘操作正在访问的内存大小一致的临时缓冲。磁盘读操作被修改为在bounce buffer中读取特定数据，并且数据仅在IO操作完成并被传递的时候拷贝到虚拟机内存。类似的，对于磁盘写操作，将要被发送的数据会先拷贝到bounce buffer,磁盘写操作位被修改为写数据到bounce buffer. Bounce buffer的使用能够减慢磁盘操作，但是我们还没有看到任何明显的性能差异。</p>
          </div>

<p>Third, there are some issues associated with disk IOs that are outstanding (i.e. not completed) on the primary when a failure happens, and the backup takes over. There is no way for the newly-promoted primary VM to be sure if the disk IOs were <code>issued</code> to the disk or completed successfully. In addition, because the disk IOs were not issued externally on the backup VM, there will be no explicit IO completion for them as the newly-promoted primary VM continues to run, which would eventually cause the guest operating system in the VM to start an abort or reset <code>procedure</code>. Therefore, we would like to ensure that a completion is sent to the VM for each pending IO. We could send an error completion that indicates that each IO failed, since it is acceptable to return an error even if the IO completed successfully. However, the guest OS might not respond well to errors from its local disk. Instead, we re-issue the IOs during the go-live process of the VM. Because we have <code>eliminated</code> all races and all IOs specify directly which memory and disk blocks are accessed, these disk operations can be re-issued even if they have already completed successfully (i.e. they are <code>idempotent</code>).</p>
<div class="note info">
            <p>第三，当主机故障的时候在主机上可能会有一些未完成的和磁盘IO相关的问题，而备机进行了接管。对新提升的主机就没有办法确定磁盘IO被发布到磁盘还是已经成功完成。另外，因为磁盘IO没有在外部的备机进行发布，当新提升的主机继续运行的时候，不会有明确的IO完成，最终可能导致虚拟机的虚拟机操作系统开始终止或者重置程序。因此，我们希望确保对于每一个挂起的IO，完成信息被发送给虚拟机。我们可以发送错误完成信息来表明IO失败，因为即使IO成功完成，返回错误也是可接受的。然而，虚拟机操作系统可能不会从本地磁盘很好的响应错误。相反，我们在虚拟机go-live的过程重新发布IO。因为我们已经消除了所有的竞争并且所有的IO直接指定了要访问的内存和磁盘块，这些磁盘操作可以重新发布即使已经成功完成了（即是幂等的)</p>
          </div>

<hr>
<h3 id="3-5-Implementation-Issues-for-Network-IO"><a href="#3-5-Implementation-Issues-for-Network-IO" class="headerlink" title="3.5 Implementation Issues for Network IO"></a>3.5 Implementation Issues for Network IO</h3><p>VMware vSphere provides many performance optimizations for VM networking. Many of these optimizations are based on the hypervisor asynchronously updating the state of the virtual machine’s network device. For example, receive buffers can be updated directly by the hypervisor while the VM is executing. Unfortunately these asynchronous updates to a VM’s state add non-determinism. Unless we can guarantee that all updates happen at the same point in the <code>instruction</code> stream on the primary and the backup, the backup’s execution can <code>diverge</code> from that of the primary.</p>
<div class="note info">
            <p>VMware vSphere对于虚拟机网络提供了许多性能优化。多数这些优化是基于虚拟机管理程序异步更新虚拟机网络设备的状态。比如，在虚拟机运行的时候接收缓冲区可以被虚拟机管理程序直接更新。不幸的是，这种对于虚拟机状态的异步更新增加了不确定性。除非我们能够保证所有的更新在主机和备机的指令流同时发生，否则备机的执行可能和主机不同</p>
          </div>

<p>The biggest change to the networking <code>emulation</code> code for fault tolerance is the <code>elimination</code> of the asynchronous network optimizations. All updates to VM networking state must be done while the VM is not executing instructions so we can log the updates and replay the updates on the backup at the same point in the instruction stream. The code that asynchronously updates VM <code>ring</code> buffers with incoming packets has been modified to instead force the guest to <code>trap to</code> the hypervisor where it can log the updates and then apply them to the VM. Similarly, code that previously pulled packets out of <code>transmit</code> queues asynchronously has been disabled for FT and instead we require transmits to be done through a trap to the hypervisor (except as noted below).</p>
<div class="note info">
            <p>对于容错的网络仿真代码的最大改变是消除了异步网络优化。所有对于虚拟机网络状态的更新必须在虚拟机不执行指令的时候完成，以便我们可以记录更新日志并在备机上指令流的同一点重放。异步更新虚拟机ring buffer的代码被修改为强制guest陷入到虚拟机管理程序，在虚拟机管理程序里可以更新然后应用更新日志带虚拟机。类似的，之前异步拉取传输队列的包的代码被容错禁用了，取而代之的我们要求通过陷入到虚拟机管理程序来完成传输(如下所示)</p>
          </div>

<p>The elimination of the asynchronous updates of the network device combined with the delaying of sending packets described in Section 2.2 has provided some performance challenges for networking. We’ve taken two approaches to improving VM network performance while running FT. First, we implemented clustering optimizations to reduce VM traps and interrupts. When we are streaming data at a <code>sufficient</code> bit rate, we are able to do one transmit trap per group of packets and, in the best case, zero traps, since we can transmit the packets as part of receiving new packets. <code>Likewise</code>, we can reduce the number of interrupts to the VM for incoming packets by only posting the interrupt for a group of packets.</p>
<div class="note info">
            <p>网络设备异步更新的消除和2.2节描述的发送包的延迟，为网络的性能带来了挑战。我们已经使用两种方法来提高运行容错的虚拟机的网络性能。首先，我们实现了集群优化来江都虚拟机的陷入和中断。当我们以足够的比特率传输数据，我们可以对于每一组包进行一次传输陷入，最好的情况下是0陷入，因为我们将包作为新接收的包的一部分进行传输。同样的，我们通过对每一组包发送一次中断，来降低对于传入包的虚拟机的中断次数。</p>
          </div>

<p>Our second performance optimization for networking <code>involves</code> reducing the delay for transmitted packets. As noted earlier, we have to delay all transmitted packets until we get an acknowledgment from the backup that it has received the appropriate log entries. The key to reducing the transmit delay is to reduce the time required to send a log message to the backup and get an acknowledgment. Our primary optimizations in this area involve ensuring that sending and receiving log entries and acknowledgments can all be done without any thread context switch. The VMware vSphere hypervisor allows functions to be registered<br>with the TCP stack that will be called from a <code>deferred-execution</code> context (similar to a <code>tasklet</code> in Linux) whenever TCP data is received. This allows us to quickly handle any incoming log messages on the backup and any acknowledgments received by the primary without any thread context switches. In addition, when the primary VM enqueues a packet to be transmitted, we force an immediate log flush of the associated output log entry (as described in Section 2.2) by scheduling a deferred-execution context to do the flush.</p>
<div class="note info">
            <p>我们对于网络的第二个性能优化涉及降低传输包的延迟。如前面提到的，我们必须延迟所有的传输包直到获取了备机的确认信息，在备机接受到合适的日志项。降低传输延迟的关键是降低要求的发送给备机的日志信息和获取更新的时间。我们在这个方面的主要优化设计确保发送接受日志项和确认信息都在不发生线程上下文切换的情况下完成。VMware vSphere虚拟机管理程序允许函数被注册为TCP栈，任何接收到tcp数据的时候，将在推迟执行上下文中调用(类似linux的软中断)。这允许我们在备机上快速处理所有的输入日志项和由主机收到的确认信息，而不会发生任何的线程上下文切换。另外，当主机将需要被传输的包入队，我们通过调度延迟执行上下文来将需要立即刷新的和输出日志项关联的日志进行刷新。</p>
          </div>

<hr>
<h2 id="4-Design-Alternatives"><a href="#4-Design-Alternatives" class="headerlink" title="4 Design Alternatives"></a>4 Design Alternatives</h2><p>In our implementation of VMware FT, we have explored a number of interesting design alternatives. In this section, we explore some of these alternatives.</p>
<div class="note info">
            <p>在我们VMware容错的实现中，我们已经探索了许多有趣的设计替代方案。在这一节，我们探索一部分替代方案</p>
          </div>

<hr>
<h3 id="4-1-Shared-vs-Non-shared-Disk"><a href="#4-1-Shared-vs-Non-shared-Disk" class="headerlink" title="4.1 Shared vs. Non-shared Disk"></a>4.1 Shared vs. Non-shared Disk</h3><p>In our default design, the primary and backup VMs share the same virtual disks. Therefore, the content of the shared disks is naturally correct and available if a failover occurs. <code>Essentially</code>, the shared disk is considered external to the primary and backup VMs, so any write to the shared disk is considered a communication to the external world. Therefore, only the primary VM does actual writes to the disk, and writes to the shared disk must be delayed in <code>accordance</code> with the Output Rule. The shared disk model is the one used in [3, 9, 7].</p>
<div class="note info">
            <p>在我们的缺省设计中，主机和备机共享相同的虚拟磁盘。因此，共享磁盘的内容在故障转移发生的时候自然是正确和可用的。基本上，共享磁盘被认为在主机和备机的外部，所以共享磁盘的写入是到外部世界的通信。因此，只有主机实际上写磁盘，共享磁盘的写入以和输出规则一致的方式进行延迟。共享磁盘模型在[3, 9, 7]中使用</p>
          </div>

<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/Snipaste_2021-02-17_23-19-51_water.jpg"></p>
<p>An alternative design is for the primary and backup VMs to have separate (non-shared) virtual disks. In this design, the backup VM does do all disk writes to its virtual disks, and in doing so, it naturally keeps the contents of its virtual disks in sync with the contents of the primary VM’s virtual disks. Figure 4 illustrates this configuration. In the case of nonshared disks, the virtual disks are <code>essentially</code> considered part of the internal state of each VM. Therefore, disk writes of the primary do not have to be delayed according to the Output Rule. The non-shared design is quite useful in cases where shared storage is not accessible to the primary and backup VMs. <code>This may be the case because</code> shared storage is unavailable or too expensive, or because the servers running the primary and backup VMs are <code>far apart</code> (“long-distance FT”). One disadvantage of the non-shared design is that the two copies of the virtual disks must be explicitly synced up in some manner when fault tolerance is first enabled. In addition, the disks can <code>get out of</code> sync after a failure, so they must be explicitly resynced when the backup VM is restarted after a failure. That is, FT VMotion must not only sync the running state of the primary and backup VMs, but also their disk state.</p>
<div class="note info">
            <p>对于主机和备机的一个替代设计是使用单独(非共享)的虚拟磁盘。在这种设计中，备机将所有的写写到自己的虚拟磁盘，这样做可以自然的保持备机的虚拟磁盘和主机的虚拟磁盘保持同步。图4说明了这种配置。对于非共享磁盘的情况，每个虚拟磁盘本质上被认为是每个虚拟机的内部状态的一部分。因此，主机的磁盘写不用根据输出规则做延迟。在共享存储对于主机和备机不可访问的时候非共享的设计是相当有用的。可能是因为共享存储不可用或太昂贵，或是因为运行主机和备机的服务器相距很远(远距离的容错)。非共享设计的一个缺点是在容错第一次启用的时候，虚拟磁盘的两份拷贝必须显式同步。另外，磁盘可能会在故障发生后脱离同步，所以在故障发生后虚拟机重启的时候，磁盘必须被显式的重新同步。也就是说，容错VMotion必须不光同步主机和备机的运行状态，也要同步磁盘的状态。</p>
          </div>

<p>In the non-shared-disk configuration, there may be no shared storage to use for dealing with a split-brain situation. In this case, the system could use some other external <code>tiebreaker</code>, such as a third-party server that both servers can talk to. If the servers are part of a cluster with more than two nodes, the system could alternatively use a <code>majority algorithm</code> based on cluster membership. In this case, a VM would only be allowed to go live if it is running on a server that is part of a communicating sub-cluster that contains a majority of the original nodes.</p>
<div class="note info">
            <p>在非共享磁盘的配置下，可能没有可用的共享存储对于解决脑裂的情况。在这种情况下，系统可以使用一些其他的外部的”决胜局”,比如主机和备机都可以进行通信的第三方服务器。如果服务器是超过两个节点的集群的一部分，系统可以替代性的使用基于集群成员的多数派算法。在这种情况下，如果虚拟机运行在一个属于包含多数原始节点的通信子集群的一部分的服务器上，将仅仅被允许上线。</p>
          </div>

<hr>
<h3 id="4-2-Executing-Disk-Reads-on-the-Backup-VM"><a href="#4-2-Executing-Disk-Reads-on-the-Backup-VM" class="headerlink" title="4.2 Executing Disk Reads on the Backup VM"></a>4.2 Executing Disk Reads on the Backup VM</h3><p>In our default design, the backup VM never reads from its virtual disk (whether shared or non-shared). Since the disk read is considered an input, it is <code>natural</code> to send the results of the disk read to the backup VM via the logging channel.</p>
<div class="note info">
            <p>在我们的缺省设计中，备机绝不会从虚拟磁盘(不管共享还是非共享)进行读取.因为磁盘读被认为是一个输入，通过日志通道发送磁盘读的结果给备机是自然的。</p>
          </div>

<p>An alternate design is to have the backup VM execute disk reads and therefore <code>eliminate</code> the logging of disk read data. This approach can greatly reduce the traffic on the logging channel for workloads that do a lot of disk reads. However, this approach has a number of <code>subtleties</code>. It may slow down the backup VM’s execution, since the backup VM must execute all disk reads and wait if they are not physically completed when it reaches the point in the VM execution where they completed on the primary.</p>
<div class="note info">
            <p>一个替代的设计是让备机执行磁盘读，这样可以消除磁盘读的日志。这样可以极大的降低日志通道的流量，在有大量磁盘读的工作负载上。然而，这种方法有很多微妙之处。它可能会减慢备机的执行速度，因为备机必须执行所有的磁盘读，并且在达到主机上执行完成的执行点上等待磁盘读是否在物理上完成</p>
          </div>

<p>Also, some extra work must be done to deal with failed disk read operations. If a disk read by the primary succeeds but the corresponding disk read by the backup fails, then the disk read by the backup must be retried until it succeeds, since the backup must get the same data in memory that the primary has. <code>Conversely</code>, if a disk read by the primary fails, then the contents of the target memory must be sent to the backup via the logging channel, since the contents of memory will be undetermined and not necessarily replicated by a successful disk read by the backup VM.</p>
<div class="note info">
            <p>并且，必须做一些额外的工作来处理失败的磁盘读操作。如果主机的磁盘读成功了但是备机的磁盘读失败了，那么备机的磁盘读必须重试直到成功，因为备机必须在内存中获得和主机一样的数据。反过来，如果主机的磁盘读失败，必须通过日志通道将目的内存的内容发送给备机，因为内存的内容将会是不确定性的，并且备机的成功磁盘读可能是不必要的副本</p>
          </div>

<p>Finally, there is a <code>subtlety</code> if this disk-read alternative is used with the shared disk configuration. If the primary VM does a read to a particular disk location, followed fairly soon by a write to the same disk location, then the disk write must be delayed until the backup VM has executed the first disk read. This dependence can be detected and handled correctly, but adds extra complexity to the implementation.</p>
<div class="note info">
            <p>最后，替代方案的磁盘读和共享磁盘配置一起使用的行为是微妙的。如果主机读取了一个特定的磁盘位置，然后很快又有一个对于相同磁盘位置的写操作，则第二次磁盘写将被延迟到备机已经执行了第一次的磁盘读。这种依赖可以被检测到并进行正确的处理，但是对于实现增加了额外的复杂性。</p>
          </div>

<p>In Section 5.1, we give some performance results indicating that executing disk reads on the backup can cause some slightly reduced throughput (1-4%) for real applications, but can also reduce the logging bandwidth noticeably. Hence, executing disk reads on the backup VM may be useful in cases where the bandwidth of the logging channel is quite limited.</p>
<div class="note info">
            <p>在5.1节，我们提供的一些性能结果表明在备机上执行磁盘读会对应用程序的吞吐有轻微的降低(1-4%),但也会显著降低日志的带宽。因此，对于日志通道带宽受限的情况，在备机执行磁盘读是有用的。</p>
          </div>

<hr>
<h2 id="5-Performance-Evaluation"><a href="#5-Performance-Evaluation" class="headerlink" title="5 Performance Evaluation"></a>5 Performance Evaluation</h2><p>In this section, we do a basic evaluation of the performance of VMware FT for a number of application workloads and networking benchmarks. For these results, we run the primary and backup VMs on identical servers, each with eight Intel Xeon 2.8 Ghz CPUs and 8 Gbytes of RAM. The servers are connected via a 10 Gbit/s crossover network, though as will be seen in all cases, much less than 1 Gbit/s of network bandwidth is used. Both servers access their shared virtual disks from an EMC Clariion connected through a standard 4 Gbit/s Fibre Channel network. The client used to drive some of the workloads is connected to the servers<br>via a 1 Gbit/s network.</p>
<p>The applications that we evaluate in our performance results are as follows. SPECJbb2005 is an industry-standard Java application benchmark that is very CPU- and memory-intensive and does very little IO. Kernel Compile is a workload that runs a compilation of the Linux kernel. This workload does some disk reads and writes, and is very CPU- and MMU-intensive, because of the creation and destruction of many compilation processes. Oracle Swingbench is a workload in which an Oracle 11g database is driven by the Swingbench OLTP (online transaction processing) workload. This workload does substantial disk and networking IO, and has eighty simultaneous database sessions. MS-SQL DVD Store is a workload in which a Microsoft SQL Server 2005 database is driven by the DVD Store benchmark, which has sixteen simultaneous clients.</p>
<hr>
<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/Snipaste_2021-02-17_23-20-03_water.jpg"></p>
<h3 id="5-1-Basic-Performance-Results"><a href="#5-1-Basic-Performance-Results" class="headerlink" title="5.1 Basic Performance Results"></a>5.1 Basic Performance Results</h3><p>Table 1 gives basic performance results. For each of the applications listed, the second column gives the ratio of the performance of the application when FT is enabled on the VM running the server workload vs. the performance when FT is not enabled on the same VM. For SPECJbb2005, Kernel Compile, Oracle Swingbench, and MS-SQL DVD Store, the performance measures are, respectively, business operations per second, compile time in seconds, transactions per second, and operations per second. The ratios are calculated so that a value less than 1 indicates that the FT workload is slower. Clearly, the overhead for enabling FT on these representative workloads is less than 10%. SPECJbb2005 is completely computebound and has no idle time, but performs well because it has minimal non-deterministic events beyond timer interrupts. The other workloads do disk IO and have some idle time, so some of the overhead of deterministic replay and the FT protocol may be hidden by the fact that the FT VMs have less idle time. However, the general conclusion is that VMware FT is able to support fault-tolerant VMs with a reasonable performance overhead.</p>
<p>In the third column of the table, we give the average bandwidth of data sent on the logging channel when these applications are run. For these applications, the logging bandwidth is quite reasonable and easily satisfied by a 1 Gbit/s network. In fact, the low bandwidth requirements indicate that multiple FT workloads can share the same 1 Gbit/s network without any negative performance effects.</p>
<p>For VMs that run common guest operating systems like Linux and Windows, we have found that the typical logging bandwidth while the guest OS is idle is 0.5-1.5 Mbits/sec. The “idle” bandwidth is largely the result of recording the delivery of timer interrupts. For a VM with an active workload, the logging bandwidth is dominated by the network and disk inputs that must be sent to the backup – the network packets that are received and the disk blocks that are read from disk. We have found that a useful heuristic for the network bandwidth is:</p>
<p>  FT logging bandwidth = 1 Mbit/s + 1.2 * (average disk read throughput<br>  [Mbits/s] + average network receives [Mbits/s])</p>
<p>The factor of 1.2 is a “fudge factor” that approximates the extra logging bandwidth needed for disk and network IOs aside from the input data, including the log entry headers and the extra entries for completion interrupts. Hence, the logging bandwidth can be much higher than those measured in Table 1 for applications that have very high network receive or disk read bandwidth. For these kinds of applications, the bandwidth of the logging channel could be a bottleneck, especially if there are other uses of the logging channel.</p>
<p>The relatively low bandwidth needed over the logging channel for many real applications makes replay-based fault tolerance quite attractive for a long-distance configuration using non-shared disks. For long-distance configurations where the primary and backup might be separated by 1-100 kilometers, optical fiber can easily support bandwidths of 100-1000 Mbit/s with latencies of less than 10 milliseconds. For the applications in Table 1, a bandwidth of 100-1000 Mbit/s should be sufficient for good performance. Note, however, that the extra round-trip latency between the primary and backup may cause network and disk outputs to be delayed by up to 20 milliseconds. The long-distance configuration will only be appropriate for applications whose clients can tolerate such an additional latency on each request.</p>
<p>For two applications, we have measured the performance impact of executing disk reads on the backup VM (as described in Section 4.2) vs. sending disk read data over the logging channel. For Oracle Swingbench, throughput is about 4% slower when executing disk reads on the backup VM; for MS-SQL DVD Store, throughput is about 1% slower. Meanwhile, the logging bandwidth is decreased from 12 Mbits/sec to 3 Mbits/sec for Oracle Swingbench, and from 18 Mbits/sec to 8 Mbits/sec for MS-SQL DVD Store. Clearly, the bandwidth savings could be much greater for applications with much greater disk read bandwidth. As mentioned in Section 4.2, it is expected that the performance might be somewhat worse when disk reads are executed on the backup VM. However, for cases where the bandwidth of the logging channel is limited (for example, a long-distance configuration), executing disk reads on the backup VM may be useful.</p>
<hr>
<h3 id="5-2-Network-Benchmarks"><a href="#5-2-Network-Benchmarks" class="headerlink" title="5.2 Network Benchmarks"></a>5.2 Network Benchmarks</h3><p>Networking benchmarks can be quite challenging for our system for a number of reasons. First, high-speed networking can have a very high interrupt rate, which requires the logging and replaying of asynchronous events at a very high rate. Second, benchmarks that receive packets at a high rate will cause a high rate of logging traffic, since all such packets must be sent to the backup via the logging channel. Third, benchmarks that send packets will be subject to the Output Rule, which delays the sending of network packets until the appropriate acknowledgment from the backup is received. This delay will increase the measured latency to a client. This delay could also decrease network bandwidth to a client, since network protocols (such as TCP) may have to decrease the network transmission rate as the roundtrip latency increases.</p>
<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/Snipaste_2021-02-17_23-20-15_water.jpg"></p>
<p>Table 2 gives our results for a number of measurements made by the standard netperf benchmark. In all these measurements, the client VM and primary VM are connected via a 1 Gbit/s network. The first two rows give send and receive performance when the primary and backup hosts are connected by a 1 Gbit/s network. The third and fourth rows give the send and receive performance when the primary and backup servers are connected by a 10 Gbit/s network, which not only has higher bandwidth, but also lower latency than the 1 Gbit/s network. As a rough measure, the ping time between hypervisors for the 1 Gbit/s connection is about 150 microseconds, while the ping time for a 10 Gbit/s connection is about 90 microseconds.</p>
<p>When FT is not enabled, the primary VM can achieve close (940 Mbit/s) to the 1 Gbit/s line rate for both transmits and receives. When FT is enabled for receive workloads, the logging bandwidth is very large, since all the incoming network packets must be sent on the logging channel. The logging channel can therefore become a bottleneck, as shown for the results for the 1 Gbit/s logging network. The effect is much less for the 10 Gbit/s logging network. When FT is enabled for transmit workloads, the logging bandwidth is significant since all the network interrupts must still be logged. However, the achievable network transmit bandwidths are higher than the network receive bandwidths. Overall, we see that FT can limit network bandwidths significantly at very high transmit and receive rates, but high absolute rates are still achievable.</p>
<hr>
<h2 id="6-Related-Work"><a href="#6-Related-Work" class="headerlink" title="6 Related Work"></a>6 Related Work</h2><p>Bressoud and Schneider [3] described the initial idea of implementing fault tolerance for virtual machines via software contained completely at the hypervisor level. They demonstrated the feasibility of keeping a backup virtual machine in sync with a primary virtual machine via a prototype for servers with HP PA-RISC processors. However, due to limitations of the PA-RISC architecture, they could not implement fully secure, isolated virtual machines. Also, they did not implement any method of failure detection or attempt to address any of the practical issues described in Section 3. More importantly, they imposed a number<br>of constraints on their FT protocol that were unnecessary. First, they imposed a notion of epochs, where asynchronous events are delayed until the end of a set interval. The notion of an epoch is unnecessary – they may have imposed it because they could not replay individual asynchronous events efficiently enough. Second, they required that the primary VM stop execution essentially until the backup has received and acknowledged all previous log entries. However, only the output itself (such as a network packet) must be delayed – the primary VM itself may continue executing.</p>
<p>Bressoud [4] describes a system that implements fault tolerance in the operating system (Unixware), and therefore provides fault tolerance for all applications that run on that operating system. The system call interface becomes the set of operations that must be replicated deterministically. This work has similar limitations and design choices as the hypervisor-based work.</p>
<p>Napper [9] and Friedman [7] describe implementations of fault-tolerant Java virtual machines. They follow a similar design to ours and Bressoud’s in sending information about inputs and non-deterministic operations on a logging channel. Like Bressoud, they do not appear to focus on detecting failure and re-establishing fault tolerance after a failure. In addition, their implementation is limited to providing fault tolerance for applications that run in a Java virtual machine. These systems attempt to deal with issues of multi-threaded Java applications, but require either that all data is correctly protected by locks or enforce a serialization on access to shared memory.</p>
<p>Dunlap [6] describes an implementation of deterministic replay targeted towards debugging application software on a paravirtualized system. Our work supports arbitrary operating systems running inside virtual machines and implements fault tolerance support for these VMs, which requires much higher levels of stability and performance.</p>
<p>Cully [5] describes an alternative approach for supporting fault-tolerant VMs and its implementation in a project called Remus. With this approach, the state of a primary VM is repeatedly checkpointed during execution and sent to a backup server, which collects the checkpoint information. The checkpoints must be executed very frequently (many times per second), since external outputs must be delayed until a following checkpoint has been sent and acknowledged. The advantage of this approach is that it applies equally well to uni-processor and multi-processor VMs. The main issue is that this approach has very high network bandwidth requirements to send the incremental changes to memory state at each checkpoint. The results for Remus presented in [5] show 100% to 225% slowdown for kernel compile and SPECweb benchmarks, when attempting to do 40 checkpoints per second using a 1 Gbit/s network connection for transmitting changes in memory state. There are a number of optimizations that may be useful in decreasing the required network bandwidth, but it is not clear that reasonable performance can be achieved with a 1 Gbit/s connection. In contrast, our record-replay based approach can achieve less than 10% overhead, typically with on the order of 10-50 Mbit/s bandwidth required between the primary and backup hosts.</p>
<hr>
<h2 id="7-Conclusion-and-Future-Work"><a href="#7-Conclusion-and-Future-Work" class="headerlink" title="7 Conclusion and Future Work"></a>7 Conclusion and Future Work</h2><p>We have designed and implemented an efficient and complete system in VMware vSphere that provides fault tolerance (FT) for virtual machines running on servers in a cluster. Our design is based on replicating the execution of a primary VM via a backup VM on another host using VMware deterministic replay. If the server running the primary VM fails, the backup VM takes over immediately with no interruption or loss of data.</p>
<div class="note info">
            <p>我们已经在VMware vSphere上设计实现了一个有效的完整的系统，可对运行在服务器集群上的虚拟机提供容错。我们的设计基于，运行在另外主机上通过使用VMware确定性重放功能的备机复制主机的执行。如果运行主机的服务器故障，备机可以立即接管主机，没有中断，也不会丢失数据。</p>
          </div>

<p><code>Overall</code>, the performance of fault-tolerant VMs under VMware FT on commodity hardware is excellent, and shows less than 10% overhead for some typical applications. Most of performance cost of VMware FT comes from the overhead of using VMware deterministic replay to keep the primary and backup VMs in sync. The low overhead of VMware FT therefore <code>derives from</code> the efficiency of VMware deterministic replay. In addition, the logging bandwidth required to keep the primary and backup in sync is typically quite small, often less than 100 Mbit/s. Because the logging bandwidth is quite small in most cases, it seems <code>feasible</code> to implement configurations where the primary and backup VMs are separated by long distances (1-100 kilometers).</p>
<div class="note info">
            <p>总体而言，VMware容错系统在商用硬件上的容错性能是出色的，对于一些典型应用的开销不到10%.多数VMware容错的性能开销来自保持主机备机间同步而使用的VMware确定性重放。VMware容错系统的低开销源自VMware确定性重放的效率。另外，用来保持主机备机间同步的日志带宽通常很小，一般低于100Mbit/s.因为日志带宽在大多数情况下很小，实现主机和备机远距离分布(1-100公里)看起来是可行的。</p>
          </div>

<p>Our results with VMware FT have shown that an efficient implementation of faulttolerant VMs can be built upon deterministic replay. Such a system can <code>transparently</code> provide fault tolerance for VMs running any operating systems and applications with minimal overhead. However, for a system of fault-tolerant VMs to be useful for customers, it must also be <code>robust</code>, easy-to-use, and highly automated. A usable system requires many other components <code>beyond</code> replicated execution of VMs. In particular, VMware FT automatically restores redundancy after a failure, by finding an appropriate server in the local cluster and creating a new backup VM on that server. By <code>addressing</code> all the necessary issues, we have <code>demonstrated</code> a system that is usable for real applications in customer’s datacenters.</p>
<div class="note info">
            <p>我们对VMware容错系统的研究结果表明，通过确定性重放技术能够高效的实现虚拟机容错。这样的系统可以透明的对运行在任何操作系统和应用上的虚拟机提供容错，以最小化开销。然而，对于一个对用户有用的容错虚拟机来说，他还必须是健壮的，易于使用，并且高自动化的。一个可用的系统除了复制虚拟机执行外，还需要很多其他的组件。特别的，VMware容错系统可以在故障后自动恢复冗余，通过在本地集群中寻找合适的服务器然后创建一个新的备机。通过解决所有必要的问题，我们证明了对客户数据中心上实际应用程序可用的系统</p>
          </div>

<p>In the future, we are interested in <code>investigating</code> the performance <code>characteristics</code> of the long-distance FT configurations mentioned above. We are also interested in extending our system to deal with <code>partial</code> hardware failure. By partial hardware failure, we mean a partial loss of functionality or redundancy in a server that doesn’t cause corruption or loss of data. An example would be the loss of all network connectivity to the VM, or the loss of a redundant<br>power <code>supply</code> in the physical server. If a partial hardware failure occurs on a server running a primary VM, in many cases (but not all) it would be advantageous to fail over to the backup VM immediately. Such a failover could immediately restore full service for a <code>critical</code> VM, and ensure that the VM is quickly <code>moved off</code> of a <code>potentially</code> unreliable server.</p>
<div class="note info">
            <p>今后，我们有兴趣调查前面提到的远距离容错配置的性能特征。我们也有兴趣扩展我们的系统来解决部分硬件。所谓的部分硬件故障，说的是服务器中部分功能缺失或冗余，不会导致数据的损坏或丢失。比如虚拟机的所有网络连接的丢失，或者物理服务器中冗余电源的丢失。如果部分硬件故障发生在运行主机的服务器上，在大多数情况(不是所有情况)下对于故障立即转移到备机是有利的。故障转移可以让关键的虚拟机恢复完整服务，并确保虚拟机从潜在不可靠的服务器中快速移出</p>
          </div>

<hr>
<h2 id="Acknowledgments"><a href="#Acknowledgments" class="headerlink" title="Acknowledgments"></a>Acknowledgments</h2><p>We would like to thank Krishna Raja, who generated many of the performance results. There were numerous people involved in the implementation of VMware FT. Core implementors of deterministic replay and the base FT functionality included Lan Huang, Eric Lowe, Slava Malyugin, Alex Mirgorodskiy, Boris Weissman, and Min Xu. In addition, there are many other people involved in the higher-level management of FT in VMware vCenter and in implementation issues related to specific virtual devices besides network and disk. Karyn Ritter did an excellent job managing much of the work.</p>
<hr>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] Alsberg, P., and Day, J. A Principle for Resilient Sharing of Distributed Resources. In Proceedings of the Second International Conference on Software Engineering (1976), pp. 627–644.</p>
<p>[2] AMD Corporation. AMD64 Architecture Programmer’s Manual. Sunnyvale, CA.</p>
<p>[3] Bressoud, T., and Schneider, F. Hypervisor-based Fault Tolerance. In Proceedings of SOSP 15 (Dec. 1995).</p>
<p>[4] Bressoud, T. C. TFT: A Software System for Application-Transparent Fault Tolerance. In Proceedings of the Twenty-Eighth Annual International Symposium on FaultTolerance Computing (June 1998), pp. 128–137.</p>
<p>[5] Cully, B., Lefebvre, G., Meyer, D., Feeley, M., Hutchison, N., and Warfield, A. Remus: High Availability via Asynchronous Virtual Machine Replication. In Proceedings of the Fifth USENIX Symposium on Networked Systems Design and Implementation (Apr. 2008), pp. 161–174.</p>
<p>[6] Dunlap, G. W., King, S. T., Cinar, S., Basrai, M., and Chen, P. M. ReVirt: Enabling Intrusion Analysis through Virtual Machine Logging and Replay. In Proceedings of the 2002 Symposium on Operating Systems Design and Implementation (Dec. 2002).</p>
<p>[7] Friedman, R., and Kama, A. Transparent Fault-Tolerant Java Virtual Machine. In Proceedings of Reliable Distributed System (Oct. 2003), pp. 319–328.</p>
<p>[8] Intel Corporation. IntelAˆR 64 and IA-32 Architectures Software Developer’s Manuals. Santa Clara, CA.</p>
<p>[9] Napper, J., Alvisi, L., and Vin, H. A Fault-Tolerant Java Virtual Machine. In Proceedings of the International Conference on Dependable Systems and Networks (June 2002), pp. 425–434.</p>
<p>[10] Nelson, M., Lim, B.-H., and Hutchins, G. Fast Transparent Migration for Virtual Machines. In Proceedings of the 2005 Annual USENIX Technical Conference (Apr. 2005).</p>
<p>[11] Nightingale, E. B., Veeraraghavan, K., Chen, P. M., and Flinn, J. Rethink the Sync. In Proceedings of the 2006 Symposium on Operating Systems Design and<br>Implementation (Nov. 2002).</p>
<p>[12] Schlicting, R., and Schneider, F. B. Fail-stop Processors: An Approach to Designing Fault-tolerant Computing Systems. ACM Computing Surveys 1, 3 (Aug.<br>1983), 222–238.</p>
<p>[13] Schneider, F. B. Implementing fault-tolerance services using the state machine approach: A tutorial. ACM Computing Surveys 22, 4 (Dec. 1990), 299–319.</p>
<p>[14] Stratus Technologies. Benefit from Stratus Continuing Processing Technology: Automatic 99.999% Uptime for Microsoft Windows Server Environments. At <a href="http://www.stratus.com/pdf/whitepapers/continuous-processing-for-windows.pdf">http://www.stratus.com/pdf/whitepapers/continuous-processing-for-windows.pdf</a>, June 2009.</p>
<p>[15] Xu, M., Malyugin, V., Sheldon, J., Venkitachalam, G., and Weissman, B. ReTrace: Collecting Execution Traces with Virtual Machine Deterministic Replay. In<br>Proceedings of the 2007 Workshop on Modeling, Benchmarking, and Simulation (June 2007).</p>
<h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><div class="pdfobject-container" data-target="http://nil.csail.mit.edu/6.824/2017/papers/vm-ft.pdf" data-height="1000px"></div>]]></content>
  </entry>
  <entry>
    <title>[译文]The Google File System</title>
    <url>/2021-01-26-The-Google-File-System/</url>
    <content><![CDATA[<div class="note default">
            <p><a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/gfs-sosp2003.pdf">original paper here</a></p>
          </div>

<a id="more"></a>

<h2 id="ABSTRACT"><a href="#ABSTRACT" class="headerlink" title="ABSTRACT"></a>ABSTRACT</h2><p>We have designed and implemented the Google File System, a <code>scalable</code> distributed file system for large distributed <code>data-intensive</code> applications. It provides fault tolerance while running on inexpensive <code>commodity</code> hardware, and it <code>delivers</code> high <code>aggregate</code> performance to a large number of clients.</p>
<div class="note info">
            <p>概览<br>我们已经设计并实现了GFS,一个针对大的分布式数据密集型应用的可扩展的分布式文件系统。它提供了运行在廉价的商用硬件上的容错处理，和对大量客户端的高的聚合性能。</p>
          </div>

<p>While sharing many of the same goals as previous distributed file systems, our design has been <code>driven</code> by <code>observations</code> of our application <code>workloads</code> and technological environment, both current and <code>anticipated</code>, that reflect a <code>marked departure</code> from some earlier file system <code>assumptions</code>. This has led us to <code>reexamine</code> traditional choices and explore <code>radically</code> different design points.</p>
<div class="note info">
            <p>尽管和以前的文件系统有着很多相同的目标，而我们的设计是由对于现在和将来的应用工作量和技术环境的观察驱动的，这些反应出和早期文件系统假设的明显不同。这让我们重新审视传统的选择并开始探索和原来完全不同的设计要点。</p>
          </div>

<p>The file system has successfully <code>met</code> our storage needs. It is widely deployed within Google as the storage platform for the generation and processing of data used by our service as well as research and development <code>efforts</code> that require large data sets. The largest cluster to date provides hundreds of terabytes of storage across thousands of disks on over a thousand machines, and it is concurrently accessed by hundreds of clients.</p>
<div class="note info">
            <p>文件系统已经成功满足我们的存储需求。GFS作为存储平台广泛部署在谷歌内部，用来生成和处理我们的服务数据以及需要大数据集的研究和开发的数据。上千台机器组成的集群通过上千台磁盘提供了数百Tb的数据，并且可以并行的访问上百个客户端。</p>
          </div>

<p>In this paper, we present file system interface extensions designed to support distributed applications, discuss many <code>aspects</code> of our design, and report measurements from both micro-benchmarks and real world use.</p>
<div class="note info">
            <p>在这篇论文中，我们呈现支持分布式应用的扩展的文件系统接口，讨论我们设计许多方面，并报告基于mocro-benchmarks和真实世界使用的测试数据。</p>
          </div>

<hr>
<h2 id="1-INTRODUCTION"><a href="#1-INTRODUCTION" class="headerlink" title="1. INTRODUCTION"></a>1. INTRODUCTION</h2><p>We have designed and implemented the Google File System (GFS) to meet the <code>rapidly</code> growing <code>demands</code> of Google’s data processing needs. GFS shares many of the same goals as previous distributed file systems such as performance, scalability, reliability, and availability. However, its design has been driven by key observations of our application workloads and technological environment, both current and anticipated, that reflect a marked departure from some earlier file system design assumptions. We have reexamined traditional choices and explored radically different points in the design space.</p>
<div class="note info">
            <p>我们已经设计并实现了GFS来解决谷歌迅速增长的数据处理需求。GFS和以前的分布式文件系统有许多相同的目标，比如性能，扩展性，可靠性，可用性。然而，GFS是基于我们对现在和以后的应用负载以及技术环境的观察来设计的，这反映出和早期文件系统设计的假设完全不同。我们重新审视了传统的选择并开始探索和原来完全不同的设计方式。</p>
          </div>

<p>First, <code>component</code> failures are the norm rather than the exception. The file system consists of hundreds or even thousands of storage machines built from inexpensive <code>commodity</code> parts and is accessed by<code> a comparable number of</code> client machines. The <code>quantity</code> and <code>quality</code> of the components <code>virtually</code> guarantee that some are not functional at any given time and some will not recover from their current failures. We have seen problems caused by application bugs, operating system bugs, human errors, and the failures of disks, memory, connectors, networking, and power supplies. Therefore, constant monitoring, error detection, fault tolerance, and automatic recovery must be <code>integral</code> to the system.</p>
<div class="note info">
            <p>第一，组件故障是正常现象，而非异常。文件系统由成百上千通过廉价商用部件组成的存储机器构成，并被许多客户机访问。组件的数量和质量实际上保证了，在一定的时间有些是不可用的，并且有一些不能从自身的错误中恢复。我们已经遇见了很多问题：应用bug,操作系统bug,人为错误，磁盘/内存/连接器的故障，网络和电源的错误。因此，持续监控，错误检测，容错，和自动恢复对于系统来说是必不可少的。</p>
          </div>

<p>Second, files are huge by traditional standards. Multi-GB files are common. Each file typically contains many application objects such as web documents. When we are <code>regularly</code> working with fast growing data sets of many TBs <code>comprising</code> billions of objects, it is <code>unwieldy</code> to manage billions of approximately KB-sized files even when the file system could support it. As a result, design <code>assumptions</code> and parameters such as I/O operation and blocksizes have to be revisited.</p>
<div class="note info">
            <p>第二，按传统标椎看现在的文件是很大的。数GB的文件很常见。每个文件通常都包括许多应用对象，比如网页文档。当我们定期处理快速增长的包含数十亿对象的数据集合，即使文件系统支持这样的量级，管理起来也是很笨重的。所以，必须重新设计假设条件和参数的值，比如I/O操作和块大小。</p>
          </div>

<p>Third, most files are <code>mutated</code> by appending new data rather than overwriting existing data. Random writes within a file are <code>practically</code> non-existent. Once written, the files are only read, and often only sequentially. A variety of data share these characteristics. Some may <code>constitute</code> large <code>repositories</code> that data analysis programs scan through. Some may be data streams <code>continuously</code> generated by running applications. Some may be <code>archival</code> data. Some may be intermediate results produced on one machine and processed on another, whether <code>simultaneously</code> or later in time. Given this access pattern on huge files, appending becomes the focus of performance optimization and atomicity guarantees, while caching data blocks in the client loses its <code>appeal</code>.</p>
<div class="note info">
            <p>第三，大多数文件的变化都是通过追加新数据而不是覆盖原始数据进行的。文件内的随机写几乎不存在。一旦写入，文件就是只读的，通常都是顺序读。许多数据都有这种特性。可能是数据分析程序扫描用的数据仓库，可能是运行中程序连续生成的数据流，可能是档案数据。可能是一台机器产生的中间结果，同时会稍后被另一台机器处理。鉴于对大型文件的这种访问方式，追加写成为了性能优化和原子性保证的重点，相应的在客户端缓存数据块便失去了吸引力。</p>
          </div>

<p>Fourth, <code>co-designing</code> the applications and the file system API <code>benefits</code> the <code>overall</code> system by increasing our <code>flexibility</code> .For example, we have relaxed GFS’s consistency model to <code>vastly</code> simplify the file system without <code>imposing</code> an <code>onerous</code> <code>burden</code> on the applications. We have also introduced an atomic append operation so that multiple clients can append concurrently to a file without extra synchronization between them. These will be discussed in more details later in the paper.</p>
<div class="note info">
            <p>第四，应用程序和文件系统api共同设计可以提高整个系统的灵活性。例如，我们放宽了GFS的一致性模型来极大的简化文件系统，避免给应用程序带来繁重的负担。我们也介绍了原子追加写的方式可以让多个客户端能够并行的追加写而不需要进行额外的同步。论文的后面会对这些细节进行更多的讨论。</p>
          </div>

<p>Multiple GFS clusters are currently deployed for different purposes. The largest ones have over 1000 storage nodes, over 300 TB of diskstorage, and are heavily accessed by hundreds of clients on distinct machines<code> on a continuous basis</code>.</p>
<div class="note info">
            <p>目前已经部署了多个GFS集群，出于不同的目的。最大的一个包含超过1000个节点，超过300TB的磁盘存储，并且连续不断的被分布在不同机器上的数百个客户端大量访问。</p>
          </div>

<hr>
<h2 id="2-DESIGN-OVERVIEW"><a href="#2-DESIGN-OVERVIEW" class="headerlink" title="2. DESIGN OVERVIEW"></a>2. DESIGN OVERVIEW</h2><h3 id="2-1-Assumptions"><a href="#2-1-Assumptions" class="headerlink" title="2.1 Assumptions"></a>2.1 Assumptions</h3><p>In designing a file system for our needs, we have been guided by assumptions that offer both challenges and opportunities. We <code>alluded</code> to some key observations earlier and now <code>lay out</code> our assumptions in more details.</p>
<div class="note info">
            <p>在设计满足我们需求的文件系统的时候，我们需要以挑战和机遇并存的假设为指引。前面我们已经提过了一些关键的观察点，现在将阐述关于假设更多的细节。</p>
          </div>

<ul>
<li>The system is built from many inexpensive commodity components that often fail. It must constantly monitor itself and detect, tolerate, and recover <code>promptly</code> from component failures on a <code>routine basis</code>.</li>
</ul>
<div class="note info">
            <p>系统是由许多容易出故障的廉价组件构成的。必须对系统进行持续的监控，检测，容错，以及及时的从组件故障中恢复。</p>
          </div>

<ul>
<li>The system stores a <code>modest</code> number of large files. We <code>expect</code> a few million files, each typically 100 MB or larger in size. Multi-GB files are the common case and should be managed efficiently. Small files must be supported, but we need not optimize for them.</li>
</ul>
<div class="note info">
            <p>文件系统存储了适量的大文件。我们预计有几百万个文件，每个通常为100m或者更大。数Gb的文件是常见的情况，这应该能够有效的管理。小文件必须支持，但我们不需要对小文件进行优化。</p>
          </div>

<ul>
<li>The workloads primarily consist of two kinds of reads: large streaming reads and small random reads. In large streaming reads, <code>individual</code> operations typically read hundreds of KBs, more commonly 1 MB or more. <code>Successive</code> operations from the same client often read through a <code>contiguous</code> region of a file. A small random read typically reads a few KBs at some <code>arbitrary</code> offset. <code>Performance-conscious</code> applications often batch and sort their small reads to <code>advance</code> <code>steadily</code> through the file rather than go backand forth.</li>
</ul>
<div class="note info">
            <p>工作负载主要包含两种读取：大的流式读取和小的随机读取。对于大的流式读取，个人操作通常读取几百kbs，更常见的是1m或者更多。同一客户端的连续读取通常读取的是文件的连续区域。小的随机读取通常在任意偏移位置读取几kbs的数据。注重性能表现的程序通常对于小的读取进行批处理和排序来稳定的向前读取文件，而不是来回切换的读取。</p>
          </div>

<ul>
<li>The workloads also have many large, sequential writes that append data to files. Typical operation sizes are similar to those for reads. Once written, files are <code>seldom</code> modified again. Small writes at arbitrary positions in a file are supported but do not have to be <code>efficient</code>.</li>
</ul>
<div class="note info">
            <p>工作负载也包含许多大的连续的顺序追加写。这些写操作通常和读取操作的大小是相似的。一旦写入，文件很少会被修改。小的随机写需要支持，但不需要保证效率。</p>
          </div>

<ul>
<li>The system must efficiently implement well-defined <code>semantics</code> for multiple clients that concurrently append to the same file. Our files are often used as producer-consumer queues or for many-way merging. Hundreds of producers, running one per machine, will concurrently append to a file. Atomicity with <code>minimal</code> synchronization <code>overhead</code> is <code>essential</code>. The file may be read later, or a consumer may be reading through the file <code>simultaneously</code>.</li>
</ul>
<div class="note info">
            <p>文件系统必须对多个客户端在同一个文件追加写实现定义良好的语义。文件通常作为生产者消费者队列或用于多路合并。数百个生产者，每个机器运行一个，将并发追加写到文件。原子性和最小化的同步开销是必要的。文件可能稍后被读取，也可能同时被一个消费者读取。</p>
          </div>

<ul>
<li>High <code>sustained</code> bandwidth is more important than low <code>latency</code>. Most of our target applications <code> place a premium on</code> processing data in bulkat a high rate, while few have <code>stringent</code> response time requirements for an individual read or write.</li>
</ul>
<div class="note info">
            <p>高持续性的带宽比低延迟更加重要。大多数的目标应用程序更加重视高速率的处理大的数据，而不会对单个的读或写的响应时间有严格要求。</p>
          </div>

<hr>
<h3 id="2-2-Interface"><a href="#2-2-Interface" class="headerlink" title="2.2 Interface"></a>2.2 Interface</h3><p>GFS provides a <code>familiar</code> file system interface, though it does not implement a standard API such as POSIX. Files are organized <code>hierarchically</code> in directories and identified by pathnames. We support the usual operations to create, delete, open, close, read, and write files.</p>
<div class="note info">
            <p>GFS提供了熟悉的文件系统接口，即使它没有实现像POSIX那样的标椎API.文件在目录中有组织的分层，通过路径标识。我们支持常用的操作，像是create/delete/open/close/read/write.</p>
          </div>

<p>Moreover, GFS has snapshot and record append operations. Snapshot creates a copy of a file or a directory tree at low cost. Record append allows multiple clients to append data to the same file concurrently while guaranteeing the atomicity of each individual client’s append. It is useful for implementing multi-way merge results and producerconsumer queues that many clients can simultaneously append to without additional locking. We have found these types of files to be <code>invaluable</code> in building large distributed applications. Snapshot and record append are discussed further in Sections 3.4 and 3.3 <code>respectively</code>.</p>
<div class="note info">
            <p>此外，GFS有快照和记录追加机制。快照以低成本创建文件或目录树的拷贝。记录追加机制允许多个客户端并行的追加写数据到相同的文件并保证了每一个追加写的原子性。这对于实现多路合并以及生产者消费者队列是有用的，多个客户端可以同时追加写而不需要额外的锁操作。我们发现这种文件类型对于建立大型分布式应用是非常有价值的。快照和记录追加将在3.4和3.3节进行更多的讨论。</p>
          </div>

<hr>
<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/Snipaste_2021-02-11_02-20-08.jpg"></p>
<h3 id="2-3-Architecture"><a href="#2-3-Architecture" class="headerlink" title="2.3 Architecture"></a>2.3 Architecture</h3><p>A GFS cluster consists of a single master and multiple chunkservers and is accessed by multiple clients, as shown in Figure 1. Each of these is typically a commodity Linux machine running a user-level server process. It is easy to run both a chunkserver and a client on the same machine, as long as machine resources permit and the lower reliability caused by running possibly <code>flaky</code> application code is acceptable.</p>
<div class="note info">
            <p>架构<br>GFS集群由一个master和多个chunkservers组成并被多个客户端访问，如图1所示。master/chunkserver通常都是运行在商用linux机器的用户级进程。可以将chunkserver和客户端运行在相同的机器，只要机器资源允许，并且可以接受运行不稳定程序可能带来的低可靠性。</p>
          </div>

<p>Files are divided into <code>fixed-size</code> chunks. Each chunk is identified by an <code>immutable</code> and globally unique 64 bit chunk handle assigned by the master at the time of chunk creation. Chunkservers store chunks on local disks as Linux files and read or write chunkdata specified by a chunk handle and byte range. For reliability, each chunk is replicated on multiple chunkservers. By default, we store three replicas, though users can <code>designate</code> different replication levels for different regions of the file namespace.</p>
<div class="note info">
            <p>文件被分割为固定大小的chunks。每个chunk由一个固定且全局的64bit chunk handle组成，chunk handle在chunk创建的时候由master分配。chunkserver将chunks存储在磁盘中，以文件的方式，并根据chunkhandle和字节大小读取或写入chunkdata.为了可靠性，每个chunk会在多个chunkserver进行备份。缺省情况下，会保存3份拷贝，用户也可以为文件命名空间的不同区域指定不同的复制级别。</p>
          </div>

<p>The master <code>maintains</code> all file system metadata. This includes the namespace, access control information, the mapping from files to chunks, and the current locations of chunks. It also controls system-wide activities such as chunk <code>lease</code> management, <code>garbage</code> collection of <code>orphaned</code> chunks, and chunk <code>migration</code> between chunkservers. The master <code>periodically</code> communicates with each chunkserver in HeartBeat messages to give it instructions and collect its state.</p>
<div class="note info">
            <p>master维护所有文件系统的元数据。包括命名空间，访问控制信息，文件到chunks的映射，chunks的当前位置。master还控制整个系统的活动，比如chunk的租约管理，孤儿chunk的垃圾回收，以及多个chunkservers间的chunk迁移。master定期的和每个chunkserver通过心跳包进行保活，也通过心跳包给chunkserver发送指示和收集chunkserver的状态信息。</p>
          </div>

<p>GFS client code linked into each application implements the file system API and communicates with the master and chunkservers to read or write data on <code>behalf</code> of the application. Clients <code>interact</code> with the master for metadata operations, but all <code>data-bearing</code> communication goes directly to the chunkservers. We do not provide the POSIX API and therefore need not hookinto the Linux vnode layer.</p>
<div class="note info">
            <p>GFS中链接到应用程序的client实现了文件系统API,和master/chunkserver进行通信，代替应用来读取和写入数据。client和master通信来进行元数据操作，但是承载的数据由client和chunkserver直接传输。我们没有提供POSIX API接口，因此client代码不需要嵌入到linux的vnode层。</p>
          </div>

<p>Neither the client nor the chunkserver caches file data. Client caches offer little <code>benefit</code> because most applications stream through huge files or have working sets too large to be cached. Not having them simplifies the client and the overall system by <code>eliminating</code> cache <code>coherence</code> issues. (Clients do cache metadata, however.) Chunkservers need not cache file data because chunks are stored as local files and so Linux’s buffer cache already keeps frequently accessed data in memory.</p>
<div class="note info">
            <p>clinet和chunkserver都不缓存文件数据。client缓存作用很小，因为大多数用于都是通过大文件进行流式存储或者数据集太大根本就无法缓存。没有缓存让client和整个系统变得简单，因为消除了缓存的一致性问题(但实际上client会缓存元数据)。chunkservers不需要缓存文件数据因为chunks是存储在磁盘的本地文件，而linux的buffer cache层已经缓存了频繁访问的数据在内存。</p>
          </div>

<hr>
<h3 id="2-4-Single-Master"><a href="#2-4-Single-Master" class="headerlink" title="2.4 Single Master"></a>2.4 Single Master</h3><p>Having a single master vastly simplifies our design and enables the master to make <code>sophisticated</code> chunk placement and replication decisions using global knowledge. However, we must minimize its <code>involvement</code> in reads and writes so that it does not become a <code>bottleneck</code>. Clients never read and write file data through the master. Instead, a client asks the master which chunkservers it should contact. It caches this information for a limited time and interacts with the<br>chunkservers directly for many <code>subsequent</code> operations. </p>
<div class="note info">
            <p>只有一个master极大的简化了我们的设计，也使得master可以根据掌握的全局信息来决定chunk和副本的位置。但是，必须最小化master对于读和写的参与以避免master成为瓶颈。clients不会从master直接读取文件数据。而是向master询问它应该和哪一个chunkserver进行联系。client会缓存这些元数据的信息在有限的时间内，然后直接和相应的chunkservers进行通信，进行相应的操作。</p>
          </div>

<p>Let us explain the interactions for a simple read with reference to Figure 1. First, using the fixed chunksize, the client translates the file name and byte offset specified by the application into a chunk index within the file. Then, it sends the master a request containing the file name and chunk index. The master replies with the <code>corresponding</code> chunk handle and locations of the replicas. The client caches this information using the file name and chunkindex as the key.</p>
<div class="note info">
            <p>让我们参考图1解释下一次读流程的交互过程。首先，通过固定的chanksize,客户端将应用指定的文件名和字节偏移转换为chunk index.然后将文件名和chunk index发给Master。master回复chunk的handle和位置信息给客户端。客户端将这些信息缓存下来，key是文件名和chunk index.</p>
          </div>

<p>The client then sends a request to one of the replicas, most likely the closest one. The request specifies the chunk handle and a byte range within that chunk. Further reads of the same chunk require no more client-master interaction until the cached information expires or the file is reopened. In fact, the client typically asks for multiple chunks in the same request and the master can also include the information for chunks immediately following those requested. This extra information <code>sidesteps</code> several future client-master interactions at practically no extra cost.</p>
<div class="note info">
            <p>然后客户端发送请求给其中一个副本，最可能是离得最近的那个。请求指定了chunk的句柄和chunk内的字节范围。在客户端缓存失效或者文件被reopen之前，请求相同的chunk，客户端都不再需要和master进行交互。事实上，客户端通常一次请求多个chunks, master也会在请求到来后携带多个chunks的信息给客户端。这些额外的信息减少了以后客户端和master之间的交互，并且没有额外的代价。</p>
          </div>

<hr>
<h3 id="2-5-Chunk-Size"><a href="#2-5-Chunk-Size" class="headerlink" title="2.5 Chunk Size"></a>2.5 Chunk Size</h3><p>Chunksize is one of the key design parameters. We have chosen 64 MB, which is much larger than typical file system blocksizes. Each chunk replica is stored as a <code>plain</code> Linux file on a chunkserver and is extended only as needed. Lazy space allocation avoids wasting space due to internal <code>fragmentation</code>, perhaps the greatest objection against such a large chunksize. </p>
<div class="note info">
            <p>chunksize是一个关键的设计参数。我们选择了比一般的文件系统块大得多的64M.每个chunk的副本以普通linux文件的方式存储在chunkserver,只有在需要的时候才扩展。这种惰性空间分配避免了内部碎片造成的空间浪费，这些碎片最大可能有一个chunksize那么大(?这里英文不是很理解)。</p>
          </div>

<p>A large chunksize offers several important <code>advantages</code>. First, it reduces clients’ need to interact with the master because reads and writes on the same chunk require only one initial request to the master for chunklocation information. The reduction is especially <code>significant</code> for our workloads because applications mostly read and write large files sequentially. Even for small random reads, the client can comfortably cache all the chunklocation information for a multi-TB working set. Second, since on a large chunk, a client is more likely to perform many operations on a given chunk, it can reduce network <code>overhead</code> by keeping a <code>persis-tent</code> TCP connection to the chunkserver over an extended <code>period of</code> time. Third, it reduces the size of the metadata stored on the master. This allows us to keep the metadata in memory, which in turn brings other advantages that we will discuss in Section 2.6.1.</p>
<div class="note info">
            <p>大的chunksize有几个重要的优点.首先，它减少了客户端和Master交互的需求，因为一个chunk上的读和写只需要客户端和master之间一次初始化请求，拿到chunk的位置信息就行了。也能减少我们的工作负载，因为应用几乎都是顺序的读写大文件，也因此客户端可以在一个指定的chunk执行更多的操作，通过和chunkserver保持tcp长连接，也能减少网络负载。第三，可以减少master存储的元数据。这使得master可以加个元数据缓存在内存中，并带来其他的优先，具体我们将在2.6.1节再进行讨论。</p>
          </div>

<p>On the other hand, a large chunksize, even with lazy space allocation, has its disadvantages. A small file consists of a small number of chunks, perhaps just one. The chunkservers storing those chunks may become <code>hot spots</code> if many clients are accessing the same file. In practice, hot spots have not been a major issue because our applications mostly read large multi-chunkfiles sequentially.</p>
<div class="note info">
            <p>另一方面，大的chunk size,即使是惰性空间分配，也有它的缺点。一个小的文件由少量的chunks组成，也可能只有一个chunk.如果许多客户端都访问相同的文件，chunkserver存储的这些chunks就可能成为热点数据。实际上，热点并不是主要的问题，因为应用程序基本上都是顺序访问大的多chunks组成的文件。</p>
          </div>

<p>However, hot spots did develop when GFS was first used by a batch-queue system: an executable was written to GFS as a single-chunkfile and then started on hundreds of machines at the same time. The few chunkservers storing this executable were overloaded by hundreds of <code>simultaneous</code> requests. We fixed this problem by storing such executables with a higher replication factor and by making the batchqueue system <code>stagger</code> application start times. A <code>potential</code> <code>long-term</code> solution is to allow clients to read data from other clients in such situations.</p>
<div class="note info">
            <p>然而，热点数据被批队列系统第一次使用的时候出现了：一个单chunk的可执行文件被写入GFS,然后在数百台机器上同时执行。存储这个可执行文件的几个chunkservers被同一时间收到的数百条请求搞过载了。我们已经解决了这个问题，通过给这个可执行文件更高的拷贝因子并且让批队列系统错开启动时间。一个潜在的长期的解决方案是允许客户端在这种场景下可以从其他的客户端读取数据。</p>
          </div>

<hr>
<h3 id="2-6-Metadata"><a href="#2-6-Metadata" class="headerlink" title="2.6 Metadata"></a>2.6 Metadata</h3><p>The master stores three major types of metadata: the file and chunk namespaces, the mapping from files to chunks, and the locations of each chunk’s replicas. All metadata is kept in the master’s memory. The first two types (namespaces and file-to-chunkmapping) are also kept <code>persistent</code> by logging <code>mutations</code> to an operation log stored on the master’s local disk and replicated on remote machines. Using a log allows us to update the master state simply, reliably, and without risking <code>inconsistencies</code> in the event of a master crash. The master does not store chunk location information persistently. Instead, it asks each chunkserver about its chunks at master startup and whenever a chunkserver joins the cluster.</p>
<div class="note info">
            <p>master存储3种主要的元数据类型：文件和chunk的命名空间，文件到chunks的映射关系，每个chunk的副本的位置。所有的元数据在master中缓存。前两种(文件和chunk的命名空间，文件到chunks的映射关系)的变化信息也被记录到保存在master本地磁盘的操作日志中，日志也会备份在其他机器上。使用日志让我们可以简单的更新master的状态，变得可靠，不用冒master奔溃引起的不一致的风险。master也不是固定的存储这些元数据，master启动的时候会取询问每一个chunkserver他们的chunks的信息，并且有新的chunkserver加入的时候也会去询问。</p>
          </div>

<hr>
<h4 id="2-6-1-In-Memory-Data-Structures"><a href="#2-6-1-In-Memory-Data-Structures" class="headerlink" title="2.6.1 In-Memory Data Structures"></a>2.6.1 In-Memory Data Structures</h4><p>Since metadata is stored in memory, master operations are fast. Furthermore, it is easy and efficient for the master to <code>periodically</code> scan through its entire state in the background. This periodic scanning is used to implement chunk garbage collection, re-replication in the presence of chunkserver failures, and chunk <code>migration</code> to balance load and diskspace usage across chunkservers. Sections 4.3 and 4.4 will discuss these activities further.</p>
<div class="note info">
            <p>因为元数据存储在内存中，所以master的操作很快。此外，这使得master在后台扫描所有的状态变得简单有效。持续的扫描是为了进行chunk的垃圾回收，chunkserver故障时的重新复制，以及为了平衡负载和磁盘使用情况在chunkservers间进行的chunk迁移。第4.3和4.4节将更讨论这些活动。</p>
          </div>

<p>One <code>potential</code> concern for this memory-only <code>approach</code> is that the number of chunks and <code>hence</code> the capacity of the whole system is limited by how much memory the master has. This is not a serious limitation in practice. The master maintains less than 64 bytes of metadata for each 64 MB chunk. Most chunks are full because most files contain many chunks, only the last of which may be partially filled. Similarly, the file namespace data typically requires less then 64 bytes per file because it stores file names <code>compactly</code> using prefix <code>compression</code>.</p>
<div class="note info">
            <p>对于这种只使用内存保存的方法有一个潜在的问题，就是chunks的数量，以及整个系统的容量受到master的内存大小的限制。但实际上这不是严重的限制。每个64M大小的块在master中对应的元数据大小少于64字节，因为多数文件都是包含多个块的，只有最后的块可能是部分填充的。并且，master中存储的单个命名空间数据也是少于64字节的，因为文件名使用前缀压缩算法保存。</p>
          </div>

<p>If necessary to support even larger file systems, the cost of adding extra memory to the master is a small price to pay for the simplicity, reliability, performance, and flexibility we gain by storing the metadata in memory.</p>
<div class="note info">
            <p>如果要支持更大的文件系统，给master增加更多内存的代价，远小于存储到内存中带来的易用性，可靠性，高性能，可维护性带来的好处。我们将这些元数据保存在内存中而获益。</p>
          </div>

<hr>
<h4 id="2-6-2-Chunk-Locations"><a href="#2-6-2-Chunk-Locations" class="headerlink" title="2.6.2 Chunk Locations"></a>2.6.2 Chunk Locations</h4><p>The master does not keep a persistent record of which chunkservers have a replica of a given chunk. It simply polls chunkservers for that information at startup. The master can keep itself up-to-date <code>thereafter</code> because it controls all chunk placement and monitors chunkserver status with <code>regular</code> HeartBeat messages.</p>
<div class="note info">
            <p>master并不会持久性的保存这些记录(一个指定的chunk的拷贝在哪些chunkservers上)。master在启动时轮训所以的chunservers来获取这些信息。master控制所有chunk的位置并且通过定时的心跳包来监控chunkserver的状态，所以master存储的信息总是最新的。</p>
          </div>

<p>We initially attempted to keep chunk location information persistently at the master, but we decided that it was much simpler to request the data from chunkservers at startup, and periodically thereafter. This <code>eliminated</code> the problem of keeping the master and chunkservers in sync as chunkservers join and leave the cluster, change names, fail, restart, and so on. In a cluster with hundreds of servers, these events happen all too often.</p>
<div class="note info">
            <p>我们一开始尝试在master中持久性的保存chunk的位置信息，但是我们发现master在启动以及启动后定期的向chunkserver请求这些数据会更加简单。这也解决了master和chunkserver保持同步的问题，有新加入的chunkserver，有退出的chunkserver,chunkserver的重命名，故障，重启，等等。在一个有数百台机器的集群中，这是经常发生的。</p>
          </div>

<p>Another way to understand this design decision is to realize that a chunkserver has the final word over what chunks it does or does not have on its own disks. There is no point in trying to maintain a consistent view of this information on the master because errors on a chunkserver may cause chunks to <code>vanish</code> <code>spontaneously</code> (e.g., a disk may go bad and be disabled) or an operator may rename a chunkserver.</p>
<div class="note info">
            <p>另一种理解这种设计的方式是意识到chunkserver对chunks要不要保存在自己的磁盘中有最终的决定权。持久性的保存这些信息在master中没有意义，因为一些错误可能导致部分chunks消失(比如磁盘故障或者不可用)或者有操作可能重新命名了chunkserver.</p>
          </div>

<hr>
<h4 id="2-6-3-Operation-Log"><a href="#2-6-3-Operation-Log" class="headerlink" title="2.6.3 Operation Log"></a>2.6.3 Operation Log</h4><p>The operation log contains a historical record of <code>critical</code> metadata changes. It is <code>central</code> to GFS. Not only is it the only persistent record of metadata, but it also serves as a logical time line that defines the order of concurrent operations. Files and chunks, as well as their versions (see Section 4.5), are all uniquely and <code>eternally</code> identified by the logical times at which they were created.</p>
<div class="note info">
            <p>操作日志保留了关键元数据变更的历史记录。这是GFS的核心。不仅仅因为操作日志是唯一持久化保存的元数据记录，也因为它记录了并发操作的逻辑时间线。对于文件，chunks,以及它们的版本(见4.5节)，都是在他们创建的时候通过逻辑时间唯一且永久的定义的。</p>
          </div>

<p>Since the operation log is critical, we must store it reliably and not make changes <code>visible</code> to clients until metadata changes are made persistent. Otherwise, we effectively lose the whole file system or recent client operations even if the chunks themselves survive. Therefore, we replicate it on multiple remote machines and respond to a client operation only after flushing the corresponding log record to disk both locally and remotely. The master batches several log<br>records together before flushing there by reducing the <code>impact</code> of flushing and replication on overall system throughput.</p>
<div class="note info">
            <p>因为操作日志十分重要，所以我们必须可靠的对齐进行存储，直到元数据持久化之后再将变化对客户端可见。否则，我们可能会丢失整个文件系统或最近的客户端操作，即使chunkserver还是运行的。因此，我们再其他机器上对元数据进行备份，仅当数据在本地和其他机器上落盘后才响应给客户端。master在刷盘前会批处理一些日志记录来减少刷盘拷贝对于整个系统吞吐量的影响。</p>
          </div>

<p>The master recovers its file system state by replaying the operation log. To minimize startup time, we must keep the log small. The master checkpoints its state whenever the log grows beyond a certain size so that it can recover by loading the latest checkpoint from local disk and replaying only the limited number of log records after that. The checkpoint is in a compact B-tree like form that can be directly mapped into memory and used for namespace lookup without extra parsing. This <code>further</code> speeds up recovery and improves availability.</p>
<div class="note info">
            <p>master通过重放操作日志可以恢复自身的文件系统。为了最小化启动时间，我们必须让日志比较小。当日志增长到超过一个固定的大小master会检查自身状态，为了实现从磁盘加载最近的检查点的时候只重放检查点后的有限的记录。检查点保存在类似B-tree的结构，可以直接映射到内存用于命名空间的查找而不需要额外的解析。这进一步加快了恢复速度并提高了可用性。</p>
          </div>

<p>Because building a checkpoint can take a while, the master’s internal state is structured in such a way that a new checkpoint can be created without delaying incoming mutations. The master switches to a new log file and creates the new checkpoint in a separate thread. The new checkpoint includes all mutations before the switch. It can be created in a minute <code>or so</code> for a cluster with a few million files. When completed, it is written to diskboth locally and remotely.</p>
<div class="note info">
            <p>因为建立一个检查点需要一些时间，所以master内部状态的结构化是以这种方式：一个新的检查点被创建，没有延迟处理传入的变化。master切换到一个新的日志文件然后在一个分离的线程中创建新的检查点。新的检查点包含了切换前的所有变化。对于几百万的文件可以在一分钟左右创建完成。完成的时候，已经同时写入了本地和其他机器上的磁盘。</p>
          </div>

<p>Recovery needs only the latest complete checkpoint and <code>subsequent</code> log files. Older checkpoints and log files can be freely deleted, though we keep a few around to guard against <code>catastrophes</code>. A failure during checkpointing does not affect correctness because the recovery code detects and skips incomplete checkpoints.</p>
<div class="note info">
            <p>恢复只需要最近的完成的检查点和其后的日志文件。老的检查点和日志文件可以被删除，即使我们会保存一些来保证容灾的处理。创建检查点期间发生的故障并不影响正确性，因为恢复的代码会检查并跳过未完成的检查点。</p>
          </div>

<hr>
<h3 id="2-7-Consistency-Model"><a href="#2-7-Consistency-Model" class="headerlink" title="2.7 Consistency Model"></a>2.7 Consistency Model</h3><p>GFS has a relaxed consistency model that supports our highly distributed applications well but remains <code>relatively</code> simple and efficient to implement. We now discuss GFS’s guarantees and what they mean to applications. We also highlight how GFS maintains these guarantees but leave the details to other parts of the paper.</p>
<div class="note info">
            <p>GFS有相对宽松的一致性模型，能够很好的支持我们的高分布式的应用且实现起来相对的简单和有效。我们现在讨论GFS的一致性保证，以及其对于应用程序的意义。我们也会重点讨论GFS如何提供一致性保证但是将细节留在其他部分讨论。</p>
          </div>

<hr>
<h4 id="2-7-1-Guarantees-by-GFS"><a href="#2-7-1-Guarantees-by-GFS" class="headerlink" title="2.7.1 Guarantees by GFS"></a>2.7.1 Guarantees by GFS</h4><p>File namespace mutations (e.g., file creation) are atomic. They are handled <code>exclusively</code> by the master: namespace locking guarantees atomicity and correctness (Section 4.1); the master’s operation log defines a global total order of these operations (Section 2.6.3).</p>
<div class="note info">
            <p>文件命名空间的变化(比如文件创建)是原子的。这些只由master来处理：命名空间锁保证了原子性和正确性(4.1节)；master的操作日志定义了全局的所有这些操作的顺序(2.6.3)。</p>
          </div>

<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/Snipaste_2021-02-11_02-20-36.jpg"></p>
<p>The state of a file region after a data mutation depends on the type of mutation, whether it succeeds or fails, and whether there are concurrent mutations. Table 1 summarizes the result. A file region is consistent if all clients will always see the same data, <code>regardless</code> of which replicas they read from. A region is defined after a file data mutation if it is consistent and clients will see what the mutation writes in its <code>entirety</code>. When a mutation succeeds without <code>interference</code> from concurrent writers, the affected region is defined (and by <code>implication</code> consistent): all clients will always see what the mutation has written. Concurrent successful mutations leave the region undefined but consistent: all clients see the same data, but it may not reflect what any one mutation has written. Typically, it consists of <code>mingled</code> <code>fragments</code> from multiple mutations. A failed mutation makes the region inconsistent (hence also undefined): different clients may see different data at different times. We describe below how our applications can distinguish defined regions from undefined regions. The applications do not need to further distinguish between different kinds of undefined regions.</p>
<div class="note info">
            <p>文件区域在数据变化后的状态取决于变化的类型，而不管是成功或失败，或者是不是并行的变更。表1概述了这种结果。如果所有的客户端都总是能看到相同的数据，不管它读取的是哪个副本,那么这个文件区域就是一致性的。如果它是一致性的并且客户端总是能读取所有变化写入的数据，那么区域A在文件变化后是已定义的。当一个变更在没有并发写干扰下成功执行，受影响的区域是已定义的(也是含义一致的):所有客户端都总能看到写入的变更。并行的成功变更导致区域是未定义但一致性的：所有客户端看到相同的数据，但是看不出是哪一个写入的变更。通常，由多个变更的碎片混杂在一起组成。一个失败的变更会导致区域成为非一致性(也是未定义的)：不同的客户端在不同的时间可能会看到不同的数据。我们在下面描述我们的应用程序如何区别已定义德和未定义的区域。程序并不需要更多的区分不同种类的未定义的区域。</p>
          </div>

<p>Data mutations may be writes or record appends. A write causes data to be written at an application-specified file offset. A record append causes data (the “record”) to be appended atomically at least once even in the presence of concurrent mutations, but at an offset of GFS’s choosing (Section 3.3). (In <code>contrast</code>, a “regular” append is <code>merely</code> a write at an offset that the client believes to be the current end of file.) The offset is returned to the client and marks the beginning of a defined region that contains the record. In addition, GFS may insert padding or record <code>duplicates</code> in between. They <code>occupy</code> regions considered to be inconsistent and are typically <code>dwarfed</code> by the amount of user data.</p>
<div class="note info">
            <p>写入和追加记录会引起数据变化。写入是将数据写入文件中应用指定的偏移位置。记录追加将数据原子性的追加至少一次，即使是在并行的情况下，但是是追加的位置是GFS选择的(3.3节)。(而常规的追加写是仅仅写到客户端人为的当前文件的末尾) 偏移位置会返回给客户端然后标记这块记录所在的已定义区域的起始位置。除此之外，GFS可能会插入padding或者重复的记录数据。他们会占据被认为是不一致的区域，这通常比用户数据小得多。</p>
          </div>

<p>After a sequence of successful mutations, the mutated file region is guaranteed to be defined and contain the data written by the last mutation. GFS achieves this by (a) applying mutations to a chunk in the same order on all its replicas (Section 3.1), and (b) using chunkversion numbers to detect any replica that has become <code>stale</code> because it has missed mutations while its chunkserver was down (Section 4.5). Stale replicas will never be <code>involved</code> in a mutation or given to clients asking the master for chunk locations. They are garbage collected at the earliest opportunity.</p>
<div class="note info">
            <p>在一系列变更之后，变化的文件区域可以保证是已定义的，并且包含最后一次变更写入的数据。GFS是通过这两点来实现的：a 按顺序将对chunk的变更应用到chunk的所有副本(3.1节)，b 使用chunk版本号来检测因为chunkserver挂掉而丢失变更从而已经过期的副本。过期的副本不会算入变更，在客户端向master请求chunk位置的时候也会过滤掉已经过期的副本。这些过期的副本会被尽可能早的进行垃圾回收。</p>
          </div>

<p>Since clients cache chunk locations, they may read from a stale replica before that information is refreshed. This window is limited by the cache entry’s timeout and the next open of the file, which <code>purges</code> from the cache all chunk information for that file. Moreover, as most of our files are append-only, a stale replica usually returns a <code>premature</code> end of chunk rather than outdated data. When a reader retries and contacts the master, it will immediately get current chunk locations.</p>
<div class="note info">
            <p>因为客户端缓存了chunk的位置信息，在缓存数据刷新前可能会从已经过期的副本上读取。这种情况会受到一些约束，缓存项超过超期时间或者文件被重新打开，都会清除掉对应文件的所有缓存位置信息。并且，大多数的文件都是追加写入的，已过期的副本通常会返回早期的chunk的尾部信息而不是已经过期的数据。当reader重试然后和master进行沟通，将会立刻获得最新的chunk的位置信息。</p>
          </div>

<p>Long after a successful mutation, <code>component</code> failures can of course still <code>corrupt</code> or destroy data. GFS identifies failed chunkservers by regular handshakes between master and all chunkservers and detects data corruption by checksumming (Section 5.2). Once a problem <code>surfaces</code>, the data is <code>restored</code> from valid replicas as soon as possible (Section 4.3). A chunk is lost <code>irreversibly</code> only if all its replicas are lost before GFS can react, typically within minutes. Even in this case, it becomes unavailable, not corrupted: applications receive clear errors rather than corrupt data.</p>
<div class="note info">
            <p>成功变更很久之后，组件故障也还是可能损坏和破坏数据.GFS通过master和所有chunkserver进行定期的握手来检测故障的chunkserver,并通过校验和检查数据是否已损坏。一单问题发生，会尽快的从有效的副本恢复。chunk的丢失不可逆转的情况只发生在，GFS反应前所有的chunk的副本都丢失了，反应时间通常在几分钟内。即使在这种情况下，数据是不可用的，而不是已损坏的：应用程序可以接受到明确的错误信息而不是收到已损坏的数据。</p>
          </div>

<hr>
<h4 id="2-7-2-Implications-for-Applications"><a href="#2-7-2-Implications-for-Applications" class="headerlink" title="2.7.2 Implications for Applications"></a>2.7.2 Implications for Applications</h4><p>GFS applications can <code>accommodate</code> the relaxed consistency model with a few simple <code>techniques</code> already needed for other purposes: relying on appends rather than overwrites, checkpointing, and writing self-validating, self-identifying records.</p>
<div class="note info">
            <p>GFS应用程序可以通过一些其他的简单技术来适应这种宽松的一致性模型：追加写而不是覆盖写，检查点，写入自验证，自标识的记录。</p>
          </div>

<p>Practically all our applications mutate files by appending rather than overwriting. In one typical use, a writer generates a file from beginning to end. It atomically renames the file to a <code>permanent</code> name after writing all the data, or <code>periodically</code> checkpoints how much has been successfully written. Checkpoints may also include application-level checksums. Readers verify and process only the file region up to the last checkpoint, which is known to be in the defined<br>state. Regardless of consistency and concurrency issues, this <code>approach</code> has served us well. Appending is far more efficient and more <code>resilient</code> to application failures than random writes. Checkpointing allows writers to restart <code>incrementally</code> and keeps readers from processing successfully written file data that is still incomplete from the application’s <code>perspective</code>.</p>
<div class="note info">
            <p>实际上我们的应用程序修改文件都是通过追加写而不是随机写。一种典型的情况是，一个write从头到尾写一个文件。所有数据写完的时候会原子性的重命名文件，或者定期的检查有多少成功写入了。检查点可能包含应用级别的校验和。reader校验并处理到上一次检查点之间文件范围的数据，这些数据都是已定义的状态。忽视一致性和并行的问题，这种方式工作的很好。追加写相比于随机写，要非常的高效并且对于应用故障也更有弹性。检查点允许writer可以渐进的重新启动，并阻止reader读取已经写入的数据，这些数据在应用角度来看是不完整的。</p>
          </div>

<p>In the other typical use, many writers concurrently append to a file for merged results or as a producer-consumer queue. Record append’s append-at-least-once <code>semantics</code> preserves each writer’s output. Readers deal with the <code>occasional</code> padding and duplicates as follows. Each record prepared by the writer contains extra information like checksums so that its validity can be verified. A reader can identify and discard extra padding and record <code>fragments</code> using the checksums. If it cannot tolerate the occasional duplicates (e.g., if they would trigger <code>non-idempotent</code> operations), it can filter them out using unique identifiers in the records, which are often needed anyway to name corresponding application entities such as web documents. These functionalities for record I/O (except duplicate <code>removal</code>) are in library code shared by our applications and applicable to other file interface implementations at Google. With that, the same sequence of records, plus rare duplicates, is always delivered to the record reader.</p>
<div class="note info">
            <p>另外一种典型的情况是，多个writers并行的追加写用于合并文件或者用于生产者消费者队列。记录追加写的”至少追加写一次“语义保留了每一个write的输出。reader处理偶尔的padding和重复。writer写记录之前都会加入额外的信息(比如校验和)确保记录可以被验证有效性。reader可以通过校验和识别并忽略额外的填充和记录碎片信息。如果不能容忍偶尔的重复数据(比如可能触发了非幂等的操作)，也可以通过唯一标识来过滤记录，这通常需要命名相应的程序项，比如web文档。这些记录IO(不包含重复的删除)的功能都在我们程序共享的库代码中，并且对于谷歌已实现的其他文件接口也是适用的。这样一来，相同的记录顺序，加上罕见的重复，总是会呈现给记录的reader.</p>
          </div>

<hr>
<h2 id="3-SYSTEM-INTERACTIONS"><a href="#3-SYSTEM-INTERACTIONS" class="headerlink" title="3. SYSTEM INTERACTIONS"></a>3. SYSTEM INTERACTIONS</h2><p>We designed the system to minimize the master’s involvement in all operations. With that background, we now describe how the client, master, and chunkservers interact to implement data mutations, atomic record append, and snapshot.</p>
<div class="note info">
            <p>我们设计这个系统是要最小化master和各种操作的相关性。在这个背景之下，我们现在描述client,master,chunkserver之间如何交互以实现数据的变更，原子记录的写入，和快照。</p>
          </div>

<hr>
<h3 id="3-1-Leases-and-Mutation-Order"><a href="#3-1-Leases-and-Mutation-Order" class="headerlink" title="3.1 Leases and Mutation Order"></a>3.1 Leases and Mutation Order</h3><p>A mutation is an operation that changes the contents or metadata of a chunk such as a write or an append operation. Each mutation is performed at all the chunk’s replicas. We use <code>leases</code> to maintain a consistent mutation order across replicas. The master grants a chunk lease to one of the replicas, which we call the primary. The primary picks a serial order for all mutations to the chunk. All replicas follow this order when applying mutations. Thus, the global mutation order is defined first by the lease grant order chosen by the master, and within a lease by the serial numbers assigned by the primary.</p>
<div class="note info">
            <p>变更指的是文本或者元信息的chunk被修改的操作，例如覆盖写或者追加写。每一个变更都在chunk的所有副本上生效。我们使用租约来保持多个副本之间变更的一致性。master分配一个租约给其中我们称之为primary的副本。primaru会为该chunk的所有变更选择一个顺序。应用变更的时候所有副本都基于这个顺序。因此，master一开始会分配租约分配顺序来定义全局的变更顺序，每一个租约内部的顺序由parimary分配</p>
          </div>

<p>The lease <code>mechanism</code> is designed to minimize management overhead at the master. A lease has an initial timeout of 60 seconds. However, as long as the chunk is being mutated, the primary can request and typically receive extensions from the master <code>indefinitely</code>. These extension requests and grants are <code>piggybacked</code> on the HeartBeat messages regularly exchanged between the master and all chunkservers. The master may sometimes try to <code>revoke</code> a lease before it expires (e.g., when the master wants to disable mutations on a file that is being renamed). Even if the master loses communication with a primary, it can safely grant a new<br>lease to another replica after the old lease expires.</p>
<div class="note info">
            <p>租约机制旨在最小化master的管理开销。每个租约有一个初始化的60s的超时时间。但是只要chunk正在变更，primary就可以向master申请无限期的延长租约时间，通常还会收到一些扩展的信息。扩展信息和租约分配都是带在master和所有的chunkserver之间定期的心跳包里面。master有时候可能会尝试在租约过期之前进行撤销(例如，master想要对一个重命名的文件禁用变更)。即使master丢失了primary的信息，它也可以在这个primary过期之后，分配一个新的租约给另一个副本。</p>
          </div>

<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/Snipaste_2021-02-11_02-20-55.jpg"></p>
<p>In Figure 2, we <code>illustrate</code> this process by following the control flow of a write through these numbered steps.</p>
<div class="note info">
            <p>在图2中，我们按照下面编号的步骤说明一个写控制流的过程。</p>
          </div>

<ol>
<li>The client asks the master which chunkserver holds the current lease for the chunk and the locations of the other replicas. If no one has a lease, the master<br>grants one to a replica it chooses (not shown).</li>
</ol>
<div class="note info">
            <p>1 客户端向master询问哪一个chunkserver有chunk的当前租约，以及其他副本所在的位置。如果没有chunkserver拥有租约，master会选择一个副本分配租约。(这里没有展示)</p>
          </div>

<ol start="2">
<li>The master replies with the identity of the primary and the locations of the other (secondary) replicas. The client caches this data for future mutations. It needs to contact the master again only when the primary becomes unreachable or replies that it no longer holds a lease.</li>
</ol>
<div class="note info">
            <p>2 master回复primary的标识和其他副本的位置。客户端为以后的变更缓存这个数据。只有当primary变得不可访问或者primary回复说它不再拥有租约了，客户端才需要再次和master联系。</p>
          </div>

<ol start="3">
<li>The client pushes the data to all the replicas. A client can do so in any order. Each chunkserver will store the data in an internal LRU buffer cache until the data is used or aged out. By <code>decoupling</code> the data flow from the control flow, we can improve performance by scheduling the expensive data flow based on the <code>network topology</code> regardless of which chunkserver is the primary. Section 3.2 discusses this further.</li>
</ol>
<div class="note info">
            <p>3 客户端推送数据给所有副本。客户端可以按照任意顺序推送。chunkserver会将数据存储在LRU的缓存中，知道数据被数据或者过期。通过对数据流和控制流进行解耦，我们提高在网络拓扑上调度数据的性能，而不用管primary在哪一个chunkserver上。3.2节将讨论更多</p>
          </div>

<ol start="4">
<li>Once all the replicas have <code>acknowledged</code> receiving the data, the client sends a write request to the primary. The request identifies the data pushed earlier to all of the replicas. The primary assigns <code>consecutive</code> serial numbers to all the mutations it receives, possibly from multiple clients, which provides the necessary serialization. It applies the mutation to its own local state in serial number order.</li>
</ol>
<div class="note info">
            <p>一旦所有的副本都确认收到了数据，客户端会发送一个写请求给primary.请求中标识了之前推送给所有副本的数据。primary为它接受的可能来自多个客户端的所有变更，分配连续的序列号，这提供了必要的序列化。primary会按照序列号的顺序应用变更到自己的本地状态。</p>
          </div>

<ol start="5">
<li>The primary forwards the write request to all secondary replicas. Each secondary replica applies mutations in the same serial number order assigned by the primary.</li>
</ol>
<div class="note info">
            <p>primary传递写请求给所有其他次要的的副本。每一个次要的副本按照primary分配的序列号的顺序应用变更。</p>
          </div>

<ol start="6">
<li>The secondaries all reply to the primary <code>indicating</code> that they have completed the operation.</li>
</ol>
<div class="note info">
            <p>所有次要的副本回复给primary表明自己已经完成了变更</p>
          </div>

<ol start="7">
<li>The primary replies to the client. Any errors encountered at any of the replicas are reported to the client. In case of errors, the write may have succeeded at the primary and an <code>arbitrary</code> subset of the secondary replicas. (If it had failed at the primary, it would not have been assigned a serial number and forwarded.) The client request is considered to have failed, and the modified region is left in an inconsistent state. Our client code handles such errors by retrying the failed mutation. It will make a few attempts at steps (3) through (7) before falling backto a retry from the beginning of the write.</li>
</ol>
<div class="note info">
            <p>7 primary回复client.任何副本发生任何错误都会报告给客户端。错误发生的时候，primary或者其他副本的一部分可能已经成功写入了。(如果primary失败了，它就不会分配序列号也不会传递写请求)。客户端请求被认为是处理失败的，修改的区域也变为了不一致的状态。我们的客户端通过对错误的变更进行重试来处理这种错误。在开始写返回到重试前，可能会在3-7阶段进行一些尝试。</p>
          </div>

<p>If a write by the application is large or <code>straddles</code> a chunk boundary, GFS client code breaks it down into multiple write operations. They all follow the control flow described above but may be <code>interleaved</code> with and overwritten by concurrent operations from other clients. Therefore, the shared file region may end up containing fragments from different clients, although the replicas will be <code>identical</code> because the <code>individual</code> operations are completed successfully in the same order on all replicas. This leaves the file region in consistent but undefined state as noted in Section 2.7.</p>
<div class="note info">
            <p>如果应用程序的写操作很大或者跨块边界，GFS客户端代码会将其拆分为多个写操作。他们都按照前面描述的控制流程执行，但可能会在来自多个客户端的并行操作的覆盖写之间交错。因此，共享的文件区域最终可能包含了来自不同客户端的片段，但是所有副本最终都是一致的，因为每个副本的操作都是按照相同的顺序成功完成的。这导致文件区域是一致性但未定义的状态，如2.7节所述</p>
          </div>

<hr>
<h2 id="3-2-Data-Flow"><a href="#3-2-Data-Flow" class="headerlink" title="3.2 Data Flow"></a>3.2 Data Flow</h2><p>We decouple the flow of data from the flow of control to use the network efficiently. While control flows from the client to the primary and then to all secondaries, data is pushed <code>linearly</code> along a carefully picked chain of chunkservers in a pipelined fashion. Our goals are to fully <code>utilize</code> each machine’s network bandwidth, avoid network <code>bottlenecks</code> and <code>high-latency</code> links, and minimize the latency to push through all the data.</p>
<div class="note info">
            <p>我们解耦了数据流和控制流，为了高效使用网络。当控制从客户端流向primary然后流向其他所有的副本，数据以流水线的方式沿着chunkservers之间选择的链路线性的推送。我们的目标是充分利用每天机器的网络带宽，避免网络瓶颈和高延迟的链接，以及最小化推送所有数据的延迟。</p>
          </div>

<p>To fully utilize each machine’s networkbandwidth, the data is pushed linearly along a chain of chunkservers rather than distributed in some other <code>topology</code> (e.g., tree). Thus, each machine’s full outbound bandwidth is used to transfer the data as fast as possible rather than divided among multiple <code>recipients</code>.</p>
<div class="note info">
            <p>为了充分利用每台机器的网络带宽，数据在chunkservers之间按链路线性推送而不是以其他的拓扑结构(例如tree)分布.因此，每台机器的所有出站带宽都被用来尽可能快的传输数据，而不会其中一些接受者分掉。</p>
          </div>

<p>To avoid network bottlenecks and high-latency links (e.g., <code>inter-switch</code> links are often both) as much as possible, each machine forwards the data to the “closest” machine in the networktopology that has not received it. Suppose the client is pushing data to chunkservers S1 through S4. It sends the data to the closest chunkserver, say S1. S1 forwards it to the closest chunkserver S2 through S4 closest to S1, say S2. Similarly, S2 forwards it to S3 or S4, whichever<br>is closer to S2, and so on. Our networktopology is simple enough that “distances” can be <code>accurately</code> <code>estimated</code> from IP addresses.</p>
<div class="note info">
            <p>为了尽可能的避免网络瓶颈和高延迟的链接(例如交换机通常两者都是)，每一台机器传输数据给还没有接收数据的在网络拓扑中离自己最近的机器。加入客户端推送数据从chunkserver的S1到S4.客户端发送数据给最近的chunkserver,比如s1,s1传输数据给s4到s1之间最近的s2.相似的，s2传输数据给s4-s2之间离s2最近的s3或者s4,以此类推。我们的网络拓扑足够简单，距离可以通过ip地址进行准确的估算。</p>
          </div>

<p>Finally, we minimize latency by pipelining the data transfer over TCP connections. Once a chunkserver receives some data, it starts forwarding immediately. Pipelining is <code>especially</code> helpful to us because we use a switched network with <code>full-duplex </code>links. Sending the data immediately does not reduce the receive rate. Without network <code>congestion</code>, the ideal <code>elapsed</code> time for transferring B bytes to R replicas is B/T + RL where T is the network <code>throughput</code> and L is latency to transfer bytes between two machines. Our network links are typically 100 Mbps (T), and L is far below 1 ms. Therefore, 1 MB can <code>ideally</code> be distributed in about 80 ms.</p>
<div class="note info">
            <p>最后，我们通过以流水线的方式传输数据在tcp传输数据中最小化延迟。一旦chunkserver受到一些数据，就会立即开始传输。流水线对我们特别有用，因为我们使用全双工的交换网络。立即发送数据不会影响接受速率。在没有网络拥塞的情况下，传输B字节到R个副本的理想时间是 B/T + RL,其中T是网络吞吐量，L是两台机器间传输数据的延迟。我们的网络连接通常是100Mbps(T), L远小于1ms.因此1Mb的数据理想情况下只需要80ms就可以分布式的传输完</p>
          </div>

<hr>
<h3 id="3-3-Atomic-Record-Appends"><a href="#3-3-Atomic-Record-Appends" class="headerlink" title="3.3 Atomic Record Appends"></a>3.3 Atomic Record Appends</h3><p>GFS provides an atomic append operation called record append. In a traditional write, the client specifies the offset at which data is to be written. Concurrent writes to the same region are not serializable: the region may end up containing data fragments from multiple clients. In a record append, however, the client specifies only the data. GFS appends it to the file at least once atomically (i.e., as one continuous sequence of bytes) at an offset of GFS’s choosing and returns that offset to the client. This is similar to writing to a file opened in O_APPEND mode in Unix without the race conditions when multiple writers do so concurrently.</p>
<div class="note info">
            <p>GFS提供了一个称为record append的追加写操作。传统的写入，客户端会给要写的文件指定一个偏移量。并行的写入同一区域不是串行的：被写区域最终可能包含了不同客户端的片段。然而对于record append,客户端只指定数据。GFS至少原子性的追加写一次(如一个连续的顺序流)在一个由GFS选择的偏移位置，然后返回偏移位置给客户端。这和unix中的O_APPEND方式很相似，当多个并行的写没有竞争情况的时候。</p>
          </div>

<p>Record append is heavily used by our distributed applications in which many clients on different machines append to the same file concurrently. Clients would need additional <code>complicated</code> and expensive synchronization, for example through a distributed lock manager, if they do so with traditional writes. In our workloads, such files often serve as multiple-producer/single-consumer queues or contain merged results from many different clients.</p>
<div class="note info">
            <p>record append在我们的分布式应用中广泛使用，这些应用里会有不同机器上的多个客户端并行的向同一个文件写入数据。如果使用传统的覆盖写，客户端会引入额外的复杂和昂贵的同步操作，比如通过分布式锁管理器。在我们的工作中，前面说的这些文件通常被用于多个生产者/单个消费者的队列或者用于保留来自多个不同客户端的合并结果。</p>
          </div>

<p>Record append is a kind of mutation and follows the control flow in Section 3.1 with only a little extra logic at the primary. The client pushes the data to all replicas of the last chunk of the file Then, it sends its request to the primary. The primary checks to see if appending the record to the current chunk would cause the chunk to <code>exceed</code> the maximum size (64 MB). If so, it pads the chunk to the maximum size, tells secondaries to do the same, and replies to<br>the client indicating that the operation should be retried on the next chunk. (Record append is <code>restricted</code> to be at most <code>one-fourth</code> of the maximum chunksize to keep worst case fragmentation at an acceptable level.) If the record <code>fits</code> within the maximum size, which is the common case, the primary appends the data to its replica, tells the secondaries to write the data at the <code>exact</code> offset where it has, and finally replies success to the client.</p>
<div class="note info">
            <p>record append是变更的一种，遵循3.1节的控制流，只是在primary中有一些额外的逻辑。客户端推送数据给直到最后一个chunk给予回复信息，然后客户端发送请求给primary. primary会检查追加写这些记录到当前的chunk是否会让chunk超过最大大小(64M).如果超过了，就将超过的信息写入新的chunk并填充到最大值，然后告诉所有次要的副本也这样做，然后回复客户端指示其需要在下一个chunk上进行重试。(record append被限制最多为chunksize最大值的1/4,来保证最坏情况下数据碎片仍在可接受的程度) 如果记录刚好在最大值内，这是最常见的情况，则primary会追加写数据到自己的回复，告诉所有其他次要的副本在同样的偏移位置写入，并最终回复成功响应给客户端。</p>
          </div>

<p>If a record append fails at any replica, the client retries the operation. As a result, replicas of the same chunk may contain different data possibly including duplicates of the same record in whole or in part. GFS does not guarantee that all replicas are bytewise <code>identical</code>. It only guarantees that the data is written at least once as an atomic unit. This <code>property</code> follows <code>readily</code> from the simple observation that for the operation to report success, the data must have been written at the same offset on all replicas of some chunk. Furthermore, after this, all replicas are at least as long as the end of record and therefore any future record will be assigned a higher offset or a different chunk even if a different replica later becomes the primary. In terms of our consistency guarantees, the regions in which successful record append operations have written their data are defined (hence consistent), whereas <code>intervening</code> regions are inconsistent (hence undefined). Our applications can deal with inconsistent regions as we discussed in Section 2.7.2.</p>
<div class="note info">
            <p>如果任何一个回复的record append失败了，客户端都会重试。最终，同一个chunk的多个回复可能包含了不同的数据，这些不同的数据可能包含了部分或者整个记录的重复数据。GFS不保证所有的副本每个字节都相同。GFS只保证数据被原子性的至少写入一次。这种属性可以从对于成功操作报告的观察简单的得出，数据必须在每个副本都写入相同的偏移位置。而且之后所有的副本都至少到达了记录的结尾因此以后的记录都将会被分配更大的偏移位置或者在不同的chunk上，即使primary变为了别的副本也是这样。在我们一致性保证下，record append成功写入数据的区域是已定义的(也是一致性的)，而介入其间的区域是非一致性的(也即未定义的)。我们的应用可以处理这种非一致性的区域，如2.7.2讨论的那样。</p>
          </div>

<hr>
<h3 id="3-4-Snapshot"><a href="#3-4-Snapshot" class="headerlink" title="3.4 Snapshot"></a>3.4 Snapshot</h3><p>The snapshot operation makes a copy of a file or a directory tree (the “source”) almost <code>instantaneously</code>, while minimizing any <code>interruptions</code> of <code>ongoing</code> mutations. Our users use it to quickly create branch copies of huge data sets (and often copies of those copies, <code>recursively</code>), or to checkpoint the current state before <code>experimenting</code> with changes that can later be committed or rolled back easily.</p>
<div class="note info">
            <p>快照可以瞬间创建文件或目录的拷贝，能够最小化对于进行中变更的影响。我们的用户能够使用快照快速的创建对于大数据集的拷贝分支(通常递归的对拷贝再进行拷贝)，或者在测试修改能否稍后提交或者回滚之前检查当前的状态。</p>
          </div>

<p>Like AFS [5], we use standard copy-on-write techniques to implement snapshots. When the master receives a snapshot request, it first revokes any <code>outstanding</code> leases on the chunks in the files it is about to snapshot. This ensures that any <code>subsequent</code> writes to these chunks will require an interaction with the master to find the lease holder. This will give the master an opportunity to create a new copy of the chunk first.</p>
<div class="note info">
            <p>和AFS一样，我们使用标椎写时拷贝技术来实现快照。当master接收到快照请求，它首先撤销快照涉及文件对应的chunks上未完成的租约。这样确保了随后的对这些chunks的写都将和master交互去获取租约持有者。这将给master一个机会可以闯将一个chunk的新的拷贝。</p>
          </div>

<p>After the leases have been revoked or have expired, the master logs the operation to disk. It then applies this log record to its in-memory state by duplicating the metadata for the source file or directory tree. The newly created snapshot files point to the same chunks as the source files.</p>
<div class="note info">
            <p>在租约被撤销或者过期之后，master记录操作日志到磁盘。通过复制源文件或目录树的元数据，master将日志记录应用到内存中状态。新创建的快照文件和源文件指向相同的chunks.</p>
          </div>

<p>The first time a client wants to write to a chunk C after the snapshot operation, it sends a request to the master to find the current lease holder. The master notices that the reference count for chunk C is greater than one. It defers replying to the client request and instead picks a new chunk handle C’. It then asks each chunkserver that has a current replica of C to create a new chunk called C’. By creating the new chunk on the same chunkservers as the original, we ensure that the data can be copied locally, not over the network(our disks are about three times as fast as our 100 Mb Ethernet links). From this point, request handling is no different from that for any chunk: the master grants one of the replic as a lease on the new chunkC’ and replies to the client, which can write the chunk normally, not knowing that it has just been created from an existing chunk.</p>
<div class="note info">
            <p>在快照之后客户端第一次想要对chunk c进行写入，会先发送请求给master来查找当前租约的持有者。master注意到chunk c的引用大于 1的话，会推迟回复给client响应，而是先选择一个新的chunk句柄 C’.然后master要求每一个chunk c的副本所在chunkserver都创建一个新的chunk c’.通过在和原来chunk c相同的chunkserver上创建新的chunk,我们可以确保数据是在本地进行拷贝的，而不经过网络(我们磁盘的读写速度是我们100M以太网的3倍)。基于这点，对于任何chunk的请求都是一样的：master对chunk c’的的一个副本分配租约然后回复给客户端，客户端可以正常的写入数据，而不知道写入的chunk其实是刚刚从原来的chunk新创建的。</p>
          </div>

<hr>
<h2 id="4-MASTER-OPERATION"><a href="#4-MASTER-OPERATION" class="headerlink" title="4. MASTER OPERATION"></a>4. MASTER OPERATION</h2><p>The master executes all namespace operations. In addition, it manages chunk replicas throughout the system: it makes placement decisions, creates new chunks and hence replicas, and <code>coordinates</code> various system-wide activities to keep chunks fully replicated, to balance load across all the chunkservers, and to <code>reclaim</code> unused storage. We now discuss each of these topics.</p>
<div class="note info">
            <p>master执行所有命名空间的操作。并且，它管理整个系统上chunk的副本：决定chunk的位置，创建新的chunk和副本，协调整个系统范围的各种活动来保证chunk的完整复制，通过chunkservers来做负载均衡，回收未使用的存储。现在我们分别来讨论这些主题</p>
          </div>

<hr>
<h3 id="4-1-Namespace-Management-and-Locking"><a href="#4-1-Namespace-Management-and-Locking" class="headerlink" title="4.1 Namespace Management and Locking"></a>4.1 Namespace Management and Locking</h3><p>Many master operations can take a long time: for example, a snapshot operation has to revoke chunkserver leases on all chunks covered by the snapshot. We do not want to delay other master operations while they are running. Therefore, we allow multiple operations to be active and use locks over regions of the namespace to ensure proper serialization.</p>
<div class="note info">
            <p>有许多的master操作都需要很长的处理时间：比如，一个快照操作需要撤销快照覆盖的所有chunks的租约。我们不想在快照执行的时候延迟其他的master操作。因此，我们允许多个master操作处于活动状态，通过命名空间锁来保证正确的顺序。</p>
          </div>

<p>Unlike many traditional file systems, GFS does not have a per-directory data structure that lists all the files in that directory. <code>Nor does</code> it support aliases for the same file or directory (i.e, hard or <code>symbolic</code> links in Unix terms). GFS logically represents its namespace as a lookup table mapping full pathnames to metadata. With prefix <code>compression</code>, this table can be efficiently represented in memory. Each node in the namespace tree (either an <code>absolute</code> file name or an absolute directory name) has an <code>associated</code> read-write lock.</p>
<div class="note info">
            <p>和许多传统的文件系统不同的是，GFS没有per-directory的数据结构来列出目录下所有的文件。它也不支持对于文件和目录的别称(想unix中的硬链接，软连接).GFS逻辑上将命名空间表示为所有路径名到元数据的查找表。通过前缀压缩，命名空间表可以高效的保存在内存中。每一个命名空间树的节点(绝对的文件名或者绝对的目录名)都有一个相关联的读写锁。</p>
          </div>

<p>Each master operation acquires a set of locks before it runs. Typically, if it involves /d1/d2/…/dn/leaf, it will acquire read-locks on the directory names /d1, /d1/d2, …, /d1/d2/…/dn, and either a read lockor a write lock on the full pathname /d1/d2/…/dn/leaf. Note that leaf may be a file or directory depending on the operation.</p>
<div class="note info">
            <p>每个master操作在运行前都需要一组锁。通常，包含/d1/d2/…/dn/leaf的情况,master会在名录名为d1, /d1/d2, … /d1/d2/…/dn的地方分别获取读锁，在完整路径名/d1/d2/…/dn/leaf获取一个读锁或写锁。记住叶子节点可能是文件或者目录，这取决于操作。</p>
          </div>

<p>We now <code>illustrate</code> how this locking <code>mechanism</code> can prevent a file /home/user/foo from being created while /home/user is being snapshotted to /save/user. The snapshot operation acquires read lock s on /home and /save, and write locks on /home/user and /save/user. The file creation acquires read locks on /home and /home/user, and a write lockon /home/user/foo. The two operations will be serialized properly because they try to <code>obtain</code> conflicting locks on /home/user. File creation does not require a write lock on the parent directory because there is no “directory”, or inode-like, data structure to be protected from modification.<br>The read lock on the name is <code>sufficient</code> to protect the parent directory from deletion.</p>
<div class="note info">
            <p>我们现在说明锁机制如何保护/home/user被快照到/save/user的时候，/home/user/foo不被创建。快照操作获取/home和/save的读锁，以及/home/user和/save/user的写锁。文件创建获取/hoem和/home/user的读锁，以及/home/user/foo的写锁。两个操作可以正确顺序的执行因为他们获取/home/user的锁会冲突。文件创建不需要获取父目录的写锁因为没有目录或者inode节点的数据结构需要保护。创建文件获取父目录的读锁就足够保护父目录不被删除了。</p>
          </div>

<p>One nice <code>property</code> of this locking <code>scheme</code> is that it allows concurrent mutations in the same directory. For example, multiple file creations can be executed concurrently in the same directory: each acquires a read lock on the directory name and a write lock on the file name. The read lock on the directory name suffices to prevent the directory from being deleted, renamed, or snapshotted. The write locks on file names serialize attempts to create a file with the same<br>name twice.</p>
<div class="note info">
            <p>锁方案的一个好处是可以允许对于相同目录的并行变更。比如，同一目录下多个文件创建操作可以并行处理：每个操作都获取目录名的读锁以及文件名的写锁。目录名的读锁足够保护目录不被删除，重命名，或者快照。文件名的写锁保证两次对一个文件的相同重命名是顺序执行的。</p>
          </div>

<p>Since the namespace can have many nodes, read-write lock objects are allocated lazily and deleted once they are not in use. Also, locks are acquired in a consistent total order to prevent deadlock: they are first ordered by level in the namespace tree and <code>lexicographically</code> within the same level.</p>
<div class="note info">
            <p>因为命名空间有很多节点，读写锁对象是懒分配并在不被使用的时候删除。而且锁是按一致性的顺序来获取的以防止死锁的发生：锁先按在命名空间树中的层级排序，然后在相同层级内按字段序排序。</p>
          </div>

<hr>
<h3 id="4-2-Replica-Placement"><a href="#4-2-Replica-Placement" class="headerlink" title="4.2 Replica Placement"></a>4.2 Replica Placement</h3><p>A GFS cluster is highly distributed at more levels than one. It typically has hundreds of chunkservers <code>spread across</code> many machine racks. These chunkservers <code>in turn</code> may be accessed from hundreds of clients from the same or different racks. Communication between two machines on different racks may cross one or more network switches. Additionally, bandwidth into or out of a rack may be less than the <code>aggregate</code> bandwidth of all the machines within the rack. Multi-level distribution presents a unique challenge to distribute data for <code>scalability</code>, reliability, and availability.</p>
<div class="note info">
            <p>GFS集群是多层级高分布式的。通常由分布在多个机架上的数百台机器组成。chunkserver反过来可能被一个或者多个机架上的数百台机器访问。不同机架上的两台机器通信可能会经过一个或者多个网络交换机。另外，进出一个机架的带宽可能少于这台机架上所有机器的总带宽。多层级分布给分布式数据的可扩展性，可靠性，可用性带来了特别的挑战。</p>
          </div>

<p>The chunk replica placement policy serves two purposes: maximize data reliability and availability, and maximize networkbandwidth utilization. For both, it is not enough to spread replicas across machines, which only <code>guards against</code> disk or machine failures and fully utilizes each machine’s networkbandwidth. We must also spread chunk replicas across racks. This ensures that some replicas of a chunk will survive and remain available even if an entire rack is damaged<br>or offline (for example, due to failure of a shared resource like a network switch or power <code>circuit</code>). It also means that <code>traffic</code>, especially reads, for a chunk can <code>exploit</code> the aggregate bandwidth of multiple racks. On the other hand, write traffic has to flow through multiple racks, a <code>tradeoff</code> we make <code>willingly</code>.</p>
<div class="note info">
            <p>chunk的副本放置的策略出于两个目的：最大化数据的可靠性和可用性，以及最大化网络带宽的利用率。出于这两个目的，仅仅将副本分布在机器间是不够的，这样只能应对磁盘和机器的故障，以及可以充分利用每台机器的带宽。我们也需要将副本分布在不同的机架上。这可以确保即使整个机架损坏或者离线了(比如网络交换机或者电源电路这些共享资源故障了)仍有一些副本保留下来可用。这也意味着流量，尤其是读流量，对于chunk来说能够利用多台机架的总带宽。另一方面，写流量要穿过多个机架，这是我们乐意做的折中。</p>
          </div>

<hr>
<h3 id="4-3-Creation-Re-replication-Rebalancing"><a href="#4-3-Creation-Re-replication-Rebalancing" class="headerlink" title="4.3 Creation, Re-replication, Rebalancing"></a>4.3 Creation, Re-replication, Rebalancing</h3><p>Chunk replicas are created for three reasons: chunk creation, re-replication, and rebalancing.</p>
<div class="note info">
            <p>chunk副本的创建出于3个原因：chunk的创建，重复制，再平衡。</p>
          </div>

<p>When the master creates a chunk, it chooses where to place the initially empty replicas. It considers several <code>factors</code>. (1) We want to place new replicas on chunkservers with below-average diskspace utilization. Over time this will <code>equalize</code> disk utilization across chunkservers. (2) We want to limit the number of “recent” creations on each chunkserver. Although creation itself is cheap, it <code>reliably</code> <code>predicts</code> <code>imminent</code> heavy write traffic because chunks are created when <code>demanded</code> by writes, and in our append-once-read-many workload they typically become practically read-only once they have been completely written. (3) As discussed above, we want to spread replicas of a chunkacross racks.</p>
<div class="note info">
            <p>当master创建chunk的时候，他会选择一个位置来初始化空的副本。会基于几个因素来考虑：(1) 我们会想放置一个新的副本在一个磁盘利用率低于平均值的chunkserver上。随着时间的推移能够均衡各个chunkservers的磁盘利用率。(2) 我们想限制每个chunkserver近期创建的chunk的数量。即使创建操作本身代价很小，但能够预测到很快会有大量的写流量，因为chunks就是因为写操作而创建的，对于我们append-once-read-many，通常在写入完成的时候工作负载就变成只读的了。(3) 如前面讨论的，我们想将副本分布在不同的机架上。</p>
          </div>

<p>The master re-replicates a chunk as soon as the number of available replicas <code>falls below</code> a user-specified goal. This could happen for various reasons: a chunkserver becomes unavailable, it reports that its replica may be <code>corrupted</code>, one of its disks is disabled because of errors, or the replication goal is <code>increased</code>. Each chunk that needs to be re-replicated is <code>prioritized</code> based on several factors. One is how far it is from its replication goal. For example, we give higher priority to a chunk that has lost two replicas than to a chunkthat has lost only one. In addition, we prefer to first re-replicate chunks for live files as <code>opposed</code> to chunks that belong to recently deleted files (see Section 4.4). Finally, to minimize the impact of failures on running applications, we <code>boost</code> the priority of any chunk that is blocking client progress.</p>
<div class="note info">
            <p>当可用的chunk副本数量低于用户指定的值,master会马上对chunk进行重复制。这种情况的发生有多种原因：一个chunkserver不可访问，chunkserver报告了一个副本损坏了，一个磁盘因为错误而不可用，或者复制的目标被提高了。每个需要再复制的chunk会基于几个因素增加优先级。一个因素是看距离副本完成的目标还有多远。比如，我们会给一个丢失了两份副本的chunk更高的优先级，相对于只丢失了一个副本的chunk.另外，我们更愿意给一个文件存在的chunk更高的优先级，而不是相反给文件被删除的chunk更高的优先级(见4.4节)。最后，为了最小化对于运行期程序的影响，我们会提高所有客户端阻塞中的chunk的优先级。</p>
          </div>

<p>The master picks the highest priority chunk and “clones” it by instructing some chunkserver to copy the chunk data directly from an existing valid replica. The new replica is placed with goals similar to those for creation: equalizing diskspace utilization, limiting active clone operations on any single chunkserver, and spreading replicas across racks. To keep cloning traffic from <code>overwhelming</code> client traffic, the master limits the numbers of active clone operations both for the cluster and for each chunkserver. Additionally, each chunkserver limits the amount of bandwidth it spends on each clone operation by <code>throttling</code> its read requests to the source chunkserver.</p>
<div class="note info">
            <p>master选择最高优先级的chunk,通过指示一些chunkserver直接从现有的有效的副本处拷贝数据来对这个chunk进行clone.新的副本的放置和前面说的创建有相似的目标：均衡磁盘利用率，限制单个chunkserver上活动的clone操作的数量，将副本分布在不同机架。为了防止clone的流量挤占过多客户端的流量，master限制了整个集群和单个chunkserver上活动的clone的数量。另外，每个chunkserver限制了clone操作对于源chunkserver的读请求的流量。</p>
          </div>

<p>Finally, the master rebalances replicas periodically: it examines the current replica distribution and moves replicas for better disk space and load balancing. Also through this process, the master gradually fills up a new chunkserver rather than <code>instantly</code> <code>swamps</code> it with new chunks and the heavy write traffic that comes with them. The placement <code>criteria</code> for the new replica are similar to those discussed above. In addition, the master must also choose which existing replica to remove. In general, it prefers to remove those on chunkservers with below-average free space so as to equalize diskspace usage.</p>
<div class="note info">
            <p>最后，master定期对副本进行再平衡：master检查当前副本的分布然后对其移动为了更好的磁盘空间使用和负载均衡。同样通过这个过程，master逐渐的填充新的chunkserver,而不是一下子通过新的chunks和随之而来的大的写入流量进行填充。新的副本的放置策略和前面说的一样。另外，master必须选择一个已存在的副本移除。总的来说，master更可能一出一个空间磁盘低于平均值的chunkserver来均衡磁盘的使用率。</p>
          </div>

<hr>
<h3 id="4-4-Garbage-Collection"><a href="#4-4-Garbage-Collection" class="headerlink" title="4.4 Garbage Collection"></a>4.4 Garbage Collection</h3><p>After a file is deleted, GFS does not immediately <code>reclaim</code> the available physical storage. It does so only lazily during regular garbage collection at both the file and chunklevels. We find that this approach makes the system much simpler and more reliable.</p>
<div class="note info">
            <p>文件被删除之后，GFS不会立即回收可用的物理存储。仅在文件和块级别的常规垃圾回收期间才这样做。我们发现这能够提高系统的易用性和可靠性。</p>
          </div>

<hr>
<h4 id="4-4-1-Mechanism"><a href="#4-4-1-Mechanism" class="headerlink" title="4.4.1 Mechanism"></a>4.4.1 Mechanism</h4><p>When a file is deleted by the application, the master logs the deletion immediately just like other changes. However instead of reclaiming resources immediately, the file is just renamed to a hidden name that includes the deletion timestamp. During the master’s regular scan of the file system namespace, it removes any such hidden files if they have existed for more than three days (the interval is configurable). <code>Until then</code>, the file can still be read under the new, special name and can be undeleted by renaming it back to normal. When the hidden file is removed from the namespace, its inmemory metadata is erased. This effectively severs its links to all its chunks.</p>
<div class="note info">
            <p>当一个文件被应用程序删除，master会和对待其他变化一样，立即将删除操作记录到日志。然而文件只是被重命名为包含删除时间戳的隐藏名称，而不是立即回收资源。在master定期扫描文件系统命名空间的时候，master会真正移除已经存在超过三天(内部可配置)的隐藏文件.在这之前，文件仍可以通过新的特殊名称来访问，也可以通过重命名来将其恢复成正常文件。当隐藏文件从命名空间移除，它在内存中的元数据也会被删除。这会影响到所有和它关联的chunks.</p>
          </div>

<p>In a similar regular scan of the chunk namespace, the master identifies <code>orphaned</code> chunks (i.e., those not reachable from any file) and erases the metadata for those chunks. In a HeartBeat message regularly exchanged with the master, each chunkserver reports a subset of the chunks it has, and the master replies with the identity of all chunks that are no longer present in the master’s metadata. The chunkserver is free to delete its replicas of such chunks.</p>
<div class="note info">
            <p>在对chunk命名空间的类似定期扫描中，master会识别孤立的chunks(那些无法被任何文件访问的)然后删除这些chunks的元数据。在定期和master交换的心跳包中，每个chunkserver会上报自身所含chunks的一个子集，然后master将回复元数据已经不存在的chunks的标识给chunkserver. chunkserver可以删除这些chunks的副本数据。</p>
          </div>

<hr>
<h4 id="4-4-2-Discussion"><a href="#4-4-2-Discussion" class="headerlink" title="4.4.2 Discussion"></a>4.4.2 Discussion</h4><p>Although distributed garbage collection is a hard problem that demands <code>complicated</code> solutions in the context of programming languages, it is quite simple in our case. We can easily identify all references to chunks: they are in the file-to-chunk mappings maintained <code>exclusively</code> by the master. We can also easily identify all the chunk replicas: they are Linux files under <code>designated</code> directories on each chunkserver. Any such replica not known to the master is “garbage.”</p>
<div class="note info">
            <p>即使分布式垃圾回收是个很难的问题，在编程语言上下文中这需要复杂的解决方案，但我们遇到的情况却很简单。我们可以容易的识别所有chunks的引用信息：它们只保留在master中file-to-chunk的映射里。我们也可以轻易的识别所有chunks的副本：它们是每个chunkserver指定目录下的linux文件。任何master不能识别的副本都是垃圾信息。</p>
          </div>

<p>The garbage collection approach to storage reclamation offers several advantages over <code>eager</code> deletion. First, it is simple and reliable in a large-scale distributed system where <code>component</code> failures are common. Chunk creation may succeed on some chunkservers but not others, leaving replicas that the master does not know exist. Replica deletion messages may be lost, and the master has to remember to <code>resend</code> them across failures, both its own and the chunkserver’s. Garbage collection provides a <code>uniform</code> and dependable way to clean up any replicas not known to be useful. Second, it merges storage <code>reclamation</code> into the regular background activities of the master, such as the regular scans of namespaces and handshakes with chunkservers. Thus, it is done in batches and the cost is <code>amortized</code>. Moreover, it is done only when the master is relatively free. The master can respond more <code>promptly</code> to client requests that demand timely attention. Third, the delay in reclaiming storage provides a safety net against <code>accidental</code>, <code>irreversible</code> deletion.</p>
<div class="note info">
            <p>存储回收的垃圾回收方法相比直接删除有几个优点。首先，这对于组件经常故障的大规模分布式系统来说更加简单和可靠。chunk创建可能在部分chunkservers成功，在部分上失败，因此有部分master不知道的副本。副本删除信息可能丢失，因此master必须记住这些并在在故障发生的时候重新发送，不管是master自身还是chunkserver发生故障。垃圾回收提高了统一和可靠的方式清理那些master不知道的副本。第二，master将存储回收和其他master的后台活动进行合并，比如定期的命名空间扫描和与chunkservers间的握手。因此，这是批量完成的，成本可以摊销。并且，这些活动只在master空闲的时候执行。所以master可以迅速的对客户端要求立即关注的请求进行回复。第三，存储回收的延迟给偶然和不可逆的删除操作提供了安全网。</p>
          </div>

<p>In our experience, the main disadvantage is that the delay sometimes <code>hinders</code> user <code>effort to</code> fine <code>tune</code> usage when storage is <code>tight</code>. Applications that repeatedly create and delete temporary files may not be able to reuse the storage right away. We <code>address these issues</code> by <code>expediting</code> storage reclamation if a deleted file is explicitly deleted again. We also allow users to apply different replication and reclamation policies to different parts of the namespace. For example, users can specify that all the chunks in the files within some directory tree are to be stored without replication, and any deleted files are immediately and irrevocably removed from the file system state.</p>
<div class="note info">
            <p>根据我们的经验，这种存储回收的延迟主要的缺点是在存储紧张的时候，阻碍了用户对于存储使用调整的努力。重复创建和删除临时文件的应用程序可能不能立即重用存储。我们通过，在删除的文件被再次显示删除的时候，加快存储回收来解决这些问题。我们也允许用户对命名空间下不同部分应用不同的拷贝和回收的策略。比如，用户可以指定一些目录树中文件的所有都被无副本的保存，也可以指定删除的文件被立即不可撤销的从系统中删除。</p>
          </div>

<hr>
<h2 id="4-5-Stale-Replica-Detection"><a href="#4-5-Stale-Replica-Detection" class="headerlink" title="4.5 Stale Replica Detection"></a>4.5 Stale Replica Detection</h2><p>Chunk replicas may become stale if a chunkserver fails and misses mutations to the chunk while it is down. For each chunk, the master maintains a chunk version number to distinguish between <code>up-to-date</code> and stale replicas.</p>
<div class="note info">
            <p>chunk的副本可能因为chunkserver故障或者在chunkserver故障期间丢失了chunk的变更信息，而过期。对于这些chunk,master保留了chunk的版本号来区别最新的和过期的副本。</p>
          </div>

<p>Whenever the master grants a new lease on a chunk, it increases the chunk version number and <code>informs</code> the up-to-date replicas. The master and these replicas all record the new version number in their persistent state. This occurs before any client is notified and therefore before it can start writing to the chunk. If another replica is currently unavailable, its chunk version number will not be advanced. The master will detect that this chunkserver has a stale replica when the chunkserver restarts and reports its set of chunks and their <code>associated</code> version numbers. If the master sees a version number greater than the one in its records, the master <code>assumes</code> that it failed when granting the lease and so takes the higher version to be up-to-date.</p>
<div class="note info">
            <p>每当master给chunk分配新租约的时候，都会增加chunk的版本号并通知最新的副本。master和这些副本都会持续的记录新的版本号。因为这发生在客户端收到通知前，因此也在chunk被写之前。如果另一个副本变得不可用。它的chunk版本号将不会提前。master可以检测到这些过期副本所在的chunkservers，当chunkserver重启和报告自身chunk的子集以及相关联的版本号的时候。如果master看到一个比自己更大的版本号的时候，master会假定在分配租约的时候失败了，因此会将高的版本号置位最新的版本号。</p>
          </div>

<p>The master removes stale replicas in its regular garbage collection. Before that, it effectively considers a stale replica not to exist at all when it replies to client requests for chunk information. As another safeguard, the master includes the chunk version number when it informs clients which chunkserver holds a lease on a chunk or when it instructs a chunkserver to read the chunk from another chunkserver in a cloning operation. The client or the chunkserver verifies the version number when it performs the operation so that it is always accessing up-to-date data.</p>
<div class="note info">
            <p>master在定期的垃圾回收中移除过期的副本。在那之前，当master回复客户端关于chunk信息请求的时候，master会当这些过期副本实际并不存在一样。另一种安全保障是，当master通知客户端哪个chunkserver持有租约，或者在clone操作中指示一个chunkserver从其他chunkserver读取数据的时候，master发送的信息都会携带chunk的版本号。客户端或者chunkserver都会验证版本号当它们执行操作的时候，因此他们总是访问最新数据。</p>
          </div>

<hr>
<h2 id="5-FAULT-TOLERANCE-AND-DIAGNOSIS"><a href="#5-FAULT-TOLERANCE-AND-DIAGNOSIS" class="headerlink" title="5. FAULT TOLERANCE AND DIAGNOSIS"></a>5. FAULT TOLERANCE AND DIAGNOSIS</h2><p>One of our greatest challenges in designing the system is dealing with frequent component failures. The quality and quantity of components together make these problems more the norm than the exception: we cannot completely trust the machines, nor can we completely trust the disks. Component failures can result in an unavailable system or, worse, corrupted data. We discuss how we meet these challenges and the tools we have built into the system to <code>diagnose</code> problems when they <code>inevitably</code> occur</p>
<div class="note info">
            <p>我们在设计系统时遇到的最大挑战之一是处理频繁的组件故障。组件的质量和数量加在一起使得这些问题的出现更像是正常情况而非异常：我们不会完全相信机器，也不会完全指望磁盘。组件故障可能导致系统不可用，或者更糟的情况使数据损坏。我们会讨论我们遇到的挑战，以及我们已经内置到系统的工具，可以工具可以诊断那些不可避免发生的问题</p>
          </div>

<hr>
<h3 id="5-1-High-Availability"><a href="#5-1-High-Availability" class="headerlink" title="5.1 High Availability"></a>5.1 High Availability</h3><p><code>Among</code> hundreds of servers in a GFS cluster, some are <code>bound to be</code> unavailable at any given time. We keep the overall system highly available with two simple yet effective <code>strategies</code>: fast recovery and replication.</p>
<div class="note info">
            <p>在GFS集群的数百台服务器中，在任意给定时间一定会有部分机器不可用。我们通过两种简单但有效的策略来提高整个系统的高可用性：快速恢复和复制。</p>
          </div>

<hr>
<h4 id="5-1-1-Fast-Recovery"><a href="#5-1-1-Fast-Recovery" class="headerlink" title="5.1.1 Fast Recovery"></a>5.1.1 Fast Recovery</h4><p>Both the master and the chunkserver are designed to <code>restore</code> their state and start in seconds no matter how they terminated. In fact, we do not distinguish between normal and <code>abnormal</code> termination; servers are <code>routinely</code> shut down just by killing the process. Clients and other servers experience a <code>minor</code> <code>hiccup</code> as they time out on their <code>outstanding</code> requests, reconnect to the restarted server, and retry. Section 6.2.2 reports observed startup times.</p>
<div class="note info">
            <p>master和chunkserver都被设计成在任何终止情况都可以在数秒内重启并恢复状态。事实上，我们并不区分正常和异常的终止；通过杀掉进程就可以正常的关闭服务端。客户端和其他的服务端在他们未完成的请求超时的时候会经历短暂的停顿，然后重新连接重启的服务端，并重试。6.2.2节报告了观察的启动时间</p>
          </div>

<hr>
<h4 id="5-1-2-Chunk-Replication"><a href="#5-1-2-Chunk-Replication" class="headerlink" title="5.1.2 Chunk Replication"></a>5.1.2 Chunk Replication</h4><p>As discussed earlier, each chunk is replicated on multiple chunkservers on different racks. Users can specify different replication levels for different parts of the file namespace. The default is three. The master clones existing replicas as needed to keep each chunk fully replicated as chunkservers go offline or detect corrupted replicas through checksum verification (see Section 5.2). Although replication has served us well, we are exploring other forms of cross-server <code>redundancy</code> such as <code>parity</code> or erasure codes for our increasing readonly storage requirements. We expect that it is challenging but manageable to implement these more complicated redundancy schemes in our very <code>loosely</code> <code>coupled</code> system because our traffic is <code>dominated</code> by appends and reads rather than small random writes.</p>
<div class="note info">
            <p>如前面讨论的那样，每个chunk都被复制到不同机架上的多个chunkservers.用户可以为文件命名空间的不同部分指定不同的复制级别。缺省级别是3.master clone已存在的副本为了在chunkserver离线或者通过校验码(见5.2节)检查到有损坏的副本的情况下，chunk也能被完全复制。即使副本工作的很好，我们仍在探索其他的跨服务器冗余的形式，比如parity(奇偶码？)或者纠删码，来应对我们日益增加的只读存储请求。我们认为在我们非常松散的耦合系统上实现更加复杂的冗余方案是有挑战性但可管理的，因为我们的流量主要是追加写和读操作，而不是小的随机写</p>
          </div>

<hr>
<h4 id="5-1-3-Master-Replication"><a href="#5-1-3-Master-Replication" class="headerlink" title="5.1.3 Master Replication"></a>5.1.3 Master Replication</h4><p>The master state is replicated for reliability. Its operation log and checkpoints are replicated on multiple machines. A mutation to the state is considered committed only after its log record has been flushed to disk locally and on all<br>master replicas. For <code>simplicity</code>, one master process remains <code>in charge of</code> all mutations as well as background activities such as garbage collection that change the system internally. When it fails, it can restart almost instantly. If its machine or disk fails, monitoring <code>infrastructure</code> outside GFS starts a new master process <code>elsewhere</code> with the replicated operation log. Clients use only the <code>canonical</code> name of the master (e.g. gfs-test), which is a DNS alias that can be changed if the master is <code>relocated</code> to another machine.</p>
<div class="note info">
            <p>为了可靠性，master的状态会被复制。其操作日志和检查点会被复制到多台机器。一个状态的变更只有在日志记录被写到本地磁盘以及所有master的副本的时候才会提交。为了简单起见，一个master仍然处理所有的变更和后台活动，比如会在内部修改系统的垃圾回收。master失败的时候，几乎总是可以立即重启。如果是机器或者磁盘故障，GFS外部的监控基础设施会通过操作日志副本信息在别处启动一个新的master.客户端仅仅使用master的规范名称(如gfs-test),这其实是一个dns别名，会随着master迁移到另一台机器的时候跟着变化</p>
          </div>

<p>Moreover, “shadow” masters provide read-only access to the file system even when the primary master is down. They are shadows, not mirrors, in that they may <code>lag</code> the primary slightly, typically <code>fractions</code> of a second. They <code>enhance</code> read availability for files that are not being actively mutated or applications that do not mind getting slightly stale results. In fact, since file content is read from chunkservers, applications do not observe stale file content. What could be stale within short windows is file metadata, like directory contents or access control information.</p>
<div class="note info">
            <p>另外，shwdow master提供了文件系统的只读访问，即使在primary master挂掉的时候。他们是影子而不是镜子，shodow master可能会轻微落后于primary master,通常少于一秒。shadows master对于不经常变化或应用程序不介意获取稍微过期的结果的情况下，能够提高文件的读可用性。事实上，因为文件内容是从chunkservers读取的，应用程序观察不到过期的文件内容。会在短窗口期内过期的是文件元数据，像是目录内容或者访问控制信息</p>
          </div>

<p>To keep itself informed, a shadow master reads a replica of the growing operation log and applies the same sequence of changes to its data structures exactly as the primary does. Like the primary, it polls chunkservers at startup (and in frequently thereafter) to locate chunk replicas and exchanges frequent handshake messages with them to monitor their status. It depends on the primary master only for replica location updates resulting from the primary’s decisions to create and delete replicas.</p>
<div class="note info">
            <p>为了保持同步，shadow master读取不断增长的操作日志的副本并按照和primary master相同的顺序将变更应用到自己的数据结构。像primary一样，shadow在启动阶段(随后会频繁的)轮训chunkservers来定位副本的位置，并频繁的通过和客户端的握手报文来监控客户端的状态。shadows master仅仅依赖与primary master对于副本位置的更新，master创建和删除副本的时候会导致副本位置更新。</p>
          </div>

<hr>
<h3 id="5-2-Data-Integrity"><a href="#5-2-Data-Integrity" class="headerlink" title="5.2 Data Integrity"></a>5.2 Data Integrity</h3><p>Each chunkserver uses checksumming to detect corruption of stored data. Given that a GFS cluster often has thousands of disks on hundreds of machines, it regularly experiences disk failures that cause data corruption or loss on both the<br>read and write paths. (See Section 7 for one cause.) We can recover from corruption using other chunk replicas, but it would be <code>impractical</code> to detect corruption by comparing replicas across chunkservers. Moreover, <code>divergent</code> replicas may be legal: the semantics of GFS mutations, in particular atomic record append as discussed earlier, does not guarantee <code>identical</code> replicas. Therefore, each chunkserver must independently verify the <code>integrity</code> of its own copy by maintaining checksums.</p>
<div class="note info">
            <p>每个chunkserver使用校验和来检测存储数据是否损坏。一个通常包含上百台机器，数千个磁盘的GFS集群，经常遇到磁盘故障对于读和写造成的数据损坏或丢失(见第七节中的一个原因)。我们可以使用chunk副本来恢复损坏数据，但是通过比较不同chunkservers的副本来检测损坏数据是不切实际的。不同的副本也不能是合法的：GFS变更的语义，尤其对于我们前面讨论的原子记录追加写，并不保证完全相同的副本。因此，每个chunkserver必须独立验证自己的副本的完整性，通过维护校验和</p>
          </div>

<p>A chunk is broken up into 64 KB blocks. Each has a corresponding 32 bit checksum. Like other metadata, checksums are kept in memory and stored <code>persistently</code> with logging, separate from user data.</p>
<div class="note info">
            <p>每个chunk被分为64kb大小的块。每个块有相应的32位的校验和。和其他元数据一样，校验和保存在内存中并通过日志进行持久化，并和用户数据分离。 </p>
          </div>

<p>For reads, the chunkserver verifies the checksum of data blocks that <code>overlap</code> the read range before returning any data to the requester, whether a client or another chunkserver. Therefore chunkservers will not <code>propagate</code> corruptions to other machines. If a block does not match the recorded checksum, the chunkserver returns an error to the requestor and reports the mismatch to the master. In response, the requestor will read from other replicas, while the master will clone the chunk from another replica. After a valid new replica is in place, the master instructs the chunkserver that reported the mismatch to delete its replica.</p>
<div class="note info">
            <p>对于读请求，chunkserver在返回任何数据给请求方之前，会对这次读请求重叠的范围内的数据验证校验和，不管请求方是客户端还是chunkserver.因此每个chunkserver都不会传递损坏数据给其他的机器。如果某个块和记录的校验和不匹配，chunkserver会返回错误给请求方并报告匹配无效给master.作为回应，请求方会从另一个副本处读取，同时master会在另一个副本处clone这个chunk.在一个新的副本被放置后，master会指示之前那个报告了匹配无效的chunkserver删除无效的副本。</p>
          </div>

<p>Checksumming has little effect on read performance for several reasons. Since most of our reads <code>span</code> at least a few blocks, we need to read and checksum only a relatively small amount of extra data for verification. GFS client code further reduces this overhead by trying to <code>align</code> reads at checksum block boundaries. Moreover, checksum lookups and comparison on the chunkserver are done without any I/O, and checksum calculation can often be <code>overlapped</code> with I/Os.</p>
<div class="note info">
            <p>出于几个原因，校验和对读取性能的影响很小。因为我们大多数的读取都至少跨了几个块，因此我们只需要读取并对少量相关的额外数据进行验证。GFS的客户端代码通过尝试对校验和边缘进行对齐更加减少了读取的开销。此外，校验和在chunkserver上查找和比较是不涉及IO操作的，并且校验和的计算经常喝IO是重叠的。</p>
          </div>

<p>Checksum computation is heavily optimized for writes that append to the end of a chunk(<code>as opposed to</code> writes that overwrite existing data) because they are dominant in our workloads. We just <code>incrementally</code> update the checksum for the last partial checksum block, and compute new checksums for any <code>brand new</code> checksum blocks filled by the append. Even if the last partial checksum block is already corrupted and we fail to detect it now, the new checksum value will not match the stored data, and the corruption will be detected as usual when the block is next read.</p>
<div class="note info">
            <p>校验和的计算对于chunk的追加写进行了极大的优化(相对于覆盖写)因为我们工作中主要是追加写。我们只需要对最后部分的校验和块进行增量更新校验和，然后对于任何通过追加写添加的权限的校验和块重新计算新的校验和。即使最后部分的校验和块已经损坏了并且我们正在尝试的检测也失败了，新的校验和后面也不会和存储的数据匹配成功，当损坏的块下次被读取的时候将会向通常那样被检测到</p>
          </div>

<p><code>In contrast</code>, if a write overwrites an existing range of the chunk, we must read and verify the first and last blocks of the range being overwritten, then perform the write, and finally compute and record the new checksums. If we do not verify the first and last blocks before overwriting them partially, the new checksums may hide corruption that exists in the regions not being overwritten.</p>
<div class="note info">
            <p>相反，如果写操作覆盖了chunk的现有范围，我们必须读取并验证被覆盖范围中第一个和最后一个块，然后再执行写操作，最终计算并记录新的校验和。如果我们不验证第一个和最后一个块在部分写之前，那么新的校验和可能会隐藏掉存在于没有被覆盖写的区域中的损坏数据。</p>
          </div>

<p>During idle periods, chunkservers can scan and verify the contents of inactive chunks. This allows us to detect corruption in chunks that are <code>rarely</code> read. Once the corruption is detected, the master can create a new uncorrupted replica and delete the corrupted replica. This prevents an inactive but corrupted chunk replica from fooling the master into thinking that it has enough valid replicas of a chunk.</p>
<div class="note info">
            <p>在处理期间，chunkserver可以扫描并验证不活跃的chunks的内容。这允许我们检查这些chunks中很少被读取的损坏的数据。一旦校测到损坏数据，master可以创建新的未损坏的副本，然后删除掉损坏的副本。这阻止了不活跃但已损坏的chunk的副本让master误以为它头足够数量的有效的chunk的副本。</p>
          </div>

<hr>
<h3 id="5-3-Diagnostic-Tools"><a href="#5-3-Diagnostic-Tools" class="headerlink" title="5.3 Diagnostic Tools"></a>5.3 Diagnostic Tools</h3><p><code>Extensive</code> and <code>detailed</code> diagnostic logging has helped <code>immeasurably</code> in problem isolation, debugging, and performance analysis, while <code>incurring</code> only a minimal cost. Without logs, it is hard to understand <code>transient</code>, non-repeatable interactions between machines. GFS servers generate diagnostic logs that record many <code>significant</code> events (such as chunkservers going up and down) and all RPC requests and replies. These diagnostic logs can be freely deleted without affecting the correctness of the system. However, we try to keep these logs around as far as space permits.</p>
<div class="note info">
            <p>广泛和详细的诊断日志能够极大的帮助我们对于问题的分解，调试，和性能分析，只需要很小的代价。没有这些日志，将很难理解不同机器间短暂又不可重复的交互。GFS服务端生成诊断日志记录了许多重要的事件(比如chunskerver的启动和关闭)以及RPC的请求和回复。这些诊断日志可以自由的删除而不会影响系统的正确性。但是，在空间允许的情况下我们会尝试保留这些日志</p>
          </div>

<p>The RPC logs include the <code>exact</code> requests and responses sent <code>on the wire</code>, except for the file data being read or written. By matching requests with replies and collating RPC records on different machines, we can <code>reconstruct</code> the entire interaction history to diagnose a problem. The logs also serve as traces for load testing and performance analysis.</p>
<div class="note info">
            <p>RPC日志包含了线上精确的请求和响应，除了读和写的文件数据。通过匹配记录在不同机器上的请求和响应，我们能够重建整个交互历史来诊断问题。日志也用于负载测试已经性能分析的跟踪</p>
          </div>

<p>The performance impact of logging is minimal (and far outweighed by the <code>benefits</code>) because these logs are written sequentially and asynchronously. The most recent events are also kept in memory and available for continuous online monitoring.</p>
<div class="note info">
            <p>日志的性能影响是很小的(带来的好处远胜于这点影响)，因为这些日志是异步顺序写的。大多数最近的时间也保存在内存中，可用于线上持续的监控</p>
          </div>

<hr>
<h2 id="6-MEASUREMENTS"><a href="#6-MEASUREMENTS" class="headerlink" title="6. MEASUREMENTS"></a>6. MEASUREMENTS</h2><p>In this section we present a few micro-benchmarks to illustrate the bottlenecks inherent in the GFS architecture and implementation, and also some numbers from real clusters in use at Google.</p>
<hr>
<h3 id="6-1-Micro-benchmarks"><a href="#6-1-Micro-benchmarks" class="headerlink" title="6.1 Micro-benchmarks"></a>6.1 Micro-benchmarks</h3><p>We measured performance on a GFS cluster consisting of one master, two master replicas, 16 chunkservers, and 16 clients. Note that this configuration was set up for ease of testing. Typical clusters have hundreds of chunkservers and hundreds of clients.</p>
<p>All the machines are configured with dual 1.4 GHz PIII processors, 2 GB of memory, two 80 GB 5400 rpm disks, and a 100 Mbps full-duplex Ethernet connection to an HP 2524 switch. All 19 GFS server machines are connected to one switch, and all 16 client machines to the other. The two switches are connected with a 1 Gbps link.</p>
<hr>
<h4 id="6-1-1-Reads"><a href="#6-1-1-Reads" class="headerlink" title="6.1.1 Reads"></a>6.1.1 Reads</h4><p>N clients read simultaneously from the file system. Each client reads a randomly selected 4 MB region from a 320 GB file set. This is repeated 256 times so that each client ends up reading 1 GB of data. The chunkservers taken together have only 32 GB of memory, so we expect at most a 10% hit rate in the Linux buffer cache. Our results should be close to cold cache results.</p>
<p>Figure 3(a) shows the aggregate read rate for N clients and its theoretical limit. The limit peaks at an aggregate of 125 MB/s when the 1 Gbps linkbetween the two switches is saturated, or 12.5 MB/s per client when its 100 Mbps networkinterface gets saturated, whichever applies. The observed read rate is 10 MB/s, or 80% of the per-client limit, when just one client is reading. The aggregate read rate reaches 94 MB/s, about 75% of the 125 MB/s linklimit, for 16 readers, or 6 MB/s per client. The efficiency drops from 80% to 75% because as the number of readers increases, so does the probability that multiple readers simultaneously read from the same chunkserver.</p>
<hr>
<h4 id="6-1-2-Writes"><a href="#6-1-2-Writes" class="headerlink" title="6.1.2 Writes"></a>6.1.2 Writes</h4><p>N clients write simultaneously to N distinct files. Each client writes 1 GB of data to a new file in a series of 1 MB writes. The aggregate write rate and its theoretical limit are shown in Figure 3(b). The limit plateaus at 67 MB/s because we need to write each byte to 3 of the 16 chunk servers, each with a 12.5 MB/s input connection.</p>
<p>The write rate for one client is 6.3 MB/s, about half of the limit. The main culprit for this is our networkstack. It does not interact very well with the pipelining scheme we use for pushing data to chunkreplicas. Delays in propagating data from one replica to another reduce the overall write rate.</p>
<p>Aggregate write rate reaches 35 MB/s for 16 clients (or 2.2 MB/s per client), about half the theoretical limit. As in the case of reads, it becomes more likely that multiple clients write concurrently to the same chunkserver as the number of clients increases. Moreover, collision is more likely for 16 writers than for 16 readers because each write involves three different replicas.</p>
<p>Writes are slower than we would like. In practice this has not been a major problem because even though it increases the latencies as seen by individual clients, it does not significantly affect the aggregate write bandwidth delivered by the system to a large number of clients.</p>
<hr>
<h4 id="6-1-3-Record-Appends"><a href="#6-1-3-Record-Appends" class="headerlink" title="6.1.3 Record Appends"></a>6.1.3 Record Appends</h4><p>Figure 3(c) shows record append performance. N clients append simultaneously to a single file. Performance is limited by the networkbandwidth of the chunkservers that store the last chunkof the file, independent of the number of clients. It starts at 6.0 MB/s for one client and drops to 4.8 MB/s for 16 clients, mostly due to congestion and variances in networktransfer rates seen by different clients.</p>
<p>Our applications tend to produce multiple such files concurrently. In other words, N clients append to M shared files simultaneously where both N and M are in the dozens or hundreds. Therefore, the chunkserver network congestion in our experiment is not a significant issue in practice because a client can make progress on writing one file while the chunkservers for another file are busy.</p>
<hr>
<h3 id="6-2-Real-World-Clusters"><a href="#6-2-Real-World-Clusters" class="headerlink" title="6.2 Real World Clusters"></a>6.2 Real World Clusters</h3><p>We now examine two clusters in use within Google that are representative of several others like them. Cluster A is used regularly for research and development by over a hundred engineers. A typical taskis initiated by a human user and runs up to several hours. It reads through a few MBs to a few TBs of data,transforms or analyzes the data, and writes the results backto the cluster. Cluster B is primarily used for production data processing. The tasks last much<br>longer and continuously generate and process multi-TB data sets with only occasional human intervention. In both cases, a single “task” consists of many processes on many machines reading and writing many files simultaneously.</p>
<hr>
<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/Snipaste_2021-02-11_02-21-14.jpg"></p>
<h4 id="6-2-1-Storage"><a href="#6-2-1-Storage" class="headerlink" title="6.2.1 Storage"></a>6.2.1 Storage</h4><p>As shown by the first five entries in the table, both clusters have hundreds of chunkservers, support many TBs of disk space, and are fairly but not completely full. “Used space” includes all chunkreplicas. Virtually all files are replicated three times. Therefore, the clusters store 18 TB and 52 TB of file data respectively.</p>
<p>The two clusters have similar numbers of files, though B has a larger proportion of dead files, namely files which were deleted or replaced by a new version but whose storage have not yet been reclaimed. It also has more chunks because its files tend to be larger.</p>
<hr>
<h4 id="6-2-2-Metadata"><a href="#6-2-2-Metadata" class="headerlink" title="6.2.2 Metadata"></a>6.2.2 Metadata</h4><p>The chunkservers in aggregate store tens of GBs of metadata, mostly the checksums for 64 KB blocks of user data. The only other metadata kept at the chunkservers is the chunkversion number discussed in Section 4.5.</p>
<p>The metadata kept at the master is much smaller, only tens of MBs, or about 100 bytes per file on average. This agrees with our assumption that the size of the master’s memory does not limit the system’s capacity in practice. Most of the per-file metadata is the file names stored in a prefix-compressed form. Other metadata includes file ownership and permissions, mapping from files to chunks, and each chunk’s current version. In addition, for each chunk we store the current replica locations and a reference count for implementing copy-on-write.</p>
<p>Each individual server, both chunkservers and the master, has only 50 to 100 MB of metadata. Therefore recovery is fast: it takes only a few seconds to read this metadata from diskbefore the server is able to answer queries. However, the master is somewhat hobbled for a period – typically 30 to 60 seconds – until it has fetched chunklocation information from all chunkservers.</p>
<hr>
<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/Snipaste_2021-02-11_02-21-28.jpg"></p>
<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/Snipaste_2021-02-11_02-21-38.jpg"></p>
<h4 id="6-2-3-Read-and-Write-Rates"><a href="#6-2-3-Read-and-Write-Rates" class="headerlink" title="6.2.3 Read and Write Rates"></a>6.2.3 Read and Write Rates</h4><p>Table 3 shows read and write rates for various time periods. Both clusters had been up for about one weekwhen these measurements were taken. (The clusters had been restarted recently to upgrade to a new version of GFS.)</p>
<p>The average write rate was less than 30 MB/s since the restart. When we tookthese measurements, B was in the middle of a burst of write activity generating about 100 MB/s of data, which produced a 300 MB/s networkload because writes are propagated to three replicas.</p>
<p>Figure 3: Aggregate Throughputs. Top curves show theoretical limits imposed by our networktopology. Bottom curves show measured throughputs. They have error bars that show 95% confidence intervals, which are illegible in some cases because of low variance in measurements.</p>
<p>The read rates were much higher than the write rates. The total workload consists of more reads than writes as we have assumed. Both clusters were in the middle of heavy read activity. In particular, A had been sustaining a read rate of 580 MB/s for the preceding week. Its network configuration can support 750 MB/s, so it was using its resources efficiently. Cluster B can support peakread rates of 1300 MB/s, but its applications were using just 380 MB/s.</p>
<hr>
<h4 id="6-2-4-Master-Load"><a href="#6-2-4-Master-Load" class="headerlink" title="6.2.4 Master Load"></a>6.2.4 Master Load</h4><p>Table 3 also shows that the rate of operations sent to the master was around 200 to 500 operations per second. The master can easily keep up with this rate, and therefore is not a bottleneckfor these workloads.</p>
<p>In an earlier version of GFS, the master was occasionally a bottleneckfor some workloads. It spent most of its time sequentially scanning through large directories (which contained hundreds of thousands of files) looking for particular files. We have since changed the master data structures to allow efficient binary searches through the namespace. It can now easily support many thousands of file accesses per second. If necessary, we could speed it up further by placing name lookup caches in front of the namespace data structures.</p>
<hr>
<h4 id="6-2-5-Recovery-Time"><a href="#6-2-5-Recovery-Time" class="headerlink" title="6.2.5 Recovery Time"></a>6.2.5 Recovery Time</h4><p>After a chunkserver fails, some chunks will become underreplicated and must be cloned to restore their replication levels. The time it takes to restore all such chunks depends on the amount of resources. In one experiment, we killed a single chunkserver in cluster B. The chunkserver had about 15,000 chunks containing 600 GB of data. To limit the impact on running applications and provide leeway for scheduling decisions, our default parameters limit this cluster to 91 concurrent clonings (40% of the number of chunkservers) where each clone operation is allowed to consume at most 6.25 MB/s (50 Mbps). All chunks were restored in 23.2 minutes, at an effective replication rate of 440 MB/s.</p>
<p>In another experiment, we killed two chunkservers each with roughly 16,000 chunks and 660 GB of data. This double failure reduced 266 chunks to having a single replica. These 266 chunks were cloned at a higher priority, and were all restored to at least 2x replication within 2 minutes, thus putting the cluster in a state where it could tolerate another chunkserver failure without data loss.</p>
<hr>
<h3 id="6-3-Workload-Breakdown"><a href="#6-3-Workload-Breakdown" class="headerlink" title="6.3 Workload Breakdown"></a>6.3 Workload Breakdown</h3><p>In this section, we present a detailed breakdown of the workloads on two GFS clusters comparable but not identical to those in Section 6.2. Cluster X is for research and development while cluster Y is for production data processing.</p>
<hr>
<h4 id="6-3-1-Methodology-and-Caveats"><a href="#6-3-1-Methodology-and-Caveats" class="headerlink" title="6.3.1 Methodology and Caveats"></a>6.3.1 Methodology and Caveats</h4><p>These results include only client originated requests so that they reflect the workload generated by our applications for the file system as a whole. They do not include interserver requests to carry out client requests or internal background activities, such as forwarded writes or rebalancing.</p>
<p>Statistics on I/O operations are based on information heuristically reconstructed from actual RPC requests logged by GFS servers. For example, GFS client code may breaka read into multiple RPCs to increase parallelism, from which we infer the original read. Since our access patterns are highly stylized, we expect any error to be in the noise. Explicit logging by applications might have provided slightly more accurate data, but it is logistically impossible to recompile and restart thousands of running clients to do so and cumbersome to collect the results from as many machines.</p>
<p>One should be careful not to overly generalize from our workload. Since Google completely controls both GFS and its applications, the applications tend to be tuned for GFS, and conversely GFS is designed for these applications. Such mutual influence may also exist between general applications and file systems, but the effect is likely more pronounced in our case.</p>
<hr>
<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/Snipaste_2021-02-11_02-21-49.jpg"></p>
<h3 id="6-3-2-Chunkserver-Workload"><a href="#6-3-2-Chunkserver-Workload" class="headerlink" title="6.3.2 Chunkserver Workload"></a>6.3.2 Chunkserver Workload</h3><p>Table 4 shows the distribution of operations by size. Read sizes exhibit a bimodal distribution. The small reads (under 64 KB) come from seek-intensive clients that look up small pieces of data within huge files. The large reads (over 512 KB) come from long sequential reads through entire files.</p>
<p>A significant number of reads return no data at all in cluster Y. Our applications, especially those in the production systems, often use files as producer-consumer queues. Producers append concurrently to a file while a consumer reads the end of file. Occasionally, no data is returned when the consumer outpaces the producers. Cluster X shows this less often because it is usually used for short-lived data analysis tasks rather than long-lived distributed applications.</p>
<p>Write sizes also exhibit a bimodal distribution. The large writes (over 256 KB) typically result from significant buffering within the writers. Writers that buffer less data, checkpoint or synchronize more often, or simply generate less data account for the smaller writes (under 64 KB).</p>
<p>As for record appends, cluster Y sees a much higher percentage of large record appends than cluster X does because our production systems, which use cluster Y, are more aggressively tuned for GFS.</p>
<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/Snipaste_2021-02-11_02-22-00.jpg"></p>
<p>Table 5 shows the total amount of data transferred in operations of various sizes. For all kinds of operations, the larger operations (over 256 KB) generally account for most of the bytes transferred. Small reads (under 64 KB) do transfer a small but significant portion of the read data because of the random seekworkload.</p>
<hr>
<h3 id="6-3-3-Appends-versus-Writes"><a href="#6-3-3-Appends-versus-Writes" class="headerlink" title="6.3.3 Appends versus Writes"></a>6.3.3 Appends versus Writes</h3><p>Record appends are heavily used especially in our production systems. For cluster X, the ratio of writes to record appends is 108:1 by bytes transferred and 8:1 by operation counts. For cluster Y, used by the production systems, the ratios are 3.7:1 and 2.5:1 respectively. Moreover, these ratios suggest that for both clusters record appends tend to be larger than writes. For cluster X, however, the overall usage of record append during the measured period is fairly<br>low and so the results are likely skewed by one or two applications with particular buffer size choices.</p>
<p>As expected, our data mutation workload is dominated by appending rather than overwriting. We measured the amount of data overwritten on primary replicas. This approximates the case where a client deliberately overwrites previous written data rather than appends new data. For cluster X, overwriting accounts for under 0.0001% of bytes mutated and under 0.0003% of mutation operations. For cluster Y, the ratios are both 0.05%. Although this is minute, it is still higher than we expected. It turns out that most of these overwrites came from client retries due to errors or timeouts. They are not part of the workload per se but a<br>consequence of the retry mechanism.</p>
<hr>
<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/Snipaste_2021-02-11_02-22-10.jpg"></p>
<h3 id="6-3-4-Master-Workload"><a href="#6-3-4-Master-Workload" class="headerlink" title="6.3.4 Master Workload"></a>6.3.4 Master Workload</h3><p>Table 6 shows the breakdown by type of requests to the master. Most requests askfor chunklocations (FindLocation) for reads and lease holder information (FindLeaseLocker) for data mutations.</p>
<p>Clusters X and Y see significantly different numbers of Delete requests because cluster Y stores production data sets that are regularly regenerated and replaced with newer versions. Some of this difference is further hidden in the difference in Open requests because an old version of a file may be implicitly deleted by being opened for write from scratch (mode “w” in Unix open terminology).</p>
<p>FindMatchingFiles is a pattern matching request that supports “ls” and similar file system operations. Unlike other requests for the master, it may process a large part of the namespace and so may be expensive. Cluster Y sees it much more often because automated data processing tasks tend to examine parts of the file system to understand global application state. In contrast, cluster X’s applications are under more explicit user control and usually know the names of all needed files in advance.</p>
<hr>
<h2 id="7-EXPERIENCES"><a href="#7-EXPERIENCES" class="headerlink" title="7. EXPERIENCES"></a>7. EXPERIENCES</h2><p>In the process of building and deploying GFS, we have experienced a variety of issues, some operational and some technical.</p>
<div class="note info">
            <p>在构建和部署GFS的过程中，我们遇到了许多问题，一些操作方面的，一些是技术方面的。</p>
          </div>

<p>Initially, GFS was <code>conceived</code> as the <code>backend</code> file system for our production systems. Over time, the usage <code>evolved</code> to include <code>research</code> and development tasks. It started with little support for things like permissions and <code>quotas</code> but now includes <code>rudimentary</code> forms of these. While production systems are well <code>disciplined</code> and controlled, users sometimes are not. More <code>infrastructure</code> is required to keep users from <code>interfering</code> with one another.</p>
<div class="note info">
            <p>最初，GFS被构思为我们生产系统的后台文件系统。随着时间的推移，它也被用于研究和开发任务。GFS最开始很少支持权限和配额，但现在已经有了基础的支持。生产系统是被约束和控制的，但用户间有时候却不是这样。需要更多的基础设施来防止用户间相互干扰。</p>
          </div>

<p>Some of our biggest problems were disk and Linux related. Many of our disks <code>claimed</code> to the Linux driver that they supported <code>a range of</code> IDE protocol versions but in fact responded reliably only to the more recent ones. Since the protocol versions are very similar, these drives mostly worked, but occasionally the <code>mismatches</code> would cause the drive and the kernel to disagree about the drive’s state. This would corrupt data silently due to problems in the kernel. This problem <code>motivated</code> our use of checksums to detect data corruption, while <code>concurrently</code> we modified the kernel to handle these protocol mismatches.</p>
<div class="note info">
            <p>一些我们遇到的最大问题是磁盘和linux相关的。我们的许多磁盘都声称它们支持一系列IDE协议版本的linux驱动，但实际上只有最新的一些才有好的反应。因为协议版本是非常相似的，这些驱动大多数时间都能正常工作，但是偶发的不匹配会造成磁驱动和内核对于驱动的状态产生分歧。这将会因为内核的问题导致数据被默默损坏。这些问题促使我们使用校验和来检测数据损坏，同时我们已经修改了内核代码来解决协议不匹配问题</p>
          </div>

<p>Earlier we had some problems with Linux 2.2 kernels due to the cost of fsync(). Its cost is <code>proportional</code> to the size of the file rather than the size of the modified <code>portion</code>. This was a problem for our large operation logs especially before we implemented checkpointing. We <code>worked around</code> this <code>for a time</code> by using <code>synchronous</code> writes and <code>eventually</code> <code>migrated</code> to Linux 2.4.</p>
<div class="note info">
            <p>早先在linux2.2版本，我们有一些fsync的开销导致的问题。fsync的开销和文件大小成比例而不是和修改部分的大小成比例。这对于我们的大的操作日志是个问题，特别是在我们实现检查点之前。有一段时间我们通过同步写并最终升级到linxu2.4版本来解决这个问题</p>
          </div>

<p>Another Linux problem was a single reader-writer lock which any thread in an address space must hold when it pages in from disk(reader lock) or modifies the address space in an mmap() call (writer lock). We saw <code>transient</code> timeouts in our system under <code>light load</code> and looked hard for resource bottlenecks or <code>sporadic</code> hardware failures. Eventually, we found that this single lock blocked the primary network thread from mapping new data into memory while the disk threads were paging in previously mapped data. Since we are mainly limited by the networkinterface rather than by memory copy bandwidth, we worked around this by replacing mmap() with pread() at the cost of an extra copy. <code>Despite</code> occasional problems, the availability of Linux code has helped us <code>time and again</code> to explore and understand system behavior. When <code>appropriate</code>, we <code>improve</code> the kernel and share the changes with the open source community.</p>
<div class="note info">
            <p>另一个linux系统造成的问题是，任何地址空间的线程必须持有的单个读写锁，在它从磁盘分页时是读锁，通过mmap修改地址空间是写锁。我们看到我们的系统在低负载下会出现短暂的超时，并且很难寻找文件瓶颈或者零散的硬件故障。最终，我们发现是因为单个锁阻塞了主要的网络线程映射新的数据到内存，在磁盘线程正在对先前已映射数据进行分页的时候。因为我们主要受到网络接口的限制而不是内存拷贝带宽的限制，所以我们通过用pread代替mmap解决了这个问题，以额外的拷贝为代价。尽管有偶发的问题发生，linux代码的可用性已经帮助我们很多次了，在我们探索和理解系统行为上。在合适的时候，我们会改进内核并将共享修改的代码给开源社区</p>
          </div>

<hr>
<h2 id="8-RELATED-WORK"><a href="#8-RELATED-WORK" class="headerlink" title="8. RELATED WORK"></a>8. RELATED WORK</h2><p>Like other large distributed file systems such as AFS [5], GFS provides a location independent namespace which enables data to be moved transparently for load balance or fault tolerance. Unlike AFS, GFS spreads a file’s data across storage servers in a way more akin to xFS [1] and Swift [3] in order to deliver aggregate performance and increased fault tolerance.</p>
<p>As disks are relatively cheap and replication is simpler than more sophisticated RAID [9] approaches, GFS currently uses only replication for redundancy and so consumes more raw storage than xFS or Swift.</p>
<p>In contrast to systems like AFS, xFS, Frangipani [12], and Intermezzo [6], GFS does not provide any caching below the file system interface. Our target workloads have little reuse within a single application run because they either stream through a large data set or randomly seekwithin it and read small amounts of data each time.</p>
<p>Some distributed file systems like Frangipani, xFS, Minnesota’s GFS[11] and GPFS [10] remove the centralized server and rely on distributed algorithms for consistency and management. We opt for the centralized approach in order to simplify the design, increase its reliability, and gain flexibility. In particular, a centralized master makes it much easier to implement sophisticated chunkplacement and replication policies since the master already has most of the relevant information and controls how it changes. We address fault tolerance by keeping the master state small and fully replicated on other machines. Scalability and high availability (for reads) are currently provided by our shadow master mechanism. Updates to the master state are made persistent by appending to a write-ahead log. Therefore we could adapt a primary-copy scheme like the one in Harp [7] to provide high availability with stronger consistency guarantees than our current scheme.</p>
<p>We are addressing a problem similar to Lustre [8] in terms of delivering aggregate performance to a large number of clients. However, we have simplified the problem significantly by focusing on the needs of our applications rather than building a POSIX-compliant file system. Additionally, GFS assumes large number of unreliable components and so fault tolerance is central to our design.</p>
<p>GFS most closely resembles the NASD architecture [4]. While the NASD architecture is based on network-attached diskdrives, GFS uses commodity machines as chunkservers, as done in the NASD prototype. Unlike the NASD work, our chunkservers use lazily allocated fixed-size chunks rather than variable-length objects. Additionally, GFS implements features such as rebalancing, replication, and recovery that are required in a production environment.</p>
<p>Unlike Minnesota’s GFS and NASD, we do not seek to alter the model of the storage device. We focus on addressing day-to-day data processing needs for complicated distributed systems with existing commodity components.</p>
<p>The producer-consumer queues enabled by atomic record appends address a similar problem as the distributed queues in River [2]. While River uses memory-based queues distributed across machines and careful data flow control, GFS uses a persistent file that can be appended to concurrently by many producers. The River model supports m-to-n distributed queues but lacks the fault tolerance that comes with persistent storage, while GFS only supports m-to-1 queues efficiently. Multiple consumers can read the same file, but they must coordinate to partition the incoming load.</p>
<hr>
<h2 id="9-CONCLUSIONS"><a href="#9-CONCLUSIONS" class="headerlink" title="9. CONCLUSIONS"></a>9. CONCLUSIONS</h2><p>The Google File System <code>demonstrates</code> the <code>qualities</code> <code>essential</code> for supporting large-scale data processing workloads on commodity hardware. While some design decisions are specific to our unique setting, many may apply to data processing tasks of a similar <code>magnitude</code> and cost <code>consciousness</code>.</p>
<div class="note info">
            <p>GFS证明了其支持在商用硬件上的大规模数据处理工作的基础特性。虽然它的一些设计决策是针对于我们的独特设置，但是多数都可以用于类似的量和开销的处理任务。</p>
          </div>

<p>We started by reexamining traditional file system <code>assumptions</code> <code>in light of</code> our current and <code>anticipated</code> application workloads and technological environment. Our observations have <code>led to</code> radically different points in the design space. We treat component failures as the norm rather than the exception, optimize for huge files that are mostly appended to (perhaps concurrently) and then read (usually sequentially), and both extend and relax the standard file system interface to improve the overall system.</p>
<div class="note info">
            <p>我们首先根据我们现在和预期的应用程序工作负载和技术环境，重新审视了传统文件系统的假设。我们的这些观察导致我们在设计空间上有完全不同的观点。我们认为组件故障是正常情况，而非异常，对于大文件的优化大多是通过追加写(可能并行的)然后读取(通常是顺序读)，我们通过扩展和放宽标椎文件系统接口来提高整个系统</p>
          </div>

<p>Our system provides fault tolerance by constant monitoring, replicating <code>crucial</code> data, and fast and automatic recovery. Chunk replication allows us to tolerate chunkserver failures. The frequency of these failures motivated a <code>novel</code> online repair mechanism that regularly and <code>transparently</code> repairs the damage and <code>compensates</code> for lost replicas as soon as possible. Additionally, we use checksumming to detect data corruption at the disk or IDE subsystem level, which becomes all too common given the number of disks in the system.</p>
<div class="note info">
            <p>我们的系统通过持续监控，复制关键数据，以及快速和原子的恢复来实现容错。chunk的副本存在允许我们容忍chunkserver发生故障。这些频繁发生的故障促使我们采用了新颖的在线修复机制，一种可以定期透明的对丢失的副本进行尽可能块的修复和补偿。另外，我们使用校验和来检测磁盘上损坏的数据或者检查IDE子系统的级别，这在系统给定磁盘数量的时候很常见。</p>
          </div>

<p>Our design delivers high <code>aggregate</code> <code>throughput</code> to many concurrent readers and writers performing a variety of tasks. We achieve this by separating file system control, which passes through the master, from data transfer, which passes directly between chunkservers and clients. Master involvement in common operations is minimized by a large chunk size and by chunk leases, which <code>delegates</code> <code>authority</code> to primary replicas in data mutations. This makes possible a simple, <code>centralized</code> master that does not become a bottleneck. We believe that improvements in our networking stack will <code>lift</code> the current limitation on the write throughput seen by an individual client.</p>
<div class="note info">
            <p>我们的设计对于多个并行的reader和writer的运行中的多种任务呈现出高聚合吞吐。我们通过分离传递给Master的文件系统控制信息，和直接在chunskervers于客户端见传输的数据，来实现。通过大的chunk大小参数和chunk的租约机制来最小化master参与到常用操作中，通过在数据变更的时候将权限委托给primaey副本。这使得简单，集中的master不会成为瓶颈。我们相信我们网络栈的提高将会改进现在对于单个客户端写吞吐量的限制</p>
          </div>

<p>GFS has successfully met our storage needs and is widely used within Google as the storage platform for research and development as well as production data processing. It is an important tool that enables us to continue to <code>innovate</code> and <code>attack</code> problems on the scale of the entire web.</p>
<div class="note info">
            <p>GFS已经成功的实现了我们的存储需求并作为存储平台在谷歌内部广泛使用，用于研究和开发以及生产数据的处理。它是个重要的工具，对于能够使我们在整个网络规模上继续进行创建和解决问题</p>
          </div>

<hr>
<h2 id="ACKNOWLEDGMENTS"><a href="#ACKNOWLEDGMENTS" class="headerlink" title="ACKNOWLEDGMENTS"></a>ACKNOWLEDGMENTS</h2><p>We wish to thankthe following people for their contributions to the system or the paper. Brain Bershad (our shepherd) and the anonymous reviewers gave us valuable comments and suggestions. Anurag Acharya, Jeff Dean, and David desJardins contributed to the early design. Fay Chang worked on comparison of replicas across chunkservers. Guy Edjlali worked on storage quota. Markus Gutschke worked on a testing frameworkand security enhancements. David Kramer worked on performance enhancements. Fay Chang, Urs Hoelzle, Max Ibel, Sharon Perl, Rob Pike, and Debby Wallach commented on earlier drafts of the paper. Many of our colleagues at Google bravely trusted their data to a new file system and gave us useful feedback. Yoshka helped with early testing.</p>
<hr>
<h2 id="REFERENCES"><a href="#REFERENCES" class="headerlink" title="REFERENCES"></a>REFERENCES</h2><p>[1] Thomas Anderson, Michael Dahlin, Jeanna Neefe, David Patterson, Drew Roselli, and Randolph Wang. Serverless networkfile systems. In Proceedings of the<br>15th ACM Symposium on Operating System Principles, pages 109–126, Copper Mountain Resort, Colorado, December 1995.</p>
<p>[2] Remzi H. Arpaci-Dusseau, Eric Anderson, Noah Treuhaft, David E. Culler, Joseph M. Hellerstein, David Patterson, and Kathy Yelick. Cluster I/O with River: Making the fast case common. In Proceedings of the Sixth Workshop on Input/Output in Parallel and Distributed Systems (IOPADS ’99), pages 10–22, Atlanta, Georgia, May 1999.</p>
<p>[3] Luis-Felipe Cabrera and Darrell D. E. Long. Swift: Using distributed diskstriping to provide high I/O data rates. Computer Systems, 4(4):405–436, 1991.</p>
<p>[4] Garth A. Gibson, David F. Nagle, Khalil Amiri, Jeff Butler, Fay W. Chang, Howard Gobioff, Charles Hardin, ErikRiedel, David Rochberg, and Jim Zelenka. A cost-effective, high-bandwidth storage architecture. In Proceedings of the 8th Architectural Support for Programming Languages and Operating Systems, pages 92–103, San Jose, California, October 1998.</p>
<p>[5] John Howard, Michael Kazar, Sherri Menees, David Nichols, Mahadev Satyanarayanan, Robert Sidebotham, and Michael West. Scale and performance in a distributed file system. ACM Transactions on Computer Systems, 6(1):51–81, February 1988.</p>
<p>[6] InterMezzo. <a href="http://www.inter-mezzo.org/">http://www.inter-mezzo.org</a>, 2003.</p>
<p>[7] Barbara Liskov, Sanjay Ghemawat, Robert Gruber, Paul Johnson, Liuba Shrira, and Michael Williams. Replication in the Harp file system. In 13th Symposium on Operating System Principles, pages 226–238, Pacific Grove, CA, October 1991.</p>
<p>[8] Lustre. <a href="http://www.lustreorg/">http://www.lustreorg</a>, 2003.</p>
<p>[9] David A. Patterson, Garth A. Gibson, and Randy H. Katz. A case for redundant arrays of inexpensive disks (RAID). In Proceedings of the 1988 ACM SIGMOD<br>International Conference on Management of Data, pages 109–116, Chicago, Illinois, September 1988.</p>
<p>[10] FrankSchmuckand Roger Haskin. GPFS: A shared-diskfile system for large computing clusters. In Proceedings of the First USENIX Conference on File<br>and Storage Technologies, pages 231–244, Monterey, California, January 2002.</p>
<p>[11] Steven R. Soltis, Thomas M. Ruwart, and Matthew T. O’Keefe. The Gobal File System. In Proceedings of the Fifth NASA Goddard Space Flight Center Conference<br>on Mass Storage Systems and Technologies, College Park, Maryland, September 1996.</p>
<p>[12] Chandramohan A. Thekkath, Timothy Mann, and Edward K. Lee. Frangipani: A scalable distributed file system. In Proceedings of the 16th ACM Symposium<br>on Operating System Principles, pages 224–237, Saint-Malo, France, October 1997.</p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000023309479">其他翻译</a></p>
<div class="pdfobject-container" data-target="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/gfs-sosp2003.pdf" data-height="1000px"></div>]]></content>
  </entry>
</search>
