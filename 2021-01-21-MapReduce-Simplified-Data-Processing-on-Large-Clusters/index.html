<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/river.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"riverferry.site","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="尝试翻译一下，会大量参考翻译软件和其他翻译文章，纯自学，无其他用途。参考文章在文末，原文在此: MapReduce: Simplified Data Processing on Large Clusters 翻译的工作量超出了预期，让我产生了投入回报比的疑惑，这种积累需要很长时期的沉淀，而目前我的重点应该是内容而不是语言的形式。所以后面应该会依赖于对翻译文章的搜索以及各种翻译软件的使用。英文水平提">
<meta property="og:type" content="article">
<meta property="og:title" content="[译文]MapReduce: Simplified Data Processing on Large Clusters">
<meta property="og:url" content="https://riverferry.site/2021-01-21-MapReduce-Simplified-Data-Processing-on-Large-Clusters/index.html">
<meta property="og:site_name" content="TheRiver | blog">
<meta property="og:description" content="尝试翻译一下，会大量参考翻译软件和其他翻译文章，纯自学，无其他用途。参考文章在文末，原文在此: MapReduce: Simplified Data Processing on Large Clusters 翻译的工作量超出了预期，让我产生了投入回报比的疑惑，这种积累需要很长时期的沉淀，而目前我的重点应该是内容而不是语言的形式。所以后面应该会依赖于对翻译文章的搜索以及各种翻译软件的使用。英文水平提">
<meta property="og:locale">
<meta property="og:image" content="https://raw.githubusercontent.com/RiverFerry/picBed/master/Snipaste_2021-01-21_14-27-03.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/RiverFerry/picBed/master/Snipaste_2021-01-21_14-37-29.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/RiverFerry/picBed/master/Snipaste_2021-01-21_14-39-22.jpg">
<meta property="article:published_time" content="2021-01-21T00:00:00.000Z">
<meta property="article:modified_time" content="2022-09-12T16:24:32.289Z">
<meta property="article:author" content="TheRiver">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/RiverFerry/picBed/master/Snipaste_2021-01-21_14-27-03.jpg">

<link rel="canonical" href="https://riverferry.site/2021-01-21-MapReduce-Simplified-Data-Processing-on-Large-Clusters/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'default'
  };
</script>

  <title>[译文]MapReduce: Simplified Data Processing on Large Clusters | TheRiver | blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">TheRiver | blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">You have reached the world's edge, none but devils play past here</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/RiverFerry/RiverFerry.github.io" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="https://riverferry.site/2021-01-21-MapReduce-Simplified-Data-Processing-on-Large-Clusters/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="TheRiver">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TheRiver | blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          [译文]MapReduce: Simplified Data Processing on Large Clusters
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-21 00:00:00" itemprop="dateCreated datePublished" datetime="2021-01-21T00:00:00+00:00">2021-01-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-12 16:24:32" itemprop="dateModified" datetime="2022-09-12T16:24:32+00:00">2022-09-12</time>
              </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>58k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>53 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>尝试翻译一下，会大量参考翻译软件和其他翻译文章，纯自学，无其他用途。参考文章在文末，原文在此: <a target="_blank" rel="noopener" href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf">MapReduce: Simplified Data Processing on Large Clusters</a></p>
<p>翻译的工作量超出了预期，让我产生了投入回报比的疑惑，这种积累需要很长时期的沉淀，而目前我的重点应该是内容而不是语言的形式。所以后面应该会依赖于对翻译文章的搜索以及各种翻译软件的使用。英文水平提高待日后再提上日程吧。</p>
<a id="more"></a>

<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>MapReduce is a programming model and an associated implementation for processing and generating large data sets. Users specify a map function that processes a key/value pair to generate a set of intermediate key/value pairs, and a reduce function that merges all intermediate values associated with the same intermediate key. Many real world tasks are expressible in this model, as shown in the paper.</p>
<div class="note info">
            <p>MapReduce一种编程模型，和处理，生成大数据库集的相关实现。用户指定一个map函数，处理k/v pair并生成中间的k/v pair,以及一个reduce函数来合并所有相同的中间key对应的中间value.很多真实世界的任务都可以通过这个模型表示，如本文描述的那样。</p>
          </div>

<p>Programs written in this functional style are automatically <code>parallelized</code> and executed on a large cluster of <code>commodity</code> machines. The run-time system takes care of the details of partitioning the input data, scheduling the program’s execution across a set of machines, handling machine failures, and managing the required inter-machine communication. This allows programmers without any experience with parallel and <code>distributed</code> systems to easily <code>utilize</code> the resources of a large distributed system.</p>
<div class="note info">
            <p>用MapReduce这种函数风格实现的程序能够自动实现并行化，可以运行在大的商用集群中。运行时系统负责一些细节：划分输入数据，调度程序在一组机器上执行，处理机器故障，管理内部机器间的交流请求。这使毫无并行以及分布式经验的程序员能够很容易的利用一个大的分布式系统的资源。</p>
          </div>

<p>Our implementation of MapReduce runs on a large cluster of <code>commodity</code> machines and is highly <code>scalable</code>: a typical MapReduce <code>computation</code> processes many <code>terabytes</code> of data on thousands of machines. Programmers find the system easy to use: hundreds of MapReduce programs have been implemented and <code>upwards</code> of one thousand MapReduce jobs are executed on Google’s clusters every day.</p>
<div class="note info">
            <p>我们对MapReduce的实现可在大的商业集群上运行并有很好的扩展性：一个典型的在数千台机器上处理TB级数据的MapReduce计算。谷歌程序员觉得这种系统很容易使用：已经有数百个MapReduce被实现，谷歌的集群上每天运行一千个mapReduce作业</p>
          </div>

<hr>
<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><p>Over the past five years, the authors and many others at Google have implemented hundreds of special-purpose computations that process large <code>amounts</code> of <code>raw data</code>, such as <code>crawled</code> documents, web request logs, etc., to compute <code>various kinds of</code> derived data, such as <code>inverted indices</code>, various <code>representations</code> of the <code>graph</code> structure of web documents, <code>summaries</code> of the number of pages crawled per host, the set of most frequent queries in a given day, etc. Most such computations are <code>conceptually straightforward</code>. However, the input data is usually large and the computations have to be distributed across hundreds or thousands of machines in order to finish in a reasonable amount of time. The issues of how to parallelize the computation, distribute the data, and handle failures <code>conspire</code> to <code>obscure </code>the original simple computation with large amounts of complex code to deal with these issues.</p>
<div class="note info">
            <p>过去5年，笔者和许多谷歌人员已经实现了数百个用于特定用途的计算过程，包括处理大量的原始数据(比如抓取的文档，web请求日志等)，处理各种衍生数据(如反向索引，各种网页文档中图结构的表示,单台主机抓取网页数量概要，指定日期top频次查询的集合等)。大多数这类计算在概念上是直截了当的。然而输入数据通常很大，需要成百上千台机器通过分布式计算以在合理时间内完成。解决并行计算，分布式数据，错误处理这些问题引入了大量复杂的代码将原本简单的计算变得晦涩难懂。</p>
          </div>

<p>As a reaction to this complexity, we designed a new abstraction that allows us to express the simple computations we were trying to perform but hides the messy details of parallelization, fault-tolerance, data distribution and load balancing in a library. Our abstraction is <code>inspired</code> by the map and reduce <code>primitives</code> present in Lisp and many other functional languages. We realized that<br>most of our computations <code>involved</code> applying a map operation to each logical “record” in our input in order to compute a set of intermediate key/value pairs, and then applying a reduce operation to all the values that shared the same key, in order to <code>combine</code> the derived data appropriately. Our use of a functional model with userspecified map and reduce operations allows us to parallelize large computations easily and to use re-execution as the primary <code>mechanism</code> for fault tolerance.</p>
<div class="note info">
            <p>作为对这种复杂性的回应，我们设计了一个新的抽象，允许我们将计算进行简单的表达，而隐藏对于并行，容错，分布式计算，负载均衡这些复杂的细节。我们实现的抽象，受到了当下Lisp等函数式语言的启发。我们意识到大多数的计算都涉及到对于每一个输入的逻辑数据的map操作从而计算出一个中间的k/v pair的集合，然后对于所有相同key的value,进行reduce操作,从而适当的合并这些衍生的数据。使用这种通过用户指定map reduce操作的函数模型让我们可以很容易的将大型计算并行化，并且以恢复执行作为容错的机制。</p>
          </div>

<p>The major <code>contributions</code> of this work are a simple and powerful interface that enables automatic parallelization and distribution of <code>large-scale</code> computations, combined with an implementation of this interface that <code>achieve</code>s high performance on large clusters of <code>commodity</code> PCs.</p>
<div class="note info">
            <p>这份工作主要的贡献是提供一个简单而强大的接口，能够自动实现并行化和大规模分布式计算。结合这些接口的实现能够在大的商用pc集群中有很好的表现。</p>
          </div>

<p>Section 2 describes the basic programming model and gives several examples. Section 3 describes an implementation of the MapReduce interface tailored towards our cluster-based computing environment. Section 4 describes several <code>refinements</code> of the programming model that we have found useful. Section 5 has performance <code>measurements</code> of our implementation for a <code>variety</code> of tasks. Section 6 explores the use of MapReduce within Google including our experiences in using it as the basis for a rewrite of our production indexing system. Section 7 discusses related and future work.</p>
<div class="note info">
            <p>第二部分描述了简单的程序模型并提供了几个例子。第三部分描述了对于我们基础计算集群环境上量身定制的MapReduce接口的实现。第四部分描述了几种我们已经发现的有用的程序模型的细化。第五部分展示了我们的实现对于各种各样任务的数据表现。第六部分探索了谷歌内部基于MapReduce改写我们的索引系统中的经验。第七部分讨论了相关的和未来的工作。</p>
          </div>

<hr>
<h2 id="2-Programming-Model"><a href="#2-Programming-Model" class="headerlink" title="2 Programming Model"></a>2 Programming Model</h2><p>The computation takes a set of input key/value pairs, and produces a set of output key/value pairs. The user of the MapReduce library expresses the computation as two functions: Map and Reduce.</p>
<div class="note info">
            <p>计算过程使用一个输入的k/v pair集合，产出一个输出的k/v pair集合。MapReduce库的用户通过map和reduce函数来使用。</p>
          </div>

<p>Map, written by the user, takes an input pair and produces a set of intermediate key/value pairs. The MapReduce library groups together all intermediate values associated with the same intermediate key I and passes them to the Reduce function.</p>
<div class="note info">
            <p>map函数由用户实现，使用一个输入的pair然后产出一个中间的kv pair.MapReduce库对所有有相同key的中间值进行组合然后传递给reduce函数。</p>
          </div>

<p>The Reduce function, also written by the user, accepts an intermediate key I and a set of values for that key. It merges together these values to form a possibly smaller set of values. Typically just zero or one output value is produced per Reduce invocation. The intermediate values are supplied to the user’s reduce function via an iterator. This allows us to handle lists of values that are too large to fit in memory.</p>
<div class="note info">
            <p>reduce函数也由用户实现，接受一个中间的key和该key对应的value的集合，合并这些值并构造出一个更小的值得集合。典型的o或1作为reduce函数每次执行的输出。中间值通过迭代器提供给用户的reduce函数。这允许我们处理哪些太大以至于不能保存在内存中的以链表保存的值。</p>
          </div>

<hr>
<h3 id="2-1-Example"><a href="#2-1-Example" class="headerlink" title="2.1 Example"></a>2.1 Example</h3><p>Consider the problem of counting the number of occurrences of each word in a large collection of documents. The user would write code similar to the following <code>pseudo-code</code>:</p>
<div class="note info">
            <p>思考统计一个大的文档中单词出现次数的问题。用户可以很简单的写出如下的伪代码。</p>
          </div>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">map(String key, String value):</span><br><span class="line">    &#x2F;&#x2F; key: document name</span><br><span class="line">    &#x2F;&#x2F; value: document contents</span><br><span class="line">    for each word w in value:</span><br><span class="line">        EmitIntermediate(w, &quot;1&quot;);</span><br><span class="line"></span><br><span class="line">reduce(String key, Iterator values):</span><br><span class="line">    &#x2F;&#x2F; key: a word</span><br><span class="line">    &#x2F;&#x2F; values: a list of counts</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    for each v in values:</span><br><span class="line">        result +&#x3D; ParseInt(v);</span><br><span class="line">    Emit(AsString(result));</span><br></pre></td></tr></table></figure>

<p>The map function emits each word plus an associated count of occurrences (just ‘1’ in this simple example). The reduce function sums together all counts emitted for a <code>particular</code> word.</p>
<div class="note info">
            <p>map函数发射每一个单词加上关联的次数(本例中是1)。reduce函数统计所有发出的特定单词的次数。</p>
          </div>

<p>In addition, the user writes code to fill in a mapreduce specification object with the names of the input and output files, and optional <code>tuning parameters</code>. The user then invokes the MapReduce function, passing it the specification object. The user’s code is linked together with the MapReduce library (implemented in C++). Appendix A contains the full program text for this example.</p>
<div class="note info">
            <p>除此之外，用户实现代码用输入输出文件名和可选的调优参数填充特定的mapreduce函数。然后传递特定的对象并执行MapReduce函数。用户的代码和MapReduce库链接起来(用c++实现)。附录A包含完整的此实例的代码。</p>
          </div>

<hr>
<h3 id="2-2-Types"><a href="#2-2-Types" class="headerlink" title="2.2 Types"></a>2.2 Types</h3><p>Even though the previous pseudo-code is written in terms of string inputs and outputs, <code>conceptually</code> the map and reduce functions supplied by the user have associated types:</p>
<div class="note info">
            <p>即使前面伪代码里面用string作为输入和输出，概念上用户提供的map和reduce函数是和类型关联的：</p>
          </div>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map (k1,v1) → list(k2,v2)</span><br><span class="line">reduce (k2,list(v2)) → list(v2)</span><br></pre></td></tr></table></figure>

<p>I.e., the input keys and values are <code>drawn from</code> a different domain than the output keys and values. Furthermore, the intermediate keys and values are from the same domain as the output keys and values.</p>
<div class="note info">
            <p>输入的k/v和输出的k/v来自不同的域。此外，中间的k/v和输出的k/v来自同一域。</p>
          </div>

<p>Our C++ implementation passes strings to and from the user-defined functions and leaves it to the user code to convert between strings and appropriate types.</p>
<div class="note info">
            <p>我们的c++实现传递string到用户定义的函数，用户代码将string和相应的类型进行转换。</p>
          </div>

<hr>
<h3 id="2-3-More-Examples"><a href="#2-3-More-Examples" class="headerlink" title="2.3 More Examples"></a>2.3 More Examples</h3><p>Here are a few simple examples of interesting programs that can be easily expressed as MapReduce computations.</p>
<div class="note info">
            <p>这里有一些简单有趣的程序可以容易的用于MapRedece计算</p>
          </div>

<p><strong>Distributed Grep</strong>: The map function emits a line if it matches a supplied pattern. The reduce function is an <code>identity function</code> that just copies the supplied intermediate data to the output.</p>
<div class="note info">
            <p>分布式grep: map函数如果匹配到特定模式则发射一行。reduce函数复制中间数据到输出。</p>
          </div>

<p><strong>Count of URL Access Frequency</strong>: The map function processes logs of web page requests and outputs (URL, 1). The reduce function adds together all values for the same URL and emits a (URL, total count) pair.</p>
<div class="note info">
            <p>统计url访问频率：map函数处理网页输入和输出日志(url, 1). reduce函数把所有相同url的值加起来然后发射(url, total count)pair.</p>
          </div>

<p><strong>Reverse Web-Link Graph</strong>: The map function outputs (target, source) pairs for each link to a target URL found in a page named source. The reduce function <code>concatenates</code> the list of all source URLs associated with a given target URL and emits the pair: (target, list(source))</p>
<div class="note info">
            <p>反向web链接图：map函数对于source页中每一个指向target的链接都输出一个(target, source)pair. reduce函数将所有和给定target相关联的source串联成链表然后发送：(target, list(source)) pair.</p>
          </div>

<p><strong>Term-Vector per Host</strong>: A term vector summarizes the most important words that occur in a document or a set of documents as a list of (word, frequency) pairs. The map function emits a (hostname, term vector) pair for each input document (where the hostname is extracted from the URL of the document). The reduce function is passed all per-document term vectors for a given host. It adds these term vectors together, throwing away <code>infrequent</code> terms, and then emits a final (hostname, term vector) pair.</p>
<div class="note info">
            <p>每台主机的关键词向量： 关键词向量概括了一个或一组文档中出现的最重要的单词，形如(word, frequency) pair的链表。map函数对于每一个输入数据(其中hostname是从文档的Url中提取的)发射(hostname, term vector)pair. 给定主机的所有关键词向量都会传递给reduce函数。reduce函数将这些关键词向量相加，去掉频率较低的关键词，然后发射最终的(hostname, term vector) pair.</p>
          </div>

<p><strong>Inverted Index</strong>: The map function parses each document, and emits a sequence of (word, document ID) pairs. The reduce function accepts all pairs for a given word, sorts the <code>corresponding </code>document IDs and emits a (word, list(document ID)) pair. The set of all output pairs forms a simple inverted index. It is easy to <code>augment</code> this computation to keep track of word positions.</p>
<div class="note info">
            <p>反向索引(倒排索引)：map函数解析每一个文件，然后发射一个有序的(word, document id)pair. reduce函数接收所有给定单词的所有pairs,对document ids进行排序然后发射(word, list(document id))pair.所有输出的pairs组成一个简单的反向索引。通过扩展这个计算来跟踪单词位置是很容易的。</p>
          </div>

<p><strong>Distributed Sort</strong>: The map function <code>extracts</code> the key from each record, and emits a (key, record) pair. The reduce function emits all pairs unchanged. This computation depends on the partitioning <code>facilities</code> described in Section 4.1 and the <code>ordering properties</code> described in Section 4.2.</p>
<div class="note info">
            <p>分布式排序：map函数从每一个记录中提取key,然后发射(key, record) pair. reduce函数发射所有未改变的pairs.这个计算依赖于4.1节描述的划分机制以及4.2节描述的排序性质。</p>
          </div>

<hr>
<h2 id="3-Implementation"><a href="#3-Implementation" class="headerlink" title="3 Implementation"></a>3 Implementation</h2><p>Many different implementations of the MapReduce interface are possible. The right choice depends on the environment. For example, one implementation may be suitable for a small shared-memory machine, another for a large NUMA multi-processor, and yet another for an even larger collection of networked machines.</p>
<div class="note info">
            <p>许多不同MapReduce接口的实现都是可能的。正确的选择依赖于环境。例如，有的实现可能适合一个小的共享内存机器，有的适合大的NUMA多处理器，也有的适合大的网络机器集合</p>
          </div>

<p>This section describes an implementation targeted to the computing environment in wide use at Google:</p>
<div class="note info">
            <p>这个部分描述的实现主要针对谷歌使用的计算环境：</p>
          </div>

<p>large clusters of commodity PCs connected together with switched Ethernet [4]. In our environment:</p>
<div class="note info">
            <p>大集群的商用pc机通过以太网连接在一起，在我们的环境中：</p>
          </div>


<p>(1) Machines are typically dual-processor x86 processors running Linux, with 2-4 GB of memory per machine.</p>
<div class="note info">
            <p>(1) 每台机器都是典型的基于x86架构的运行在linux下的2-4g内存的配置</p>
          </div>

<p>(2) Commodity networking hardware is used – typically either 100 megabits/second or 1 gigabit/second at the machine level, but averaging considerably less in <code>overall</code> <code>bisection bandwidth</code>.</p>
<div class="note info">
            <p>(2) 使用商用的网络硬件-在机器层面上通常是100mb/s或者1g/s，但平均下来少于整体带宽一般的速度。</p>
          </div>

<p>(3) A cluster consists of hundreds or thousands of machines, and therefore machine failures are common.</p>
<div class="note info">
            <p>(3) 成百上千机器组成的集群，所以机器故障会很常见</p>
          </div>

<p>(4) Storage is provided by inexpensive IDE disks attached directly to <code>individual</code> machines. A distributed file system [8] developed <code>in-house</code> is used to manage the data stored on these disks. The file system uses replication to provide availability and reliability on top of unreliable hardware.</p>
<div class="note info">
            <p>(4) 廉价IDE磁盘嵌入到个人机作为存储。内部开发的文件系统用来管理这些存储在磁盘的数据。文件系统使用复制来保证在不可靠的硬件上提供可用性，可靠性</p>
          </div>

<p>(5) Users submit jobs to a scheduling system. Each job consists of a set of tasks, and is mapped by the scheduler to a set of available machines within a cluster.</p>
<div class="note info">
            <p>(5) 用户提交作业到调度系统。每个作业由一组任务组成，通过调度器映射到集群中一组可用的机器。</p>
          </div>

<hr>
<h3 id="3-1-Execution-Overview"><a href="#3-1-Execution-Overview" class="headerlink" title="3.1 Execution Overview"></a>3.1 Execution Overview</h3><p>The Map invocations are distributed across multiple machines by automatically partitioning the input data into a set of M splits. The input splits can be processed in parallel by different machines. Reduce invocations are distributed by partitioning the intermediate key space into R pieces using a partitioning function (e.g., hash(key) mod R). The number of partitions (R) and the partitioning function are specified by the user.</p>
<div class="note info">
            <p>通过自动化的将输入数据分割成M块的集合，map调用可以在多台机器上分布式执行。输入数据可以通过不同的机器并行处理。reduce通过分割函数(eg., hash(key) mod R)分割中间数据成R块来分布式调用。R的数量和分割函数由用户指定</p>
          </div>

<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/Snipaste_2021-01-21_14-27-03.jpg"></p>
<p>Figure 1 shows the <code>overall flow</code> of a MapReduce operation in our implementation. When the user program calls the MapReduce function, the following sequence of actions occurs (the numbered labels in Figure 1 <code>correspond</code> to the numbers in the list below):</p>
<div class="note info">
            <p>图一展示了实现的MapReduce操作的总体流程。用户调用MapReduce函数的时候，会发生下面的行为(图一的标号和下面列表的数字对应)</p>
          </div>

<ol>
<li>The MapReduce library in the user program first splits the input files into M pieces of typically 16 megabytes to 64 megabytes (MB) per piece (controllable by the user via an optional parameter). It then starts up many copies of the program on a cluster of machines.</li>
</ol>
<div class="note info">
            <ol><li>MapReduce库在用户程序中首先分割输入数据成典型的16m-64m(用户通过可选参数指定)大小的M片，然后在集群中启动多个程序的副本</li></ol>
          </div>

<ol start="2">
<li>One of the copies of the program is special – the master. The rest are workers that are assigned work by the master. There are M map tasks and R reduce tasks to assign. The master picks idle workers and assigns each one a map task or a reduce task.</li>
</ol>
<div class="note info">
            <ol start="2"><li>其中一个副本程序时特殊的-主节点。其余的工作节点通过主节点分配工作。一共有m个map任务和r个reduce任务需要分配。主节点选择一个idle的工作节点执行map或者reduce任务</li></ol>
          </div>

<ol start="3">
<li>A worker who is assigned a map task reads the contents of the corresponding input split. It parses key/value pairs out of the input data and passes each pair to the user-defined Map function. The intermediate key/value pairs produced by the Map function are buffered in memory.</li>
</ol>
<div class="note info">
            <ol><li>被分配map任务的worker(工作节点)读取相应输入块的内容。worker解析输入文件成k/v pair然后发给用户定义的map函数。map函数生成中间的k/v pair并缓存在内存中</li></ol>
          </div>

<ol start="4">
<li><code>Periodically</code>, the buffered pairs are written to local disk, partitioned into <code>R regions</code> by the partitioning function. The locations of these buffered pairs on the local disk are passed back to the master, who is <code>responsible</code> for forwarding these locations to the reduce workers.</li>
</ol>
<div class="note info">
            <ol start="4"><li>缓存的pair会定期的写入本地磁盘，通过分割函数分割到R个块。存在本地磁盘的缓存pairs将被传递给master,由master负责传递给reduce workers</li></ol>
          </div>

<ol start="5">
<li>When a reduce worker is notified by the master about these locations, it uses remote procedure calls to read the buffered data from the local disks of the map workers. When a reduce worker has read all intermediate data, it sorts it by the intermediate keys so that all occurrences of the same key are grouped together. The sorting is needed because typically many different keys map to the same reduce task. If the amount of intermediate data is too large to fit in memory, an external sort is used.</li>
</ol>
<div class="note info">
            <ol start="5"><li>当reduce work收到master发来的位置通知信息，会通过rpc从map workers读取缓存的pairs. reduce读取完所有的中间数据后，将对所有的中间keys进行排序分组。之所以排序是因为通常多个不同的keys会映射到同一个reduce task. 如果中间数据太大以至于内存放不下，则会使用外部排序</li></ol>
          </div>

<ol start="6">
<li>The reduce worker iterates over the sorted intermediate data and for each unique intermediate key encountered, it passes the key and the corresponding set of intermediate values to the user’s Reduce function. The output of the Reduce function is appended to a final output file for this reduce partition.</li>
</ol>
<div class="note info">
            <ol start="6"><li>reduce worker迭代的对唯一的中间keys进行排序统计， 传递key和相应的value到用户的Reduce函数。 Reduce函数输出会追加到该reduce work的最终输出文件。</li></ol>
          </div>

<ol start="7">
<li>When all map tasks and reduce tasks have been completed, the master wakes up the user program. At this point, the MapReduce call in the user program returns back to the user code.</li>
</ol>
<div class="note info">
            <ol start="7"><li>当所有的map和reduce task处理完成， master会唤醒用户程序。 然后MapReduce调用结束返回到用户代码</li></ol>
          </div>

<p>After successful completion, the output of the mapreduce execution is available in the R output files (one per reduce task, with file names as specified by the user). Typically, users do not need to combine these R output files into one file – they often pass these files as input to another MapReduce call, or use them from another distributed application that is able to deal with input that is partitioned into multiple files.</p>
<div class="note info">
            <p>成功执行后，MapReduce将输出写入到R个输出文件(每一个reduce任务都有一个由用户指定的文件名)。 通常用户不需要合并这R个文件到一个文件中-一般会将这些文件作为输入传递给其他的MapReduce调用， 或者使用那些能够处理以多个文件作为输入的分布式程序</p>
          </div>

<hr>
<h3 id="3-2-Master-Data-Structures"><a href="#3-2-Master-Data-Structures" class="headerlink" title="3.2 Master Data Structures"></a>3.2 Master Data Structures</h3><p>The master keeps several data structures. For each map task and reduce task, it stores the state (idle, in-progress, or completed), and the identity of the worker machine (for non-idle tasks).</p>
<div class="note info">
            <p>master有几种数据结构。对于每一个map任务和reduce任务，master会保存状态(idle, in-progress, or completed)，对于非空闲的任务还会保存任务的ID</p>
          </div>

<p>The master is the <code>conduit</code> through which the location of intermediate file <code>regions</code> is <code>propagated</code> from map tasks to reduce tasks. Therefore, for each completed map task, the master stores the locations and sizes of the R intermediate file regions produced by the map task. Updates to this location and size information are received as map tasks are completed. The information is pushed <code>incrementally</code> to workers that have in-progress reduce tasks.</p>
<div class="note info">
            <p>主节点是map任务将中间文件的位置信息传递给reduce任务的渠道。因此，对于每一个完成的map任务，master保存其R个中间文件(map task生成的)的位置和大小。map任务完成的时候会受到更新位置和大小的通知。这些信息会逐步推送给处于in-progress状态的reduce worker.</p>
          </div>

<hr>
<h3 id="3-3-Fault-Tolerance"><a href="#3-3-Fault-Tolerance" class="headerlink" title="3.3 Fault Tolerance"></a>3.3 Fault Tolerance</h3><p>Since the MapReduce library is designed to help process very large amounts of data using hundreds or thousands of machines, the library must tolerate machine failures <code>gracefully</code>.</p>
<div class="note info">
            <p>因为MapReduce库是设计用来通过数千台机器处理非常大的数据，所以该库必须能够优雅的处理机器故障。</p>
          </div>

<hr>
<h3 id="Worker-Failure"><a href="#Worker-Failure" class="headerlink" title="Worker Failure"></a>Worker Failure</h3><p>The master pings every worker <code>periodically</code>. If no response is received from a worker in a <code>certain</code> amount of time, the master marks the worker as failed. Any map tasks completed by the worker are reset back to their <code>initial</code> idle state, and therefore become <code>eligible</code> for scheduling on other workers. Similarly, any map task or reduce task in progress on a failed worker is also reset to idle and becomes eligible for rescheduling.</p>
<div class="note info">
            <p>master定时ping所有的worker(工作节点).如果没有在一定的时间内收到响应，master会标记这些work为failed状态。这个工作节点的所有已完成任务都会被重置为初始的idle状态，其他工作节点就可以处理这些任务了。类似的，任何一个故障的worker中未完成的map或reduce任务，也会被置为idle状态，等待重新调度</p>
          </div>

<p>Completed map tasks are re-executed on a failure because their output is stored on the local disk(s) of the failed machine and is therefore inaccessible. Completed reduce tasks do not need to be re-executed since their output is stored in a global file system.</p>
<div class="note info">
            <p>已完成的map任务遇到错误会重新执行，因为输出保存在故障机器的本地磁盘中所以是不可访问的。已完成的reduce task不需要从新执行，因为输出存储在公共的文件系统中。</p>
          </div>

<p>When a map task is executed first by worker A and then later executed by worker B (because A failed), all workers executing reduce tasks are notified of the reexecution. Any reduce task that has not already read the data from worker A will read the data from worker B.</p>
<div class="note info">
            <p>当一个map task一开始在worker a执行然后在worker b执行(因为work a)故障了，所有执行reduce task的worker都被收到通知。任何还没有从worker a读取数据的reduce task都会从work b开始读取数据。</p>
          </div>

<p>MapReduce is <code>resilient</code> to large-scale worker failures. For example, during one MapReduce operation, <code>network maintenance</code> on a running cluster was causing groups of 80 machines at a time to become unreachable for several minutes. The MapReduce <code>mastersimply</code> re-executed the work done by the unreachable worker machines, and continued to make forward progress, eventually completing the MapReduce operation.</p>
<div class="note info">
            <p>MapReduce能够弹性处理大规模工作节点故障。比如，网络维护导致80台机器同时持续几分钟不可访问。MapReduce会重新执行网络不可达的worker，然后继续向前执行，最终完成所有的MapReduce操作。</p>
          </div>

<h3 id="Master-Failure"><a href="#Master-Failure" class="headerlink" title="Master Failure"></a>Master Failure</h3><p>It is easy to make the master write <code>periodic</code> checkpoints of the master data structures described above. If the master task dies, a new copy can be started from the last checkpointed state. However, given that there is only a single master, its failure is unlikely; therefore our current implementation aborts the MapReduce computation if the master fails. Clients can check for this condition and retry the MapReduce operation if they <code>desire</code>.</p>
<div class="note info">
            <p>master可以很容易的将前面描述的数据结构写成checkpoint。如果master task失败了，可以从最新的checkpoint开始新的程序副本。然而，给定的只有一台主节点,它也不太可能失败。所以现在的MapReduce没有实现对于master fails的处理。如果客户端需要的话，可以自己检查这种情况然后重新尝试MapReduce操作。</p>
          </div>
<h3 id="Semantics-in-the-Presence-of-Failures"><a href="#Semantics-in-the-Presence-of-Failures" class="headerlink" title="Semantics in the Presence of Failures"></a>Semantics in the Presence of Failures</h3><p>When the user-supplied map and reduce operators are <code>deterministic</code> functions of their input values, our distributed implementation produces the same output as would have been produced by a non-faulting sequential execution of the <code>entire</code> program.</p>
<div class="note info">
            <p>当用户提供的map和reduce函数对于输入值是确定的，我们的分布式实现和非故障顺序执行的结果是一样的。</p>
          </div>

<p>We <code>rely</code> on atomic commits of map and reduce task outputs to achieve this <code>property</code>. Each in-progress task writes its output to private temporary files. A reduce task produces one such file, and a map task produces R such files (one per reduce task). When a map task completes, the worker sends a message to the master and includes the names of the R temporary files in the message. If the master receives a completion message for an already completed map task, it ignores the message. Otherwise, it records the names of R files in a master data structure.</p>
<div class="note info">
            <p>我们依靠原子提交map/reduce任务的输出来实现这个性质。所有in-grogress task将输出写入到自己私有的临时文件中。每个reduce task只生成一个这种文件，每个map task生成r个这种文件(每个reduce一个)。当一个map task完成的时候，会发送包含R个文件名称的消息给master。如果master从一个已经完成了的map task收到一个完成消息，会忽视掉。否则，会记录R个文件的文件名在master的数据结构中。</p>
          </div>

<p>When a reduce task completes, the reduce worker atomically renames its temporary output file to the final output file. If the same reduce task is executed on multiple machines, multiple rename calls will be executed for the same final output file. We rely on the atomic rename operation provided by the underlying file system to guarantee that the final file system state contains just the data produced by one execution of the reduce task.</p>
<div class="note info">
            <p>当reduce任务完成的时候，reduce工作节点会原子的将临时输出文件重命名为最终的输出文件。当相同的reduce任务在多台机器上执行，多个相同的对于最终输出文件的重命名调用会被执行。我们依赖底层文件系统提供的原子重命名操作来保证最终的文件系统仅包含一个reduce任务执行产生的数据。</p>
          </div>

<p><code>The vast majority</code> of our map and reduce operators are deterministic, and the fact that our semantics are equivalent to a sequential execution in this case makes it very easy for programmers to reason about their program’s behavior. When the map and/or reduce operators are nondeterministic, we provide weaker but still reasonable semantics. In the presence of non-deterministic operators, the output of a particular reduce task R1 is equivalent to the output for R1 produced by a sequential execution of the non-deterministic program. However, the output for a different reduce task R2 may correspond to the output for R2 produced by a different sequential execution of the non-deterministic program.</p>
<div class="note info">
            <p>绝大多数map和reduce操作都是确定性的，这在语义上和顺序执行是相等的，都很容易去解释程序的行为。当map或者reduce操作是不确定的时候我们提供较弱但仍旧合理的语义。对于不确定性操作，一个reduce任务R1的输出等价于一个不确定性的顺序执行的R1的输出。然而一个不同的reduce任务R2的输出可能和另外的不确定程序顺序执行下的输出R2相符。</p>
          </div>

<p>Consider map task M and reduce tasks R1 and R2. Let e(Ri) be the execution of Ri that committed (there is exactly one such execution). The weaker semantics <code>arise</code> because e(R1) may have read the output produced by one execution of M and e(R2) may have read the output produced by a different execution of M.</p>
<div class="note info">
            <p>考虑map任务M和reduce任务R1,R2. 让e(Ri)表示Ri的已提交的执行(只执行一次)。此时弱语义生效，因为e(R1)可能读取了M的输出，而e(R2)可能读取了M的另一个输出。</p>
          </div>

<hr>
<h3 id="3-4-Locality"><a href="#3-4-Locality" class="headerlink" title="3.4 Locality"></a>3.4 Locality</h3><p>Network <code>bandwidth</code> is a relatively <code>scarce</code> resource in our computing environment. We <code>conserve</code> network bandwidth by <code>taking advantage</code> of the fact that the input data (managed by GFS [8]) is stored on the local disks of the machines that make up our cluster. GFS divides each file into 64 MB blocks, and stores several copies of each block (typically 3 copies) on different machines. The MapReduce master takes the location information of the input files into account and attempts to schedule a map task on a machine that contains a <code>replica</code> of the corresponding input data. Failing that, it attempts to schedule a map task near a replica of that task’s input data (e.g., on a worker machine that is on the same network switch as the machine containing the data). When running large MapReduce operations on a <code>significant fraction</code> of the workers in a cluster, most input data is read locally and consumes no network bandwidth.</p>
<div class="note info">
            <p>局部性<br>网络带宽在我们的计算环境中是相对稀缺的资源。事实上我们利用将输入数据(通过GFS管理)存储在组成集群的机器的本地磁盘中从而节省了带宽。GFS将每个文件切割成64M大小的块，每块复制几份(通常是3份)存储到不同的机器。考虑到MapReduce master中保存了输入文件的位置信息，可以调用存储了输入数据的机器来执行map task.如果失败了，会接着尝试调度靠近存储输入数据备份的机器(比如和存储数据的机器在同一网关的其他机器)。当一个集群中大部分worker在运行一个大的MapReduce操作的时候，大多数输入数据都是本都读取的，而不消耗带宽。</p>
          </div>

<hr>
<h3 id="3-5-Task-Granularity"><a href="#3-5-Task-Granularity" class="headerlink" title="3.5 Task Granularity"></a>3.5 Task Granularity</h3><p>We <code>subdivide</code> the map phase into M pieces and the reduce phase into R pieces, as described above. <code>Ideally</code>, M and R should be much larger than the number of worker machines. Having each worker perform many different tasks <code>improves</code> dynamic load balancing, and also speeds up recovery when a worker fails: the many map tasks it has completed can be <code>spread out</code> across all the other worker machines.</p>
<div class="note info">
            <p>任务粒度<br>将map细分为M个阶段，reudce细分为R个阶段。理想情况下，M和R的总数远大于机器的worker数。每个worker都运行许多不同的任务从而提供了动态负载均衡，并且加速了worker故障的恢复：失败节点已经完成的map tasks可以扩散到到所有其他的worker中 </p>
          </div>

<p>There are <code>practical bounds</code> on how large M and R can be in our implementation, since the master must make O(M + R) scheduling decisions and keeps O(M<em>R) state in memory as described above. (The constant factors for memory usage are small however: the O(M</em>R) piece of the state consists of <code>approximately</code> one byte of data per map task/reduce task pair.)</p>
<div class="note info">
            <p>在我们的实现中,M和R有实际的上限，因为如前面所讲那样，master必须对O(M+R)做出调度决策，并存储O(M x R)的状态在内存中。(然后内存使用的常数项很小：O(M x R)个状态中每个map/reduce任务对只需要一个字节的数据)</p>
          </div>

<p>Furthermore, R is often <code>constrained</code> by users because the output of each reduce task ends up in a <code>separate</code> output file. In practice, we <code>tend to</code> choose M so that each <code>individual</code> task is <code>roughly</code> 16 MB to 64 MB of input data (so that the locality optimization described above is most effective), and we make R a small multiple of the number of worker machines we expect to use. We often perform MapReduce computations with M = 200000 and R = 5000, using 2000 worker machines.</p>
<div class="note info">
            <p>此外，R通常由用户指定，因为每一个reduce task的输出最终都保存在一个单独的输出文件中。在实践中，我们倾向于这样选择M，即将每个单独的任务都是16-64m大小的输入数据(这样前面说的局部性优化是最有效的)  因为每一个单独的任务的输入文件大小是16到64M(因为地区优化是最有效的)，并且我们选择R为我们希望使用的工作节点机器的小数倍。我们通常使用M=200000,R=5000,使用2000个worker机器来进行MapReduce计算。</p>
          </div>

<hr>
<h3 id="3-6-Backup-Tasks"><a href="#3-6-Backup-Tasks" class="headerlink" title="3.6 Backup Tasks"></a>3.6 Backup Tasks</h3><p>One of the common causes that <code>lengthens</code> the total time taken for a MapReduce operation is a “straggler”: a machine that takes an unusually long time to complete one of the last few map or reduce tasks in the computation. Stragglers can arise for a whole <code>host of reasons</code>. For example, a machine with a bad disk may experience frequent correctable errors that slow its read performance from 30 MB/s to 1 MB/s. The cluster scheduling system may have scheduled other tasks on the machine, causing it to execute the MapReduce code more slowly due to <code>competition</code> for CPU, memory, local disk, or network bandwidth. A recent problem we experienced was a bug in machine initialization code that caused processor caches to be disabled: computations on affected machines slowed down by over a <code>factor of one hundred</code>.</p>
<div class="note info">
            <p>备份任务<br>延长MapReduce操作总时间的常见原因之一是“落后者”：在计算中一台机器需要不正常的大量时间才能完成最后的几个map或者reduce任务。落后者的出现有很多原因。比如，一台机器磁盘损坏可能造成频繁的校正错误从而导致读取速度从30m/s变慢到1m/s.集群调度系统可能已经调度了其他任务在这台机器，因为需要竞争Cpu,内存，本地磁盘，网络带宽进而使得MapReduce变得更慢。我们最近遇到的一个机器初始化代码的bug造成缓存不可用：受影响的机器的计算速度下降了100倍</p>
          </div>

<p>We have a general <code>mechanism</code> to <code>alleviate</code> the problem of stragglers. When a MapReduce operation is close to completion, the master schedules backup executions of the <code>remaining</code> in-progress tasks. The task is marked as completed whenever either the primary or the backup execution completes. We have <code>tuned</code> this mechanism so that it typically increases the computational resources used by the operation by no more than a few percent. We have found that this significantly reduces the time to complete large MapReduce operations. As an example, the sort program described in Section 5.3 takes 44% longer to complete when the backup task mechanism is disabled.</p>
<div class="note info">
            <p>我们有一个一般的机制来减轻落后者的问题：当一个MapReduce操作接近完成的时候，master调度其他in-progress的tasks备份执行。不管是主要的还是备份的执行完成，task都会被master标记为已完成。我们已经调整了该机制使得其增加的计算资源不超过百分之几。我们发现这样显著的降低了完成大的MapReduce操作的时间。作为例子，5.3部分的排序程序在备份任务机制被禁用的情况下多消耗44%的时间。</p>
          </div>

<hr>
<h2 id="4-Refinements"><a href="#4-Refinements" class="headerlink" title="4 Refinements"></a>4 Refinements</h2><p>Although the basic functionality provided by simply writing Map and Reduce functions is <code>sufficient</code> for most needs, we have found a few extensions useful. These are described in this section.</p>
<div class="note info">
            <p>细化<br>尽管map reduce函数提供的基础功能已经足够使用了，我们还发现了一些有用的扩展，会在这部分描述。</p>
          </div>

<hr>
<h3 id="4-1-Partitioning-Function"><a href="#4-1-Partitioning-Function" class="headerlink" title="4.1 Partitioning Function"></a>4.1 Partitioning Function</h3><p>The users of MapReduce specify the number of reduce tasks/output files that they desire (R). Data gets partitioned across these tasks using a partitioning function on the intermediate key. A default partitioning function is provided that uses hashing (e.g. “hash(key) mod R”). This tends to result in fairly well-balanced partitions. In some cases, however, it is useful to partition data by some other function of the key. For example, sometimes the output keys are URLs, and we want all entries for a single host to end up in the same output file. To support situations like this, the user of the MapReduce library can provide a special partitioning function. For example, using “hash(Hostname(urlkey)) mod R” as the partitioning function causes all URLs from the same host to<br>end up in the same output file.</p>
<div class="note info">
            <p>MapReduce的用户可以指定他们想要的reduce tasks/output文件的数量(R).数据被划分函数通过中间key进行划分。我们提供了一个缺省的划分函数hash.这通常会生成成很好平衡性的划分。然而某些情况，其他的划分函数会更加有效。比如，有些时候输出的keys是URLs,我们希望某个主机的所有项最终都在相同的输出文件中。为了支持这种情况，MapReduce的用户可以指定一个特别的划分函数。比如使用hash(Hostname(urlkey)) mod R作为分区函数，这样所有相同主机的URLs都会在相同的输出文件。</p>
          </div>

<hr>
<h3 id="4-2-Ordering-Guarantees"><a href="#4-2-Ordering-Guarantees" class="headerlink" title="4.2 Ordering Guarantees"></a>4.2 Ordering Guarantees</h3><p>We guarantee that within a given partition, the intermediate key/value pairs are processed in increasing key order. This ordering guarantee makes it easy to generate a sorted output file per partition, which is useful when the output file format needs to support efficient random access lookups by key, or users of the output find it <code>convenient</code> to have the data sorted.</p>
<div class="note info">
            <p>我们保证在一个给定的分区内，中间的k/v pairs按照递增key的顺序处理。这种有序保证了每一个分区生成排序的输出文件变得容易，当输出文件格式需要指出按key随机有效访问，或者需要输出数据有序的时候用户会发现这很方便。</p>
          </div>

<hr>
<h3 id="4-3-Combiner-Function"><a href="#4-3-Combiner-Function" class="headerlink" title="4.3 Combiner Function"></a>4.3 Combiner Function</h3><p>In some cases, there is significant <code>repetition</code> in the intermediate keys produced by each map task, and the userspecified Reduce function is <code>commutative</code> and <code>associative</code>. A good example of this is the word counting example in Section 2.1. Since word frequencies tend to follow a Zipf distribution, each map task will produce hundreds or thousands of records of the form &lt;the, 1&gt;. All of these counts will be sent over the network to a single reduce task and then added together by the Reduce function to produce one number. We allow the user to specify an optional Combiner function that does partial merging of this data before it is sent over the network.</p>
<div class="note info">
            <p>合并函数<br>某些情况下，每一个map task生成的中间key有大量重复，并且用户指定的reduce函数可进行交换组合。一个好的例子是2.1节的单词统计例子，因为单词频率分布倾向于Zipf分布，每一个map task从&lt;the, 1&gt;中都会生成成百上千个记录。所有这些次数会通过网络发送给一个简单的reduce task，通过一个reduce函数加起来生成一个总数。我们允许用户指定一个可选的Combiner函数，在发送之前进行部分合并。</p>
          </div>

<p>The Combiner function is executed on each machine that performs a map task. Typically the same code is used to implement both the combiner and the reduce functions. The only difference between a reduce function and a combiner function is how the MapReduce library handles the output of the function. The output of a reduce function is written to the final output file. The output of a combiner function is written to an intermediate file that will be sent to a reduce task.</p>
<div class="note info">
            <p>Combiner函数在任意机器上作为map task运行。典型的combiner和reduce函数使用相同的代码实现。Combiner和Reduce函数的区别是MapReduce库如何处理输出数据。MapReduce函数的输出数据写在最终的输出文件。Combiner函数的输出数据写在中间文件然后发送给reduce task.</p>
          </div>

<p>Partial combining significantly speeds up certain classes of MapReduce operations. Appendix A contains an example that uses a combiner.</p>
<div class="note info">
            <p>部分合并能够显著加快各种MapReduce操作。附录A有一个使用combiner的例子。</p>
          </div>

<hr>
<h3 id="4-4-Input-and-Output-Types"><a href="#4-4-Input-and-Output-Types" class="headerlink" title="4.4 Input and Output Types"></a>4.4 Input and Output Types</h3><p>The MapReduce library provides support for reading input data in several different formats. For example, “text” mode input treats each line as a key/value pair: the key is the offset in the file and the value is the contents of the line. Another common supported format stores a sequence of key/value pairs sorted by key. Each input type implementation knows how to split itself into <code>meaningful</code> ranges for processing as separate map tasks (e.g. text mode’s range splitting ensures that range splits occur only at line boundaries). Users can add support for a new input type by providing an implementation of a simple reader interface, though most users just use one of a small number of <code>predefined</code> input types.</p>
<div class="note info">
            <p>MapReduce库提供了几种不同的格式来读取输入文件。比如，文本模式的输入文件的每一行作为一个k/v pair:key是在文件中的偏移，value是每一行的内容。另一种支持的格式存储了按照key排序的k/v pairs.每一种输入类型都应该知道如何分割为有意义的范围来让每个单独的map task处理(例如，文本模式下范围分割确保在每一行的行边界进行分割)。用户可以通过提供一个简单的读接口来增加新的输入类型，即使大多数用户只使用少数预定义的输入类型。</p>
          </div>

<p>A reader does not necessarily need to provide data read from a file. For example, it is easy to define a reader that reads records from a database, or from data structures mapped in memory.</p>
<div class="note info">
            <p>一个reader不一定要从文件中读取。比如，一个简单实现的reader可以从数据库，或者映射到内存的数据结构读取。</p>
          </div>

<p><code>In a similar fashion</code>, we support a set of output types for producing data in different formats and it is easy for<br>user code to add support for new output types.</p>
<div class="note info">
            <p>类似的方式，我们支持一组输出类型来生成不同格式的数据，用户编码增加新的输出类型很容易。</p>
          </div>

<hr>
<h3 id="4-5-Side-effects"><a href="#4-5-Side-effects" class="headerlink" title="4.5 Side-effects"></a>4.5 Side-effects</h3><p>In some cases, users of MapReduce have found it convenient to produce <code>auxiliary</code> files as additional outputs from their map and/or reduce operators. We rely on the application writer to make such side-effects atomic and <code>idempotent</code>. Typically the application writes to a temporary file and atomically renames this file once it has been fully generated. We do not provide support for atomic two-phase commits of multiple output files produced by a single task. Therefore, tasks that produce multiple output files with cross-file consistency requirements should be deterministic. This <code>restriction</code> has never been an issue in practice.</p>
<div class="note info">
            <p>边界效应<br>某些情况，MapReduce用户发现从他们的map reduce操作生成一些额外的辅助文件很有用。我们依赖应用编写者确保边界效应是原子的和幂等的。通常应用编写者会写到临时文件然后等完整生成的时候进行重命名。我们不支持一个task生成的多个输出文件的自动两阶段提交。因此，生成的多个输出文件的跨文件一致性要求必须是确定性的。这种限制在实践中还没出过问题。</p>
          </div>

<hr>
<h3 id="4-6-Skipping-Bad-Records"><a href="#4-6-Skipping-Bad-Records" class="headerlink" title="4.6 Skipping Bad Records"></a>4.6 Skipping Bad Records</h3><p>Sometimes there are bugs in user code that cause the Map or Reduce functions to crash deterministically on certain records. Such bugs <code>prevent</code> a MapReduce operation from completing. The usual <code>course of action</code> is to fix the bug, but sometimes this is not <code>feasible</code>; perhaps the bug is in a third-party library for which source code is unavailable. Also, sometimes it is acceptable to ignore a few records, for example when doing <code>statistical</code> <code>analysis</code> on a large data set. We provide an optional mode of execution where the MapReduce library detects which records cause deterministic crashes and skips these records in order to make forward progress.</p>
<div class="note info">
            <p>跳过坏记录<br>某些时候，用户代码的bug会在固定的记录上必然的崩溃。这些bug阻止了MapReduce操作的完成。通常的行动方针是修复bug,但有时是不可行的。或许bug来源于第三方库不可读的代码。或者，有时候忽视少数记录也是可接受的，比如统计分析大数据集合的时候。我们提供了一个可选的执行模式当MapReduce库检测到记录会造成确定性的崩溃则跳过这些记录来让程序继续运行。</p>
          </div>

<p>Each worker process installs a signal handler that catches segmentation <code>violations</code> and bus errors. Before invoking a user Map or Reduce operation, the MapReduce library stores the sequence number of the argument in a global variable. If the user code generates a signal, the signal handler sends a “last gasp” UDP packet that contains the sequence number to the MapReduce master. When the master has seen more than one failure on a particular record, it <code>indicates</code> that the record should be skipped when it issues the next re-execution of the corresponding Map or Reduce task.</p>
<div class="note info">
            <p>每一个worker进程都注册了信号处理函数来捕捉分段错误和bus错误。调用用户map reduce函数之前，MapReduce库在全局变量中存储了参数的顺序。如果用户代码产生了信号，信号处理函数发送包含最终序列号的udp报文给MapReduce主节点。当master发现在特定的记录上出现多次错误，表示当下一次记录重新执行map reduce的时候应该被跳过。</p>
          </div>

<hr>
<h3 id="4-7-Local-Execution"><a href="#4-7-Local-Execution" class="headerlink" title="4.7 Local Execution"></a>4.7 Local Execution</h3><p>Debugging problems in Map or Reduce functions can be <code>tricky</code>, since the actual computation happens in a distributed system, often on several thousand machines, with work assignment decisions made dynamically by the master. To help <code>facilitate</code> debugging, <code>profiling</code>, and small-scale testing, we have developed an <code>alternative</code> implementation of the MapReduce library that sequentially executes all of the work for a MapReduce operation on the local machine. Controls are provided to the user so that the computation can be limited to particular map tasks. Users invoke their program with a special flag and can then easily use any debugging or testing tools they find useful (e.g. gdb).</p>
<div class="note info">
            <p>Map Reduce函数的调试问题是棘手的，因为实际的计算发生在分布式系统，通常包括数千台机器，由master动态决定工作的分配。为了便于调试，分析，和小规模测试，我们开发了MapReduce库的另一实现，可在本地机器上顺序执行所有MapReduce操作。提供给用户的控制权使得计算可以被限制在部分的map tasks.用户可以通过特殊的标记调用程序，然后就可以很容易的使用任何他们觉得有用的调试和测试工具(比如gdb)</p>
          </div>

<hr>
<h3 id="4-8-Status-Information"><a href="#4-8-Status-Information" class="headerlink" title="4.8 Status Information"></a>4.8 Status Information</h3><p>The master runs an internal HTTP server and exports a set of status pages for human consumption. The status pages show the progress of the computation, such as how many tasks have been completed, how many are in progress, bytes of input, bytes of intermediate data, bytes of output, processing rates, etc. The pages also contain links to the standard error and standard output files generated by each task. The user can use this data to <code>predict</code> how long the computation will take, and whether or not more resources should be added to the computation. These pages can also be used to figure out when the computation is much slower than expected.</p>
<div class="note info">
            <p>master运行一个内部的http服务，可以将状态导出为网页供用户使用。状态页展示了计算的进度，比如已完成的任务数，处理中的任务数，输入数据大小，中间数据的大小，输出数据大小，处理速度等。页面还包含了指向每个task任务的标准错误和标椎输出文件的链接。用户可以使用这些数据预测计算需要多久，是否需要增加更多的计算资源。这些页面也可以被用来计算什么时间计算是低于预期的。</p>
          </div>

<p>In addition, the top-level status page shows which workers have failed, and which map and reduce tasks they were processing when they failed. This information is useful when attempting to <code>diagnose</code> bugs in the user code.</p>
<div class="note info">
            <p>另外，最高等级的状态页显示了哪些workers失败了，以及失败的时候有哪些map和reduce task在执行。这些信息在你调试用户代码中的Bug时将会很有用。</p>
          </div>

<hr>
<h3 id="4-9-Counters"><a href="#4-9-Counters" class="headerlink" title="4.9 Counters"></a>4.9 Counters</h3><p>The MapReduce library provides a counter facility to count occurrences of various events. For example, user code may want to count total number of words processed or the number of German documents indexed, etc.</p>
<div class="note info">
            <p>MapReduce库提供了一个计数器机制来统计各种事件的发生。比如，用户代码可能希望统计所有被处理的单词的总数或者德语文档索引的总数等。</p>
          </div>

<p>To use this facility, user code creates a named counter object and then increments the counter <code>appropriately</code> in the Map and/or Reduce function. For example:</p>
<div class="note info">
            <p>要使用这个机制，用户代码需要在Map/Reduce函数创建一个命名的计数器对象然后适当的增加该值。比如：</p>
          </div>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Counter* uppercase;</span><br><span class="line">uppercase &#x3D; GetCounter(&quot;uppercase&quot;);</span><br><span class="line"></span><br><span class="line">map(String name, String contents):</span><br><span class="line">    for each word w in contents:</span><br><span class="line">        if (IsCapitalized(w)):</span><br><span class="line">            uppercase-&gt;Increment();</span><br><span class="line">        EmitIntermediate(w, &quot;1&quot;);</span><br></pre></td></tr></table></figure>

<p>The counter values from individual worker machines are <code>periodically</code> <code>propagated</code> to the master (<code>piggybacked</code> on the ping response). The master <code>aggregates</code> the counter values from successful map and reduce tasks and returns them to the user code when the MapReduce operation is completed. The current counter values are also displayed on the master status page so that a human can watch the progress of the live computation. When aggregating counter values, the master <code>eliminates</code> the effects of duplicate executions of the same map or reduce task to avoid double counting. (Duplicate executions can arise from our use of backup tasks and from re-execution of tasks due to failures.)</p>
<div class="note info">
            <p>每个机器的计数值会定期的传播给master(带在ping响应中)。master会汇总成功的map和reduce的计数值并在MapReduce操作成功完成的时候返回给用户代码。这些信息也可以显示在master的状态页中，让用户能够看到实时的计算进展。在汇总这些值的时候，master会消除相同map/reduce重复执行造成的冲突的影响。(冲突会在用户使用备份任务或者任务失败导致的重新执行这些情况下发生)</p>
          </div>

<p>Some counter values are automatically <code>maintained</code> by the MapReduce library, such as the number of input key/value pairs processed and the number of output key/value pairs produced.</p>
<div class="note info">
            <p>一些计数值会由MapReduce库自动维护，比如输入k/v pairs处理的数量，输出的k/v pairs生成的数量。</p>
          </div>

<p>Users have found the counter facility useful for <code>sanity</code> checking the behavior of MapReduce operations. For example, in some MapReduce operations, the user code may want to ensure that the number of output pairs produced exactly equals the number of input pairs processed, or that the fraction of German documents processed is within some <code>tolerable</code> fraction of the total number of documents processed.</p>
<div class="note info">
            <p>用户发现计数机制对于MapReduce操作的智能检查非常有用。比如，对于一些MapReduce操作，用户代码可能希望生成的输出k/v pairs的数量等于处理的输入的pairs，或者已处理的德语文档的比例在所有已处理文档比例的可接受范围内。</p>
          </div>

<hr>
<h2 id="5-Performance"><a href="#5-Performance" class="headerlink" title="5 Performance"></a>5 Performance</h2><p>In this section we <code>measure</code> the performance of MapReduce on two computations running on a large cluster of machines. One computation searches through <code>approximately</code> one terabyte of data looking for a particular pattern. The other computation sorts approximately one terabyte of data.</p>
<div class="note info">
            <p>这部分我们测试MapReduce运行在大集群中的两种计算能力。一种计算用于查找大约1T大小的数据来寻找特定的模式，另一种计算对大约1T的数据进行排序。</p>
          </div>

<p>These two programs are <code>representative</code> of a large subset of the real programs written by users of MapReduce – one class of programs shuffles data from one representation to another, and another class <code>extracts</code> a small amount of interesting data from a large data set.</p>
<div class="note info">
            <p>这两种程序是用户编写的MapReduce程序的的代表。– 一种程序将数据从一种表示形式转换成另一种形式，另一种从大的数据集中提取一小部分感兴趣的数据。</p>
          </div>

<hr>
<h2 id="5-1-Cluster-Configuration"><a href="#5-1-Cluster-Configuration" class="headerlink" title="5.1 Cluster Configuration"></a>5.1 Cluster Configuration</h2><p>All of the programs were executed on a cluster that consisted of approximately 1800 machines. Each machine had two 2GHz Intel Xeon processors with <code>HyperThreading</code> enabled, 4GB of memory, two 160GB IDE disks, and a <code>gigabit</code> Ethernet link. The machines were <code>arranged</code> in a two-level tree-shaped switched network with approximately 100-200 Gbps of <code>aggregate</code> bandwidth available at the root. All of the machines were in the same <code>hosting facility</code> and therefore the <code>round-trip</code> time between any pair of machines was less than a millisecond.</p>
<div class="note info">
            <p>集群配置<br>所有的程序都在大约1800台机器组成的集群上运行。每台机器都有启用了超线程的2GHz的intel xeon处理器，4G内存，两个160g的IDE磁盘，一个千兆的以太网连接。这些机器排列在两层的树形交换机中，根部拥有100-200G的带宽。所有的机器都在相同的托管设施中，任何两台机器的往返时间都在1ms之内。</p>
          </div>

<p>Out of the 4GB of memory, approximately 1-1.5GB was <code>reserved</code> by other tasks running on the cluster. The programs were executed on a weekend afternoon, when the CPUs, disks, and network were mostly idle.</p>
<div class="note info">
            <p>除了4G内存外，还有1-1.5G的内存保留给了集群上其他的task使用。程序在周末的下午执行，此时cpu,磁盘和网络大多处于闲置状态。</p>
          </div>


<hr>
<h3 id="5-2-Grep"><a href="#5-2-Grep" class="headerlink" title="5.2 Grep"></a>5.2 Grep</h3><p>The grep program scans through 10^10 100-byte records, searching for a relatively <code>rare</code> three-character pattern (the pattern occurs in 92,337 records). The input is split into approximately 64MB pieces (M = 15000), and the entire output is placed in one file (R = 1).</p>
<div class="note info">
            <p>grep程序扫描10^10个100字节的记录，寻找比较罕见的3个字符组成的模式(模式在92337个记录中出现)。输入数据被分为64m左右的块(M=15000), 整个输出都包含在一个文件内(R=1)</p>
          </div>

<p>Figure 2 shows the progress of the computation over time. The Y-axis shows the rate at which the input data is scanned. The rate gradually <code>picks up</code> as more machines are assigned to this MapReduce computation, and peaks at over 30 GB/s when 1764 workers have been assigned. As the map tasks finish, the rate starts dropping and hits zero about 80 seconds into the computation. The entire computation takes approximately 150 seconds from start to finish. This includes about a minute of <code>startup overhead</code>. The overhead is due to the <code>propagation</code> of the program to all worker machines, and delays <code>interacting</code> with GFS to open the set of 1000 input files and to get the information needed for the locality optimization.</p>
<div class="note info">
            <p>图2显示了随着时间推移的计算进度。Y轴是输入数据的扫描速度。随着被分配给MapReduce计算的机器数增多速度开始增高，当被分配1764个workers的时候达到30g/s.等到map tasks完成的时候，速度在80秒内逐渐下降到0.整个计算从开始到结束花费大概150s。这包含了一分钟的启动花销。花销是因为程序在所有机器上的传播，以及和GFS互动而打开的1000个输入文件和为了局部优化获取数据造成的。</p>
          </div>

<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/Snipaste_2021-01-21_14-37-29.jpg"></p>
<hr>
<h3 id="5-3-Sort"><a href="#5-3-Sort" class="headerlink" title="5.3 Sort"></a>5.3 Sort</h3><p>The sort program sorts 10^10 100-byte records (approximately 1 terabyte of data). This program is modeled after the TeraSort benchmark [10].</p>
<div class="note info">
            <p>sort程序对大约1T数据进行排序，该程序模仿了TeraSort benchmark。</p>
          </div>

<p>The sorting program consists of less than 50 lines of user code. A three-line Map function extracts a 10-byte sorting key from a text line and emits the key and the original text line as the intermediate key/value pair. We used a built-in Identity function as the Reduce operator. This functions passes the intermediate key/value pair unchanged as the output key/value pair. The final sorted output is written to a set of 2-way replicated GFS files (i.e., 2 terabytes are written as the output of the program).</p>
<div class="note info">
            <p>排序程序由不到50行用户代码组成。map函数一共3行，它从文本行中提取排序的key然后发送key和原始的文本行到中间的k/v pairs.我们使用内置的函数实现reduce操作。该函数传递未改动的中间k/v pair作为输出的k/v pair.最终的结果写到一组2路复制的GFS文件中</p>
          </div>

<p>As before, the input data is split into 64MB pieces (M = 15000). We partition the sorted output into 4000 files (R = 4000). The partitioning function uses the initial bytes of the key to segregate it into one of R pieces.</p>
<div class="note info">
            <p>和前面一样，输入数据被分为64m大小的块。(M=15000) 我们划分有序的输出到4000个文件中(R=4000)。划分函数根据key的首字节将其划分到一个R文件中。</p>
          </div>

<p>Our partitioning function for this benchmark has builtin knowledge of the distribution of keys. In a general sorting program, we would add a pre-pass MapReduce operation that would collect a sample of the keys and use the distribution of the sampled keys to compute splitpoints for the final sorting pass.</p>
<div class="note info">
            <p>此次测试中我们的划分函数已经内建了key分布的知识。在一般的排序程序中，我们会预先添加MapReduce操作，收集key的样本，并使用key抽样的分布来计算最终输出文件的划分点。</p>
          </div>

<p><img src="https://raw.githubusercontent.com/RiverFerry/picBed/master/Snipaste_2021-01-21_14-39-22.jpg"></p>
<p>Figure 3 (a) shows the progress of a normal execution of the sort program. The top-left graph shows the rate at which input is read. The rate peaks at about 13 GB/s and dies off fairly quickly since all map tasks finish before 200 seconds have <code>elapsed</code>. Note that the input rate is less than for grep. This is because the sort map tasks spend about half their time and I/O bandwidth writing intermediate output to their local disks. The corresponding intermediate output for grep had <code>negligible</code> size.</p>
<div class="note info">
            <p>图3展示了排序程序正常执行的过程。左上角图显示了输入数据读取的速度。速度高峰的时候达到13g/s然后在200秒快速降下去。注意这里的输入速度远小于grep.因为排序的map任务写中间文件到磁盘花费了一半的时间和I/O带宽。而grep的中间输出数据非常小。</p>
          </div>

<p>The middle-left graph shows the rate at which data is sent over the network from the map tasks to the reduce tasks. This shuffling starts as soon as the first map task completes. The first <code>hump</code> in the graph is for the first batch of approximately 1700 reduce tasks (the entire MapReduce was assigned about 1700 machines, and each machine executes <code>at most one</code> reduce task at a time). <code>Roughly</code> 300 seconds into the computation, some of these first batch of reduce tasks finish and we start shuffling data for the <code>remaining</code> reduce tasks. All of the shuffling is done about 600 seconds into the computation.</p>
<div class="note info">
            <p>左边中间的图显示了map任务通过网络给reduce任务发送数据的速度。在第一个map任务完成的时候快速变化。图中第一个驼峰是大约1700个reduce任务批量运行的时候(整个MapReduce被分配了1700台机器，每台机器都同时间运行最多一个reduce任务)。计算大概300秒，一些reduce任务已经完成了并开始向其他的reduce任务传递(改组？)数据。所有的传送在600秒结束。</p>
          </div>

<p>The bottom-left graph shows the rate at which sorted data is written to the final output files by the reduce tasks. There is a delay between the end of the first shuffling <code>period</code> and the start of the writing period because the machines are busy sorting the intermediate data. The writes continue at a rate of about 2-4 GB/s for a while. All of the writes finish about 850 seconds into the computation. Including <code>startup overhead</code>, the entire computation takes 891 seconds. This is similar to the current best reported result of 1057 seconds for the TeraSort benchmark [18].</p>
<div class="note info">
            <p>左边底部的图显示了reduce任务将排序数据写到最终输出文件的速度。在第一次传输数据和开始写入数据之间有一个延迟，因为这会机器正忙于对中间数据进行排序。写数据保持2-4G/s的速度一段时间。850秒的时候所有写操作结束。算上启动开销，整个计算需要891秒。这和TeraSort报告的最新测试数据1057秒很接近。</p>
          </div>

<p>A few things to note: the input rate is higher than the shuffle rate and the output rate because of our locality optimization – most data is read from a local disk and bypasses our relatively bandwidth constrained network. The shuffle rate is higher than the output rate because the output phase writes two copies of the sorted data (we make two replicas of the output for reliability and availability reasons). We write two replicas because that is the <code>mechanism</code> for reliability and availability provided by our underlying file system. Network bandwidth requirements for writing data would be reduced if the underlying file system used <code>erasure</code> coding [14] rather than replication.</p>
<div class="note info">
            <p>一些要注意的事：输入数据的速度是高于传输数据和输出数据的因为局部性优化-绕开了带宽受限的网络。传输速度高于输出数据是因为写输出阶段要对排序数据写两份拷贝(我们通过对输出数据写两份拷贝来实现可靠性和可用性)。写两份拷贝是底层文件系统对可靠性和可用性提供的机制。如果底层文件系统使用删除代码而不是复制，写数据的带宽将会降低。</p>
          </div>

<hr>
<h3 id="5-4-Effect-of-Backup-Tasks"><a href="#5-4-Effect-of-Backup-Tasks" class="headerlink" title="5.4 Effect of Backup Tasks"></a>5.4 Effect of Backup Tasks</h3><p>In Figure 3 (b), we show an execution of the sort program with backup tasks disabled. The execution flow is similar to that shown in Figure 3 (a), except that there is a very long tail where hardly any write activity occurs. After 960 seconds, all except 5 of the reduce tasks are completed. However these last few stragglers don’t finish until 300 seconds later. The entire computation takes 1283 seconds, an increase of 44% in elapsed time.</p>
<div class="note info">
            <p>备份任务的影响</p><p>图3b显示了，禁用备份任务下排序程序的运行。和图3a看起来很相似。除了尾部有非常长的时间几乎没有写操作发生。960秒后，只有5个reduce任务还没有完成。但这几个落后者直到300秒后才全部完成。整个计算花了1283秒，比之前多了44%的时间。</p>
          </div>

<hr>
<h3 id="5-5-Machine-Failures"><a href="#5-5-Machine-Failures" class="headerlink" title="5.5 Machine Failures"></a>5.5 Machine Failures</h3><p>In Figure 3 (c), we show an execution of the sort program where we <code>intentionally</code> killed 200 out of 1746 worker processes several minutes into the computation. The underlying cluster scheduler immediately restarted new worker processes on these machines (since only the processes were killed, the machines were still <code>functioning</code> properly).</p>
<div class="note info">
            <p>机器故障<br>图3c中,显示的是我们故意杀掉1746个工作节点中的200个节点达几分钟时排序程序的执行。底层集群调度器马上在这些机器上重启了新的工作节点。(进程被杀掉了，机器还在正常运行)</p>
          </div>

<p>The worker deaths show up as a <code>negative</code> input rate since some previously completed map work disappears (since the corresponding map workers were killed) and needs to be redone. The re-execution of this map work happens relatively quickly. The entire computation finishes in 933 seconds including startup overhead (just an increase of 5% over the normal execution time).</p>
<div class="note info">
            <p>工作节点挂掉显示为负的输入速度，因为之前已经完成的一些map任务消失了(相应的工作节点被杀掉了)需要重新完成。重新执行这些map任务会很快发生。整个计算过程包含启动开销一共花了933秒(只比正常的执行时间多了5%)</p>
          </div>

<hr>
<h2 id="6-Experience"><a href="#6-Experience" class="headerlink" title="6 Experience"></a>6 Experience</h2><p>We wrote the first version of the MapReduce library in February of 2003, and made significant enhancements to it in August of 2003, including the locality optimization, dynamic load balancing of task execution across worker machines, etc. Since that time, we have been pleasantly surprised at how broadly applicable the MapReduce library has been for the kinds of problems we work on.<br>It has been used across a wide range of domains within Google, including:</p>
<ul>
<li>large-scale machine learning problems,</li>
<li>clustering problems for the Google News and Froogle products,</li>
<li>extraction of data used to produce reports of popular queries (e.g. Google Zeitgeist),</li>
<li>extraction of properties of web pages for new experiments and products (e.g. extraction of geographical locations from a large corpus of web pages for localized search), and</li>
<li>large-scale graph computations.</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog-1254238374.cos.ap-hongkong.myqcloud.com/blog/Snipaste_2021-01-21_14-42-41.jpg">https://blog-1254238374.cos.ap-hongkong.myqcloud.com/blog/Snipaste_2021-01-21_14-42-41.jpg</a></p>
<p>Figure 4 shows the significant growth in the number of separate MapReduce programs checked into our primary source code management system over time, from 0 in early 2003 to almost 900 separate instances as of late September 2004. MapReduce has been so successful because it makes it possible to write a simple program and run it efficiently on a thousand machines in the course of half an hour, greatly speeding up the development and prototyping cycle. Furthermore, it allows programmers who have no experience with distributed and/or parallel systems to exploit large amounts of resources easily.</p>
<p>At the end of each job, the MapReduce library logs statistics about the computational resources used by the job. In Table 1, we show some statistics for a subset of MapReduce jobs run at Google in August 2004.</p>
<div class="note info">
            <p>经验</p>
          </div>

<hr>
<h3 id="6-1-Large-Scale-Indexing"><a href="#6-1-Large-Scale-Indexing" class="headerlink" title="6.1 Large-Scale Indexing"></a>6.1 Large-Scale Indexing</h3><p>One of our most significant uses of MapReduce to date has been a complete rewrite of the production indexing system that produces the data structures used for the Google web search service. The indexing system takes as input a large set of documents that have been <code>retrieved</code> by our crawling system, stored as a set of GFS files. The raw contents for these documents are more than 20 terabytes of data. The indexing process runs as a sequence of five to ten MapReduce operations. Using MapReduce (instead of the ad-hoc distributed passes in the prior version of the indexing system) has provided several benefits:</p>
<div class="note info">
            <p>大规模索引<br>我们对于MapReduce的最重要的一个使用是完全重写了生产环境索引系统，它用来生成谷歌网络搜索服务需要的数据结构。索引系统以我们爬取系统抓取的很多文档集合作为输入，存储为一组GFS文件。这些文件中的原始内容超过20Tb.索引系统以5-20个MapReduce程序运行。使用MapReduce(而不是老版本索引系统中的ad-hoc)带来了几点好处：</p>
          </div>

<ul>
<li>The indexing code is simpler, smaller, and easier to understand, because the code that deals with fault tolerance, distribution and parallelization is hidden within the MapReduce library. For example, the size of one phase of the computation dropped from approximately 3800 lines of C++ code to approximately 700 lines when expressed using MapReduce.</li>
</ul>
<div class="note info">
            <p>索引代码简单，代码量小，容易理解，因为处理容错，分布式和并行化的代码隐藏在了MapReduce的库里面。比如，其中一个阶段的计算在使用了MapReduce后代码量从3800行C++代码降低到只需要700行。</p>
          </div>

<ul>
<li>The performance of the MapReduce library is good enough that we can keep conceptually unrelated computations separate, instead of mixing them together to avoid extra passes over the data. This makes it easy to change the indexing process. For example, one change that took a few months to make in our old indexing system took only a few days to implement in the new system.</li>
</ul>
<div class="note info">
            <p>MapReduce的性能足够好，我们可以把概念上无关的计算分离，而不需要为了避免额外传输数据将其混杂在一起。这让修改索引进程变得容易，以前修改老的索引系统需要几个月的时间，而在现在新实现的索引系统上只需要几天时间。</p>
          </div>

<ul>
<li>The indexing process has become much easier to operate, because most of the problems caused by machine failures, slow machines, and <code>networking hiccups</code> are dealt with automatically by the MapReduce library without operator <code>intervention</code>. Furthermore, it is easy to improve the performance of the indexing process by adding new machines to the indexing cluster.</li>
</ul>
<div class="note info">
            <p>索引系统更容易去操作，因为大多数机器故障，机器执行缓慢，网络中断问题都可以由MapReduce库自动处理而不需要额外介入。此外，通过增加集群中的机器数可以很容易的提高索引进程的性能。</p>
          </div>

<hr>
<h2 id="7-Related-Work"><a href="#7-Related-Work" class="headerlink" title="7 Related Work"></a>7 Related Work</h2><p>Many systems have provided restricted programming models and used the restrictions to parallelize the computation automatically. For example, an associative function can be computed over all prefixes of an N element array in log N time on N processors using parallel prefix computations [6, 9, 13]. MapReduce can be considered a simplification and distillation of some of these models<br>based on our experience with large real-world computations. More significantly, we provide a fault-tolerant implementation that scales to thousands of processors. In contrast, most of the parallel processing systems have only been implemented on smaller scales and leave the details of handling machine failures to the programmer.</p>
<p>Bulk Synchronous Programming [17] and some MPI primitives [11] provide higher-level abstractions that make it easier for programmers to write parallel programs. A key difference between these systems and MapReduce is that MapReduce exploits a restricted programming model to parallelize the user program automatically and to provide transparent fault-tolerance.</p>
<p>Our locality optimization draws its inspiration from techniques such as active disks [12, 15], where computation is pushed into processing elements that are close to local disks, to reduce the amount of data sent across I/O subsystems or the network. We run on commodity processors to which a small number of disks are directly connected instead of running directly on disk controller<br>processors, but the general approach is similar.</p>
<p>Our backup task mechanism is similar to the eager scheduling mechanism employed in the Charlotte System [3]. One of the shortcomings of simple eager scheduling is that if a given task causes repeated failures, the entire computation fails to complete. We fix some instances of this problem with our mechanism for skipping bad records.</p>
<p>The MapReduce implementation relies on an in-house cluster management system that is responsible for distributing and running user tasks on a large collection of shared machines. Though not the focus of this paper, the cluster management system is similar in spirit to other systems such as Condor [16].</p>
<p>The sorting facility that is a part of the MapReduce library is similar in operation to NOW-Sort [1]. Source machines (map workers) partition the data to be sorted and send it to one of R reduce workers. Each reduce worker sorts its data locally (in memory if possible). Of course NOW-Sort does not have the user-definable Map and Reduce functions that make our library widely applicable.</p>
<p>River [2] provides a programming model where processes communicate with each other by sending data over distributed queues. Like MapReduce, the River system tries to provide good average case performance even in the presence of non-uniformities introduced by<br>heterogeneous hardware or system perturbations. River achieves this by careful scheduling of disk and network<br>transfers to achieve balanced completion times. MapReduce has a different approach. By restricting the programming model, the MapReduce framework is able to partition the problem into a large number of finegrained tasks. These tasks are dynamically scheduled<br>on available workers so that faster workers process more tasks. The restricted programming model also allows us to schedule redundant executions of tasks near the end of the job which greatly reduces completion time in the presence of non-uniformities (such as slow or stuck workers).</p>
<p>BAD-FS [5] has a very different programming model from MapReduce, and unlike MapReduce, is targeted to the execution of jobs across a wide-area network. However, there are two fundamental similarities. (1) Both systems use redundant execution to recover from data loss caused by failures. (2) Both use locality-aware scheduling to reduce the amount of data sent across congested network links.</p>
<p>TACC [7] is a system designed to simplify construction of highly-available networked services. Like MapReduce, it relies on re-execution as a mechanism for implementing fault-tolerance.</p>
<div class="note info">
            <p>相关工作<br>…</p>
          </div>

<hr>
<h2 id="8-Conclusions"><a href="#8-Conclusions" class="headerlink" title="8 Conclusions"></a>8 Conclusions</h2><p>The MapReduce programming model has been successfully used at Google for many different purposes. We <code>attribute</code> this success to several reasons. First, the model is easy to use, even for programmers without experience with parallel and distributed systems, since it hides the details of parallelization, fault-tolerance, locality optimization, and load balancing. Second, a large variety of problems are easily expressible as MapReduce computations. For example, MapReduce is used for the generation of data for Google’s production web search service, for sorting, for <code>data mining</code>, for machine learning, and many other systems. Third, we have developed an implementation of MapReduce that scales to large clusters of machines <code>comprising</code> thousands of machines. The implementation makes efficient use of these machine resources and therefore is suitable for use on many of the large computational problems encountered at Google.</p>
<div class="note info">
            <p>结论<br>MapReduce编程模型在谷歌内部已经成功的用于很多不同的用途。我们将其成功归结于几个方面。首先，该模型易于使用，即使对于没有并行和分布式经验的程序员，因为模型隐藏了并行化，容错，局部优化和负载均衡的细节。其次，很多种类的问题都可以方便的表示为MapReduce模型。比如，MapReduce被用于谷歌网络搜索服务的数据生成，排序，数据挖掘，和用于机器学习以及其他的系统。第三，我们已经开发了MapReduce的实现，可以扩展到数千台机器组成的大规模集群中。该实现可以高效利用机器资源，因此适用于谷歌遇到的的许多大的计算问题。</p>
          </div>

<p>We have learned several things from this work. First, <code>restricting</code> the programming model makes it easy to parallelize and distribute computations and to make such computations fault-tolerant. Second, network bandwidth is a <code>scarce</code> resource. <code>A number of</code> optimizations in our system are therefore targeted at reducing the amount of data sent across the network: the locality optimization allows us to read data from local disks, and writing a single copy of the intermediate data to local disk saves network bandwidth. Third, <code>redundant</code> execution can be used to reduce the <code>impact</code> of slow machines, and to handle machine failures and data loss.</p>
<div class="note info">
            <p>从这项工作中我们学到了一些东西。首先，约束编程模型使得并行以及分布式计算，以及计算容错，变得简单。其次，网络带宽是稀缺资源。我们系统因此针对通过网络传输大量数据做了一些优化：局部性优化允许我们从本地磁盘读取数据，写一份中间数据到本地磁盘也节省了带宽。第三，冗余执行可以降低慢机器造成的影响，以及处理机器故障和数据丢失。</p>
          </div>

<hr>
<h2 id="Acknowledgements"><a href="#Acknowledgements" class="headerlink" title="Acknowledgements"></a>Acknowledgements</h2><p>Josh Levenberg has been instrumental in revising and extending the user-level MapReduce API with a number of new features based on his experience with using MapReduce and other people’s suggestions for enhancements. MapReduce reads its input from and writes its output to the Google File System [8]. We would like to thank Mohit Aron, Howard Gobioff, Markus Gutschke,</p>
<p>David Kramer, Shun-Tak Leung, and Josh Redstone for their work in developing GFS. We would also like to thank Percy Liang and Olcan Sercinoglu for their work in developing the cluster management system used by MapReduce. Mike Burrows, Wilson Hsieh, Josh Levenberg, Sharon Perl, Rob Pike, and Debby Wallach provided helpful comments on earlier drafts of this paper. The anonymous OSDI reviewers, and our shepherd, Eric Brewer, provided many useful suggestions of areas where the paper could be improved. Finally, we thank all the users of MapReduce within Google’s engineering organization for providing helpful feedback, suggestions, and bug reports.</p>
<div class="note info">
            <p>致谢…</p>
          </div>

<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] Andrea C. Arpaci-Dusseau, Remzi H. Arpaci-Dusseau, David E. Culler, Joseph M. Hellerstein, and David A. Patterson. High-performance sorting on networks of workstations. In Proceedings of the 1997 ACM SIGMOD International Conference on Management of Data, Tucson, Arizona, May 1997.</p>
<p>[2] Remzi H. Arpaci-Dusseau, Eric Anderson, Noah Treuhaft, David E. Culler, Joseph M. Hellerstein, David Patterson, and Kathy Yelick. Cluster I/O with River: Making the fast case common. In Proceedings of the Sixth Workshop on Input/Output in Parallel and Distributed<br>Systems (IOPADS ’99), pages 10–22, Atlanta, Georgia, May 1999.</p>
<p>[3] Arash Baratloo, Mehmet Karaul, Zvi Kedem, and Peter Wyckoff. Charlotte: Metacomputing on the web. In Proceedings of the 9th International Conference on Parallel and Distributed Computing Systems, 1996.</p>
<p>[4] Luiz A. Barroso, Jeffrey Dean, and Urs Holzle. ¨ Web search for a planet: The Google cluster architecture. IEEE Micro, 23(2):22–28, April 2003.</p>
<p>[5] John Bent, Douglas Thain, Andrea C.Arpaci-Dusseau, Remzi H. Arpaci-Dusseau, and Miron Livny. Explicit control in a batch-aware distributed file system. In Proceedings of the 1st USENIX Symposium on Networked Systems Design and Implementation NSDI, March 2004.</p>
<p>[6] Guy E. Blelloch. Scans as primitive parallel operations. IEEE Transactions on Computers, C-38(11), November</p>
<p>[7] Armando Fox, Steven D. Gribble, Yatin Chawathe, Eric A. Brewer, and Paul Gauthier. Cluster-based scalable network services. In Proceedings of the 16th ACM Symposium on Operating System Principles, pages 78– 91, Saint-Malo, France, 1997.</p>
<p>[8] Sanjay Ghemawat, Howard Gobioff, and Shun-Tak Leung. The Google file system. In 19th Symposium on Operating Systems Principles, pages 29–43, Lake George, New York, 2003.</p>
<p>[9] S. Gorlatch. Systematic efficient parallelization of scan and other list homomorphisms. In L. Bouge, P. Fraigniaud, A. Mignotte, and Y. Robert, editors, Euro-Par’96. Parallel Processing, Lecture Notes in Computer Science 1124, pages 401–408. Springer-Verlag, 1996.</p>
<p>[10] Jim Gray. Sort benchmark home page. <a target="_blank" rel="noopener" href="http://research.microsoft.com/barc/SortBenchmark/">http://research.microsoft.com/barc/SortBenchmark/</a>.</p>
<p>[11] William Gropp, Ewing Lusk, and Anthony Skjellum. Using MPI: Portable Parallel Programming with the Message-Passing Interface. MIT Press, Cambridge, MA,</p>
<p>[12] L. Huston, R. Sukthankar, R. Wickremesinghe, M. Satyanarayanan, G. R. Ganger, E. Riedel, and A. Ailamaki. Diamond: A storage architecture for early discard in interactive search. In Proceedings of the 2004 USENIX File and Storage Technologies FAST Conference, April 2004.</p>
<p>[13] Richard E. Ladner and Michael J. Fischer. Parallel prefix computation. Journal of the ACM, 27(4):831–838, 1980.</p>
<p>[14] Michael O. Rabin. Efficient dispersal of information for security, load balancing and fault tolerance. Journal of<br>the ACM, 36(2):335–348, 1989.</p>
<p>[15] Erik Riedel, Christos Faloutsos, Garth A. Gibson, and David Nagle. Active disks for large-scale data processing. IEEE Computer, pages 68–74, June 2001.</p>
<p>[16] Douglas Thain, Todd Tannenbaum, and Miron Livny. Distributed computing in practice: The Condor experience. Concurrency and Computation: Practice and Experience, 2004.</p>
<p>[17] L. G. Valiant. A bridging model for parallel computation. Communications of the ACM, 33(8):103–111, 1997.</p>
<p>[18] Jim Wyllie. Spsort: How to sort a terabyte quickly. <a target="_blank" rel="noopener" href="http://alme1.almaden.ibm.com/cs/spsort.pdf">http://alme1.almaden.ibm.com/cs/spsort.pdf</a>.</p>
<h2 id="A-Word-Frequency"><a href="#A-Word-Frequency" class="headerlink" title="A Word Frequency"></a>A Word Frequency</h2><p>This section contains a program that counts the number of occurrences of each unique word in a set of input files specified on the command line.</p>
<p>这部分是一个统计由命令行指定的输入文件集合中每一个唯一的单词出现次数的统计程序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mapreduce/mapreduce.h&quot;</span></span></span><br><span class="line"><span class="comment">// User’s map function</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordCounter</span> :</span> <span class="keyword">public</span> Mapper &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Map</span><span class="params">(<span class="keyword">const</span> MapInput&amp; input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> string&amp; text = input.<span class="built_in">value</span>();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = text.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ) &#123;</span><br><span class="line">            <span class="comment">// Skip past leading whitespace</span></span><br><span class="line">            <span class="keyword">while</span> ((i &lt; n) &amp;&amp; <span class="built_in">isspace</span>(text[i]))</span><br><span class="line">                i++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Find word end</span></span><br><span class="line">            <span class="keyword">int</span> start = i;</span><br><span class="line">            <span class="keyword">while</span> ((i &lt; n) &amp;&amp; !<span class="built_in">isspace</span>(text[i]))</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">if</span> (start &lt; i)</span><br><span class="line">                <span class="built_in">Emit</span>(text.<span class="built_in">substr</span>(start,i-start),<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">REGISTER_MAPPER</span>(WordCounter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// User’s reduce function</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adder</span> :</span> <span class="keyword">public</span> Reducer &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Reduce</span><span class="params">(ReduceInput* input)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Iterate over all entries with the</span></span><br><span class="line">        <span class="comment">// same key and add the values</span></span><br><span class="line">        int64 value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!input-&gt;<span class="built_in">done</span>()) &#123;</span><br><span class="line">            value += <span class="built_in">StringToInt</span>(input-&gt;<span class="built_in">value</span>());</span><br><span class="line">            input-&gt;<span class="built_in">NextValue</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Emit sum for input-&gt;key()</span></span><br><span class="line">        <span class="built_in">Emit</span>(<span class="built_in">IntToString</span>(value));</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">REGISTER_REDUCER</span>(Adder);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ParseCommandLineFlags</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">    MapReduceSpecification spec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Store list of input files into &quot;spec&quot;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        MapReduceInput* input = spec.<span class="built_in">add_input</span>();</span><br><span class="line">        input-&gt;<span class="built_in">set_format</span>(<span class="string">&quot;text&quot;</span>);</span><br><span class="line">        input-&gt;<span class="built_in">set_filepattern</span>(argv[i]);</span><br><span class="line">        input-&gt;<span class="built_in">set_mapper_class</span>(<span class="string">&quot;WordCounter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Specify the output files:</span></span><br><span class="line">    <span class="comment">// /gfs/test/freq-00000-of-00100</span></span><br><span class="line">    <span class="comment">// /gfs/test/freq-00001-of-00100</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    MapReduceOutput* out = spec.<span class="built_in">output</span>();</span><br><span class="line">    out-&gt;<span class="built_in">set_filebase</span>(<span class="string">&quot;/gfs/test/freq&quot;</span>);</span><br><span class="line">    out-&gt;<span class="built_in">set_num_tasks</span>(<span class="number">100</span>);</span><br><span class="line">    out-&gt;<span class="built_in">set_format</span>(<span class="string">&quot;text&quot;</span>);</span><br><span class="line">    out-&gt;<span class="built_in">set_reducer_class</span>(<span class="string">&quot;Adder&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optional: do partial sums within map</span></span><br><span class="line">    <span class="comment">// tasks to save network bandwidth</span></span><br><span class="line">    out-&gt;<span class="built_in">set_combiner_class</span>(<span class="string">&quot;Adder&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tuning parameters: use at most 2000</span></span><br><span class="line">    <span class="comment">// machines and 100 MB of memory per task</span></span><br><span class="line">    spec.<span class="built_in">set_machines</span>(<span class="number">2000</span>);</span><br><span class="line">    spec.<span class="built_in">set_map_megabytes</span>(<span class="number">100</span>);</span><br><span class="line">    spec.<span class="built_in">set_reduce_megabytes</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now run it</span></span><br><span class="line">    MapReduceResult result;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">MapReduce</span>(spec, &amp;result)) <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Done: ’result’ structure contains info</span></span><br><span class="line">    <span class="comment">// about counters, time taken, number of</span></span><br><span class="line">    <span class="comment">// machines used, etc.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://www.bbsmax.com/A/KE5Q0Nq3JL/">https://www.bbsmax.com/A/KE5Q0Nq3JL/</a></p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>TheRiver
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="https://riverferry.site/2021-01-21-MapReduce-Simplified-Data-Processing-on-Large-Clusters/" title="[译文]MapReduce: Simplified Data Processing on Large Clusters">https://riverferry.site/2021-01-21-MapReduce-Simplified-Data-Processing-on-Large-Clusters/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020-11-07-hash%20in%20redis/" rel="prev" title="hash in redis">
      <i class="fa fa-chevron-left"></i> hash in redis
    </a></div>
      <div class="post-nav-item">
    <a href="/2021-01-26-The-Google-File-System/" rel="next" title="[译文]The Google File System">
      [译文]The Google File System <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  
   <div>
     <div>
  
    <div style="text-align:center;color:#bfbfbf;font-size:16px;">
      <span>----------- ending -----------</span>
    </div>
  
</div>

   </div>
 



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Abstract"><span class="nav-number">1.</span> <span class="nav-text">Abstract</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Introduction"><span class="nav-number">2.</span> <span class="nav-text">1 Introduction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Programming-Model"><span class="nav-number">3.</span> <span class="nav-text">2 Programming Model</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-Example"><span class="nav-number">3.1.</span> <span class="nav-text">2.1 Example</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-Types"><span class="nav-number">3.2.</span> <span class="nav-text">2.2 Types</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-More-Examples"><span class="nav-number">3.3.</span> <span class="nav-text">2.3 More Examples</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Implementation"><span class="nav-number">4.</span> <span class="nav-text">3 Implementation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-Execution-Overview"><span class="nav-number">4.1.</span> <span class="nav-text">3.1 Execution Overview</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-Master-Data-Structures"><span class="nav-number">4.2.</span> <span class="nav-text">3.2 Master Data Structures</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-Fault-Tolerance"><span class="nav-number">4.3.</span> <span class="nav-text">3.3 Fault Tolerance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Worker-Failure"><span class="nav-number">4.4.</span> <span class="nav-text">Worker Failure</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Master-Failure"><span class="nav-number">4.5.</span> <span class="nav-text">Master Failure</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Semantics-in-the-Presence-of-Failures"><span class="nav-number">4.6.</span> <span class="nav-text">Semantics in the Presence of Failures</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-Locality"><span class="nav-number">4.7.</span> <span class="nav-text">3.4 Locality</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-Task-Granularity"><span class="nav-number">4.8.</span> <span class="nav-text">3.5 Task Granularity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-Backup-Tasks"><span class="nav-number">4.9.</span> <span class="nav-text">3.6 Backup Tasks</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Refinements"><span class="nav-number">5.</span> <span class="nav-text">4 Refinements</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-Partitioning-Function"><span class="nav-number">5.1.</span> <span class="nav-text">4.1 Partitioning Function</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-Ordering-Guarantees"><span class="nav-number">5.2.</span> <span class="nav-text">4.2 Ordering Guarantees</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-Combiner-Function"><span class="nav-number">5.3.</span> <span class="nav-text">4.3 Combiner Function</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-Input-and-Output-Types"><span class="nav-number">5.4.</span> <span class="nav-text">4.4 Input and Output Types</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-Side-effects"><span class="nav-number">5.5.</span> <span class="nav-text">4.5 Side-effects</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-Skipping-Bad-Records"><span class="nav-number">5.6.</span> <span class="nav-text">4.6 Skipping Bad Records</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7-Local-Execution"><span class="nav-number">5.7.</span> <span class="nav-text">4.7 Local Execution</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-8-Status-Information"><span class="nav-number">5.8.</span> <span class="nav-text">4.8 Status Information</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-9-Counters"><span class="nav-number">5.9.</span> <span class="nav-text">4.9 Counters</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Performance"><span class="nav-number">6.</span> <span class="nav-text">5 Performance</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-Cluster-Configuration"><span class="nav-number">7.</span> <span class="nav-text">5.1 Cluster Configuration</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-Grep"><span class="nav-number">7.1.</span> <span class="nav-text">5.2 Grep</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-Sort"><span class="nav-number">7.2.</span> <span class="nav-text">5.3 Sort</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-Effect-of-Backup-Tasks"><span class="nav-number">7.3.</span> <span class="nav-text">5.4 Effect of Backup Tasks</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-Machine-Failures"><span class="nav-number">7.4.</span> <span class="nav-text">5.5 Machine Failures</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-Experience"><span class="nav-number">8.</span> <span class="nav-text">6 Experience</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-Large-Scale-Indexing"><span class="nav-number">8.1.</span> <span class="nav-text">6.1 Large-Scale Indexing</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-Related-Work"><span class="nav-number">9.</span> <span class="nav-text">7 Related Work</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-Conclusions"><span class="nav-number">10.</span> <span class="nav-text">8 Conclusions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Acknowledgements"><span class="nav-number">11.</span> <span class="nav-text">Acknowledgements</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#References"><span class="nav-number">12.</span> <span class="nav-text">References</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#A-Word-Frequency"><span class="nav-number">13.</span> <span class="nav-text">A Word Frequency</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">14.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="TheRiver"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">TheRiver</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">210</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">68</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">TheRiver</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">1.1m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">17:09</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '828d98635e4048805831',
      clientSecret: 'cdf9f70acdfbecd65e89bc3a8c2954be1af2ee01',
      repo        : 'gitalk',
      owner       : 'RiverFerry',
      admin       : ['RiverFerry'],
      id          : '07b9b58c89c56be4aaf5828cb99ff89e',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/ Relative)","tagMode":false,"log":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"left","width":300,"height":800,"hOffset":20,"vOffset":20},"mobile":{"show":false,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2}});</script></body>
</html>
