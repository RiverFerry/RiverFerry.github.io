<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/river.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"riverferry.site","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="参考Posix线程编程指南(3) glibc nptl库pthread_mutex_lock和pthread_mutex_unlock浅析">
<meta property="og:type" content="article">
<meta property="og:title" content="linux-互斥锁和条件变量">
<meta property="og:url" content="https://riverferry.site/2020-04-07-linux-posix%E4%BA%92%E6%96%A5%E9%94%81%E5%92%8C%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%20/index.html">
<meta property="og:site_name" content="TheRiver | blog">
<meta property="og:description" content="参考Posix线程编程指南(3) glibc nptl库pthread_mutex_lock和pthread_mutex_unlock浅析">
<meta property="og:locale">
<meta property="og:image" content="https://i.loli.net/2020/04/05/L9yTWmxYrC3JgiN.jpg">
<meta property="article:published_time" content="2020-04-07T00:00:00.000Z">
<meta property="article:modified_time" content="2022-09-12T16:24:32.280Z">
<meta property="article:author" content="TheRiver">
<meta property="article:tag" content="ipc">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/04/05/L9yTWmxYrC3JgiN.jpg">

<link rel="canonical" href="https://riverferry.site/2020-04-07-linux-posix%E4%BA%92%E6%96%A5%E9%94%81%E5%92%8C%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%20/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'default'
  };
</script>

  <title>linux-互斥锁和条件变量 | TheRiver | blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">TheRiver | blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">You have reached the world's edge, none but devils play past here</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/RiverFerry/RiverFerry.github.io" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="https://riverferry.site/2020-04-07-linux-posix%E4%BA%92%E6%96%A5%E9%94%81%E5%92%8C%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="TheRiver">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TheRiver | blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          linux-互斥锁和条件变量
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-07 00:00:00" itemprop="dateCreated datePublished" datetime="2020-04-07T00:00:00+00:00">2020-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-12 16:24:32" itemprop="dateModified" datetime="2022-09-12T16:24:32+00:00">2022-09-12</time>
              </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>33k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>30 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/thread/posix_threadapi/part3/">Posix线程编程指南(3)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/a7980718/article/details/88544075">glibc nptl库pthread_mutex_lock和pthread_mutex_unlock浅析</a></p>
<a id="more"></a>

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>互斥锁和条件变量出自posix.1线程标准，它们总是可用来同步一个进程内的各个线程的，如果一个互斥锁或条件变量存放在多个进程间共享的某个内存区内，那么posix还允许它用于这些个进程间的同步。</p>
<p><strong>Posix mutex</strong> <br><br>互斥锁（英语：Mutual exclusion，缩写 Mutex）是一种用于多线程编程中，防止两条线程同时对同一公共资源（比如全局变量）进行读写的机制。该目的通过将代码切片成一个一个的临界区域（critical section）达成。临界区域指的是一块对公共资源进行访问的代码，并非一种机制或是算法。一个程序、进程、线程可以拥有多个临界区域，但是并不一定会应用互斥锁。</p>
<p><strong>Posix Thread中的条件变量</strong> <br><br>pthread中，条件变量实际上是一个阻塞线程处于睡眠状态的线程队列。每个条件变量都必须与一个（且建议只能是一个）互斥锁配套使用。一个线程首先获得互斥锁，然后检查或者修改“条件”；如果条件不成立，则调用pthread_cond_wait()，依次实施3个操作：</p>
<p>1 对当前互斥锁解锁（以便其它线程可以访问或者修改“条件”）<br><br>2 把线程自身阻塞挂起到互斥锁的线程队列中 <br><br>3 被其它线程的信号从互斥锁的线程队列唤醒后，对当前配套的互斥锁申请加锁，如果加锁未能成功，则阻塞挂起到当前互斥锁上。pthread_cond_wait() 函数将不返回直到线程获得配套的互斥锁。 <br></p>
<p>线程离开“条件”的临界区时，必须对当前互斥锁执行解锁。</p>
<h2 id="NPTL"><a href="#NPTL" class="headerlink" title="NPTL"></a>NPTL</h2><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Native_POSIX_Thread_Library">Native POSIX Thread Library</a></p>
<p>Native POSIX Thread Library（NPTL）是Linux内核中实践POSIX Threads标准的库</p>
<p>在Linux内核2.6出现之前进程是(最小)可调度的对象，当时的Linux不真正支持线程。但是Linux内核有一个系统调用指令<code>clone()</code>，这个指令产生一个调用调用的进程的复件，而且这个复件与原进程使用同一地址空间。LinuxThreads计划使用这个系统调用来提供一个内核级的线程支持。但是这个解决方法与真正的POSIX标准有一些不兼容的地方，尤其是在信号处理、进程调度和进程间同步原语方面。</p>
<p>要提高LinuxThreads的效应很明显需要提供内核支持以及必须重写线程函数库。为了解决这个问题出现了两个互相竞争的项目：一个IBM的组的项目叫做NGPT（Next Generation POSIX Threads，下一代POSIX线程），另一个组是由Red Hat程序员组成的。2003年中NGPT被放弃，几乎与此同时NPTL公布了。</p>
<p>NPTL首次是随Red Hat Linux 9发表的。此前老式的Linux POSIX线程偶尔会发生系统无法产生线程的毛病，这个毛病的原因是因为在新线程开始的时候系统没有借机先占。当时的Windows系统对这个问题的解决比较好。Red Hat在关于Red Hat Linux 9上的Java的网页上发表了一篇文章称NPTL解决了这个问题[3]。</p>
<p>从第3版开始NPTL是Red Hat Enterprise Linux的一部分，从Linux内核2.6开始它被纳入内核。当前它完全被结合入<code>GNU C</code> 库。</p>
<p>NPTL的解决方法与LinuxThreads类似，内核看到的首要抽象依然是一个进程，新线程是通过clone()系统调用产生的。但是NPTL需要特殊的内核支持来解决同步的原始类型之间互相竞争的状况。在这种情况下线程必须能够入眠和再复苏。用来完成这个任务的原始类型叫做<code>futex</code>。</p>
<p>NPTL是一个所谓的<code>1×1线程函数库</code>。用户产生的线程与内核能够分配的对象之间的联系是一对一的。这是所有线程程序中最简单的。</p>
<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>GNU C Library (GNU libc) stable release version 2.17, by Roland McGrath et al.</p>
<hr>
<h3 id="pthread-mutex-t"><a href="#pthread-mutex-t" class="headerlink" title="pthread_mutex_t"></a>pthread_mutex_t</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Data structures for mutex handling.  The structure of the attribute</span></span><br><span class="line"><span class="comment">   type is deliberately not exposed.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">pthread_mutex_s</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">int</span> __lock;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> __count;</span><br><span class="line">    <span class="keyword">int</span> __owner;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> __nusers;</span><br><span class="line">    <span class="comment">/* KIND must stay at this position in the structure to maintain</span></span><br><span class="line"><span class="comment">       binary compatibility.  */</span></span><br><span class="line">    <span class="keyword">int</span> __kind;</span><br><span class="line">    <span class="keyword">int</span> __spins;</span><br><span class="line">    <span class="keyword">__pthread_list_t</span> __list;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __PTHREAD_MUTEX_HAVE_PREV	1</span></span><br><span class="line">  &#125; __data;</span><br><span class="line">  <span class="keyword">char</span> __size[__SIZEOF_PTHREAD_MUTEX_T];</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> __align;</span><br><span class="line">&#125; <span class="keyword">pthread_mutex_t</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="PTHREAD-MUTEX-INITIALIZER"><a href="#PTHREAD-MUTEX-INITIALIZER" class="headerlink" title="PTHREAD_MUTEX_INITIALIZER"></a>PTHREAD_MUTEX_INITIALIZER</h3><p>静态初始化的宏</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mutex=PTHREAD_MUTEX_INITIALIZER; </span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex=PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Mutex initializers.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __PTHREAD_MUTEX_HAVE_PREV</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> PTHREAD_MUTEX_INITIALIZER \</span></span><br><span class="line">  &#123; &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, &#123; <span class="number">0</span>, <span class="number">0</span> &#125; &#125; &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="pthread-mutex-init"><a href="#pthread-mutex-init" class="headerlink" title="pthread_mutex_init"></a>pthread_mutex_init</h3><p>动态初始化的函数(malloc或者分配在共享内存区)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__pthread_mutex_init (mutex, mutexattr)</span><br><span class="line">     <span class="keyword">pthread_mutex_t</span> *mutex;</span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *mutexattr;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pthread_mutexattr</span> *<span class="title">imutexattr</span>;</span></span><br><span class="line"></span><br><span class="line">  assert (<span class="keyword">sizeof</span> (<span class="keyword">pthread_mutex_t</span>) &lt;= __SIZEOF_PTHREAD_MUTEX_T);</span><br><span class="line"></span><br><span class="line">  imutexattr = (<span class="keyword">const</span> struct pthread_mutexattr *) mutexattr ?: &amp;default_attr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Sanity checks.  */</span></span><br><span class="line">  <span class="keyword">switch</span> (__builtin_expect (imutexattr-&gt;mutexkind</span><br><span class="line">			    &amp; PTHREAD_MUTEXATTR_PROTOCOL_MASK,</span><br><span class="line">			    PTHREAD_PRIO_NONE</span><br><span class="line">			    &lt;&lt; PTHREAD_MUTEXATTR_PROTOCOL_SHIFT))</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> PTHREAD_PRIO_NONE &lt;&lt; PTHREAD_MUTEXATTR_PROTOCOL_SHIFT:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> PTHREAD_PRIO_INHERIT &lt;&lt; PTHREAD_MUTEXATTR_PROTOCOL_SHIFT:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __ASSUME_FUTEX_LOCK_PI</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (tpi_supported == <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">int</span> lock = <span class="number">0</span>;</span><br><span class="line">	  INTERNAL_SYSCALL_DECL (err);</span><br><span class="line">	  <span class="keyword">int</span> ret = INTERNAL_SYSCALL (futex, err, <span class="number">4</span>, &amp;lock, FUTEX_UNLOCK_PI,</span><br><span class="line">				      <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	  assert (INTERNAL_SYSCALL_ERROR_P (ret, err));</span><br><span class="line">	  tpi_supported = INTERNAL_SYSCALL_ERRNO (ret, err) == ENOSYS ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (tpi_supported &lt; <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">	<span class="keyword">return</span> ENOTSUP;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">/* <span class="doctag">XXX:</span> For now we don&#x27;t support robust priority protected mutexes.  */</span></span><br><span class="line">      <span class="keyword">if</span> (imutexattr-&gt;mutexkind &amp; PTHREAD_MUTEXATTR_FLAG_ROBUST)</span><br><span class="line">	<span class="keyword">return</span> ENOTSUP;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Clear the whole variable.  */</span></span><br><span class="line">  <span class="built_in">memset</span> (mutex, <span class="string">&#x27;\0&#x27;</span>, __SIZEOF_PTHREAD_MUTEX_T);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Copy the values from the attribute.  */</span></span><br><span class="line">  mutex-&gt;__data.__kind = imutexattr-&gt;mutexkind &amp; ~PTHREAD_MUTEXATTR_FLAG_BITS;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((imutexattr-&gt;mutexkind &amp; PTHREAD_MUTEXATTR_FLAG_ROBUST) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __ASSUME_SET_ROBUST_LIST</span></span><br><span class="line">      <span class="keyword">if</span> ((imutexattr-&gt;mutexkind &amp; PTHREAD_MUTEXATTR_FLAG_PSHARED) != <span class="number">0</span></span><br><span class="line">	  &amp;&amp; __set_robust_list_avail &lt; <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> ENOTSUP;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      mutex-&gt;__data.__kind |= PTHREAD_MUTEX_ROBUST_NORMAL_NP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (imutexattr-&gt;mutexkind &amp; PTHREAD_MUTEXATTR_PROTOCOL_MASK)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> PTHREAD_PRIO_INHERIT &lt;&lt; PTHREAD_MUTEXATTR_PROTOCOL_SHIFT:</span><br><span class="line">      mutex-&gt;__data.__kind |= PTHREAD_MUTEX_PRIO_INHERIT_NP;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> PTHREAD_PRIO_PROTECT &lt;&lt; PTHREAD_MUTEXATTR_PROTOCOL_SHIFT:</span><br><span class="line">      mutex-&gt;__data.__kind |= PTHREAD_MUTEX_PRIO_PROTECT_NP;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> ceiling = (imutexattr-&gt;mutexkind</span><br><span class="line">		     &amp; PTHREAD_MUTEXATTR_PRIO_CEILING_MASK)</span><br><span class="line">		    &gt;&gt; PTHREAD_MUTEXATTR_PRIO_CEILING_SHIFT;</span><br><span class="line">      <span class="keyword">if</span> (! ceiling)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">if</span> (__sched_fifo_min_prio == <span class="number">-1</span>)</span><br><span class="line">	    __init_sched_fifo_prio ();</span><br><span class="line">	  <span class="keyword">if</span> (ceiling &lt; __sched_fifo_min_prio)</span><br><span class="line">	    ceiling = __sched_fifo_min_prio;</span><br><span class="line">	&#125;</span><br><span class="line">      mutex-&gt;__data.__lock = ceiling &lt;&lt; PTHREAD_MUTEX_PRIO_CEILING_SHIFT;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The kernel when waking robust mutexes on exit never uses</span></span><br><span class="line"><span class="comment">     FUTEX_PRIVATE_FLAG FUTEX_WAKE.  */</span></span><br><span class="line">  <span class="keyword">if</span> ((imutexattr-&gt;mutexkind &amp; (PTHREAD_MUTEXATTR_FLAG_PSHARED</span><br><span class="line">				| PTHREAD_MUTEXATTR_FLAG_ROBUST)) != <span class="number">0</span>)</span><br><span class="line">    mutex-&gt;__data.__kind |= PTHREAD_MUTEX_PSHARED_BIT;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Default values: mutex not used yet.  */</span></span><br><span class="line">  <span class="comment">// mutex-&gt;__count = 0;	already done by memset</span></span><br><span class="line">  <span class="comment">// mutex-&gt;__owner = 0;	already done by memset</span></span><br><span class="line">  <span class="comment">// mutex-&gt;__nusers = 0;	already done by memset</span></span><br><span class="line">  <span class="comment">// mutex-&gt;__spins = 0;	already done by memset</span></span><br><span class="line">  <span class="comment">// mutex-&gt;__next = NULL;	already done by memset</span></span><br><span class="line"></span><br><span class="line">  LIBC_PROBE (mutex_init, <span class="number">1</span>, mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>比较复杂，不研究了</p>
<p><strong>unp:</strong> <br></p>
<blockquote>
<p>你可能会碰到省略了初始化操作的代码，因为它所在的实现把初始化常量定义为0(而且静态分配的变量被自动得初始化为0)，不过这是不正确的代码</p>
</blockquote>
<hr>
<h3 id="pthread-mutex-lock"><a href="#pthread-mutex-lock" class="headerlink" title="__pthread_mutex_lock"></a>__pthread_mutex_lock</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pthread_mutex_lock.c</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">__pthread_mutex_lock (mutex)</span><br><span class="line">     <span class="keyword">pthread_mutex_t</span> *mutex;</span><br><span class="line">&#123;</span><br><span class="line">  assert (<span class="keyword">sizeof</span> (mutex-&gt;__size) &gt;= <span class="keyword">sizeof</span> (mutex-&gt;__data));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> type = PTHREAD_MUTEX_TYPE (mutex);</span><br><span class="line"></span><br><span class="line">  LIBC_PROBE (mutex_entry, <span class="number">1</span>, mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (type &amp; ~PTHREAD_MUTEX_KIND_MASK_NP, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> __pthread_mutex_lock_full (mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">pid_t</span> id = THREAD_GETMEM (THREAD_SELF, tid);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (type, PTHREAD_MUTEX_TIMED_NP)</span><br><span class="line">      == PTHREAD_MUTEX_TIMED_NP)</span><br><span class="line">    &#123;</span><br><span class="line">    simple:</span><br><span class="line">      <span class="comment">/* Normal mutex.  */</span></span><br><span class="line">      LLL_MUTEX_LOCK (mutex);</span><br><span class="line">      assert (mutex-&gt;__data.__owner == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (__builtin_expect (type == PTHREAD_MUTEX_RECURSIVE_NP, <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//递归锁</span></span><br><span class="line">      <span class="comment">/* Recursive mutex.  */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Check whether we already hold the mutex.  */</span></span><br><span class="line">      <span class="keyword">if</span> (mutex-&gt;__data.__owner == id)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* Just bump the counter.  */</span></span><br><span class="line">	  <span class="keyword">if</span> (__builtin_expect (mutex-&gt;__data.__count + <span class="number">1</span> == <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">	    <span class="comment">/* Overflow of the counter.  */</span></span><br><span class="line">	    <span class="keyword">return</span> EAGAIN;</span><br><span class="line"></span><br><span class="line">	  ++mutex-&gt;__data.__count;</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We have to get the mutex.  */</span></span><br><span class="line">      LLL_MUTEX_LOCK (mutex);</span><br><span class="line"></span><br><span class="line">      assert (mutex-&gt;__data.__owner == <span class="number">0</span>);</span><br><span class="line">      mutex-&gt;__data.__count = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (__builtin_expect (type == PTHREAD_MUTEX_ADAPTIVE_NP, <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (! __is_smp)</span><br><span class="line">	<span class="keyword">goto</span> simple;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (LLL_MUTEX_TRYLOCK (mutex) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	  <span class="keyword">int</span> max_cnt = MIN (MAX_ADAPTIVE_COUNT,</span><br><span class="line">			     mutex-&gt;__data.__spins * <span class="number">2</span> + <span class="number">10</span>);</span><br><span class="line">	  <span class="keyword">do</span></span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">if</span> (cnt++ &gt;= max_cnt)</span><br><span class="line">		&#123;</span><br><span class="line">		  LLL_MUTEX_LOCK (mutex);</span><br><span class="line">		  <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> BUSY_WAIT_NOP</span></span><br><span class="line">	      BUSY_WAIT_NOP;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	    &#125;</span><br><span class="line">	  <span class="keyword">while</span> (LLL_MUTEX_TRYLOCK (mutex) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	  mutex-&gt;__data.__spins += (cnt - mutex-&gt;__data.__spins) / <span class="number">8</span>;</span><br><span class="line">	&#125;</span><br><span class="line">      assert (mutex-&gt;__data.__owner == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      assert (type == PTHREAD_MUTEX_ERRORCHECK_NP);</span><br><span class="line">      <span class="comment">/* Check whether we already hold the mutex.  */</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (mutex-&gt;__data.__owner == id, <span class="number">0</span>))</span><br><span class="line">	<span class="keyword">return</span> EDEADLK;</span><br><span class="line">      <span class="keyword">goto</span> simple;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Record the ownership.  */</span></span><br><span class="line">  mutex-&gt;__data.__owner = id;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NO_INCR</span></span><br><span class="line">  ++mutex-&gt;__data.__nusers;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  LIBC_PROBE (mutex_acquired, <span class="number">1</span>, mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>如果是普通锁，调用LLL_MUTEX_LOCK，进行CAS(Compare-and-Swap)操作，失败则执行系统调用sys_futex陷入内核态</li>
<li>如果是递归锁，判断是否是当前进程(线程)持有锁。然后将count计数器加一，如果count等于0，则return EAGAIN</li>
<li>如果是自适应锁，通过非阻塞的LLL_MUTEX_TRYLOCK自旋到最大次数后，执行LLL_MUTEX_LOCK</li>
<li>如果是检错锁，判断是否是当前进程(线程)重复加锁，返回EDEADLK</li>
</ul>
<hr>
<h3 id="pthread-mutex-unlock"><a href="#pthread-mutex-unlock" class="headerlink" title="__pthread_mutex_unlock"></a>__pthread_mutex_unlock</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__pthread_mutex_unlock (mutex)</span><br><span class="line">     <span class="keyword">pthread_mutex_t</span> *mutex;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __pthread_mutex_unlock_usercnt (mutex, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">internal_function attribute_hidden</span><br><span class="line">__pthread_mutex_unlock_usercnt (mutex, decr)</span><br><span class="line">     <span class="keyword">pthread_mutex_t</span> *mutex;</span><br><span class="line">     <span class="keyword">int</span> decr;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> type = PTHREAD_MUTEX_TYPE (mutex);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (type &amp; ~PTHREAD_MUTEX_KIND_MASK_NP, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> __pthread_mutex_unlock_full (mutex, decr);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (type, PTHREAD_MUTEX_TIMED_NP)</span><br><span class="line">      == PTHREAD_MUTEX_TIMED_NP)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Always reset the owner field.  */</span></span><br><span class="line">    normal:</span><br><span class="line">      mutex-&gt;__data.__owner = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (decr)</span><br><span class="line">	<span class="comment">/* One less user.  */</span></span><br><span class="line">	--mutex-&gt;__data.__nusers;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Unlock.  */</span></span><br><span class="line">      lll_unlock (mutex-&gt;__data.__lock, PTHREAD_MUTEX_PSHARED (mutex));</span><br><span class="line"></span><br><span class="line">      LIBC_PROBE (mutex_release, <span class="number">1</span>, mutex);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (__builtin_expect (type == PTHREAD_MUTEX_RECURSIVE_NP, <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Recursive mutex.  */</span></span><br><span class="line">      <span class="keyword">if</span> (mutex-&gt;__data.__owner != THREAD_GETMEM (THREAD_SELF, tid))</span><br><span class="line">	<span class="keyword">return</span> EPERM;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (--mutex-&gt;__data.__count != <span class="number">0</span>)</span><br><span class="line">	<span class="comment">/* We still hold the mutex.  */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">goto</span> normal;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (__builtin_expect (type == PTHREAD_MUTEX_ADAPTIVE_NP, <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">goto</span> normal;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Error checking mutex.  */</span></span><br><span class="line">      assert (type == PTHREAD_MUTEX_ERRORCHECK_NP);</span><br><span class="line">      <span class="keyword">if</span> (mutex-&gt;__data.__owner != THREAD_GETMEM (THREAD_SELF, tid)</span><br><span class="line">	  || ! lll_islocked (mutex-&gt;__data.__lock))</span><br><span class="line">	<span class="keyword">return</span> EPERM;</span><br><span class="line">      <span class="keyword">goto</span> normal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果是普通锁，执行lll_unlock</li>
<li>如果是递归锁，判断是否是当前的进程(线程)持有锁，如果是，count计数器减一，count为0的话，返回</li>
<li>如果是自适应锁，执行lll_unlock</li>
<li>如果是检错锁，判断是否是当前的进程(线程)持有锁，如果是，执行lll_unlock。如果不是，返回EPERM</li>
</ul>
<hr>
<h3 id="pthread-mutex-trylock"><a href="#pthread-mutex-trylock" class="headerlink" title="__pthread_mutex_trylock"></a>__pthread_mutex_trylock</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__pthread_mutex_trylock (mutex)</span><br><span class="line">     <span class="keyword">pthread_mutex_t</span> *mutex;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> oldval;</span><br><span class="line">  <span class="keyword">pid_t</span> id = THREAD_GETMEM (THREAD_SELF, tid);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (__builtin_expect (PTHREAD_MUTEX_TYPE (mutex),</span><br><span class="line">			    PTHREAD_MUTEX_TIMED_NP))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Recursive mutex.  */</span></span><br><span class="line">    <span class="keyword">case</span> PTHREAD_MUTEX_RECURSIVE_NP:</span><br><span class="line">      <span class="comment">/* Check whether we already hold the mutex.  */</span></span><br><span class="line">      <span class="keyword">if</span> (mutex-&gt;__data.__owner == id)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* Just bump the counter.  */</span></span><br><span class="line">	  <span class="keyword">if</span> (__builtin_expect (mutex-&gt;__data.__count + <span class="number">1</span> == <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">	    <span class="comment">/* Overflow of the counter.  */</span></span><br><span class="line">	    <span class="keyword">return</span> EAGAIN;</span><br><span class="line"></span><br><span class="line">	  ++mutex-&gt;__data.__count;</span><br><span class="line">	  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (lll_trylock (mutex-&gt;__data.__lock) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* Record the ownership.  */</span></span><br><span class="line">	  mutex-&gt;__data.__owner = id;</span><br><span class="line">	  mutex-&gt;__data.__count = <span class="number">1</span>;</span><br><span class="line">	  ++mutex-&gt;__data.__nusers;</span><br><span class="line">	  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> PTHREAD_MUTEX_ERRORCHECK_NP:</span><br><span class="line">    <span class="keyword">case</span> PTHREAD_MUTEX_TIMED_NP:</span><br><span class="line">    <span class="keyword">case</span> PTHREAD_MUTEX_ADAPTIVE_NP:</span><br><span class="line">      <span class="comment">/* Normal mutex.  */</span></span><br><span class="line">      <span class="keyword">if</span> (lll_trylock (mutex-&gt;__data.__lock) != <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Record the ownership.  */</span></span><br><span class="line">      mutex-&gt;__data.__owner = id;</span><br><span class="line">      ++mutex-&gt;__data.__nusers;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> PTHREAD_MUTEX_ROBUST_RECURSIVE_NP:</span><br><span class="line">    <span class="keyword">case</span> PTHREAD_MUTEX_ROBUST_ERRORCHECK_NP:</span><br><span class="line">    <span class="keyword">case</span> PTHREAD_MUTEX_ROBUST_NORMAL_NP:</span><br><span class="line">    <span class="keyword">case</span> PTHREAD_MUTEX_ROBUST_ADAPTIVE_NP:</span><br><span class="line">      THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending,</span><br><span class="line">		     &amp;mutex-&gt;__data.__list.__next);</span><br><span class="line"></span><br><span class="line">      oldval = mutex-&gt;__data.__lock;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">	again:</span><br><span class="line">	  <span class="keyword">if</span> ((oldval &amp; FUTEX_OWNER_DIED) != <span class="number">0</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="comment">/* The previous owner died.  Try locking the mutex.  */</span></span><br><span class="line">	      <span class="keyword">int</span> newval = id | (oldval &amp; FUTEX_WAITERS);</span><br><span class="line"></span><br><span class="line">	      newval</span><br><span class="line">		= atomic_compare_and_exchange_val_acq (&amp;mutex-&gt;__data.__lock,</span><br><span class="line">						       newval, oldval);</span><br><span class="line"></span><br><span class="line">	      <span class="keyword">if</span> (newval != oldval)</span><br><span class="line">		&#123;</span><br><span class="line">		  oldval = newval;</span><br><span class="line">		  <span class="keyword">goto</span> again;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	      <span class="comment">/* We got the mutex.  */</span></span><br><span class="line">	      mutex-&gt;__data.__count = <span class="number">1</span>;</span><br><span class="line">	      <span class="comment">/* But it is inconsistent unless marked otherwise.  */</span></span><br><span class="line">	      mutex-&gt;__data.__owner = PTHREAD_MUTEX_INCONSISTENT;</span><br><span class="line"></span><br><span class="line">	      ENQUEUE_MUTEX (mutex);</span><br><span class="line">	      THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	      <span class="comment">/* Note that we deliberately exist here.  If we fall</span></span><br><span class="line"><span class="comment">		 through to the end of the function __nusers would be</span></span><br><span class="line"><span class="comment">		 incremented which is not correct because the old</span></span><br><span class="line"><span class="comment">		 owner has to be discounted.  */</span></span><br><span class="line">	      <span class="keyword">return</span> EOWNERDEAD;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Check whether we already hold the mutex.  */</span></span><br><span class="line">	  <span class="keyword">if</span> (__builtin_expect ((oldval &amp; FUTEX_TID_MASK) == id, <span class="number">0</span>))</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">int</span> kind = PTHREAD_MUTEX_TYPE (mutex);</span><br><span class="line">	      <span class="keyword">if</span> (kind == PTHREAD_MUTEX_ROBUST_ERRORCHECK_NP)</span><br><span class="line">		&#123;</span><br><span class="line">		  THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending,</span><br><span class="line">				 <span class="literal">NULL</span>);</span><br><span class="line">		  <span class="keyword">return</span> EDEADLK;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	      <span class="keyword">if</span> (kind == PTHREAD_MUTEX_ROBUST_RECURSIVE_NP)</span><br><span class="line">		&#123;</span><br><span class="line">		  THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending,</span><br><span class="line">				 <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		  <span class="comment">/* Just bump the counter.  */</span></span><br><span class="line">		  <span class="keyword">if</span> (__builtin_expect (mutex-&gt;__data.__count + <span class="number">1</span> == <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">		    <span class="comment">/* Overflow of the counter.  */</span></span><br><span class="line">		    <span class="keyword">return</span> EAGAIN;</span><br><span class="line"></span><br><span class="line">		  ++mutex-&gt;__data.__count;</span><br><span class="line"></span><br><span class="line">		  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  oldval = lll_robust_trylock (mutex-&gt;__data.__lock, id);</span><br><span class="line">	  <span class="keyword">if</span> (oldval != <span class="number">0</span> &amp;&amp; (oldval &amp; FUTEX_OWNER_DIED) == <span class="number">0</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	      <span class="keyword">return</span> EBUSY;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (__builtin_expect (mutex-&gt;__data.__owner</span><br><span class="line">				== PTHREAD_MUTEX_NOTRECOVERABLE, <span class="number">0</span>))</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="comment">/* This mutex is now not recoverable.  */</span></span><br><span class="line">	      mutex-&gt;__data.__count = <span class="number">0</span>;</span><br><span class="line">	      <span class="keyword">if</span> (oldval == id)</span><br><span class="line">		lll_unlock (mutex-&gt;__data.__lock,</span><br><span class="line">			    PTHREAD_ROBUST_MUTEX_PSHARED (mutex));</span><br><span class="line">	      THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending, <span class="literal">NULL</span>);</span><br><span class="line">	      <span class="keyword">return</span> ENOTRECOVERABLE;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">while</span> ((oldval &amp; FUTEX_OWNER_DIED) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      ENQUEUE_MUTEX (mutex);</span><br><span class="line">      THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">      mutex-&gt;__data.__owner = id;</span><br><span class="line">      ++mutex-&gt;__data.__nusers;</span><br><span class="line">      mutex-&gt;__data.__count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> PTHREAD_MUTEX_PI_RECURSIVE_NP:</span><br><span class="line">    <span class="keyword">case</span> PTHREAD_MUTEX_PI_ERRORCHECK_NP:</span><br><span class="line">    <span class="keyword">case</span> PTHREAD_MUTEX_PI_NORMAL_NP:</span><br><span class="line">    <span class="keyword">case</span> PTHREAD_MUTEX_PI_ADAPTIVE_NP:</span><br><span class="line">    <span class="keyword">case</span> PTHREAD_MUTEX_PI_ROBUST_RECURSIVE_NP:</span><br><span class="line">    <span class="keyword">case</span> PTHREAD_MUTEX_PI_ROBUST_ERRORCHECK_NP:</span><br><span class="line">    <span class="keyword">case</span> PTHREAD_MUTEX_PI_ROBUST_NORMAL_NP:</span><br><span class="line">    <span class="keyword">case</span> PTHREAD_MUTEX_PI_ROBUST_ADAPTIVE_NP:</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="keyword">int</span> kind = mutex-&gt;__data.__kind &amp; PTHREAD_MUTEX_KIND_MASK_NP;</span><br><span class="line">	<span class="keyword">int</span> robust = mutex-&gt;__data.__kind &amp; PTHREAD_MUTEX_ROBUST_NORMAL_NP;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (robust)</span><br><span class="line">	  <span class="comment">/* Note: robust PI futexes are signaled by setting bit 0.  */</span></span><br><span class="line">	  THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending,</span><br><span class="line">			 (<span class="keyword">void</span> *) (((<span class="keyword">uintptr_t</span>) &amp;mutex-&gt;__data.__list.__next)</span><br><span class="line">				   | <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">	oldval = mutex-&gt;__data.__lock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check whether we already hold the mutex.  */</span></span><br><span class="line">	<span class="keyword">if</span> (__builtin_expect ((oldval &amp; FUTEX_TID_MASK) == id, <span class="number">0</span>))</span><br><span class="line">	  &#123;</span><br><span class="line">	    <span class="keyword">if</span> (kind == PTHREAD_MUTEX_ERRORCHECK_NP)</span><br><span class="line">	      &#123;</span><br><span class="line">		THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">return</span> EDEADLK;</span><br><span class="line">	      &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> (kind == PTHREAD_MUTEX_RECURSIVE_NP)</span><br><span class="line">	      &#123;</span><br><span class="line">		THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Just bump the counter.  */</span></span><br><span class="line">		<span class="keyword">if</span> (__builtin_expect (mutex-&gt;__data.__count + <span class="number">1</span> == <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">		  <span class="comment">/* Overflow of the counter.  */</span></span><br><span class="line">		  <span class="keyword">return</span> EAGAIN;</span><br><span class="line"></span><br><span class="line">		++mutex-&gt;__data.__count;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	      &#125;</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	oldval</span><br><span class="line">	  = atomic_compare_and_exchange_val_acq (&amp;mutex-&gt;__data.__lock,</span><br><span class="line">						 id, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (oldval != <span class="number">0</span>)</span><br><span class="line">	  &#123;</span><br><span class="line">	    <span class="keyword">if</span> ((oldval &amp; FUTEX_OWNER_DIED) == <span class="number">0</span>)</span><br><span class="line">	      &#123;</span><br><span class="line">		THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> EBUSY;</span><br><span class="line">	      &#125;</span><br><span class="line"></span><br><span class="line">	    assert (robust);</span><br><span class="line"></span><br><span class="line">	    <span class="comment">/* The mutex owner died.  The kernel will now take care of</span></span><br><span class="line"><span class="comment">	       everything.  */</span></span><br><span class="line">	    <span class="keyword">int</span> <span class="keyword">private</span> = (robust</span><br><span class="line">			   ? PTHREAD_ROBUST_MUTEX_PSHARED (mutex)</span><br><span class="line">			   : PTHREAD_MUTEX_PSHARED (mutex));</span><br><span class="line">	    INTERNAL_SYSCALL_DECL (__err);</span><br><span class="line">	    <span class="keyword">int</span> e = INTERNAL_SYSCALL (futex, __err, <span class="number">4</span>, &amp;mutex-&gt;__data.__lock,</span><br><span class="line">				      __lll_private_flag (FUTEX_TRYLOCK_PI,</span><br><span class="line">							  <span class="keyword">private</span>), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> (INTERNAL_SYSCALL_ERROR_P (e, __err)</span><br><span class="line">		&amp;&amp; INTERNAL_SYSCALL_ERRNO (e, __err) == EWOULDBLOCK)</span><br><span class="line">	      &#123;</span><br><span class="line">		THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> EBUSY;</span><br><span class="line">	      &#125;</span><br><span class="line"></span><br><span class="line">	    oldval = mutex-&gt;__data.__lock;</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (__builtin_expect (oldval &amp; FUTEX_OWNER_DIED, <span class="number">0</span>))</span><br><span class="line">	  &#123;</span><br><span class="line">	    atomic_and (&amp;mutex-&gt;__data.__lock, ~FUTEX_OWNER_DIED);</span><br><span class="line"></span><br><span class="line">	    <span class="comment">/* We got the mutex.  */</span></span><br><span class="line">	    mutex-&gt;__data.__count = <span class="number">1</span>;</span><br><span class="line">	    <span class="comment">/* But it is inconsistent unless marked otherwise.  */</span></span><br><span class="line">	    mutex-&gt;__data.__owner = PTHREAD_MUTEX_INCONSISTENT;</span><br><span class="line"></span><br><span class="line">	    ENQUEUE_MUTEX (mutex);</span><br><span class="line">	    THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	    <span class="comment">/* Note that we deliberately exit here.  If we fall</span></span><br><span class="line"><span class="comment">	       through to the end of the function __nusers would be</span></span><br><span class="line"><span class="comment">	       incremented which is not correct because the old owner</span></span><br><span class="line"><span class="comment">	       has to be discounted.  */</span></span><br><span class="line">	    <span class="keyword">return</span> EOWNERDEAD;</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (robust</span><br><span class="line">	    &amp;&amp; __builtin_expect (mutex-&gt;__data.__owner</span><br><span class="line">				 == PTHREAD_MUTEX_NOTRECOVERABLE, <span class="number">0</span>))</span><br><span class="line">	  &#123;</span><br><span class="line">	    <span class="comment">/* This mutex is now not recoverable.  */</span></span><br><span class="line">	    mutex-&gt;__data.__count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	    INTERNAL_SYSCALL_DECL (__err);</span><br><span class="line">	    INTERNAL_SYSCALL (futex, __err, <span class="number">4</span>, &amp;mutex-&gt;__data.__lock,</span><br><span class="line">			      __lll_private_flag (FUTEX_UNLOCK_PI,</span><br><span class="line">						  PTHREAD_ROBUST_MUTEX_PSHARED (mutex)),</span><br><span class="line">			      <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	    THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending, <span class="literal">NULL</span>);</span><br><span class="line">	    <span class="keyword">return</span> ENOTRECOVERABLE;</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (robust)</span><br><span class="line">	  &#123;</span><br><span class="line">	    ENQUEUE_MUTEX_PI (mutex);</span><br><span class="line">	    THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending, <span class="literal">NULL</span>);</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	mutex-&gt;__data.__owner = id;</span><br><span class="line">	++mutex-&gt;__data.__nusers;</span><br><span class="line">	mutex-&gt;__data.__count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> PTHREAD_MUTEX_PP_RECURSIVE_NP:</span><br><span class="line">    <span class="keyword">case</span> PTHREAD_MUTEX_PP_ERRORCHECK_NP:</span><br><span class="line">    <span class="keyword">case</span> PTHREAD_MUTEX_PP_NORMAL_NP:</span><br><span class="line">    <span class="keyword">case</span> PTHREAD_MUTEX_PP_ADAPTIVE_NP:</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="keyword">int</span> kind = mutex-&gt;__data.__kind &amp; PTHREAD_MUTEX_KIND_MASK_NP;</span><br><span class="line"></span><br><span class="line">	oldval = mutex-&gt;__data.__lock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check whether we already hold the mutex.  */</span></span><br><span class="line">	<span class="keyword">if</span> (mutex-&gt;__data.__owner == id)</span><br><span class="line">	  &#123;</span><br><span class="line">	    <span class="keyword">if</span> (kind == PTHREAD_MUTEX_ERRORCHECK_NP)</span><br><span class="line">	      <span class="keyword">return</span> EDEADLK;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> (kind == PTHREAD_MUTEX_RECURSIVE_NP)</span><br><span class="line">	      &#123;</span><br><span class="line">		<span class="comment">/* Just bump the counter.  */</span></span><br><span class="line">		<span class="keyword">if</span> (__builtin_expect (mutex-&gt;__data.__count + <span class="number">1</span> == <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">		  <span class="comment">/* Overflow of the counter.  */</span></span><br><span class="line">		  <span class="keyword">return</span> EAGAIN;</span><br><span class="line"></span><br><span class="line">		++mutex-&gt;__data.__count;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	      &#125;</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> oldprio = <span class="number">-1</span>, ceilval;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	  &#123;</span><br><span class="line">	    <span class="keyword">int</span> ceiling = (oldval &amp; PTHREAD_MUTEX_PRIO_CEILING_MASK)</span><br><span class="line">			  &gt;&gt; PTHREAD_MUTEX_PRIO_CEILING_SHIFT;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> (__pthread_current_priority () &gt; ceiling)</span><br><span class="line">	      &#123;</span><br><span class="line">		<span class="keyword">if</span> (oldprio != <span class="number">-1</span>)</span><br><span class="line">		  __pthread_tpp_change_priority (oldprio, <span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">return</span> EINVAL;</span><br><span class="line">	      &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">int</span> retval = __pthread_tpp_change_priority (oldprio, ceiling);</span><br><span class="line">	    <span class="keyword">if</span> (retval)</span><br><span class="line">	      <span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">	    ceilval = ceiling &lt;&lt; PTHREAD_MUTEX_PRIO_CEILING_SHIFT;</span><br><span class="line">	    oldprio = ceiling;</span><br><span class="line"></span><br><span class="line">	    oldval</span><br><span class="line">	      = atomic_compare_and_exchange_val_acq (&amp;mutex-&gt;__data.__lock,</span><br><span class="line">						     ceilval | <span class="number">1</span>, ceilval);</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> (oldval == ceilval)</span><br><span class="line">	      <span class="keyword">break</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">	<span class="keyword">while</span> ((oldval &amp; PTHREAD_MUTEX_PRIO_CEILING_MASK) != ceilval);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (oldval != ceilval)</span><br><span class="line">	  &#123;</span><br><span class="line">	    __pthread_tpp_change_priority (oldprio, <span class="number">-1</span>);</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	assert (mutex-&gt;__data.__owner == <span class="number">0</span>);</span><br><span class="line">	<span class="comment">/* Record the ownership.  */</span></span><br><span class="line">	mutex-&gt;__data.__owner = id;</span><br><span class="line">	++mutex-&gt;__data.__nusers;</span><br><span class="line">	mutex-&gt;__data.__count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">/* Correct code cannot set any other type.  */</span></span><br><span class="line">      <span class="keyword">return</span> EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> EBUSY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>非阻塞获取锁，具体不分析了</p>
<hr>
<h3 id="pthread-mutex-destroy"><a href="#pthread-mutex-destroy" class="headerlink" title="__pthread_mutex_destroy"></a>__pthread_mutex_destroy</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__pthread_mutex_destroy (mutex)</span><br><span class="line">     <span class="keyword">pthread_mutex_t</span> *mutex;</span><br><span class="line">&#123;</span><br><span class="line">  LIBC_PROBE (mutex_destroy, <span class="number">1</span>, mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((mutex-&gt;__data.__kind &amp; PTHREAD_MUTEX_ROBUST_NORMAL_NP) == <span class="number">0</span></span><br><span class="line">      &amp;&amp; mutex-&gt;__data.__nusers != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> EBUSY;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set to an invalid value.  */</span></span><br><span class="line">  mutex-&gt;__data.__kind = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>摧毁互斥锁</p>
<hr>
<h3 id="四种锁的属性"><a href="#四种锁的属性" class="headerlink" title="四种锁的属性"></a>四种锁的属性</h3><p><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/thread/posix_threadapi/part3/">Posix线程编程指南(3)</a></p>
<p>互斥锁的属性在创建锁的时候指定，在LinuxThreads实现中仅有一个锁类型属性，不同的锁类型在试图对一个已经被锁定的互斥锁加锁时表现不同。当前（glibc2.2.3,linuxthreads0.9）有四个值可供选择：</p>
<ul>
<li><p>PTHREAD_MUTEX_TIMED_NP，这是缺省值，也就是普通锁。当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后按优先级获得锁。这种锁策略保证了资源分配的公平性</p>
</li>
<li><p>PTHREAD_MUTEX_RECURSIVE_NP,嵌套锁，允许同一个线程对同一个锁成功获得多次，并通过多次unlock解锁。如果是不同线程请求，则在加锁线程解锁时重新竞争。</p>
</li>
<li><p>PTHREAD_MUTEX_ADAPTIVE_NP 适应锁，动作最简单的锁类型，仅等待解锁后重新竞争。线程旋转直到达到最大旋转计数或获得锁定为止<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/19863734/what-is-pthread-mutex-adaptive-np">https://stackoverflow.com/questions/19863734/what-is-pthread-mutex-adaptive-np</a></p>
</li>
<li><p>PTHREAD_MUTEX_ERRORCHECK_NP 检错锁，如果同一个线程请求同一个锁，则返回EDEADLK，否则与PTHREAD_MUTEX_TIMED_NP类型动作相同。这样就保证当不允许多次加锁时不会出现最简单情况下的死锁。</p>
</li>
</ul>
<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><h3 id="pthread-cond-t"><a href="#pthread-cond-t" class="headerlink" title="pthread_cond_t"></a>pthread_cond_t</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Data structure for conditional variable handling.  The structure of</span></span><br><span class="line"><span class="comment">   the attribute type is deliberately not exposed.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">int</span> __lock;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> __futex;</span><br><span class="line">    __extension__ <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> __total_seq;</span><br><span class="line">    __extension__ <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> __wakeup_seq;</span><br><span class="line">    __extension__ <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> __woken_seq;</span><br><span class="line">    <span class="keyword">void</span> *__mutex;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> __nwaiters;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> __broadcast_seq;</span><br><span class="line">  &#125; __data;</span><br><span class="line">  <span class="keyword">char</span> __size[__SIZEOF_PTHREAD_COND_T];</span><br><span class="line">  __extension__ <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> __align;</span><br><span class="line">&#125; <span class="keyword">pthread_cond_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="PTHREAD-COND-INITIALIZER"><a href="#PTHREAD-COND-INITIALIZER" class="headerlink" title="PTHREAD_COND_INITIALIZER"></a>PTHREAD_COND_INITIALIZER</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Conditional variable handling.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTHREAD_COND_INITIALIZER &#123; &#123; 0, 0, 0, 0, 0, (void *) 0, 0, 0 &#125; &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>静态初始化</p>
<hr>
<h3 id="pthread-cond-init"><a href="#pthread-cond-init" class="headerlink" title="__pthread_cond_init"></a>__pthread_cond_init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__pthread_cond_init (cond, cond_attr)</span><br><span class="line">     <span class="keyword">pthread_cond_t</span> *cond;</span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *cond_attr;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pthread_condattr</span> *<span class="title">icond_attr</span> =</span> (struct pthread_condattr *) cond_attr;</span><br><span class="line"></span><br><span class="line">  cond-&gt;__data.__lock = LLL_LOCK_INITIALIZER;</span><br><span class="line">  cond-&gt;__data.__futex = <span class="number">0</span>;</span><br><span class="line">  cond-&gt;__data.__nwaiters = (icond_attr != <span class="literal">NULL</span></span><br><span class="line">			     ? ((icond_attr-&gt;value &gt;&gt; <span class="number">1</span>)</span><br><span class="line">				&amp; ((<span class="number">1</span> &lt;&lt; COND_NWAITERS_SHIFT) - <span class="number">1</span>))</span><br><span class="line">			     : CLOCK_REALTIME);</span><br><span class="line">  cond-&gt;__data.__total_seq = <span class="number">0</span>;</span><br><span class="line">  cond-&gt;__data.__wakeup_seq = <span class="number">0</span>;</span><br><span class="line">  cond-&gt;__data.__woken_seq = <span class="number">0</span>;</span><br><span class="line">  cond-&gt;__data.__mutex = (icond_attr == <span class="literal">NULL</span> || (icond_attr-&gt;value &amp; <span class="number">1</span>) == <span class="number">0</span></span><br><span class="line">			  ? <span class="literal">NULL</span> : (<span class="keyword">void</span> *) ~<span class="number">0l</span>);</span><br><span class="line">  cond-&gt;__data.__broadcast_seq = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  LIBC_PROBE (cond_init, <span class="number">2</span>, cond, cond_attr);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态初始化</p>
<hr>
<h3 id="pthread-cond-wait"><a href="#pthread-cond-wait" class="headerlink" title="__pthread_cond_wait"></a>__pthread_cond_wait</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__pthread_cond_wait (cond, mutex)</span><br><span class="line">     <span class="keyword">pthread_cond_t</span> *cond;</span><br><span class="line">     <span class="keyword">pthread_mutex_t</span> *mutex;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">pthread_cleanup_buffer</span> <span class="title">buffer</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">condvar_cleanup_buffer</span> <span class="title">cbuffer</span>;</span></span><br><span class="line">  <span class="keyword">int</span> err;</span><br><span class="line">  <span class="keyword">int</span> pshared = (cond-&gt;__data.__mutex == (<span class="keyword">void</span> *) ~<span class="number">0l</span>)</span><br><span class="line">		? LLL_SHARED : LLL_PRIVATE;</span><br><span class="line"></span><br><span class="line">  LIBC_PROBE (cond_wait, <span class="number">2</span>, cond, mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make sure we are alone.  */</span></span><br><span class="line">  lll_lock (cond-&gt;__data.__lock, pshared);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Now we can release the mutex.  */</span></span><br><span class="line">  err = __pthread_mutex_unlock_usercnt (mutex, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (err, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      lll_unlock (cond-&gt;__data.__lock, pshared);</span><br><span class="line">      <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We have one new user of the condvar.  */</span></span><br><span class="line">  ++cond-&gt;__data.__total_seq;</span><br><span class="line">  ++cond-&gt;__data.__futex;</span><br><span class="line">  cond-&gt;__data.__nwaiters += <span class="number">1</span> &lt;&lt; COND_NWAITERS_SHIFT;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Remember the mutex we are using here.  If there is already a</span></span><br><span class="line"><span class="comment">     different address store this is a bad user bug.  Do not store</span></span><br><span class="line"><span class="comment">     anything for pshared condvars.  */</span></span><br><span class="line">  <span class="keyword">if</span> (cond-&gt;__data.__mutex != (<span class="keyword">void</span> *) ~<span class="number">0l</span>)</span><br><span class="line">    cond-&gt;__data.__mutex = mutex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Prepare structure passed to cancellation handler.  */</span></span><br><span class="line">  cbuffer.cond = cond;</span><br><span class="line">  cbuffer.mutex = mutex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Before we block we enable cancellation.  Therefore we have to</span></span><br><span class="line"><span class="comment">     install a cancellation handler.  */</span></span><br><span class="line">  __pthread_cleanup_push (&amp;buffer, __condvar_cleanup, &amp;cbuffer);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The current values of the wakeup counter.  The &quot;woken&quot; counter</span></span><br><span class="line"><span class="comment">     must exceed this value.  */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> val;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> seq;</span><br><span class="line">  val = seq = cond-&gt;__data.__wakeup_seq;</span><br><span class="line">  <span class="comment">/* Remember the broadcast counter.  */</span></span><br><span class="line">  cbuffer.bc_seq = cond-&gt;__data.__broadcast_seq;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span> futex_val = cond-&gt;__data.__futex;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Prepare to wait.  Release the condvar futex.  */</span></span><br><span class="line">      lll_unlock (cond-&gt;__data.__lock, pshared);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Enable asynchronous cancellation.  Required by the standard.  */</span></span><br><span class="line">      cbuffer.oldtype = __pthread_enable_asynccancel ();</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Wait until woken by signal or broadcast.  */</span></span><br><span class="line">      lll_futex_wait (&amp;cond-&gt;__data.__futex, futex_val, pshared);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Disable asynchronous cancellation.  */</span></span><br><span class="line">      __pthread_disable_asynccancel (cbuffer.oldtype);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We are going to look at shared data again, so get the lock.  */</span></span><br><span class="line">      lll_lock (cond-&gt;__data.__lock, pshared);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* If a broadcast happened, we are done.  */</span></span><br><span class="line">      <span class="keyword">if</span> (cbuffer.bc_seq != cond-&gt;__data.__broadcast_seq)</span><br><span class="line">	<span class="keyword">goto</span> bc_out;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Check whether we are eligible for wakeup.  */</span></span><br><span class="line">      val = cond-&gt;__data.__wakeup_seq;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">while</span> (val == seq || cond-&gt;__data.__woken_seq == val);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Another thread woken up.  */</span></span><br><span class="line">  ++cond-&gt;__data.__woken_seq;</span><br><span class="line"></span><br><span class="line"> bc_out:</span><br><span class="line"></span><br><span class="line">  cond-&gt;__data.__nwaiters -= <span class="number">1</span> &lt;&lt; COND_NWAITERS_SHIFT;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If pthread_cond_destroy was called on this varaible already,</span></span><br><span class="line"><span class="comment">     notify the pthread_cond_destroy caller all waiters have left</span></span><br><span class="line"><span class="comment">     and it can be successfully destroyed.  */</span></span><br><span class="line">  <span class="keyword">if</span> (cond-&gt;__data.__total_seq == <span class="number">-1ULL</span></span><br><span class="line">      &amp;&amp; cond-&gt;__data.__nwaiters &lt; (<span class="number">1</span> &lt;&lt; COND_NWAITERS_SHIFT))</span><br><span class="line">    lll_futex_wake (&amp;cond-&gt;__data.__nwaiters, <span class="number">1</span>, pshared);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We are done with the condvar.  */</span></span><br><span class="line">  lll_unlock (cond-&gt;__data.__lock, pshared);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The cancellation handling is back to normal, remove the handler.  */</span></span><br><span class="line">  __pthread_cleanup_pop (&amp;buffer, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get the mutex before returning.  */</span></span><br><span class="line">  <span class="keyword">return</span> __pthread_mutex_cond_lock (mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>无条件等待pthread_cond_wait()，必须和一个互斥锁配合，以防止多个线程同时请求pthread_cond_wait()（或pthread_cond_timedwait()，下同）的竞争条件（Race Condition）。mutex互斥锁必须是普通锁（PTHREAD_MUTEX_TIMED_NP）或者适应锁（PTHREAD_MUTEX_ADAPTIVE_NP），且在调用pthread_cond_wait()前必须由本线程加锁（pthread_mutex_lock()），而在更新条件等待队列以前，mutex保持锁定状态，并在线程挂起进入等待前解锁。在条件满足从而离开pthread_cond_wait()之前，mutex将被重新加锁，以与进入pthread_cond_wait()前的加锁动作对应。</p>
<p>激发条件有两种形式，pthread_cond_signal()激活一个等待该条件的线程，存在多个等待线程时按入队顺序激活其中一个；而pthread_cond_broadcast()则激活所有等待线程。</p>
<hr>
<h3 id="pthread-cond-timedwait"><a href="#pthread-cond-timedwait" class="headerlink" title="__pthread_cond_timedwait"></a>__pthread_cond_timedwait</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__pthread_cond_timedwait (cond, mutex, abstime)</span><br><span class="line">     <span class="keyword">pthread_cond_t</span> *cond;</span><br><span class="line">     <span class="keyword">pthread_mutex_t</span> *mutex;</span><br><span class="line">     <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> *<span class="title">abstime</span>;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">pthread_cleanup_buffer</span> <span class="title">buffer</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">condvar_cleanup_buffer</span> <span class="title">cbuffer</span>;</span></span><br><span class="line">  <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Catch invalid parameters.  */</span></span><br><span class="line">  <span class="keyword">if</span> (abstime-&gt;tv_nsec &lt; <span class="number">0</span> || abstime-&gt;tv_nsec &gt;= <span class="number">1000000000</span>)</span><br><span class="line">    <span class="keyword">return</span> EINVAL;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> pshared = (cond-&gt;__data.__mutex == (<span class="keyword">void</span> *) ~<span class="number">0l</span>)</span><br><span class="line">		? LLL_SHARED : LLL_PRIVATE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make sure we are alone.  */</span></span><br><span class="line">  lll_lock (cond-&gt;__data.__lock, pshared);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Now we can release the mutex.  */</span></span><br><span class="line">  <span class="keyword">int</span> err = __pthread_mutex_unlock_usercnt (mutex, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    &#123;</span><br><span class="line">      lll_unlock (cond-&gt;__data.__lock, pshared);</span><br><span class="line">      <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We have one new user of the condvar.  */</span></span><br><span class="line">  ++cond-&gt;__data.__total_seq;</span><br><span class="line">  ++cond-&gt;__data.__futex;</span><br><span class="line">  cond-&gt;__data.__nwaiters += <span class="number">1</span> &lt;&lt; COND_NWAITERS_SHIFT;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Work around the fact that the kernel rejects negative timeout values</span></span><br><span class="line"><span class="comment">     despite them being valid.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (abstime-&gt;tv_sec &lt; <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">goto</span> timeout;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Remember the mutex we are using here.  If there is already a</span></span><br><span class="line"><span class="comment">     different address store this is a bad user bug.  Do not store</span></span><br><span class="line"><span class="comment">     anything for pshared condvars.  */</span></span><br><span class="line">  <span class="keyword">if</span> (cond-&gt;__data.__mutex != (<span class="keyword">void</span> *) ~<span class="number">0l</span>)</span><br><span class="line">    cond-&gt;__data.__mutex = mutex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Prepare structure passed to cancellation handler.  */</span></span><br><span class="line">  cbuffer.cond = cond;</span><br><span class="line">  cbuffer.mutex = mutex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Before we block we enable cancellation.  Therefore we have to</span></span><br><span class="line"><span class="comment">     install a cancellation handler.  */</span></span><br><span class="line">  __pthread_cleanup_push (&amp;buffer, __condvar_cleanup, &amp;cbuffer);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The current values of the wakeup counter.  The &quot;woken&quot; counter</span></span><br><span class="line"><span class="comment">     must exceed this value.  */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> val;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> seq;</span><br><span class="line">  val = seq = cond-&gt;__data.__wakeup_seq;</span><br><span class="line">  <span class="comment">/* Remember the broadcast counter.  */</span></span><br><span class="line">  cbuffer.bc_seq = cond-&gt;__data.__broadcast_seq;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (!defined __ASSUME_FUTEX_CLOCK_REALTIME \</span></span><br><span class="line">     || !defined lll_futex_timed_wait_bitset)</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">rt</span>;</span></span><br><span class="line">      &#123;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __NR_clock_gettime</span></span><br><span class="line">	INTERNAL_SYSCALL_DECL (err);</span><br><span class="line">	(<span class="keyword">void</span>) INTERNAL_VSYSCALL (clock_gettime, err, <span class="number">2</span>,</span><br><span class="line">				  (cond-&gt;__data.__nwaiters</span><br><span class="line">				   &amp; ((<span class="number">1</span> &lt;&lt; COND_NWAITERS_SHIFT) - <span class="number">1</span>)),</span><br><span class="line">				  &amp;rt);</span><br><span class="line">	<span class="comment">/* Convert the absolute timeout value to a relative timeout.  */</span></span><br><span class="line">	rt.tv_sec = abstime-&gt;tv_sec - rt.tv_sec;</span><br><span class="line">	rt.tv_nsec = abstime-&gt;tv_nsec - rt.tv_nsec;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="comment">/* Get the current time.  So far we support only one clock.  */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">	(<span class="keyword">void</span>) gettimeofday (&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Convert the absolute timeout value to a relative timeout.  */</span></span><br><span class="line">	rt.tv_sec = abstime-&gt;tv_sec - tv.tv_sec;</span><br><span class="line">	rt.tv_nsec = abstime-&gt;tv_nsec - tv.tv_usec * <span class="number">1000</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (rt.tv_nsec &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  rt.tv_nsec += <span class="number">1000000000</span>;</span><br><span class="line">	  --rt.tv_sec;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="comment">/* Did we already time out?  */</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (rt.tv_sec &lt; <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">if</span> (cbuffer.bc_seq != cond-&gt;__data.__broadcast_seq)</span><br><span class="line">	    <span class="keyword">goto</span> bc_out;</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">goto</span> timeout;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span> futex_val = cond-&gt;__data.__futex;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Prepare to wait.  Release the condvar futex.  */</span></span><br><span class="line">      lll_unlock (cond-&gt;__data.__lock, pshared);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Enable asynchronous cancellation.  Required by the standard.  */</span></span><br><span class="line">      cbuffer.oldtype = __pthread_enable_asynccancel ();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (!defined __ASSUME_FUTEX_CLOCK_REALTIME \</span></span><br><span class="line">     || !defined lll_futex_timed_wait_bitset)</span><br><span class="line">      <span class="comment">/* Wait until woken by signal or broadcast.  */</span></span><br><span class="line">      err = lll_futex_timed_wait (&amp;cond-&gt;__data.__futex,</span><br><span class="line">				  futex_val, &amp;rt, pshared);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span> clockbit = (cond-&gt;__data.__nwaiters &amp; <span class="number">1</span></span><br><span class="line">			       ? <span class="number">0</span> : FUTEX_CLOCK_REALTIME);</span><br><span class="line">      err = lll_futex_timed_wait_bitset (&amp;cond-&gt;__data.__futex, futex_val,</span><br><span class="line">					 abstime, clockbit, pshared);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Disable asynchronous cancellation.  */</span></span><br><span class="line">      __pthread_disable_asynccancel (cbuffer.oldtype);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We are going to look at shared data again, so get the lock.  */</span></span><br><span class="line">      lll_lock (cond-&gt;__data.__lock, pshared);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* If a broadcast happened, we are done.  */</span></span><br><span class="line">      <span class="keyword">if</span> (cbuffer.bc_seq != cond-&gt;__data.__broadcast_seq)</span><br><span class="line">	<span class="keyword">goto</span> bc_out;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Check whether we are eligible for wakeup.  */</span></span><br><span class="line">      val = cond-&gt;__data.__wakeup_seq;</span><br><span class="line">      <span class="keyword">if</span> (val != seq &amp;&amp; cond-&gt;__data.__woken_seq != val)</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Not woken yet.  Maybe the time expired?  */</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (err == -ETIMEDOUT, <span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line">	timeout:</span><br><span class="line">	  <span class="comment">/* Yep.  Adjust the counters.  */</span></span><br><span class="line">	  ++cond-&gt;__data.__wakeup_seq;</span><br><span class="line">	  ++cond-&gt;__data.__futex;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* The error value.  */</span></span><br><span class="line">	  result = ETIMEDOUT;</span><br><span class="line">	  <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Another thread woken up.  */</span></span><br><span class="line">  ++cond-&gt;__data.__woken_seq;</span><br><span class="line"></span><br><span class="line"> bc_out:</span><br><span class="line"></span><br><span class="line">  cond-&gt;__data.__nwaiters -= <span class="number">1</span> &lt;&lt; COND_NWAITERS_SHIFT;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If pthread_cond_destroy was called on this variable already,</span></span><br><span class="line"><span class="comment">     notify the pthread_cond_destroy caller all waiters have left</span></span><br><span class="line"><span class="comment">     and it can be successfully destroyed.  */</span></span><br><span class="line">  <span class="keyword">if</span> (cond-&gt;__data.__total_seq == <span class="number">-1ULL</span></span><br><span class="line">      &amp;&amp; cond-&gt;__data.__nwaiters &lt; (<span class="number">1</span> &lt;&lt; COND_NWAITERS_SHIFT))</span><br><span class="line">    lll_futex_wake (&amp;cond-&gt;__data.__nwaiters, <span class="number">1</span>, pshared);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We are done with the condvar.  */</span></span><br><span class="line">  lll_unlock (cond-&gt;__data.__lock, pshared);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The cancellation handling is back to normal, remove the handler.  */</span></span><br><span class="line">  __pthread_cleanup_pop (&amp;buffer, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get the mutex before returning.  */</span></span><br><span class="line">  err = __pthread_mutex_cond_lock (mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> err ?: result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>超时等待__pthread_cond_timedwait()，必须和一个互斥锁配合，以防止多个线程同时请求pthread_cond_wait()（或pthread_cond_timedwait()，下同）的竞争条件（Race Condition）。mutex互斥锁必须是普通锁（PTHREAD_MUTEX_TIMED_NP）或者适应锁（PTHREAD_MUTEX_ADAPTIVE_NP），且在调用pthread_cond_wait()前必须由本线程加锁（pthread_mutex_lock()），而在更新条件等待队列以前，mutex保持锁定状态，并在线程挂起进入等待前解锁。在条件满足从而离开pthread_cond_wait()之前，mutex将被重新加锁，以与进入pthread_cond_wait()前的加锁动作对应。</p>
<p>激发条件有两种形式，pthread_cond_signal()激活一个等待该条件的线程，存在多个等待线程时按入队顺序激活其中一个；而pthread_cond_broadcast()则激活所有等待线程。</p>
<hr>
<h3 id="pthread-cond-signal"><a href="#pthread-cond-signal" class="headerlink" title="__pthread_cond_signal"></a>__pthread_cond_signal</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__pthread_cond_signal (cond)</span><br><span class="line">     <span class="keyword">pthread_cond_t</span> *cond;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> pshared = (cond-&gt;__data.__mutex == (<span class="keyword">void</span> *) ~<span class="number">0l</span>)</span><br><span class="line">		? LLL_SHARED : LLL_PRIVATE;</span><br><span class="line"></span><br><span class="line">  LIBC_PROBE (cond_signal, <span class="number">1</span>, cond);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make sure we are alone.  */</span></span><br><span class="line">  lll_lock (cond-&gt;__data.__lock, pshared);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Are there any waiters to be woken?  */</span></span><br><span class="line">  <span class="keyword">if</span> (cond-&gt;__data.__total_seq &gt; cond-&gt;__data.__wakeup_seq)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Yes.  Mark one of them as woken.  */</span></span><br><span class="line">      ++cond-&gt;__data.__wakeup_seq;</span><br><span class="line">      ++cond-&gt;__data.__futex;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Wake one.  */</span></span><br><span class="line">      <span class="keyword">if</span> (! __builtin_expect (lll_futex_wake_unlock (&amp;cond-&gt;__data.__futex, <span class="number">1</span>,</span><br><span class="line">						     <span class="number">1</span>, &amp;cond-&gt;__data.__lock,</span><br><span class="line">						     pshared), <span class="number">0</span>))</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      lll_futex_wake (&amp;cond-&gt;__data.__futex, <span class="number">1</span>, pshared);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We are done.  */</span></span><br><span class="line">  lll_unlock (cond-&gt;__data.__lock, pshared);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>唤醒单个线程lll_futex_wake (&amp;cond-&gt;__data.__futex, 1, pshared);</p>
<hr>
<h3 id="pthread-cond-broadcast"><a href="#pthread-cond-broadcast" class="headerlink" title="__pthread_cond_broadcast"></a>__pthread_cond_broadcast</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__pthread_cond_broadcast (cond)</span><br><span class="line">     <span class="keyword">pthread_cond_t</span> *cond;</span><br><span class="line">&#123;</span><br><span class="line">  LIBC_PROBE (cond_broadcast, <span class="number">1</span>, cond);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> pshared = (cond-&gt;__data.__mutex == (<span class="keyword">void</span> *) ~<span class="number">0l</span>)</span><br><span class="line">		? LLL_SHARED : LLL_PRIVATE;</span><br><span class="line">  <span class="comment">/* Make sure we are alone.  */</span></span><br><span class="line">  lll_lock (cond-&gt;__data.__lock, pshared);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Are there any waiters to be woken?  */</span></span><br><span class="line">  <span class="keyword">if</span> (cond-&gt;__data.__total_seq &gt; cond-&gt;__data.__wakeup_seq)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Yes.  Mark them all as woken.  */</span></span><br><span class="line">      cond-&gt;__data.__wakeup_seq = cond-&gt;__data.__total_seq;</span><br><span class="line">      cond-&gt;__data.__woken_seq = cond-&gt;__data.__total_seq;</span><br><span class="line">      cond-&gt;__data.__futex = (<span class="keyword">unsigned</span> <span class="keyword">int</span>) cond-&gt;__data.__total_seq * <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">int</span> futex_val = cond-&gt;__data.__futex;</span><br><span class="line">      <span class="comment">/* Signal that a broadcast happened.  */</span></span><br><span class="line">      ++cond-&gt;__data.__broadcast_seq;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We are done.  */</span></span><br><span class="line">      lll_unlock (cond-&gt;__data.__lock, pshared);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Do not use requeue for pshared condvars.  */</span></span><br><span class="line">      <span class="keyword">if</span> (cond-&gt;__data.__mutex == (<span class="keyword">void</span> *) ~<span class="number">0l</span>)</span><br><span class="line">	<span class="keyword">goto</span> wake_all;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Wake everybody.  */</span></span><br><span class="line">      <span class="keyword">pthread_mutex_t</span> *mut = (<span class="keyword">pthread_mutex_t</span> *) cond-&gt;__data.__mutex;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* <span class="doctag">XXX:</span> Kernel so far doesn&#x27;t support requeue to PI futex.  */</span></span><br><span class="line">      <span class="comment">/* <span class="doctag">XXX:</span> Kernel so far can only requeue to the same type of futex,</span></span><br><span class="line"><span class="comment">	 in this case private (we don&#x27;t requeue for pshared condvars).  */</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (mut-&gt;__data.__kind</span><br><span class="line">			    &amp; (PTHREAD_MUTEX_PRIO_INHERIT_NP</span><br><span class="line">			       | PTHREAD_MUTEX_PSHARED_BIT), <span class="number">0</span>))</span><br><span class="line">	<span class="keyword">goto</span> wake_all;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* lll_futex_requeue returns 0 for success and non-zero</span></span><br><span class="line"><span class="comment">	 for errors.  */</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (lll_futex_requeue (&amp;cond-&gt;__data.__futex, <span class="number">1</span>,</span><br><span class="line">					       INT_MAX, &amp;mut-&gt;__data.__lock,</span><br><span class="line">					       futex_val, LLL_PRIVATE), <span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* The requeue functionality is not available.  */</span></span><br><span class="line">	wake_all:</span><br><span class="line">	<span class="comment">//INT_MAX 唤醒所有等待的线程</span></span><br><span class="line">	  lll_futex_wake (&amp;cond-&gt;__data.__futex, INT_MAX, pshared);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* That&#x27;s all.  */</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We are done.  */</span></span><br><span class="line">  lll_unlock (cond-&gt;__data.__lock, pshared);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>唤醒所有等待的线程lll_futex_wake (&amp;cond-&gt;__data.__futex, INT_MAX, pshared);</p>
<hr>
<h3 id="pthread-cond-destroy"><a href="#pthread-cond-destroy" class="headerlink" title="pthread_cond_destroy"></a>pthread_cond_destroy</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__pthread_cond_destroy (cond)</span><br><span class="line">     <span class="keyword">pthread_cond_t</span> *cond;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> pshared = (cond-&gt;__data.__mutex == (<span class="keyword">void</span> *) ~<span class="number">0l</span>)</span><br><span class="line">		? LLL_SHARED : LLL_PRIVATE;</span><br><span class="line"></span><br><span class="line">  LIBC_PROBE (cond_destroy, <span class="number">1</span>, cond);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make sure we are alone.  */</span></span><br><span class="line">  lll_lock (cond-&gt;__data.__lock, pshared);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cond-&gt;__data.__total_seq &gt; cond-&gt;__data.__wakeup_seq)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* If there are still some waiters which have not been</span></span><br><span class="line"><span class="comment">	 woken up, this is an application bug.  */</span></span><br><span class="line">      lll_unlock (cond-&gt;__data.__lock, pshared);</span><br><span class="line">      <span class="keyword">return</span> EBUSY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Tell pthread_cond_*wait that this condvar is being destroyed.  */</span></span><br><span class="line">  cond-&gt;__data.__total_seq = <span class="number">-1ULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If there are waiters which have been already signalled or</span></span><br><span class="line"><span class="comment">     broadcasted, but still are using the pthread_cond_t structure,</span></span><br><span class="line"><span class="comment">     pthread_cond_destroy needs to wait for them.  */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> nwaiters = cond-&gt;__data.__nwaiters;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nwaiters &gt;= (<span class="number">1</span> &lt;&lt; COND_NWAITERS_SHIFT))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Wake everybody on the associated mutex in case there are</span></span><br><span class="line"><span class="comment">	 threads that have been requeued to it.</span></span><br><span class="line"><span class="comment">	 Without this, pthread_cond_destroy could block potentially</span></span><br><span class="line"><span class="comment">	 for a long time or forever, as it would depend on other</span></span><br><span class="line"><span class="comment">	 thread&#x27;s using the mutex.</span></span><br><span class="line"><span class="comment">	 When all threads waiting on the mutex are woken up, pthread_cond_wait</span></span><br><span class="line"><span class="comment">	 only waits for threads to acquire and release the internal</span></span><br><span class="line"><span class="comment">	 condvar lock.  */</span></span><br><span class="line">      <span class="keyword">if</span> (cond-&gt;__data.__mutex != <span class="literal">NULL</span></span><br><span class="line">	  &amp;&amp; cond-&gt;__data.__mutex != (<span class="keyword">void</span> *) ~<span class="number">0l</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">pthread_mutex_t</span> *mut = (<span class="keyword">pthread_mutex_t</span> *) cond-&gt;__data.__mutex;</span><br><span class="line">	  lll_futex_wake (&amp;mut-&gt;__data.__lock, INT_MAX,</span><br><span class="line">			  PTHREAD_MUTEX_PSHARED (mut));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">	  lll_unlock (cond-&gt;__data.__lock, pshared);</span><br><span class="line"></span><br><span class="line">	  lll_futex_wait (&amp;cond-&gt;__data.__nwaiters, nwaiters, pshared);</span><br><span class="line"></span><br><span class="line">	  lll_lock (cond-&gt;__data.__lock, pshared);</span><br><span class="line"></span><br><span class="line">	  nwaiters = cond-&gt;__data.__nwaiters;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">while</span> (nwaiters &gt;= (<span class="number">1</span> &lt;&lt; COND_NWAITERS_SHIFT));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在释放或废弃条件变量之前，需要毁坏它</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>pthread_cleanup_push和pthread_cleanup_pop作为线程取消的回调函数，在wait函数中执行，防止线程退出导致的锁未释放，进而出现死锁的情况</li>
<li>条件变量机制不是异步信号安全的，也就是说，在信号处理函数中调用pthread_cond_signal()或者pthread_cond_broadcast()很可能引起死锁。</li>
<li>wait函数先解锁，然后加入睡眠列表，没有忙轮询的消耗，被其他线程”唤醒”后重新加锁</li>
<li>wait函数执行前当前线程必须已经对mutex加锁，并且锁的类型是普通锁或者适应锁</li>
</ul>
<hr>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2><p><img src="https://i.loli.net/2020/04/05/L9yTWmxYrC3JgiN.jpg" alt="80413347_p0_master1200.jpg"></p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>TheRiver
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="https://riverferry.site/2020-04-07-linux-posix%E4%BA%92%E6%96%A5%E9%94%81%E5%92%8C%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%20/" title="linux-互斥锁和条件变量">https://riverferry.site/2020-04-07-linux-posix互斥锁和条件变量 /</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/ipc/" rel="tag"><i class="fa fa-tags"></i> ipc</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020-04-04-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/" rel="prev" title="操作系统-进程互斥的实现方案">
      <i class="fa fa-chevron-left"></i> 操作系统-进程互斥的实现方案
    </a></div>
      <div class="post-nav-item">
    <a href="/2020-04-07-linux-posix%E4%BF%A1%E5%8F%B7%E9%87%8F/" rel="next" title="linux-posix信号量">
      linux-posix信号量 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  
   <div>
     <div>
  
    <div style="text-align:center;color:#bfbfbf;font-size:16px;">
      <span>----------- ending -----------</span>
    </div>
  
</div>

   </div>
 



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">1.</span> <span class="nav-text">参考</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">2.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NPTL"><span class="nav-number">3.</span> <span class="nav-text">NPTL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-number">4.</span> <span class="nav-text">互斥锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-mutex-t"><span class="nav-number">4.1.</span> <span class="nav-text">pthread_mutex_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PTHREAD-MUTEX-INITIALIZER"><span class="nav-number">4.2.</span> <span class="nav-text">PTHREAD_MUTEX_INITIALIZER</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-mutex-init"><span class="nav-number">4.3.</span> <span class="nav-text">pthread_mutex_init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-mutex-lock"><span class="nav-number">4.4.</span> <span class="nav-text">__pthread_mutex_lock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-mutex-unlock"><span class="nav-number">4.5.</span> <span class="nav-text">__pthread_mutex_unlock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-mutex-trylock"><span class="nav-number">4.6.</span> <span class="nav-text">__pthread_mutex_trylock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-mutex-destroy"><span class="nav-number">4.7.</span> <span class="nav-text">__pthread_mutex_destroy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E7%A7%8D%E9%94%81%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-number">4.8.</span> <span class="nav-text">四种锁的属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-number">5.</span> <span class="nav-text">条件变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-cond-t"><span class="nav-number">5.1.</span> <span class="nav-text">pthread_cond_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PTHREAD-COND-INITIALIZER"><span class="nav-number">5.2.</span> <span class="nav-text">PTHREAD_COND_INITIALIZER</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-cond-init"><span class="nav-number">5.3.</span> <span class="nav-text">__pthread_cond_init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-cond-wait"><span class="nav-number">5.4.</span> <span class="nav-text">__pthread_cond_wait</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-cond-timedwait"><span class="nav-number">5.5.</span> <span class="nav-text">__pthread_cond_timedwait</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-cond-signal"><span class="nav-number">5.6.</span> <span class="nav-text">__pthread_cond_signal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-cond-broadcast"><span class="nav-number">5.7.</span> <span class="nav-text">__pthread_cond_broadcast</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-cond-destroy"><span class="nav-number">5.8.</span> <span class="nav-text">pthread_cond_destroy</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ending"><span class="nav-number">7.</span> <span class="nav-text">ending</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="TheRiver"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">TheRiver</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">210</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">68</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">TheRiver</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">1.1m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">17:09</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '828d98635e4048805831',
      clientSecret: 'cdf9f70acdfbecd65e89bc3a8c2954be1af2ee01',
      repo        : 'gitalk',
      owner       : 'RiverFerry',
      admin       : ['RiverFerry'],
      id          : '1479d6d34ce25f3d6dd9ef1473617b35',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/ Relative)","tagMode":false,"log":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"left","width":300,"height":800,"hOffset":20,"vOffset":20},"mobile":{"show":false,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2}});</script></body>
</html>
