<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/river.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"riverferry.site","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="前言以前面试准备的，比较凌乱，先放这里">
<meta property="og:type" content="article">
<meta property="og:title" content="c++基础知识点">
<meta property="og:url" content="https://riverferry.site/2020-03-29-c++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/index.html">
<meta property="og:site_name" content="TheRiver | blog">
<meta property="og:description" content="前言以前面试准备的，比较凌乱，先放这里">
<meta property="og:locale">
<meta property="article:published_time" content="2020-03-29T00:00:00.000Z">
<meta property="article:modified_time" content="2022-09-12T16:24:32.279Z">
<meta property="article:author" content="TheRiver">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://riverferry.site/2020-03-29-c++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'default'
  };
</script>

  <title>c++基础知识点 | TheRiver | blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">TheRiver | blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">You have reached the world's edge, none but devils play past here</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/RiverFerry/RiverFerry.github.io" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="https://riverferry.site/2020-03-29-c++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="TheRiver">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TheRiver | blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          c++基础知识点
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-29 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-29T00:00:00+00:00">2020-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-12 16:24:32" itemprop="dateModified" datetime="2022-09-12T16:24:32+00:00">2022-09-12</time>
              </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>20k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>18 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>以前面试准备的，比较凌乱，先放这里</p>
<a id="more"></a>


<h2 id="001-说一下static关键字的作用"><a href="#001-说一下static关键字的作用" class="headerlink" title="001 说一下static关键字的作用"></a>001 说一下static关键字的作用</h2><p><strong>1. 全局静态变量</strong></p>
<p>在全局变量前加上关键字static，全局变量就定义成一个全局静态变量.</p>
<p>静态存储区，在整个程序运行期间一直存在。</p>
<p>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；</p>
<p>作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。</p>
<p><strong>2.  局部静态变量</strong></p>
<p>在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。</p>
<p>内存中的位置：静态存储区</p>
<p>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；</p>
<p>作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；</p>
<p><strong>3. 静态函数</strong></p>
<p>在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。</p>
<p>函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；</p>
<p>warning：不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；</p>
<p><strong>4. 类的静态成员</strong></p>
<p>在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用</p>
<p><strong>5. 类的静态函数</strong></p>
<p>静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。</p>
<p>在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;);</p>
<h2 id="002-extern关键字"><a href="#002-extern关键字" class="headerlink" title="002 extern关键字"></a>002 extern关键字</h2><p>我们知道，程序的编译单位是源程序文件，一个源文件可以包含一个或若干个函数。在函数内定义的变量是局部变量，而在函数之外定义的变量则称为外部变量，外部变量也就是我们所讲的全局变量。它的存储方式为静态存储，其生存周期为整个程序的生存周期。全局变量可以为本文件中的其他函数所共用，它的有效范围为从定义变量的位置开始到本源文件结束。</p>
<p>然而，如果全局变量不在文件的开头定义，有效的作用范围将只限于其定义处到文件结束。如果在定义点之前的函数想引用该全局变量，则应该在引用之前用关键字 extern 对该变量作“外部变量声明”，表示该变量是一个已经定义的外部变量。有了此声明，就可以从“声明”处起，合法地使用该外部变量。</p>
<h2 id="003-C-和C的区别"><a href="#003-C-和C的区别" class="headerlink" title="003 C++和C的区别"></a>003 C++和C的区别</h2><p><strong>设计思想上：</strong></p>
<p>C++是面向对象的语言，而C是面向过程的结构化编程语言</p>
<p><strong>语法上：</strong></p>
<p>C++具有封装、继承和多态三种特性</p>
<p>C++相比C，增加多许多类型安全的功能，比如强制类型转换、</p>
<p>C++支持范式编程，比如模板类、函数模板等</p>
<h2 id="004-说一说c-中四种cast转换"><a href="#004-说一说c-中四种cast转换" class="headerlink" title="004 说一说c++中四种cast转换"></a>004 说一说c++中四种cast转换</h2><p>C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast</p>
<p><strong>1、const_cast</strong></p>
<p>用于将const变量转为非const</p>
<p><strong>2、static_cast</strong></p>
<p>用于各种隐式转换，比如非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知；</p>
<p><strong>3、dynamic_cast</strong></p>
<p>用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。</p>
<p>向上转换：指的是子类向基类的转换</p>
<p>向下转换：指的是基类向子类的转换</p>
<p>它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。</p>
<p><strong>4、reinterpret_cast</strong></p>
<p>几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；</p>
<p><strong>5、为什么不使用C的强制转换？</strong></p>
<p>C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。</p>
<h2 id="005-请说一下C-C-中指针和引用的区别？"><a href="#005-请说一下C-C-中指针和引用的区别？" class="headerlink" title="005 请说一下C/C++ 中指针和引用的区别？"></a>005 请说一下C/C++ 中指针和引用的区别？</h2><p>1.指针有自己的一块空间，而引用只是一个别名；<br><br>2.使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；<br><br>3.指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；<br><br>4.作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；<br><br>5.可以有const指针，但是没有const引用；<br><br>6.指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；<br><br>7.指针可以有多级指针（**p），而引用至于一级；<br><br>8.指针和引用使用++运算符的意义不一样；<br><br>9.如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。<br></p>
<h2 id="006-智能指针"><a href="#006-智能指针" class="headerlink" title="006 智能指针"></a>006 智能指针</h2><h2 id="007-指针和数组的主要区别如下"><a href="#007-指针和数组的主要区别如下" class="headerlink" title="007 指针和数组的主要区别如下"></a>007 指针和数组的主要区别如下</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Dawn_sf/article/details/54588128">数组和指针的比较和关系以及区别</a></p>
<h2 id="008-请你回答一下野指针是什么？"><a href="#008-请你回答一下野指针是什么？" class="headerlink" title="008 请你回答一下野指针是什么？"></a>008 请你回答一下野指针是什么？</h2><p>野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针</p>
<h2 id="009-为什么析构函数必须是虚函数？为什么C-默认的析构函数不是虚函数-考点-虚函数-析构函数"><a href="#009-为什么析构函数必须是虚函数？为什么C-默认的析构函数不是虚函数-考点-虚函数-析构函数" class="headerlink" title="009 为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数 考点:虚函数 析构函数"></a>009 为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数 考点:虚函数 析构函数</h2><p>将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。</p>
<p>C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</p>
<h2 id="010-请你来说一下函数指针"><a href="#010-请你来说一下函数指针" class="headerlink" title="010 请你来说一下函数指针"></a>010 请你来说一下函数指针</h2><p><strong>1、定义</strong><br>函数指针是指向函数的指针变量。</p>
<p>函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。</p>
<p>C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。</p>
<p><strong>2、用途：</strong></p>
<p>调用函数和做函数的参数，比如回调函数。</p>
<p><strong>3、示例：</strong></p>
<p>char * fun(char * p)  {…}       // 函数fun</p>
<p>char * (*pf)(char * p);             // 函数指针pf</p>
<p>pf = fun;                        // 函数指针pf指向函数fun</p>
<p>pf(p);                        // 通过函数指针pf调用函数fun</p>
<h2 id="011-请你来说一下fork函数"><a href="#011-请你来说一下fork函数" class="headerlink" title="011 请你来说一下fork函数"></a>011 请你来说一下fork函数</h2><p>Fork：创建一个和当前进程映像一样的进程可以通过fork( )系统调用：<br>#include &lt;sys/types.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>pid_t fork(void);</p>
<p>成功调用fork( )会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错误，fork( )返回一个负值。</p>
<p>最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。</p>
<p>在早期的Unix系统中，创建进程比较原始。当调用fork时，内核会把所有的内部数据结构复制一份，复制进程的页表项，然后把父进程的地址空间中的内容逐页的复制到子进程的地址空间中。但从内核角度来说，逐页的复制方式是十分耗时的。现代的Unix系统采取了更多的优化，例如Linux，采用了写时复制的方法，而不是对父进程空间进程整体复制。</p>
<h2 id="012-请你来说一下C-中析构函数的作用"><a href="#012-请你来说一下C-中析构函数的作用" class="headerlink" title="012 请你来说一下C++中析构函数的作用"></a>012 请你来说一下C++中析构函数的作用</h2><p>析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。<br>析构函数名也应与类名相同，只是在函数名前面加一个位取反符<del>，例如</del>stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。</p>
<p>如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。</p>
<p>如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。</p>
<p>类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。</p>
<h2 id="013-请你来说一下静态函数和虚函数的区别"><a href="#013-请你来说一下静态函数和虚函数的区别" class="headerlink" title="013 请你来说一下静态函数和虚函数的区别"></a>013 请你来说一下静态函数和虚函数的区别</h2><p>静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销</p>
<h2 id="014-请你来说一说重载和覆盖"><a href="#014-请你来说一说重载和覆盖" class="headerlink" title="014 请你来说一说重载和覆盖"></a>014 请你来说一说重载和覆盖</h2><p>重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中<br>重写：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/skynet/archive/2010/09/05/1818636.html">C++的函数重载</a></p>
<h2 id="015-请你说一说strcpy和strlen"><a href="#015-请你说一说strcpy和strlen" class="headerlink" title="015 请你说一说strcpy和strlen"></a>015 请你说一说strcpy和strlen</h2><p>strcpy是字符串拷贝函数，原型：<br>char <em>strcpy(char</em> dest, const char *src);</p>
<p>从src逐字节拷贝到dest，直到遇到’\0’结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,安全版本是strncpy函数。<br>strlen函数是计算字符串长度的函数，返回从开始到’\0’之间的字符个数。</p>
<h2 id="016-请你说一说你理解的虚函数和多态"><a href="#016-请你说一说你理解的虚函数和多态" class="headerlink" title="016 请你说一说你理解的虚函数和多态"></a>016 请你说一说你理解的虚函数和多态</h2><p>多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。<br>虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。</p>
<h2 id="017-请你来回答一下-i和i-的区别"><a href="#017-请你来回答一下-i和i-的区别" class="headerlink" title="017 请你来回答一下++i和i++的区别"></a>017 请你来回答一下++i和i++的区别</h2><p>++i先自增1，再返回，i++先返回i,再自增1</p>
<h2 id="018-请你来写个函数在main函数执行前先运行"><a href="#018-请你来写个函数在main函数执行前先运行" class="headerlink" title="018 请你来写个函数在main函数执行前先运行"></a>018 请你来写个函数在main函数执行前先运行</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__attribute((constructor))<span class="function"><span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;before main\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="019-以下四行代码的区别是什么？"><a href="#019-以下四行代码的区别是什么？" class="headerlink" title="019 以下四行代码的区别是什么？"></a>019 以下四行代码的区别是什么？</h2><p>const char * arr = “123”; char * brr = “123”; const char crr[] = “123”; char drr[] = “123”;</p>
<p>const char * arr = “123”;<br>//字符串123保存在常量区，const本来是修饰arr指向的值不能通过arr去修改，但是字符串“123”在常量区，本来就不能改变，所以加不加const效果都一样</p>
<p>char * brr = “123”;</p>
<p>//字符串123保存在常量区，这个arr指针指向的是同一个位置，同样不能通过brr去修改”123”的值</p>
<p>const char crr[] = “123”;</p>
<p>//这里123本来是在栈上的，但是编译器可能会做某些优化，将其放到常量区</p>
<p>char drr[] = “123”;</p>
<p>//字符串123保存在栈区，可以通过drr去修改</p>
<h2 id="020-请你来说一下C-里是怎么定义常量的？常量存放在内存的哪个位置？"><a href="#020-请你来说一下C-里是怎么定义常量的？常量存放在内存的哪个位置？" class="headerlink" title="020 请你来说一下C++里是怎么定义常量的？常量存放在内存的哪个位置？"></a>020 请你来说一下C++里是怎么定义常量的？常量存放在内存的哪个位置？</h2><p>常量在C++里的定义就是一个top-level const加上对象类型，常量定义必须初始化。对于局部对象，常量存放在栈区，对于全局对象，常量存放在全局/静态存储区。对于字面值常量，常量存放在常量存储区。</p>
<h2 id="021-请你来回答一下const修饰成员函数的目的是什么？"><a href="#021-请你来回答一下const修饰成员函数的目的是什么？" class="headerlink" title="021 请你来回答一下const修饰成员函数的目的是什么？"></a>021 请你来回答一下const修饰成员函数的目的是什么？</h2><p>const修饰的成员函数表明函数调用不会对对象做出任何更改，事实上，如果确认不会对对象做更改，就应该为函数加上const限定，这样无论const对象还是普通对象都可以调用该函数。</p>
<h2 id="022-如果同时定义了两个函数，一个带const，一个不带，会有问题吗？"><a href="#022-如果同时定义了两个函数，一个带const，一个不带，会有问题吗？" class="headerlink" title="022 如果同时定义了两个函数，一个带const，一个不带，会有问题吗？"></a>022 如果同时定义了两个函数，一个带const，一个不带，会有问题吗？</h2><p>不会，这相当于函数的重载。</p>
<p>搜了下，这是一个牛客用户面经里的内容，小编直接复制粘贴过来了其中的一个片段。结合原文语境，这里的两个函数指的是一个类中两个成员函数，带const，const是放在函数后面的，也就是对this指针做const限定。所以说是重载</p>
<h2 id="023-请你来说一说隐式类型转换"><a href="#023-请你来说一说隐式类型转换" class="headerlink" title="023 请你来说一说隐式类型转换"></a>023 请你来说一说隐式类型转换</h2><h2 id="024-请你来说一说C-函数栈空间的最大值"><a href="#024-请你来说一说C-函数栈空间的最大值" class="headerlink" title="024 请你来说一说C++函数栈空间的最大值"></a>024 请你来说一说C++函数栈空间的最大值</h2><p>默认是1M，不过可以调整</p>
<h2 id="025-请你来说一说extern“C”"><a href="#025-请你来说一说extern“C”" class="headerlink" title="025 请你来说一说extern“C”"></a>025 请你来说一说extern“C”</h2><p>C++调用C函数需要extern C，因为C语言没有函数重载。</p>
<h2 id="026-请你回答一下new-delete与malloc-free的区别是什么"><a href="#026-请你回答一下new-delete与malloc-free的区别是什么" class="headerlink" title="026 请你回答一下new/delete与malloc/free的区别是什么"></a>026 请你回答一下new/delete与malloc/free的区别是什么</h2><p>首先，new/delete是C++的关键字，而malloc/free是C语言的库函数，后者使用必须指明申请内存空间的大小，对于类类型的对象，后者不会调用构造函数和析构函数</p>
<h2 id="027-请你说说虚函数表具体是怎样实现运行时多态的"><a href="#027-请你说说虚函数表具体是怎样实现运行时多态的" class="headerlink" title="027 请你说说虚函数表具体是怎样实现运行时多态的?"></a>027 请你说说虚函数表具体是怎样实现运行时多态的?</h2><p>子类若重写父类虚函数，虚函数表中，该函数的地址会被替换，对于存在虚函数的类的对象，在VS中，对象的对象模型的头部存放指向虚函数表的指针，通过该机制实现多态。</p>
<h2 id="028-请你说说C语言是怎么进行函数调用的？"><a href="#028-请你说说C语言是怎么进行函数调用的？" class="headerlink" title="028 请你说说C语言是怎么进行函数调用的？"></a>028 请你说说C语言是怎么进行函数调用的？</h2><p>每一个函数调用都会分配函数栈，在栈内进行函数执行过程。调用前，先把返回地址压栈，然后把当前函数的esp指针压栈。</p>
<h2 id="029-请你说说C语言参数压栈顺序？"><a href="#029-请你说说C语言参数压栈顺序？" class="headerlink" title="029 请你说说C语言参数压栈顺序？"></a>029 请你说说C语言参数压栈顺序？</h2><p>从右到左</p>
<h2 id="030-请你说说C-如何处理返回值？"><a href="#030-请你说说C-如何处理返回值？" class="headerlink" title="030 请你说说C++如何处理返回值？"></a>030 请你说说C++如何处理返回值？</h2><p>生成一个临时变量，把它的引用作为函数参数传入函数内。</p>
<h2 id="031-请你回答一下C-中拷贝赋值函数的形参能否进行值传递？"><a href="#031-请你回答一下C-中拷贝赋值函数的形参能否进行值传递？" class="headerlink" title="031 请你回答一下C++中拷贝赋值函数的形参能否进行值传递？"></a>031 请你回答一下C++中拷贝赋值函数的形参能否进行值传递？</h2><p>不能。如果是这种情况下，调用拷贝构造函数的时候，首先要将实参传递给形参，这个传递的时候又要调用拷贝构造函数。。如此循环，无法完成拷贝，栈也会满。</p>
<h2 id="032-请你回答一下malloc与new区别"><a href="#032-请你回答一下malloc与new区别" class="headerlink" title="032  请你回答一下malloc与new区别"></a>032  请你回答一下malloc与new区别</h2><p>malloc需要给定申请内存的大小，返回的指针需要强转。<br>new会调用构造函数，返回的指针不用强转。</p>
<p>区别是 new 失败了会掉一个 handler 做补救, 该 handler 默认是 nullptr.再一个是 new 失败了会丢 bad_alloc(如果没指定 nothrow 的话)再一个是 C++ 不许有 size 为 0 的对象, 所以这样的 new 会被强制转为 1</p>
<p>作者：a owensss<br>链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/30115922/answer/46819323">https://www.zhihu.com/question/30115922/answer/46819323</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="033-请你说一说select"><a href="#033-请你说一说select" class="headerlink" title="033 请你说一说select"></a>033 请你说一说select</h2><p>select在使用前，先将需要监控的描述符对应的bit位置1，然后将其传给select,当有任何一个事件发生时，select将会返回所有的描述符，需要在应用程序自己遍历去检查哪个描述符上有事件发生，效率很低，并且其不断在内核态和用户态进行描述符的拷贝，开销很大</p>
<h2 id="034-请你说说fork-wait-exec函数"><a href="#034-请你说说fork-wait-exec函数" class="headerlink" title="034  请你说说fork,wait,exec函数"></a>034  请你说说fork,wait,exec函数</h2><p>父进程产生子进程使用fork拷贝出来一个父进程的副本，此时只拷贝了父进程的页表，两个进程都读同一块内存，当有进程写的时候使用写实拷贝机制分配内存，exec函数可以加载一个elf文件去替换父进程，从此父进程和子进程就可以运行不同的程序了。fork从父进程返回子进程的pid，从子进程返回0.调用了wait的父进程将会发生阻塞，直到有子进程状态改变,执行成功返回0，错误返回-1。exec执行成功则子进程从新的程序开始运行，无返回值，执行失败返回-1</p>
<h2 id="035-请你来说一下map和set有什么区别，分别又是怎么实现的？"><a href="#035-请你来说一下map和set有什么区别，分别又是怎么实现的？" class="headerlink" title="035 请你来说一下map和set有什么区别，分别又是怎么实现的？"></a>035 请你来说一下map和set有什么区别，分别又是怎么实现的？</h2><p>map和set都是C++的关联容器，其底层实现都是红黑树（RB-Tree）。由于 map 和set所开放的各种操作接口，RB-tree 也都提供了，所以几乎所有的 map 和set的操作行为，都只是转调 RB-tree 的操作行为。<br>map和set区别在于：</p>
<p>（1）map中的元素是key-value（关键字—值）对：关键字起到索引的作用，值则表示与索引相关联的数据；Set与之相对就是关键字的简单集合，set中每个元素只包含一个关键字。</p>
<p>（2）set的迭代器是const的，不允许修改元素的值；map允许修改value，但不允许修改key。其原因是因为map和set是根据关键字排序来保证其有序性的，如果允许修改key的话，那么首先需要删除该键，然后调节平衡，再插入修改后的键值，调节平衡，如此一来，严重破坏了map和set的结构，导致iterator失效，不知道应该指向改变前的位置，还是指向改变后的位置。所以STL中将set的迭代器设置成const，不允许修改迭代器的值；而map的迭代器则不允许修改key值，允许修改value值。</p>
<p>（3）map支持下标操作，set不支持下标操作。map可以用key做下标，map的下标运算符[ ]将关键码作为下标去执行查找，如果关键码不存在，则插入一个具有该关键码和mapped_type类型默认值的元素至map中，因此下标运算符[ ]在map应用中需要慎用，const_map不能用，只希望确定某一个关键值是否存在而不希望插入元素时也不应该使用，mapped_type类型没有默认值也不应该使用。如果find能解决需要，尽可能用find。</p>
<h2 id="036-请你来介绍一下STL的allocaotr"><a href="#036-请你来介绍一下STL的allocaotr" class="headerlink" title="036 请你来介绍一下STL的allocaotr"></a>036 请你来介绍一下STL的allocaotr</h2><p>STL的分配器用于封装STL容器在内存管理上的底层细节。在C++中，其内存配置和释放如下：<br>new运算分两个阶段：(1)调用::operator new配置内存;(2)调用对象构造函数构造对象内容</p>
<p>delete运算分两个阶段：(1)调用对象希构函数；(2)掉员工::operator delete释放内存</p>
<p>为了精密分工，STL allocator将两个阶段操作区分开来：内存配置有alloc::allocate()负责，内存释放由alloc::deallocate()负责；对象构造由::construct()负责，对象析构由::destroy()负责。</p>
<p>同时为了提升内存管理的效率，减少申请小内存造成的内存碎片问题，SGI STL采用了两级配置器，当分配的空间大小超过128B时，会使用第一级空间配置器；当分配的空间大小小于128B时，将使用第二级空间配置器。第一级空间配置器直接使用malloc()、realloc()、free()函数进行内存空间的分配和释放，而第二级空间配置器采用了内存池技术，通过空闲链表来管理内存。</p>
<h2 id="037-请你说一说STL中MAP数据存放形式"><a href="#037-请你说一说STL中MAP数据存放形式" class="headerlink" title="037 请你说一说STL中MAP数据存放形式"></a>037 请你说一说STL中MAP数据存放形式</h2><p>红黑树。unordered map底层结构是哈希表</p>
<h2 id="038-请你来说一说STL迭代器删除元素"><a href="#038-请你来说一说STL迭代器删除元素" class="headerlink" title="038 请你来说一说STL迭代器删除元素"></a>038 请你来说一说STL迭代器删除元素</h2><p><a target="_blank" rel="noopener" href="https://github.com/selfboot/CS_Offer/blob/master/C%2B%2B/STL_Iterator.md">https://github.com/selfboot/CS_Offer/blob/master/C%2B%2B/STL_Iterator.md</a></p>
<h2 id="039-请你讲讲STL有什么基本组成"><a href="#039-请你讲讲STL有什么基本组成" class="headerlink" title="039 请你讲讲STL有什么基本组成"></a>039 请你讲讲STL有什么基本组成</h2><p>STL主要由：以下几部分组成：<br>容器迭代器仿函数算法分配器配接器<br>他们之间的关系：分配器给容器分配存储空间，算法通过迭代器获取容器中的内容，仿函数可以协助算法完成各种操作，配接器用来套接适配仿函数</p>
<h2 id="040-请你说说STL中map与unordered-map和Multimap"><a href="#040-请你说说STL中map与unordered-map和Multimap" class="headerlink" title="040 请你说说STL中map与unordered_map和Multimap"></a>040 请你说说STL中map与unordered_map和Multimap</h2><p>Multimap允许重复元素，map不允许重复。</p>
<p>map： map内部实现了一个红黑树，该结构具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素，因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行这样的操作，故红黑树的效率决定了map的效率。<br>unordered_map: unordered_map内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的</p>
<h2 id="041-请你说一说vector和list的区别，应用，越详细越好"><a href="#041-请你说一说vector和list的区别，应用，越详细越好" class="headerlink" title="041 请你说一说vector和list的区别，应用，越详细越好"></a>041 请你说一说vector和list的区别，应用，越详细越好</h2><p>1、概念：<br>1）Vector</p>
<p>连续存储的容器，动态数组，在堆上分配空间</p>
<p>底层实现：数组</p>
<p>两倍容量增长：</p>
<p>vector 增加（插入）新元素时，如果未超过当时的容量，则还有剩余空间，那么直接添加到最后（插入指定位置），然后调整迭代器。</p>
<p>如果没有剩余空间了，则会重新配置原有元素个数的两倍空间，然后将原空间元素通过复制的方式初始化新空间，再向新空间增加元素，最后析构并释放原空间，之前的迭代器会失效。</p>
<p>性能：</p>
<p>访问：O(1)</p>
<p>插入：在最后插入（空间够）：很快</p>
<p>在最后插入（空间不够）：需要内存申请和释放，以及对之前数据进行拷贝。</p>
<p>在中间插入（空间够）：内存拷贝</p>
<p>在中间插入（空间不够）：需要内存申请和释放，以及对之前数据进行拷贝。</p>
<p>删除：在最后删除：很快</p>
<p>在中间删除：内存拷贝</p>
<p>适用场景：经常随机访问，且不经常对非尾节点进行插入删除。</p>
<p>2、List</p>
<p>动态链表，在堆上分配空间，每插入一个元数都会分配空间，每删除一个元素都会释放空间。</p>
<p>底层：双向链表</p>
<p>性能：</p>
<p>访问：随机访问性能很差，只能快速访问头尾节点。</p>
<p>插入：很快，一般是常数开销</p>
<p>删除：很快，一般是常数开销</p>
<p>适用场景：经常插入删除大量数据</p>
<p>2、区别：</p>
<p>1）vector底层实现是数组；list是双向 链表。</p>
<p>2）vector支持随机访问，list不支持。</p>
<p>3）vector是顺序内存，list不是。</p>
<p>4）vector在中间节点进行插入删除会导致内存拷贝，list不会。</p>
<p>5）vector一次性分配好内存，不够时才进行2倍扩容；list每次插入新节点都会进行内存申请。</p>
<p>6）vector随机访问性能好，插入删除性能差；list随机访问性能差，插入删除性能好。</p>
<p>3、应用</p>
<p>vector拥有一段连续的内存空间，因此支持随机访问，如果需要高效的随即访问，而不在乎插入和删除的效率，使用vector。</p>
<p>list拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应使用list。</p>
<h2 id="042-请你来说一下STL中迭代器的作用，有指针为何还要迭代器"><a href="#042-请你来说一下STL中迭代器的作用，有指针为何还要迭代器" class="headerlink" title="042 请你来说一下STL中迭代器的作用，有指针为何还要迭代器"></a>042 请你来说一下STL中迭代器的作用，有指针为何还要迭代器</h2><p>1、迭代器<br>Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。</p>
<p>由于Iterator模式的以上特性：与聚合对象耦合，在一定程度上限制了它的广泛运用，一般仅用于底层聚合支持类，如STL的list、vector、stack等容器类及ostream_iterator等扩展iterator。</p>
<p>2、迭代器和指针的区别</p>
<p>迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，-&gt;、*、++、–等。迭代器封装了指针，是一个“可遍历STL（ Standard Template Library）容器内全部或部分元素”的对象， 本质是封装了原生指针，是指针概念的一种提升（lift），提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，–等操作。</p>
<p>迭代器返回的是对象引用而不是对象的值，所以cout只能输出迭代器使用*取值后的值而不能直接输出其自身。</p>
<p>3、迭代器产生原因</p>
<p>Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。</p>
<h2 id="043-请你回答一下STL里resize和reserve的区别"><a href="#043-请你回答一下STL里resize和reserve的区别" class="headerlink" title="043 请你回答一下STL里resize和reserve的区别"></a>043 请你回答一下STL里resize和reserve的区别</h2><p>resize()：改变当前容器内含有元素的数量(size())，eg: vector<int>v; v.resize(len);v的size变为len,如果原来v的size小于len，那么容器新增（len-size）个元素，元素的值为默认为0.当v.push_back(3);之后，则是3是放在了v的末尾，即下标为len，此时容器是size为len+1；<br>reserve()：改变当前容器的最大容量（capacity）,它不会生成元素，只是确定这个容器允许放入多少对象，如果reserve(len)的值大于当前的capacity()，那么会重新分配一块能存len个对象的空间，然后把之前v.size()个对象通过copy construtor复制过来，销毁之前的内存；</p>
<h2 id="044-请你来说一下C-中类成员的访问权限"><a href="#044-请你来说一下C-中类成员的访问权限" class="headerlink" title="044 请你来说一下C++中类成员的访问权限"></a>044 请你来说一下C++中类成员的访问权限</h2><p>参考回答：C++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员</p>
<h2 id="045-请你来说一下C-中struct和class的区别"><a href="#045-请你来说一下C-中struct和class的区别" class="headerlink" title="045 请你来说一下C++中struct和class的区别"></a>045 请你来说一下C++中struct和class的区别</h2><p>1.默认的继承访问权。class默认的是private,strcut默认的是public。<br>2.默认访问权限：struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。<br>3.“class”这个关键字还用于定义模板参数，就像“typename”。但关建字“struct”不用于定义模板参数</p>
<p>4.class和struct在使用大括号{ }上的区别<br>关于使用大括号初始化<br>1.）class和struct如果定义了构造函数的话，都不能用大括号进行初始化<br>　　2.）如果没有定义构造函数，struct可以用大括号初始化。<br>　　3.）如果没有定义构造函数，且所有成员变量全是public的话，class可以用大括号初始化</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/47808468">https://zhuanlan.zhihu.com/p/47808468</a></p>
<h2 id="046-请你回答一下C-类内可以定义引用数据成员吗？"><a href="#046-请你回答一下C-类内可以定义引用数据成员吗？" class="headerlink" title="046 请你回答一下C++类内可以定义引用数据成员吗？"></a>046 请你回答一下C++类内可以定义引用数据成员吗？</h2><p>可以，必须通过成员函数初始化列表初始化。</p>
<h2 id="047-请你回答一下什么是右值引用，跟左值又有什么区别？"><a href="#047-请你回答一下什么是右值引用，跟左值又有什么区别？" class="headerlink" title="047 请你回答一下什么是右值引用，跟左值又有什么区别？"></a>047 请你回答一下什么是右值引用，跟左值又有什么区别？</h2><p>右值引用是C++11中引入的新特性 , 它实现了转移语义和精确传递。它的主要目的有两个方面：</p>
<ol>
<li><p>消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。</p>
</li>
<li><p>能够更简洁明确地定义泛型函数。</p>
</li>
</ol>
<p>左值和右值的概念：</p>
<p>左值：能对表达式取地址、或具名对象/变量。一般指表达式结束后依然存在的持久对象。</p>
<p>右值：不能对表达式取地址，或匿名对象。一般指表达式结束就不再存在的临时对象。</p>
<p>右值引用和左值引用的区别：</p>
<ol>
<li><p>左值可以寻址，而右值不可以。</p>
</li>
<li><p>左值可以被赋值，右值不可以被赋值，可以用来给左值赋值。</p>
</li>
<li><p>左值可变,右值不可变（仅对基础类型适用，用户自定义类型右值引用可以通过成员函数改变）。</p>
</li>
</ol>
<h2 id="048-请你来说一下一个C-源文件从文本到可执行文件经历的过程？"><a href="#048-请你来说一下一个C-源文件从文本到可执行文件经历的过程？" class="headerlink" title="048 请你来说一下一个C++源文件从文本到可执行文件经历的过程？"></a>048 请你来说一下一个C++源文件从文本到可执行文件经历的过程？</h2><p>对于C++源文件，从文本到可执行文件一般需要四个过程：<br>预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。</p>
<p>编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件</p>
<p>汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件</p>
<p>链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件</p>
<h2 id="049-请你来回答一下include头文件的顺序以及双引号””和尖括号-lt-gt-的区别？"><a href="#049-请你来回答一下include头文件的顺序以及双引号””和尖括号-lt-gt-的区别？" class="headerlink" title="049 请你来回答一下include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别？"></a>049 请你来回答一下include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别？</h2><p>Include头文件的顺序：对于include的头文件来说，如果在文件a.h中声明一个在文件b.h中定义的变量，而不引用b.h。那么要在a.c文件中引用b.h文件，并且要先引用b.h，后引用a.h,否则汇报变量类型未声明错误。<br>双引号和尖括号的区别：编译器预处理阶段查找头文件的路径不一样。</p>
<p>对于使用双引号包含的头文件，查找头文件路径的顺序为：</p>
<p>当前头文件目录</p>
<p>编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）</p>
<p>系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径</p>
<p>对于使用尖括号包含的头文件，查找头文件的路径顺序为：</p>
<p>编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）</p>
<p>系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径</p>
<h2 id="050-请你回答一下malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？"><a href="#050-请你回答一下malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？" class="headerlink" title="050 请你回答一下malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？"></a>050 请你回答一下malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？</h2><p>Malloc函数用于动态分配内存。为了减少内存碎片和系统调用的开销，malloc其采用内存池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位。当用户申请内存时，直接从堆区分配一块合适的空闲块。Malloc采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块；同时malloc采用显示链表结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。<br>当进行内存分配时，Malloc会通过隐式链表遍历所有的空闲块，选择满足要求的块进行分配；当进行内存合并时，malloc采用边界标记法，根据每个块的前后块是否已经分配来决定是否进行块合并。</p>
<p>Malloc在申请内存时，一般会通过brk或者mmap系统调用进行申请。其中当申请内存小于128K时，会使用系统函数brk在堆区中分配；而当申请内存大于128K时，会使用系统函数mmap在映射区分配。</p>
<h2 id="051-请你说一说C-的内存管理是怎样的？"><a href="#051-请你说一说C-的内存管理是怎样的？" class="headerlink" title="051 请你说一说C++的内存管理是怎样的？"></a>051 请你说一说C++的内存管理是怎样的？</h2><p>在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。<br>代码段:包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。</p>
<p>数据段：存储程序中已初始化的全局变量和静态变量</p>
<p>bss 段：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。</p>
<p>堆区：调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存。</p>
<p>映射区:存储动态链接库以及调用mmap函数进行的文件映射</p>
<p>栈：使用栈空间存储函数的返回地址、参数、局部变量、返回值</p>
<h2 id="052-请你回答一下如何判断内存泄漏？"><a href="#052-请你回答一下如何判断内存泄漏？" class="headerlink" title="052 请你回答一下如何判断内存泄漏？"></a>052 请你回答一下如何判断内存泄漏？</h2><p>内存泄漏通常是由于调用了malloc/new等内存申请的操作，但是缺少了对应的free/delete。为了判断内存是否泄露，我们一方面可以使用linux环境下的内存泄漏检查工具Valgrind,另一方面我们在写代码时可以添加内存申请和释放的统计功能，统计当前申请和释放的内存是否一致，以此来判断内存是否泄露。</p>
<h2 id="053-请你来说一下什么时候会发生段错误"><a href="#053-请你来说一下什么时候会发生段错误" class="headerlink" title="053 请你来说一下什么时候会发生段错误"></a>053 请你来说一下什么时候会发生段错误</h2><p>段错误通常发生在访问非法内存地址的时候，具体来说分为以下几种情况：<br>使用野指针</p>
<p>试图修改字符串常量的内容</p>
<h2 id="054-请你来回答一下什么是memory-leak，也就是内存泄漏"><a href="#054-请你来回答一下什么是memory-leak，也就是内存泄漏" class="headerlink" title="054 请你来回答一下什么是memory leak，也就是内存泄漏"></a>054 请你来回答一下什么是memory leak，也就是内存泄漏</h2><p>内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。<br>内存泄漏的分类：</p>
<ol>
<li><p>堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak.</p>
</li>
<li><p>系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。</p>
</li>
<li><p>没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。</p>
</li>
</ol>
<h2 id="055-请你来回答一下new和malloc的区别"><a href="#055-请你来回答一下new和malloc的区别" class="headerlink" title="055 请你来回答一下new和malloc的区别"></a>055 请你来回答一下new和malloc的区别</h2><p>1、new分配内存按照数据类型进行分配，malloc分配内存按照指定的大小分配；<br>2、new返回的是指定对象的指针，而malloc返回的是void*，因此malloc的返回值一般都需要进行类型转化。</p>
<p>3、new不仅分配一段内存，而且会调用构造函数，malloc不会。</p>
<p>4、new分配的内存要用delete销毁，malloc要用free来销毁；delete销毁的时候会调用对象的析构函数，而free则不会。</p>
<p>5、new是一个操作符可以重载，malloc是一个库函数。</p>
<p>6、malloc分配的内存不够的时候，可以用realloc扩容。扩容的原理？new没用这样操作。</p>
<p>7、new如果分配失败了会抛出bad_malloc的异常，而malloc失败了会返回NULL。</p>
<p>8、申请数组时： new[]一次分配所有内存，多次调用构造函数，搭配使用delete[]，delete[]多次调用析构函数，销毁数组中的每个对象。而malloc则只能sizeof(int) * n。</p>
<h2 id="056-请你来说一下共享内存相关api"><a href="#056-请你来说一下共享内存相关api" class="headerlink" title="056 请你来说一下共享内存相关api"></a>056 请你来说一下共享内存相关api</h2><p>Linux允许不同进程访问同一个逻辑内存，提供了一组API，头文件在sys/shm.h中。<br>1）新建共享内存shmget</p>
<p>int shmget(key_t key,size_t size,int shmflg);</p>
<p>key：共享内存键值，可以理解为共享内存的唯一性标记。</p>
<p>size：共享内存大小</p>
<p>shmflag：创建进程和其他进程的读写权限标识。</p>
<p>返回值：相应的共享内存标识符，失败返回-1</p>
<p>2）连接共享内存到当前进程的地址空间shmat</p>
<p>void *shmat(int shm_id,const void *shm_addr,int shmflg);</p>
<p>shm_id：共享内存标识符</p>
<p>shm_addr：指定共享内存连接到当前进程的地址，通常为0，表示由系统来选择。</p>
<p>shmflg：标志位</p>
<p>返回值：指向共享内存第一个字节的指针，失败返回-1</p>
<p>3）当前进程分离共享内存shmdt</p>
<p>int shmdt(const void *shmaddr);</p>
<p>4）控制共享内存shmctl</p>
<p>和信号量的semctl函数类似，控制共享内存</p>
<p>int shmctl(int shm_id,int command,struct shmid_ds *buf);</p>
<p>shm_id：共享内存标识符</p>
<p>command: 有三个值</p>
<p>IPC_STAT:获取共享内存的状态，把共享内存的shmid_ds结构复制到buf中。</p>
<p>IPC_SET:设置共享内存的状态，把buf复制到共享内存的shmid_ds结构。</p>
<p>IPC_RMID:删除共享内存</p>
<p>buf：共享内存管理结构体。</p>
<h2 id="057-请你来说一下reactor模型组成"><a href="#057-请你来说一下reactor模型组成" class="headerlink" title="057 请你来说一下reactor模型组成"></a>057 请你来说一下reactor模型组成</h2><p>reactor模型要求主线程只负责监听文件描述上是否有事件发生，有的话就立即将该事件通知工作线程，除此之外，主线程不做任何其他实质性的工作，读写数据、接受新的连接以及处理客户请求均在工作线程中完成。其模型组成如下：</p>
<p>1）Handle：即操作系统中的句柄，是对资源在操作系统层面上的一种抽象，它可以是打开的文件、一个连接(Socket)、Timer等。由于Reactor模式一般使用在网络编程中，因而这里一般指Socket Handle，即一个网络连接。</p>
<p>2）Synchronous Event Demultiplexer（同步事件复用器）：阻塞等待一系列的Handle中的事件到来，如果阻塞等待返回，即表示在返回的Handle中可以不阻塞的执行返回的事件类型。这个模块一般使用操作系统的select来实现。</p>
<p>3）Initiation Dispatcher：用于管理Event Handler，即EventHandler的容器，用以注册、移除EventHandler等；另外，它还作为Reactor模式的入口调用Synchronous Event Demultiplexer的select方法以阻塞等待事件返回，当阻塞等待返回时，根据事件发生的Handle将其分发给对应的Event Handler处理，即回调EventHandler中的handle_event()方法。</p>
<p>4）Event Handler：定义事件处理方法：handle_event()，以供InitiationDispatcher回调使用。</p>
<p>5）Concrete Event Handler：事件EventHandler接口，实现特定事件处理逻辑。</p>
<h2 id="058-请自己设计一下如何采用单线程的方式处理高并发"><a href="#058-请自己设计一下如何采用单线程的方式处理高并发" class="headerlink" title="058 请自己设计一下如何采用单线程的方式处理高并发"></a>058 请自己设计一下如何采用单线程的方式处理高并发</h2><p>在单线程模型中，可以采用I/O复用来提高单线程处理多个请求的能力，然后再采用事件驱动模型，基于异步回调来处理事件来</p>
<h2 id="059-请你说说select，epoll的区别，原理，性能，限制都说一说"><a href="#059-请你说说select，epoll的区别，原理，性能，限制都说一说" class="headerlink" title="059 请你说说select，epoll的区别，原理，性能，限制都说一说"></a>059 请你说说select，epoll的区别，原理，性能，限制都说一说</h2><p>1）IO多路复用<br>IO复用模型在阻塞IO模型上多了一个select函数，select函数有一个参数是文件描述符集合，意思就是对这些的文件描述符进行循环监听，当某个文件描述符就绪的时候，就对这个文件描述符进行处理。</p>
<p>这种IO模型是属于阻塞的IO。但是由于它可以对多个文件描述符进行阻塞监听，所以它的效率比阻塞IO模型高效。</p>
<p>IO多路复用就是我们说的select，poll，epoll。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</p>
<p>当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p>
<p>所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。</p>
<p>I/O多路复用和阻塞I/O其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。</p>
<p>所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）</p>
<p>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p>
<p>2、select</p>
<p>select：是最初解决IO阻塞问题的方法。用结构体fd_set来告诉内核监听多个文件描述符，该结构体被称为描述符集。由数组来维持哪些描述符被置位了。对结构体的操作封装在三个宏定义中。通过轮寻来查找是否有描述符要被处理。</p>
<p>存在的问题：</p>
<ol>
<li><p>内置数组的形式使得select的最大文件数受限与FD_SIZE；</p>
</li>
<li><p>每次调用select前都要重新初始化描述符集，将fd从用户态拷贝到内核态，每次调用select后，都需要将fd从内核态拷贝到用户态；</p>
</li>
<li><p>轮寻排查当文件描述符个数很多时，效率很低；</p>
</li>
</ol>
<p>3、poll</p>
<p>poll：通过一个可变长度的数组解决了select文件描述符受限的问题。数组中元素是结构体，该结构体保存描述符的信息，每增加一个文件描述符就向数组中加入一个结构体，结构体只需要拷贝一次到内核态。poll解决了select重复初始化的问题。轮寻排查的问题未解决。</p>
<p>4、epoll</p>
<p>epoll：轮寻排查所有文件描述符的效率不高，使服务器并发能力受限。因此，epoll采用只返回状态发生变化的文件描述符，便解决了轮寻的瓶颈。</p>
<p>epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式</p>
<ol>
<li>LT模式</li>
</ol>
<p>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。</p>
<ol start="2">
<li>ET模式</li>
</ol>
<p>ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)</p>
<p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
<p>3、LT模式与ET模式的区别如下：<br>LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。<br>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p>
<h2 id="060-请你说一说C-STL-的内存优化"><a href="#060-请你说一说C-STL-的内存优化" class="headerlink" title="060  请你说一说C++ STL 的内存优化"></a>060  请你说一说C++ STL 的内存优化</h2><p>1）二级配置器结构<br>STL内存管理使用二级内存配置器。<br>1、第一级配置器<br>第一级配置器以malloc()，free()，realloc()等C函数执行实际的内存配置、释放、重新配置等操作，并且能在内存需求不被满足的时候，调用一个指定的函数。<br>一级空间配置器分配的是大于128字节的空间<br>如果分配不成功，调用句柄释放一部分内存<br>如果还不能分配成功，抛出异常<br>2、第二级配置器<br>在STL的第二级配置器中多了一些机制，避免太多小区块造成的内存碎片，小额区块带来的不仅是内存碎片，配置时还有额外的负担。区块越小，额外负担所占比例就越大。<br>3、分配原则<br>如果要分配的区块大于128bytes，则移交给第一级配置器处理。<br>如果要分配的区块小于128bytes，则以内存池管理（memory pool），又称之次层配置（sub-allocation）：每次配置一大块内存，并维护对应的16个空闲链表（free-list）。下次若有相同大小的内存需求，则直接从free-list中取。如果有小额区块被释放，则由配置器回收到free-list中。<br>当用户申请的空间小于128字节时，将字节数扩展到8的倍数，然后在自由链表中查找对应大小的子链表<br>如果在自由链表查找不到或者块数不够，则向内存池进行申请，一般一次申请20块<br>如果内存池空间足够，则取出内存<br>如果不够分配20块，则分配最多的块数给自由链表，并且更新每次申请的块数<br>如果一块都无法提供，则把剩余的内存挂到自由链表，然后向系统heap申请空间，如果申请失败，则看看自由链表还有没有可用的块，如果也没有，则最后调用一级空间配置器<br>2）二级内存池<br>二级内存池采用了16个空闲链表，这里的16个空闲链表分别管理大小为8、16、24……120、128的数据块。这里空闲链表节点的设计十分巧妙，这里用了一个联合体既可以表示下一个空闲数据块（存在于空闲链表中）的地址，也可以表示已经被用户使用的数据块（不存在空闲链表中）的地址。</p>
<p>1、空间配置函数allocate<br>首先先要检查申请空间的大小，如果大于128字节就调用第一级配置器，小于128字节就检查对应的空闲链表，如果该空闲链表中有可用数据块，则直接拿来用（拿取空闲链表中的第一个可用数据块，然后把该空闲链表的地址设置为该数据块指向的下一个地址），如果没有可用数据块，则调用refill重新填充空间。<br>2、空间释放函数deallocate<br>首先先要检查释放数据块的大小，如果大于128字节就调用第一级配置器，小于128字节则根据数据块的大小来判断回收后的空间会被插入到哪个空闲链表。<br>3、重新填充空闲链表refill<br>在用allocate配置空间时，如果空闲链表中没有可用数据块，就会调用refill来重新填充空间，新的空间取自内存池。缺省取20个数据块，如果内存池空间不足，那么能取多少个节点就取多少个。<br>从内存池取空间给空闲链表用是chunk_alloc的工作，首先根据end_free-start_free来判断内存池中的剩余空间是否足以调出nobjs个大小为size的数据块出去，如果内存连一个数据块的空间都无法供应，需要用malloc取堆中申请内存。<br>假如山穷水尽，整个系统的堆空间都不够用了，malloc失败，那么chunk_alloc会从空闲链表中找是否有大的数据块，然后将该数据块的空间分给内存池（这个数据块会从链表中去除）。<br>3、总结：</p>
<ol>
<li>使用allocate向内存池请求size大小的内存空间，如果需要请求的内存大小大于128bytes，直接使用malloc。</li>
<li>如果需要的内存大小小于128bytes，allocate根据size找到最适合的自由链表。<br>a. 如果链表不为空，返回第一个node，链表头改为第二个node。<br>b. 如果链表为空，使用blockAlloc请求分配node。<br>x. 如果内存池中有大于一个node的空间，分配竟可能多的node(但是最多20个)，将一个node返回，其他的node添加到链表中。<br>y. 如果内存池只有一个node的空间，直接返回给用户。<br>z. 若果如果连一个node都没有，再次向操作系统请求分配内存。<br>①分配成功，再次进行b过程。<br>②分配失败，循环各个自由链表，寻找空间。<br>I. 找到空间，再次进行过程b。<br>II. 找不到空间，抛出异常。</li>
<li>用户调用deallocate释放内存空间，如果要求释放的内存空间大于128bytes，直接调用free。</li>
<li>否则按照其大小找到合适的自由链表，并将其插入。</li>
</ol>
<h2 id="61-拷贝构造"><a href="#61-拷贝构造" class="headerlink" title="61 拷贝构造"></a>61 拷贝构造</h2><p>上面的定义的类Person显式的删除了拷贝构造函数和赋值运算符，在需要调用拷贝构造函数或者赋值运算符的地方，会提示_无法调用该函数，它是已删除的函数_。<br>还有一点需要注意的是，拷贝构造函数必须以引用的方式传递参数。这是因为，在值传递的方式传递给一个函数的时候，会调用拷贝构造函数生成函数的实参。如果拷贝构造函数的参数仍然是以值的方式，就会无限循环的调用下去，直到函数的栈溢出。</p>
<p>何时调用<br>拷贝构造函数和赋值运算符的行为比较相似，都是将一个对象的值复制给另一个对象；但是其结果却有些不同，拷贝构造函数使用传入对象的值生成一个新的对象的实例，而赋值运算符是将对象的值复制给一个已经存在的实例。这种区别从两者的名字也可以很轻易的分辨出来，拷贝构造函数也是一种构造函数，那么它的功能就是创建一个新的对象实例；赋值运算符是执行某种运算，将一个对象的值复制给另一个对象（已经存在的）。调用的是拷贝构造函数还是赋值运算符，主要是看是否有新的对象实例产生。如果产生了新的对象实例，那调用的就是拷贝构造函数；如果没有，那就是对已有的对象赋值，调用的是赋值运算符。</p>
<h2 id="062-深拷贝、浅拷贝"><a href="#062-深拷贝、浅拷贝" class="headerlink" title="062 深拷贝、浅拷贝"></a>062 深拷贝、浅拷贝</h2><p>说到拷贝构造函数，就不得不提深拷贝和浅拷贝。通常，默认生成的拷贝构造函数和赋值运算符，只是简单的进行值的复制。例如：上面的Person类，字段只有int和string两种类型，这在拷贝或者赋值时进行值复制创建的出来的对象和源对象也是没有任何关联，对源对象的任何操作都不会影响到拷贝出来的对象。反之，假如Person有一个对象为int *，这时在拷贝时还只是进行值复制，那么创建出来的Person对象的int *的值就和源对象的int *指向的是同一个位置。任何一个对象对该值的修改都会影响到另一个对象，这种情况就是浅拷贝。</p>
<p>深拷贝和浅拷贝主要是针对类中的指针和动态分配的空间来说的，因为对于指针只是简单的值复制并不能分割开两个对象的关联，任何一个对象对该指针的操作都会影响到另一个对象。这时候就需要提供自定义的深拷贝的拷贝构造函数，消除这种影响。通常的原则是：</p>
<p>含有指针类型的成员或者有动态分配内存的成员都应该提供自定义的拷贝构造函数<br>在提供拷贝构造函数的同时，还应该考虑实现自定义的赋值运算符<br>对于拷贝构造函数的实现要确保以下几点：</p>
<p>对于值类型的成员进行值复制<br>对于指针和动态分配的空间，在拷贝中应重新分配分配空间<br>对于基类，要调用基类合适的拷贝方法，完成基类的拷贝</p>
<h2 id="ending"><a href="#ending" class="headerlink" title="ending"></a>ending</h2>
    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>TheRiver
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="https://riverferry.site/2020-03-29-c++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/" title="c++基础知识点">https://riverferry.site/2020-03-29-c++基础知识点/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"><i class="fa fa-tags"></i> 面试</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020-03-28-%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%951-30/" rel="prev" title="华为机试1-30">
      <i class="fa fa-chevron-left"></i> 华为机试1-30
    </a></div>
      <div class="post-nav-item">
    <a href="/2020-03-29-%E8%B0%B7%E6%AD%8C%E4%BA%91%E6%90%AD%E5%BB%BAv2ray/" rel="next" title="谷歌云搭建v2ray">
      谷歌云搭建v2ray <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  
   <div>
     <div>
  
    <div style="text-align:center;color:#bfbfbf;font-size:16px;">
      <span>----------- ending -----------</span>
    </div>
  
</div>

   </div>
 



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#001-%E8%AF%B4%E4%B8%80%E4%B8%8Bstatic%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">2.</span> <span class="nav-text">001 说一下static关键字的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#002-extern%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">3.</span> <span class="nav-text">002 extern关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#003-C-%E5%92%8CC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.</span> <span class="nav-text">003 C++和C的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#004-%E8%AF%B4%E4%B8%80%E8%AF%B4c-%E4%B8%AD%E5%9B%9B%E7%A7%8Dcast%E8%BD%AC%E6%8D%A2"><span class="nav-number">5.</span> <span class="nav-text">004 说一说c++中四种cast转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#005-%E8%AF%B7%E8%AF%B4%E4%B8%80%E4%B8%8BC-C-%E4%B8%AD%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">6.</span> <span class="nav-text">005 请说一下C&#x2F;C++ 中指针和引用的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#006-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">7.</span> <span class="nav-text">006 智能指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#007-%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB%E5%A6%82%E4%B8%8B"><span class="nav-number">8.</span> <span class="nav-text">007 指针和数组的主要区别如下</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#008-%E8%AF%B7%E4%BD%A0%E5%9B%9E%E7%AD%94%E4%B8%80%E4%B8%8B%E9%87%8E%E6%8C%87%E9%92%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">9.</span> <span class="nav-text">008 请你回答一下野指针是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#009-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%BF%85%E9%A1%BB%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88C-%E9%BB%98%E8%AE%A4%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%8D%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0-%E8%80%83%E7%82%B9-%E8%99%9A%E5%87%BD%E6%95%B0-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">10.</span> <span class="nav-text">009 为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数 考点:虚函数 析构函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#010-%E8%AF%B7%E4%BD%A0%E6%9D%A5%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="nav-number">11.</span> <span class="nav-text">010 请你来说一下函数指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#011-%E8%AF%B7%E4%BD%A0%E6%9D%A5%E8%AF%B4%E4%B8%80%E4%B8%8Bfork%E5%87%BD%E6%95%B0"><span class="nav-number">12.</span> <span class="nav-text">011 请你来说一下fork函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#012-%E8%AF%B7%E4%BD%A0%E6%9D%A5%E8%AF%B4%E4%B8%80%E4%B8%8BC-%E4%B8%AD%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">13.</span> <span class="nav-text">012 请你来说一下C++中析构函数的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#013-%E8%AF%B7%E4%BD%A0%E6%9D%A5%E8%AF%B4%E4%B8%80%E4%B8%8B%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0%E5%92%8C%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">14.</span> <span class="nav-text">013 请你来说一下静态函数和虚函数的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#014-%E8%AF%B7%E4%BD%A0%E6%9D%A5%E8%AF%B4%E4%B8%80%E8%AF%B4%E9%87%8D%E8%BD%BD%E5%92%8C%E8%A6%86%E7%9B%96"><span class="nav-number">15.</span> <span class="nav-text">014 请你来说一说重载和覆盖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#015-%E8%AF%B7%E4%BD%A0%E8%AF%B4%E4%B8%80%E8%AF%B4strcpy%E5%92%8Cstrlen"><span class="nav-number">16.</span> <span class="nav-text">015 请你说一说strcpy和strlen</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#016-%E8%AF%B7%E4%BD%A0%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BD%A0%E7%90%86%E8%A7%A3%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81"><span class="nav-number">17.</span> <span class="nav-text">016 请你说一说你理解的虚函数和多态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#017-%E8%AF%B7%E4%BD%A0%E6%9D%A5%E5%9B%9E%E7%AD%94%E4%B8%80%E4%B8%8B-i%E5%92%8Ci-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">18.</span> <span class="nav-text">017 请你来回答一下++i和i++的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#018-%E8%AF%B7%E4%BD%A0%E6%9D%A5%E5%86%99%E4%B8%AA%E5%87%BD%E6%95%B0%E5%9C%A8main%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E5%89%8D%E5%85%88%E8%BF%90%E8%A1%8C"><span class="nav-number">19.</span> <span class="nav-text">018 请你来写个函数在main函数执行前先运行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#019-%E4%BB%A5%E4%B8%8B%E5%9B%9B%E8%A1%8C%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">20.</span> <span class="nav-text">019 以下四行代码的区别是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#020-%E8%AF%B7%E4%BD%A0%E6%9D%A5%E8%AF%B4%E4%B8%80%E4%B8%8BC-%E9%87%8C%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F%E7%9A%84%EF%BC%9F%E5%B8%B8%E9%87%8F%E5%AD%98%E6%94%BE%E5%9C%A8%E5%86%85%E5%AD%98%E7%9A%84%E5%93%AA%E4%B8%AA%E4%BD%8D%E7%BD%AE%EF%BC%9F"><span class="nav-number">21.</span> <span class="nav-text">020 请你来说一下C++里是怎么定义常量的？常量存放在内存的哪个位置？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#021-%E8%AF%B7%E4%BD%A0%E6%9D%A5%E5%9B%9E%E7%AD%94%E4%B8%80%E4%B8%8Bconst%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E7%9B%AE%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">22.</span> <span class="nav-text">021 请你来回答一下const修饰成员函数的目的是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#022-%E5%A6%82%E6%9E%9C%E5%90%8C%E6%97%B6%E5%AE%9A%E4%B9%89%E4%BA%86%E4%B8%A4%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%8C%E4%B8%80%E4%B8%AA%E5%B8%A6const%EF%BC%8C%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%B8%A6%EF%BC%8C%E4%BC%9A%E6%9C%89%E9%97%AE%E9%A2%98%E5%90%97%EF%BC%9F"><span class="nav-number">23.</span> <span class="nav-text">022 如果同时定义了两个函数，一个带const，一个不带，会有问题吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#023-%E8%AF%B7%E4%BD%A0%E6%9D%A5%E8%AF%B4%E4%B8%80%E8%AF%B4%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">24.</span> <span class="nav-text">023 请你来说一说隐式类型转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#024-%E8%AF%B7%E4%BD%A0%E6%9D%A5%E8%AF%B4%E4%B8%80%E8%AF%B4C-%E5%87%BD%E6%95%B0%E6%A0%88%E7%A9%BA%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-number">25.</span> <span class="nav-text">024 请你来说一说C++函数栈空间的最大值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#025-%E8%AF%B7%E4%BD%A0%E6%9D%A5%E8%AF%B4%E4%B8%80%E8%AF%B4extern%E2%80%9CC%E2%80%9D"><span class="nav-number">26.</span> <span class="nav-text">025 请你来说一说extern“C”</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#026-%E8%AF%B7%E4%BD%A0%E5%9B%9E%E7%AD%94%E4%B8%80%E4%B8%8Bnew-delete%E4%B8%8Emalloc-free%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">27.</span> <span class="nav-text">026 请你回答一下new&#x2F;delete与malloc&#x2F;free的区别是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#027-%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E5%85%B7%E4%BD%93%E6%98%AF%E6%80%8E%E6%A0%B7%E5%AE%9E%E7%8E%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%A4%9A%E6%80%81%E7%9A%84"><span class="nav-number">28.</span> <span class="nav-text">027 请你说说虚函数表具体是怎样实现运行时多态的?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#028-%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4C%E8%AF%AD%E8%A8%80%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9B%E8%A1%8C%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%EF%BC%9F"><span class="nav-number">29.</span> <span class="nav-text">028 请你说说C语言是怎么进行函数调用的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#029-%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4C%E8%AF%AD%E8%A8%80%E5%8F%82%E6%95%B0%E5%8E%8B%E6%A0%88%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="nav-number">30.</span> <span class="nav-text">029 请你说说C语言参数压栈顺序？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#030-%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4C-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9F"><span class="nav-number">31.</span> <span class="nav-text">030 请你说说C++如何处理返回值？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#031-%E8%AF%B7%E4%BD%A0%E5%9B%9E%E7%AD%94%E4%B8%80%E4%B8%8BC-%E4%B8%AD%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E5%87%BD%E6%95%B0%E7%9A%84%E5%BD%A2%E5%8F%82%E8%83%BD%E5%90%A6%E8%BF%9B%E8%A1%8C%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%9F"><span class="nav-number">32.</span> <span class="nav-text">031 请你回答一下C++中拷贝赋值函数的形参能否进行值传递？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#032-%E8%AF%B7%E4%BD%A0%E5%9B%9E%E7%AD%94%E4%B8%80%E4%B8%8Bmalloc%E4%B8%8Enew%E5%8C%BA%E5%88%AB"><span class="nav-number">33.</span> <span class="nav-text">032  请你回答一下malloc与new区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#033-%E8%AF%B7%E4%BD%A0%E8%AF%B4%E4%B8%80%E8%AF%B4select"><span class="nav-number">34.</span> <span class="nav-text">033 请你说一说select</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#034-%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4fork-wait-exec%E5%87%BD%E6%95%B0"><span class="nav-number">35.</span> <span class="nav-text">034  请你说说fork,wait,exec函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#035-%E8%AF%B7%E4%BD%A0%E6%9D%A5%E8%AF%B4%E4%B8%80%E4%B8%8Bmap%E5%92%8Cset%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%88%86%E5%88%AB%E5%8F%88%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="nav-number">36.</span> <span class="nav-text">035 请你来说一下map和set有什么区别，分别又是怎么实现的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#036-%E8%AF%B7%E4%BD%A0%E6%9D%A5%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BSTL%E7%9A%84allocaotr"><span class="nav-number">37.</span> <span class="nav-text">036 请你来介绍一下STL的allocaotr</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#037-%E8%AF%B7%E4%BD%A0%E8%AF%B4%E4%B8%80%E8%AF%B4STL%E4%B8%ADMAP%E6%95%B0%E6%8D%AE%E5%AD%98%E6%94%BE%E5%BD%A2%E5%BC%8F"><span class="nav-number">38.</span> <span class="nav-text">037 请你说一说STL中MAP数据存放形式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#038-%E8%AF%B7%E4%BD%A0%E6%9D%A5%E8%AF%B4%E4%B8%80%E8%AF%B4STL%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="nav-number">39.</span> <span class="nav-text">038 请你来说一说STL迭代器删除元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#039-%E8%AF%B7%E4%BD%A0%E8%AE%B2%E8%AE%B2STL%E6%9C%89%E4%BB%80%E4%B9%88%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90"><span class="nav-number">40.</span> <span class="nav-text">039 请你讲讲STL有什么基本组成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#040-%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4STL%E4%B8%ADmap%E4%B8%8Eunordered-map%E5%92%8CMultimap"><span class="nav-number">41.</span> <span class="nav-text">040 请你说说STL中map与unordered_map和Multimap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#041-%E8%AF%B7%E4%BD%A0%E8%AF%B4%E4%B8%80%E8%AF%B4vector%E5%92%8Clist%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%BA%94%E7%94%A8%EF%BC%8C%E8%B6%8A%E8%AF%A6%E7%BB%86%E8%B6%8A%E5%A5%BD"><span class="nav-number">42.</span> <span class="nav-text">041 请你说一说vector和list的区别，应用，越详细越好</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#042-%E8%AF%B7%E4%BD%A0%E6%9D%A5%E8%AF%B4%E4%B8%80%E4%B8%8BSTL%E4%B8%AD%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%8C%E6%9C%89%E6%8C%87%E9%92%88%E4%B8%BA%E4%BD%95%E8%BF%98%E8%A6%81%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">43.</span> <span class="nav-text">042 请你来说一下STL中迭代器的作用，有指针为何还要迭代器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#043-%E8%AF%B7%E4%BD%A0%E5%9B%9E%E7%AD%94%E4%B8%80%E4%B8%8BSTL%E9%87%8Cresize%E5%92%8Creserve%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">44.</span> <span class="nav-text">043 请你回答一下STL里resize和reserve的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#044-%E8%AF%B7%E4%BD%A0%E6%9D%A5%E8%AF%B4%E4%B8%80%E4%B8%8BC-%E4%B8%AD%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="nav-number">45.</span> <span class="nav-text">044 请你来说一下C++中类成员的访问权限</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#045-%E8%AF%B7%E4%BD%A0%E6%9D%A5%E8%AF%B4%E4%B8%80%E4%B8%8BC-%E4%B8%ADstruct%E5%92%8Cclass%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">46.</span> <span class="nav-text">045 请你来说一下C++中struct和class的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#046-%E8%AF%B7%E4%BD%A0%E5%9B%9E%E7%AD%94%E4%B8%80%E4%B8%8BC-%E7%B1%BB%E5%86%85%E5%8F%AF%E4%BB%A5%E5%AE%9A%E4%B9%89%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E5%90%97%EF%BC%9F"><span class="nav-number">47.</span> <span class="nav-text">046 请你回答一下C++类内可以定义引用数据成员吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#047-%E8%AF%B7%E4%BD%A0%E5%9B%9E%E7%AD%94%E4%B8%80%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%EF%BC%8C%E8%B7%9F%E5%B7%A6%E5%80%BC%E5%8F%88%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">48.</span> <span class="nav-text">047 请你回答一下什么是右值引用，跟左值又有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#048-%E8%AF%B7%E4%BD%A0%E6%9D%A5%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%B8%80%E4%B8%AAC-%E6%BA%90%E6%96%87%E4%BB%B6%E4%BB%8E%E6%96%87%E6%9C%AC%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%BB%8F%E5%8E%86%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="nav-number">49.</span> <span class="nav-text">048 请你来说一下一个C++源文件从文本到可执行文件经历的过程？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#049-%E8%AF%B7%E4%BD%A0%E6%9D%A5%E5%9B%9E%E7%AD%94%E4%B8%80%E4%B8%8Binclude%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E9%A1%BA%E5%BA%8F%E4%BB%A5%E5%8F%8A%E5%8F%8C%E5%BC%95%E5%8F%B7%E2%80%9D%E2%80%9D%E5%92%8C%E5%B0%96%E6%8B%AC%E5%8F%B7-lt-gt-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">50.</span> <span class="nav-text">049 请你来回答一下include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#050-%E8%AF%B7%E4%BD%A0%E5%9B%9E%E7%AD%94%E4%B8%80%E4%B8%8Bmalloc%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%8C%E5%8F%A6%E5%A4%96brk%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8Cmmap%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E4%BD%9C%E7%94%A8%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">51.</span> <span class="nav-text">050 请你回答一下malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#051-%E8%AF%B7%E4%BD%A0%E8%AF%B4%E4%B8%80%E8%AF%B4C-%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="nav-number">52.</span> <span class="nav-text">051 请你说一说C++的内存管理是怎样的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#052-%E8%AF%B7%E4%BD%A0%E5%9B%9E%E7%AD%94%E4%B8%80%E4%B8%8B%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F"><span class="nav-number">53.</span> <span class="nav-text">052 请你回答一下如何判断内存泄漏？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#053-%E8%AF%B7%E4%BD%A0%E6%9D%A5%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%8F%91%E7%94%9F%E6%AE%B5%E9%94%99%E8%AF%AF"><span class="nav-number">54.</span> <span class="nav-text">053 请你来说一下什么时候会发生段错误</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#054-%E8%AF%B7%E4%BD%A0%E6%9D%A5%E5%9B%9E%E7%AD%94%E4%B8%80%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AFmemory-leak%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-number">55.</span> <span class="nav-text">054 请你来回答一下什么是memory leak，也就是内存泄漏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#055-%E8%AF%B7%E4%BD%A0%E6%9D%A5%E5%9B%9E%E7%AD%94%E4%B8%80%E4%B8%8Bnew%E5%92%8Cmalloc%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">56.</span> <span class="nav-text">055 请你来回答一下new和malloc的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#056-%E8%AF%B7%E4%BD%A0%E6%9D%A5%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3api"><span class="nav-number">57.</span> <span class="nav-text">056 请你来说一下共享内存相关api</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#057-%E8%AF%B7%E4%BD%A0%E6%9D%A5%E8%AF%B4%E4%B8%80%E4%B8%8Breactor%E6%A8%A1%E5%9E%8B%E7%BB%84%E6%88%90"><span class="nav-number">58.</span> <span class="nav-text">057 请你来说一下reactor模型组成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#058-%E8%AF%B7%E8%87%AA%E5%B7%B1%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%8B%E5%A6%82%E4%BD%95%E9%87%87%E7%94%A8%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E5%A4%84%E7%90%86%E9%AB%98%E5%B9%B6%E5%8F%91"><span class="nav-number">59.</span> <span class="nav-text">058 请自己设计一下如何采用单线程的方式处理高并发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#059-%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4select%EF%BC%8Cepoll%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%8E%9F%E7%90%86%EF%BC%8C%E6%80%A7%E8%83%BD%EF%BC%8C%E9%99%90%E5%88%B6%E9%83%BD%E8%AF%B4%E4%B8%80%E8%AF%B4"><span class="nav-number">60.</span> <span class="nav-text">059 请你说说select，epoll的区别，原理，性能，限制都说一说</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#060-%E8%AF%B7%E4%BD%A0%E8%AF%B4%E4%B8%80%E8%AF%B4C-STL-%E7%9A%84%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96"><span class="nav-number">61.</span> <span class="nav-text">060  请你说一说C++ STL 的内存优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#61-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0"><span class="nav-number">62.</span> <span class="nav-text">61 拷贝构造</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#062-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-number">63.</span> <span class="nav-text">062 深拷贝、浅拷贝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ending"><span class="nav-number">64.</span> <span class="nav-text">ending</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="TheRiver"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">TheRiver</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">210</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">68</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">TheRiver</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">1.1m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">17:09</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '828d98635e4048805831',
      clientSecret: 'cdf9f70acdfbecd65e89bc3a8c2954be1af2ee01',
      repo        : 'gitalk',
      owner       : 'RiverFerry',
      admin       : ['RiverFerry'],
      id          : '7f86928ccb1625cd63e344485f45463e',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/ Relative)","tagMode":false,"log":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"left","width":300,"height":800,"hOffset":20,"vOffset":20},"mobile":{"show":false,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2}});</script></body>
</html>
